<!DOCTYPE HTML>
<html>
<head>
<title>Pro Git #2</title>
</head>
<body>
<table style='color:green;font-size:150%;font-weight:bold;' border=1 width=100%><tr><td>Part #&nbsp;2</td></tr></table><br>
<div class="page">
<br>
<p>$ git checkout -b featureA
Switched to a new branch 'featureA'
$ git push origin featureA
To hg::/tmp/hello
&nbsp;* [new branch] featureA -&gt; featureA
<p>That&rsquo;s all there is to it. On the Mercurial side, it looks like this:
<p>$ hg bookmarks
&nbsp; featureA 5:bd5ac26f11f9
$ hg log --style compact -G
@ 6[tip] 8f65e5e02793 2014-08-14 20:06 -0700 ben
| More documentation
|
o 5[featureA]:4,2 bd5ac26f11f9 2014-08-14 20:02 -0700 ben
|\ Merge remote-tracking branch 'origin/master'
| |
| o 4 0434aaa6b91f 2014-08-14 20:01 -0700 ben
| | update makefile
| |
| o 3:1 318914536c86 2014-08-14 20:00 -0700 ben
| | goodbye
| |
o | 2 f098c7f45c4f 2014-08-14 20:01 -0700 ben
|/ Add some documentation
|
o 1 82e55d328c8c 2005-08-26 01:21 -0700 mpm
| Create a makefile
|
o 0 0a04b987be5a 2005-08-26 01:20 -0700 mpm
&nbsp; Create a standard 'hello, world' program
<p>Note the new [featureA] tag on revision 5. These act exactly like Git branches on the Git side, with
one exception: you can&rsquo;t delete a bookmark from the Git side (this is a limitation of remote helpers).
<p>You can work on a &ldquo;heavyweight&rdquo; Mercurial branch also: just put a branch in the branches
namespace:
<p>$ git checkout -b branches/permanent
Switched to a new branch 'branches/permanent'
$ vi Makefile
$ git commit -am 'A permanent change'
$ git push origin branches/permanent
To hg::/tmp/hello
&nbsp;* [new branch] branches/permanent -&gt; branches/permanent
<p>Here&rsquo;s what that looks like on the Mercurial side:
<p>387</p>
<br>
</div>
<div class="page">
<br>
<p>$ hg branches
permanent 7:a4529d07aad4
develop 6:8f65e5e02793
default 5:bd5ac26f11f9 (inactive)
$ hg log -G
o changeset: 7:a4529d07aad4
| branch: permanent
| tag: tip
| parent: 5:bd5ac26f11f9
| user: Ben Straub &lt;ben@straub.cc&gt;
| date: Thu Aug 14 20:21:09 2014 -0700
| summary: A permanent change
|
| @ changeset: 6:8f65e5e02793
|/ branch: develop
| user: Ben Straub &lt;ben@straub.cc&gt;
| date: Thu Aug 14 20:06:38 2014 -0700
| summary: More documentation
|
o changeset: 5:bd5ac26f11f9
|\ bookmark: featureA
| | parent: 4:0434aaa6b91f
| | parent: 2:f098c7f45c4f
| | user: Ben Straub &lt;ben@straub.cc&gt;
| | date: Thu Aug 14 20:02:21 2014 -0700
| | summary: Merge remote-tracking branch 'origin/master'
[...]
<p>The branch name &ldquo;permanent&rdquo; was recorded with the changeset marked 7.
<p>From the Git side, working with either of these branch styles is the same: just checkout, commit,
fetch, merge, pull, and push as you normally would. One thing you should know is that Mercurial
doesn&rsquo;t support rewriting history, only adding to it. Here&rsquo;s what our Mercurial repository looks like
after an interactive rebase and a force-push:
<p>388</p>
<br>
</div>
<div class="page">
<br>
<p>$ hg log --style compact -G
o 10[tip] 99611176cbc9 2014-08-14 20:21 -0700 ben
| A permanent change
|
o 9 f23e12f939c3 2014-08-14 20:01 -0700 ben
| Add some documentation
|
o 8:1 c16971d33922 2014-08-14 20:00 -0700 ben
| goodbye
|
| o 7:5 a4529d07aad4 2014-08-14 20:21 -0700 ben
| | A permanent change
| |
| | @ 6 8f65e5e02793 2014-08-14 20:06 -0700 ben
| |/ More documentation
| |
| o 5[featureA]:4,2 bd5ac26f11f9 2014-08-14 20:02 -0700 ben
| |\ Merge remote-tracking branch 'origin/master'
| | |
| | o 4 0434aaa6b91f 2014-08-14 20:01 -0700 ben
| | | update makefile
| | |
+---o 3:1 318914536c86 2014-08-14 20:00 -0700 ben
| | goodbye
| |
| o 2 f098c7f45c4f 2014-08-14 20:01 -0700 ben
|/ Add some documentation
|
o 1 82e55d328c8c 2005-08-26 01:21 -0700 mpm
| Create a makefile
|
o 0 0a04b987be5a 2005-08-26 01:20 -0700 mpm
&nbsp; Create a standard "hello, world" program
<p>Changesets 8, 9, and 10 have been created and belong to the permanent branch, but the old
changesets are still there. This can be very confusing for your teammates who are using Mercurial,
so try to avoid it.
<p>Mercurial Summary
<p>Git and Mercurial are similar enough that working across the boundary is fairly painless. If you
avoid changing history that&rsquo;s left your machine (as is generally recommended), you may not even
be aware that the other end is Mercurial.
<p>Git and Bazaar
<p>Among the DVCS, another famous one is Bazaar. Bazaar is free and open source, and is part of the
GNU Project. It behaves very differently from Git. Sometimes, to do the same thing as with Git, you
have to use a different keyword, and some keywords that are common don&rsquo;t have the same
<p>389</p>
<br>
<div class="annotation">
<a href="http://bazaar.canonical.com">http://bazaar.canonical.com</a>
</div>
<div class="annotation">
<a href="https://www.gnu.org">https://www.gnu.org</a>
</div>
</div>
<div class="page">
<br>
<p>meaning. In particular, the branch management is very different and may cause confusion,
especially when someone comes from Git&rsquo;s universe. Nevertheless, it is possible to work on a
Bazaar repository from a Git one.
<p>There are many projects that allow you to use Git as a Bazaar client. Here we&rsquo;ll use Felipe Contreras'
project that you may find at https://github.com/felipec/git-remote-bzr. To install it, you just have to
download the file git-remote-bzr in a folder contained in your $PATH:
<p>$ wget https://raw.github.com/felipec/git-remote-bzr/master/git-remote-bzr -O
~/bin/git-remote-bzr
$ chmod +x ~/bin/git-remote-bzr
<p>You also need to have Bazaar installed. That&rsquo;s all!
<p>Create a Git repository from a Bazaar repository
<p>It is simple to use. It is enough to clone a Bazaar repository prefixing it by bzr::. Since Git and
Bazaar both do full clones to your machine, it&rsquo;s possible to attach a Git clone to your local Bazaar
clone, but it isn&rsquo;t recommended. It&rsquo;s much easier to attach your Git clone directly to the same place
your Bazaar clone is attached to&thinsp;&mdash;&thinsp;the central repository.
<p>Let&rsquo;s suppose that you worked with a remote repository which is at address
bzr+ssh://developer@mybazaarserver:myproject. Then you must clone it in the following way:
<p>$ git clone bzr::bzr+ssh://developer@mybazaarserver:myproject myProject-Git
$ cd myProject-Git
<p>At this point, your Git repository is created but it is not compacted for optimal disk use. That&rsquo;s why
you should also clean and compact your Git repository, especially if it is a big one:
<p>$ git gc --aggressive
<p>Bazaar branches
<p>Bazaar only allows you to clone branches, but a repository may contain several branches, and git-
remote-bzr can clone both. For example, to clone a branch:
<p>$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs/trunk emacs-trunk
<p>And to clone the whole repository:
<p>$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs emacs
<p>The second command clones all the branches contained in the emacs repository; nevertheless, it is
<p>390</p>
<br>
<div class="annotation">
<a href="https://github.com/felipec/git-remote-bzr">https://github.com/felipec/git-remote-bzr</a>
</div>
</div>
<div class="page">
<br>
<p>possible to point out some branches:
<p>$ git config remote-bzr.branches 'trunk, xwindow'
<p>Some remote repositories don&rsquo;t allow you to list their branches, in which case you have to manually
specify them, and even though you could specify the configuration in the cloning command, you
may find this easier:
<p>$ git init emacs
$ git remote add origin bzr::bzr://bzr.savannah.gnu.org/emacs
$ git config remote-bzr.branches 'trunk, xwindow'
$ git fetch
<p>Ignore what is ignored with .bzrignore
<p>Since you are working on a project managed with Bazaar, you shouldn&rsquo;t create a .gitignore file
because you may accidentally set it under version control and the other people working with
Bazaar would be disturbed. The solution is to create the .git/info/exclude file either as a symbolic
link or as a regular file. We&rsquo;ll see later on how to solve this question.
<p>Bazaar uses the same model as Git to ignore files, but also has two features which don&rsquo;t have an
equivalent into Git. The complete description may be found in the documentation. The two features
are:
<p>1. "!!" allows you to ignore certain file patterns even if they&rsquo;re specified using a "!" rule.
<p>2. "RE:" at the beginning of a line allows you to specify a Python regular expression (Git only
allows shell globs).
<p>As a consequence, there are two different situations to consider:
<p>1. If the .bzrignore file does not contain any of these two specific prefixes, then you can simply
make a symbolic link to it in the repository: ln -s .bzrignore .git/info/exclude
<p>2. Otherwise, you must create the .git/info/exclude file and adapt it to ignore exactly the same
files in .bzrignore.
<p>Whatever the case is, you will have to remain vigilant against any change of .bzrignore to make
sure that the .git/info/exclude file always reflects .bzrignore. Indeed, if the .bzrignore file were to
change and contained one or more lines starting with "!!" or "RE:", Git not being able to interpret
these lines, you&rsquo;ll have to adapt your .git/info/exclude file to ignore the same files as the ones
ignored with .bzrignore. Moreover, if the .git/info/exclude file was a symbolic link, you&rsquo;ll have to
first delete the symbolic link, copy .bzrignore to .git/info/exclude and then adapt the latter.
However, be careful with its creation because with Git it is impossible to re-include a file if a parent
directory of that file is excluded.
<p>Fetch the changes of the remote repository
<p>To fetch the changes of the remote, you pull changes as usually, using Git commands. Supposing
<p>391</p>
<br>
<div class="annotation">
<a href="http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html">http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html</a>
</div>
<div class="annotation">
<a href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a>
</div>
</div>
<div class="page">
<br>
<p>that your changes are on the master branch, you merge or rebase your work on the origin/master
branch:
<p>$ git pull --rebase origin
<p>Push your work on the remote repository
<p>Because Bazaar also has the concept of merge commits, there will be no problem if you push a
merge commit. So you can work on a branch, merge the changes into master and push your work.
Then, you create your branches, you test and commit your work as usual. You finally push your
work to the Bazaar repository:
<p>$ git push origin master
<p>Caveats
<p>Git&rsquo;s remote-helpers framework has some limitations that apply. In particular, these commands
don&rsquo;t work:
<p>&bull; git push origin :branch-to-delete (Bazaar can&rsquo;t accept ref deletions in this way.)
<p>&bull; git push origin old:new (it will push old)
<p>&bull; git push --dry-run origin branch (it will push)
<p>Summary
<p>Since Git&rsquo;s and Bazaar&rsquo;s models are similar, there isn&rsquo;t a lot of resistance when working across the
boundary. As long as you watch out for the limitations, and are always aware that the remote
repository isn&rsquo;t natively Git, you&rsquo;ll be fine.
<p>Git and Perforce
<p>Perforce is a very popular version-control system in corporate environments. It&rsquo;s been around
since 1995, which makes it the oldest system covered in this chapter. As such, it&rsquo;s designed with the
constraints of its day; it assumes you&rsquo;re always connected to a single central server, and only one
version is kept on the local disk. To be sure, its features and constraints are well-suited to several
specific problems, but there are lots of projects using Perforce where Git would actually work
better.
<p>There are two options if you&rsquo;d like to mix your use of Perforce and Git. The first one we&rsquo;ll cover is
the &ldquo;Git Fusion&rdquo; bridge from the makers of Perforce, which lets you expose subtrees of your
Perforce depot as read-write Git repositories. The second is git-p4, a client-side bridge that lets you
use Git as a Perforce client, without requiring any reconfiguration of the Perforce server.
<p>Git Fusion
<p>Perforce provides a product called Git Fusion (available at http://www.perforce.com/git-fusion),
which synchronizes a Perforce server with Git repositories on the server side.
<p>392</p>
<br>
<div class="annotation">
<a href="http://www.perforce.com/git-fusion">http://www.perforce.com/git-fusion</a>
</div>
</div>
<div class="page">
<br>
<p>Setting Up
<p>For our examples, we&rsquo;ll be using the easiest installation method for Git Fusion, which is
downloading a virtual machine that runs the Perforce daemon and Git Fusion. You can get the
virtual machine image from http://www.perforce.com/downloads/Perforce/20-User, and once it&rsquo;s
finished downloading, import it into your favorite virtualization software (we&rsquo;ll use VirtualBox).
<p>Upon first starting the machine, it asks you to customize the password for three Linux users (root,
perforce, and git), and provide an instance name, which can be used to distinguish this installation
from others on the same network. When that has all completed, you&rsquo;ll see this:
<p>Figure 146. The Git Fusion virtual machine boot screen.
<p>You should take note of the IP address that&rsquo;s shown here, we&rsquo;ll be using it later on. Next, we&rsquo;ll create
a Perforce user. Select the &ldquo;Login&rdquo; option at the bottom and press enter (or SSH to the machine),
and log in as root. Then use these commands to create a user:
<p>$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
<p>393</p>
<br>
<div class="annotation">
<a href="http://www.perforce.com/downloads/Perforce/20-User">http://www.perforce.com/downloads/Perforce/20-User</a>
</div>
</div>
<div class="page">
<br>
<p>The first one will open a VI editor to customize the user, but you can accept the defaults by typing
:wq and hitting enter. The second one will prompt you to enter a password twice. That&rsquo;s all we need
to do with a shell prompt, so exit out of the session.
<p>The next thing you&rsquo;ll need to do to follow along is to tell Git not to verify SSL certificates. The Git
Fusion image comes with a certificate, but it&rsquo;s for a domain that won&rsquo;t match your virtual
machine&rsquo;s IP address, so Git will reject the HTTPS connection. If this is going to be a permanent
installation, consult the Perforce Git Fusion manual to install a different certificate; for our example
purposes, this will suffice:
<p>$ export GIT_SSL_NO_VERIFY=true
<p>Now we can test that everything is working.
<p>$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
<p>The virtual-machine image comes equipped with a sample project that you can clone. Here we&rsquo;re
cloning over HTTPS, with the john user that we created above; Git asks for credentials for this
connection, but the credential cache will allow us to skip this step for any subsequent requests.
<p>Fusion Configuration
<p>Once you&rsquo;ve got Git Fusion installed, you&rsquo;ll want to tweak the configuration. This is actually fairly
easy to do using your favorite Perforce client; just map the //.git-fusion directory on the Perforce
server into your workspace. The file structure looks like this:
<p>394</p>
<br>
</div>
<div class="page">
<br>
<p>$ tree
.
├── objects
│&nbsp;&nbsp; ├── repos
│&nbsp;&nbsp; │&nbsp;&nbsp; └── [...]
│&nbsp;&nbsp; └── trees
│&nbsp;&nbsp; └── [...]
│
├── p4gf_config
├── repos
│&nbsp;&nbsp; └── Talkhouse
│&nbsp;&nbsp; └── p4gf_config
└── users
&nbsp; └── p4gf_usermap
<p>498 directories, 287 files
<p>The objects directory is used internally by Git Fusion to map Perforce objects to Git and vice versa,
you won&rsquo;t have to mess with anything in there. There&rsquo;s a global p4gf_config file in this directory, as
well as one for each repository &ndash; these are the configuration files that determine how Git Fusion
behaves. Let&rsquo;s take a look at the file in the root:
<p>[repo-creation]
charset = utf8
<p>[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107
<p>[perforce-to-git]
http-url = none
ssh-url = none
<p>[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False
<p>[authentication]
email-case-sensitivity = no
<p>395</p>
<br>
</div>
<div class="page">
<br>
<p>We won&rsquo;t go into the meanings of these flags here, but note that this is just an INI-formatted text
file, much like Git uses for configuration. This file specifies the global options, which can then be
overridden by repository-specific configuration files, like repos/Talkhouse/p4gf_config. If you open
this file, you&rsquo;ll see a [@repo] section with some settings that are different from the global defaults.
You&rsquo;ll also see sections that look like this:
<p>[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
<p>This is a mapping between a Perforce branch and a Git branch. The section can be named whatever
you like, so long as the name is unique. git-branch-name lets you convert a depot path that would be
cumbersome under Git to a more friendly name. The view setting controls how Perforce files are
mapped into the Git repository, using the standard view mapping syntax. More than one mapping
can be specified, like in this example:
<p>[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
&nbsp; //depot/project2/mainline/... project2/...
<p>This way, if your normal workspace mapping includes changes in the structure of the directories,
you can replicate that with a Git repository.
<p>The last file we&rsquo;ll discuss is users/p4gf_usermap, which maps Perforce users to Git users, and which
you may not even need. When converting from a Perforce changeset to a Git commit, Git Fusion&rsquo;s
default behavior is to look up the Perforce user, and use the email address and full name stored
there for the author/committer field in Git. When converting the other way, the default is to look up
the Perforce user with the email address stored in the Git commit&rsquo;s author field, and submit the
changeset as that user (with permissions applying). In most cases, this behavior will do just fine,
but consider the following mapping file:
<p>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
<p>Each line is of the format &lt;user&gt; &lt;email&gt; "&lt;full name&gt;", and creates a single user mapping. The first
two lines map two distinct email addresses to the same Perforce user account. This is useful if
you&rsquo;ve created Git commits under several different email addresses (or change email addresses),
but want them to be mapped to the same Perforce user. When creating a Git commit from a
Perforce changeset, the first line matching the Perforce user is used for Git authorship information.
<p>The last two lines mask Bob and Joe&rsquo;s actual names and email addresses from the Git commits that
are created. This is nice if you want to open-source an internal project, but don&rsquo;t want to publish
your employee directory to the entire world. Note that the email addresses and full names should
<p>396</p>
<br>
</div>
<div class="page">
<br>
<p>be unique, unless you want all the Git commits to be attributed to a single fictional author.
<p>Workflow
<p>Perforce Git Fusion is a two-way bridge between Perforce and Git version control. Let&rsquo;s have a look
at how it feels to work from the Git side. We&rsquo;ll assume we&rsquo;ve mapped in the &ldquo;Jam&rdquo; project using a
configuration file as shown above, which we can clone like this:
<p>$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
&nbsp; remotes/origin/HEAD -&gt; origin/master
&nbsp; remotes/origin/master
&nbsp; remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on
Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
<p>The first time you do this, it may take some time. What&rsquo;s happening is that Git Fusion is converting
all the applicable changesets in the Perforce history into Git commits. This happens locally on the
server, so it&rsquo;s relatively fast, but if you have a lot of history, it can still take some time. Subsequent
fetches do incremental conversion, so it&rsquo;ll feel more like Git&rsquo;s native speed.
<p>As you can see, our repository looks exactly like any other Git repository you might work with.
There are three branches, and Git has helpfully created a local master branch that tracks
origin/master. Let&rsquo;s do a bit of work, and create a couple of new commits:
<p>397</p>
<br>
</div>
<div class="page">
<br>
<p># ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the
Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
<p>We have two new commits. Now let&rsquo;s check if anyone else has been working:
<p>$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
&nbsp; d254865..6afeb15 master -&gt; origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
<p>It looks like someone was! You wouldn&rsquo;t know it from this view, but the 6afeb15 commit was
actually created using a Perforce client. It just looks like another commit from Git&rsquo;s point of view,
which is exactly the point. Let&rsquo;s see how the Perforce server deals with a merge commit:
<p>398</p>
<br>
</div>
<div class="page">
<br>
<p>$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
&nbsp;README | 2 +-
&nbsp;1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
&nbsp; 6afeb15..89cba2b master -&gt; master
<p>Git thinks it worked. Let&rsquo;s take a look at the history of the README file from Perforce&rsquo;s point of view,
using the revision graph feature of p4v:
<p>Figure 147. Perforce revision graph resulting from Git push.
<p>If you&rsquo;ve never seen this view before, it may seem confusing, but it shows the same concepts as a
graphical viewer for Git history. We&rsquo;re looking at the history of the README file, so the directory tree
at top left only shows that file as it surfaces in various branches. At top right, we have a visual
graph of how different revisions of the file are related, and the big-picture view of this graph is at
<p>399</p>
<br>
</div>
<div class="page">
<br>
<p>bottom right. The rest of the view is given to the details view for the selected revision (2 in this
case).
<p>One thing to notice is that the graph looks exactly like the one in Git&rsquo;s history. Perforce didn&rsquo;t have a
named branch to store the 1 and 2 commits, so it made an &ldquo;anonymous&rdquo; branch in the .git-fusion
directory to hold it. This will also happen for named Git branches that don&rsquo;t correspond to a named
Perforce branch (and you can later map them to a Perforce branch using the configuration file).
<p>Most of this happens behind the scenes, but the end result is that one person on a team can be using
Git, another can be using Perforce, and neither of them will know about the other&rsquo;s choice.
<p>Git-Fusion Summary
<p>If you have (or can get) access to your Perforce server, Git Fusion is a great way to make Git and
Perforce talk to each other. There&rsquo;s a bit of configuration involved, but the learning curve isn&rsquo;t very
steep. This is one of the few sections in this chapter where cautions about using Git&rsquo;s full power will
not appear. That&rsquo;s not to say that Perforce will be happy with everything you throw at it &ndash; if you try
to rewrite history that&rsquo;s already been pushed, Git Fusion will reject it &ndash; but Git Fusion tries very
hard to feel native. You can even use Git submodules (though they&rsquo;ll look strange to Perforce users),
and merge branches (this will be recorded as an integration on the Perforce side).
<p>If you can&rsquo;t convince the administrator of your server to set up Git Fusion, there is still a way to use
these tools together.
<p>Git-p4
<p>Git-p4 is a two-way bridge between Git and Perforce. It runs entirely inside your Git repository, so
you won&rsquo;t need any kind of access to the Perforce server (other than user credentials, of course).
Git-p4 isn&rsquo;t as flexible or complete a solution as Git Fusion, but it does allow you to do most of what
you&rsquo;d want to do without being invasive to the server environment.
<p>
You&rsquo;ll need the p4 tool somewhere in your PATH to work with git-p4. As of this
writing, it is freely available at http://www.perforce.com/downloads/Perforce/20-
User.
<p>Setting Up
<p>For example purposes, we&rsquo;ll be running the Perforce server from the Git Fusion OVA as shown
above, but we&rsquo;ll bypass the Git Fusion server and go directly to the Perforce version control.
<p>In order to use the p4 command-line client (which git-p4 depends on), you&rsquo;ll need to set a couple of
environment variables:
<p>$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
<p>Getting Started
<p>As with anything in Git, the first command is to clone:
<p>400</p>
<br>
<div class="annotation">
<a href="http://www.perforce.com/downloads/Perforce/20-User">http://www.perforce.com/downloads/Perforce/20-User</a>
</div>
<div class="annotation">
<a href="http://www.perforce.com/downloads/Perforce/20-User">http://www.perforce.com/downloads/Perforce/20-User</a>
</div>
</div>
<div class="page">
<br>
<p>$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into
refs/remotes/p4/master
<p>This creates what in Git terms is a &ldquo;shallow&rdquo; clone; only the very latest Perforce revision is
imported into Git; remember, Perforce isn&rsquo;t designed to give every revision to every user. This is
enough to use Git as a Perforce client, but for other purposes it&rsquo;s not enough.
<p>Once it&rsquo;s finished, we have a fully-functional Git repository:
<p>$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from
the state at revision #head
<p>Note how there&rsquo;s a &ldquo;p4&rdquo; remote for the Perforce server, but everything else looks like a standard
clone. Actually, that&rsquo;s a bit misleading; there isn&rsquo;t actually a remote there.
<p>$ git remote -v
<p>No remotes exist in this repository at all. Git-p4 has created some refs to represent the state of the
server, and they look like remote refs to git log, but they&rsquo;re not managed by Git itself, and you can&rsquo;t
push to them.
<p>Workflow
<p>Okay, let&rsquo;s do some work. Let&rsquo;s assume you&rsquo;ve made some progress on a very important feature,
and you&rsquo;re ready to show it to the rest of your team.
<p>$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at
revision #head
<p>We&rsquo;ve made two new commits that we&rsquo;re ready to submit to the Perforce server. Let&rsquo;s check if
anyone else was working today:
<p>401</p>
<br>
</div>
<div class="page">
<br>
<p>$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
<p>Looks like they were, and master and p4/master have diverged. Perforce&rsquo;s branching system is
nothing like Git&rsquo;s, so submitting merge commits doesn&rsquo;t make any sense. Git-p4 recommends that
you rebase your commits, and even comes with a shortcut to do so:
<p>$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
&nbsp;index.html | 2 +-
&nbsp;1 file changed, 1 insertion(+), 1 deletion(-)
<p>You can probably tell from the output, but git p4 rebase is a shortcut for git p4 sync followed by
git rebase p4/master. It&rsquo;s a bit smarter than that, especially when working with multiple branches,
but this is a good approximation.
<p>Now our history is linear again, and we&rsquo;re ready to contribute our changes back to Perforce. The
git p4 submit command will try to create a new Perforce revision for every Git commit between
p4/master and master. Running it drops us into our favorite editor, and the contents of the file look
something like this:
<p>402</p>
<br>
</div>
<div class="page">
<br>
<p># A Perforce Change Specification.
#
# Change: The change number. 'new' on a new changelist.
# Date: The date this specification was last modified.
# Client: The client on which the changelist was created. Read-only.
# User: The user who created the changelist.
# Status: Either 'pending' or 'submitted'. Read-only.
# Type: Either 'public' or 'restricted'. Default is 'public'.
# Description: Comments about the changelist. Required.
# Jobs: What opened jobs are to be closed by this changelist.
# You may delete jobs from this list. (New changelists only.)
# Files: What opened files from the default changelist are to be added
# to this changelist. You may delete files from this list.
# (New changelists only.)
<p>Change: new
<p>Client: john_bens-mbp_8487
<p>User: john
<p>Status: new
<p>Description:
&nbsp; Update link
<p>Files:
&nbsp; //depot/www/live/index.html # edit
<p>######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html 2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html 2014-
08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
&nbsp;&lt;/td&gt;
&nbsp;&lt;td valign=top&gt;
&nbsp;Source and documentation for
-&lt;a href="http://www.perforce.com/jam/jam.html"&gt;
+&lt;a href="jam.html"&gt;
&nbsp;Jam/MR&lt;/a&gt;,
&nbsp;a software build tool.
&nbsp;&lt;/td&gt;
<p>This is mostly the same content you&rsquo;d see by running p4 submit, except the stuff at the end which
git-p4 has helpfully included. Git-p4 tries to honor your Git and Perforce settings individually when
<p>403</p>
<br>
</div>
<div class="page">
<br>
<p>it has to provide a name for a commit or changeset, but in some cases you want to override it. For
example, if the Git commit you&rsquo;re importing was written by a contributor who doesn&rsquo;t have a
Perforce user account, you may still want the resulting changeset to look like they wrote it (and not
you).
<p>Git-p4 has helpfully imported the message from the Git commit as the content for this Perforce
changeset, so all we have to do is save and quit, twice (once for each commit). The resulting shell
output will look something like this:
<p>$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-
mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
<p>The result is as though we just did a git push, which is the closest analogy to what actually did
happen.
<p>Note that during this process every Git commit is turned into a Perforce changeset; if you want to
squash them down into a single changeset, you can do that with an interactive rebase before
running git p4 submit. Also note that the SHA-1 hashes of all the commits that were submitted as
changesets have changed; this is because git-p4 adds a line to the end of each commit it converts:
<p>404</p>
<br>
</div>
<div class="page">
<br>
<p>$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date: Sun Aug 31 10:31:44 2014 -0800
<p>&nbsp; Change page title
<p>&nbsp; [git-p4: depot-paths = "//depot/www/live/": change = 12144]
<p>What happens if you try to submit a merge commit? Let&rsquo;s give it a try. Here&rsquo;s the situation we&rsquo;ve
gotten ourselves into:
<p>$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
* 1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
<p>The Git and Perforce history diverge after 775a46f. The Git side has two commits, then a merge
commit with the Perforce head, then another commit. We&rsquo;re going to try to submit these on top of a
single changeset on the Perforce side. Let&rsquo;s see what would happen if we tried to submit now:
<p>$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-
mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-
mbp_8487/depot/www/live/
Would apply
&nbsp; b4959b6 Trademark
&nbsp; cbacd0a Table borders: yes please
&nbsp; 3be6fd8 Correct email address
<p>The -n flag is short for --dry-run, which tries to report what would happen if the submit command
were run for real. In this case, it looks like we&rsquo;d be creating three Perforce changesets, which
correspond to the three non-merge commits that don&rsquo;t yet exist on the Perforce server. That sounds
like exactly what we want, let&rsquo;s see how it turns out:
<p>405</p>
<br>
</div>
<div class="page">
<br>
<p>$ git p4 submit
[&hellip;]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
<p>Our history became linear, just as though we had rebased before submitting (which is in fact
exactly what happened). This means you can be free to create, work on, throw away, and merge
branches on the Git side without fear that your history will somehow become incompatible with
Perforce. If you can rebase it, you can contribute it to a Perforce server.
<p>Branching
<p>If your Perforce project has multiple branches, you&rsquo;re not out of luck; git-p4 can handle that in a
way that makes it feel like Git. Let&rsquo;s say your Perforce depot is laid out like this:
<p>//depot
&nbsp; └── project
&nbsp; ├── main
&nbsp; └── dev
<p>And let&rsquo;s say you have a dev branch, which has a view spec that looks like this:
<p>//depot/project/main/... //depot/project/dev/...
<p>Git-p4 can automatically detect that situation and do the right thing:
<p>406</p>
<br>
</div>
<div class="page">
<br>
<p>$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
&nbsp; Importing new branch project/dev
<p>&nbsp; Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
<p>Note the &ldquo;@all&rdquo; specifier in the depot path; that tells git-p4 to clone not just the latest changeset for
that subtree, but all changesets that have ever touched those paths. This is closer to Git&rsquo;s concept of
a clone, but if you&rsquo;re working on a project with a long history, it could take a while.
<p>The --detect-branches flag tells git-p4 to use Perforce&rsquo;s branch specs to map the branches to Git refs.
If these mappings aren&rsquo;t present on the Perforce server (which is a perfectly valid way to use
Perforce), you can tell git-p4 what the branch mappings are, and you get the same result:
<p>$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
<p>Setting the git-p4.branchList configuration variable to main:dev tells git-p4 that &ldquo;main&rdquo; and &ldquo;dev&rdquo;
are both branches, and the second one is a child of the first one.
<p>If we now git checkout -b dev p4/project/dev and make some commits, git-p4 is smart enough to
target the right branch when we do git p4 submit. Unfortunately, git-p4 can&rsquo;t mix shallow clones
and multiple branches; if you have a huge project and want to work on more than one branch,
you&rsquo;ll have to git p4 clone once for each branch you want to submit to.
<p>For creating or integrating branches, you&rsquo;ll have to use a Perforce client. Git-p4 can only sync and
submit to existing branches, and it can only do it one linear changeset at a time. If you merge two
branches in Git and try to submit the new changeset, all that will be recorded is a bunch of file
changes; the metadata about which branches are involved in the integration will be lost.
<p>Git and Perforce Summary
<p>Git-p4 makes it possible to use a Git workflow with a Perforce server, and it&rsquo;s pretty good at it.
However, it&rsquo;s important to remember that Perforce is in charge of the source, and you&rsquo;re only using
Git to work locally. Just be really careful about sharing Git commits; if you have a remote that other
<p>407</p>
<br>
</div>
<div class="page">
<br>
<p>people use, don&rsquo;t push any commits that haven&rsquo;t already been submitted to the Perforce server.
<p>If you want to freely mix the use of Perforce and Git as clients for source control, and you can
convince the server administrator to install it, Git Fusion makes using Git a first-class version-
control client for a Perforce server.
<p>Git and TFS
<p>Git is becoming popular with Windows developers, and if you&rsquo;re writing code on Windows, there&rsquo;s
a good chance you&rsquo;re using Microsoft&rsquo;s Team Foundation Server (TFS). TFS is a collaboration suite
that includes defect and work-item tracking, process support for Scrum and others, code review,
and version control. There&rsquo;s a bit of confusion ahead: TFS is the server, which supports controlling
source code using both Git and their own custom VCS, which they&rsquo;ve dubbed TFVC (Team
Foundation Version Control). Git support is a somewhat new feature for TFS (shipping with the
2013 version), so all of the tools that predate that refer to the version-control portion as &ldquo;TFS&rdquo;, even
though they&rsquo;re mostly working with TFVC.
<p>If you find yourself on a team that&rsquo;s using TFVC but you&rsquo;d rather use Git as your version-control
client, there&rsquo;s a project for you.
<p>Which Tool
<p>In fact, there are two: git-tf and git-tfs.
<p>Git-tfs (found at https://github.com/git-tfs/git-tfs) is a .NET project, and (as of this writing) it only
runs on Windows. To work with Git repositories, it uses the .NET bindings for libgit2, a library-
oriented implementation of Git which is highly performant and allows a lot of flexibility with the
guts of a Git repository. Libgit2 is not a complete implementation of Git, so to cover the difference
git-tfs will actually call the command-line Git client for some operations, so there are no artificial
limits on what it can do with Git repositories. Its support of TFVC features is very mature, since it
uses the Visual Studio assemblies for operations with servers. This does mean you&rsquo;ll need access to
those assemblies, which means you need to install a recent version of Visual Studio (any edition
since version 2010, including Express since version 2012), or the Visual Studio SDK.
<p>
Git-tf is End-of-Life (EOL), it will not get any updates. It is also no longer supported
by Microsoft.
<p>Git-tf (whose home is at https://archive.codeplex.com/?p=gittf) is a Java project, and as such runs on
any computer with a Java runtime environment. It interfaces with Git repositories through JGit (a
JVM implementation of Git), which means it has virtually no limitations in terms of Git functions.
However, its support for TFVC is limited as compared to git-tfs &ndash; it does not support branches, for
instance.
<p>So each tool has pros and cons, and there are plenty of situations that favor one over the other.
We&rsquo;ll cover the basic usage of both of them in this book.
<p>408</p>
<br>
<div class="annotation">
<a href="https://github.com/git-tfs/git-tfs">https://github.com/git-tfs/git-tfs</a>
</div>
<div class="annotation">
<a href="https://archive.codeplex.com/?p=gittf">https://archive.codeplex.com/?p=gittf</a>
</div>
</div>
<div class="page">
<br>
<p>
<p>You&rsquo;ll need access to a TFVC-based repository to follow along with these
instructions. These aren&rsquo;t as plentiful in the wild as Git or Subversion repositories,
so you may need to create one of your own. Codeplex
(https://archive.codeplex.com/) or Visual Studio Online
(https://visualstudio.microsoft.com) are both good choices for this.
<p>Getting Started: git-tf
<p>The first thing you do, just as with any Git project, is clone. Here&rsquo;s what that looks like with git-tf:
<p>$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
<p>The first argument is the URL of a TFVC collection, the second is of the form $/project/branch, and
the third is the path to the local Git repository that is to be created (this last one is optional). Git-tf
can only work with one branch at a time; if you want to make checkins on a different TFVC branch,
you&rsquo;ll have to make a new clone from that branch.
<p>This creates a fully functional Git repository:
<p>$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
<p>This is called a shallow clone, meaning that only the latest changeset has been downloaded. TFVC
isn&rsquo;t designed for each client to have a full copy of the history, so git-tf defaults to only getting the
latest version, which is much faster.
<p>If you have some time, it&rsquo;s probably worth it to clone the entire project history, using the --deep
option:
<p>$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
&nbsp; project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
&nbsp; Team Project Creation Wizard
<p>Notice the tags with names like TFS_C35189; this is a feature that helps you know which Git commits
<p>409</p>
<br>
<div class="annotation">
<a href="https://archive.codeplex.com/">https://archive.codeplex.com/</a>
</div>
<div class="annotation">
<a href="https://visualstudio.microsoft.com">https://visualstudio.microsoft.com</a>
</div>
</div>
<div class="page">
<br>
<p>are associated with TFVC changesets. This is a nice way to represent it, since you can see with a
simple log command which of your commits is associated with a snapshot that also exists in TFVC.
They aren&rsquo;t necessary (and in fact you can turn them off with git config git-tf.tag false) &ndash; git-tf
keeps the real commit-changeset mappings in the .git/git-tf file.
<p>Getting Started: git-tfs
<p>Git-tfs cloning behaves a bit differently. Observe:
<p>PS&gt; git tfs clone --with-branches \
&nbsp; https://username.visualstudio.com/DefaultCollection \
&nbsp; $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
<p>Notice the --with-branches flag. Git-tfs is capable of mapping TFVC branches to Git branches, and
this flag tells it to set up a local Git branch for every TFVC branch. This is highly recommended if
you&rsquo;ve ever branched or merged in TFS, but it won&rsquo;t work with a server older than TFS 2010 &ndash;
before that release, &ldquo;branches&rdquo; were just folders, so git-tfs can&rsquo;t tell them from regular folders.
<p>Let&rsquo;s take a look at the resulting Git repository:
<p>PS&gt; git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS&gt; git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub &lt;ben@straub.cc&gt;
Date: Fri Aug 1 03:41:59 2014 +0000
<p>&nbsp; Hello
<p>&nbsp; git-tfs-id:
[https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
<p>There are two local branches, master and featureA, which represent the initial starting point of the
clone (Trunk in TFVC) and a child branch (featureA in TFVC). You can also see that the tfs &ldquo;remote&rdquo;
has a couple of refs too: default and featureA, which represent TFVC branches. Git-tfs maps the
branch you cloned from to tfs/default, and others get their own names.
<p>410</p>
<br>
</div>
<div class="page">
<br>
<p>Another thing to notice is the git-tfs-id: lines in the commit messages. Instead of tags, git-tfs uses
these markers to relate TFVC changesets to Git commits. This has the implication that your Git
commits will have a different SHA-1 hash before and after they have been pushed to TFVC.
<p>Git-tf[s] Workflow
<p>
<p>Regardless of which tool you&rsquo;re using, you should set a couple of Git configuration
values to avoid running into issues.
<p>$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
<p>The obvious next thing you&rsquo;re going to want to do is work on the project. TFVC and TFS have
several features that may add complexity to your workflow:
<p>1. Feature branches that aren&rsquo;t represented in TFVC add a bit of complexity. This has to do with
the very different ways that TFVC and Git represent branches.
<p>2. Be aware that TFVC allows users to &ldquo;checkout&rdquo; files from the server, locking them so nobody
else can edit them. This obviously won&rsquo;t stop you from editing them in your local repository, but
it could get in the way when it comes time to push your changes up to the TFVC server.
<p>3. TFS has the concept of &ldquo;gated&rdquo; checkins, where a TFS build-test cycle has to complete
successfully before the checkin is allowed. This uses the &ldquo;shelve&rdquo; function in TFVC, which we
don&rsquo;t cover in detail here. You can fake this in a manual fashion with git-tf, and git-tfs provides
the checkintool command which is gate-aware.
<p>In the interest of brevity, what we&rsquo;ll cover here is the happy path, which sidesteps or avoids most of
these issues.
<p>Workflow: git-tf
<p>Let&rsquo;s say you&rsquo;ve done some work, made a couple of Git commits on master, and you&rsquo;re ready to
share your progress on the TFVC server. Here&rsquo;s our Git repository:
<p>$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
&nbsp; Team Project Creation Wizard
<p>We want to take the snapshot that&rsquo;s in the 4178a82 commit and push it up to the TFVC server. First
things first: let&rsquo;s see if any of our teammates did anything since we last connected:
<p>411</p>
<br>
</div>
<div class="page">
<br>
<p>$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
&nbsp; Team Project Creation Wizard
<p>Looks like someone else is working, too, and now we have divergent history. This is where Git
shines, but we have two choices of how to proceed:
<p>1. Making a merge commit feels natural as a Git user (after all, that&rsquo;s what git pull does), and git-
tf can do this for you with a simple git tf pull. Be aware, however, that TFVC doesn&rsquo;t think this
way, and if you push merge commits your history will start to look different on both sides,
which can be confusing. However, if you plan on submitting all of your changes as one
changeset, this is probably the easiest choice.
<p>2. Rebasing makes our commit history linear, which means we have the option of converting each
of our Git commits into a TFVC changeset. Since this leaves the most options open, we
recommend you do it this way; git-tf even makes it easy for you with git tf pull --rebase.
<p>The choice is yours. For this example, we&rsquo;ll be rebasing:
<p>$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
&nbsp; Team Project Creation Wizard
<p>Now we&rsquo;re ready to make a checkin to the TFVC server. Git-tf gives you the choice of making a
single changeset that represents all the changes since the last one (--shallow, which is the default)
and creating a new changeset for each Git commit (--deep). For this example, we&rsquo;ll just create one
<p>412</p>
<br>
</div>
<div class="page">
<br>
<p>changeset:
<p>$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
&nbsp; Team Project Creation Wizard
<p>There&rsquo;s a new TFS_C35348 tag, indicating that TFVC is storing the exact same snapshot as the 5a0e25e
commit. It&rsquo;s important to note that not every Git commit needs to have an exact counterpart in
TFVC; the 6eb3eb5 commit, for example, doesn&rsquo;t exist anywhere on the server.
<p>That&rsquo;s the main workflow. There are a couple of other considerations you&rsquo;ll want to keep in mind:
<p>&bull; There is no branching. Git-tf can only create Git repositories from one TFVC branch at a time.
<p>&bull; Collaborate using either TFVC or Git, but not both. Different git-tf clones of the same TFVC
repository may have different commit SHA-1 hashes, which will cause no end of headaches.
<p>&bull; If your team&rsquo;s workflow includes collaborating in Git and syncing periodically with TFVC, only
connect to TFVC with one of the Git repositories.
<p>Workflow: git-tfs
<p>Let&rsquo;s walk through the same scenario using git-tfs. Here are the new commits we&rsquo;ve made to the
master branch in our Git repository:
<p>PS&gt; git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
<p>Now let&rsquo;s see if anyone else has done work while we were hacking away:
<p>413</p>
<br>
</div>
<div class="page">
<br>
<p>PS&gt; git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS&gt; git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
<p>Yes, it turns out our coworker has added a new TFVC changeset, which shows up as the new aea74a0
commit, and the tfs/default remote branch has moved.
<p>As with git-tf, we have two fundamental options for how to resolve this divergent history:
<p>1. Rebase to preserve a linear history.
<p>2. Merge to preserve what actually happened.
<p>In this case, we&rsquo;re going to do a &ldquo;deep&rdquo; checkin, where every Git commit becomes a TFVC changeset,
so we want to rebase.
<p>PS&gt; git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS&gt; git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
<p>Now we&rsquo;re ready to complete our contribution by checking in our code to the TFVC server. We&rsquo;ll use
the rcheckin command here to create a TFVC changeset for each Git commit in the path from HEAD
to the first tfs remote branch found (the checkin command would only create one changeset, sort of
like squashing Git commits).
<p>414</p>
<br>
</div>
<div class="page">
<br>
<p>PS&gt; git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
&nbsp;add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-
commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
&nbsp;edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-
commit...
Rebase done successfully.
No more to rcheckin.
PS&gt; git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
<p>Notice how after every successful checkin to the TFVC server, git-tfs is rebasing the remaining work
onto what it just did. That&rsquo;s because it&rsquo;s adding the git-tfs-id field to the bottom of the commit
messages, which changes the SHA-1 hashes. This is exactly as designed, and there&rsquo;s nothing to
worry about, but you should be aware that it&rsquo;s happening, especially if you&rsquo;re sharing Git commits
with others.
<p>TFS has many features that integrate with its version control system, such as work items,
designated reviewers, gated checkins, and so on. It can be cumbersome to work with these features
using only a command-line tool, but fortunately git-tfs lets you launch a graphical checkin tool very
easily:
<p>PS&gt; git tfs checkintool
PS&gt; git tfs ct
<p>It looks a bit like this:
<p>415</p>
<br>
</div>
<div class="page">
<br>
<p>Figure 148. The git-tfs checkin tool.
<p>This will look familiar to TFS users, as it&rsquo;s the same dialog that&rsquo;s launched from within Visual
Studio.
<p>Git-tfs also lets you control TFVC branches from your Git repository. As an example, let&rsquo;s create one:
<p>PS&gt; git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS&gt; git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
<p>Creating a branch in TFVC means adding a changeset where that branch now exists, and this is
projected as a Git commit. Note also that git-tfs created the tfs/featureBee remote branch, but HEAD
is still pointing to master. If you want to work on the newly-minted branch, you&rsquo;ll want to base your
new commits on the 1d54865 commit, perhaps by creating a topic branch from that commit.
<p>Git and TFS Summary
<p>Git-tf and Git-tfs are both great tools for interfacing with a TFVC server. They allow you to use the
power of Git locally, avoid constantly having to round-trip to the central TFVC server, and make
<p>416</p>
<br>
</div>
<div class="page">
<br>
<p>your life as a developer much easier, without forcing your entire team to migrate to Git. If you&rsquo;re
working on Windows (which is likely if your team is using TFS), you&rsquo;ll probably want to use git-tfs,
since its feature set is more complete, but if you&rsquo;re working on another platform, you&rsquo;ll be using git-
tf, which is more limited. As with most of the tools in this chapter, you should choose one of these
version-control systems to be canonical, and use the other one in a subordinate fashion &ndash; either Git
or TFVC should be the center of collaboration, but not both.
<p>Migrating to Git
If you have an existing codebase in another VCS but you&rsquo;ve decided to start using Git, you must
migrate your project one way or another. This section goes over some importers for common
systems, and then demonstrates how to develop your own custom importer. You&rsquo;ll learn how to
import data from several of the bigger professionally used SCM systems, because they make up the
majority of users who are switching, and because high-quality tools for them are easy to come by.
<p>Subversion
<p>If you read the previous section about using git svn, you can easily use those instructions to git svn
clone a repository; then, stop using the Subversion server, push to a new Git server, and start using
that. If you want the history, you can accomplish that as quickly as you can pull the data out of the
Subversion server (which may take a while).
<p>However, the import isn&rsquo;t perfect; and because it will take so long, you may as well do it right. The
first problem is the author information. In Subversion, each person committing has a user on the
system who is recorded in the commit information. The examples in the previous section show
schacon in some places, such as the blame output and the git svn log. If you want to map this to
better Git author data, you need a mapping from the Subversion users to the Git authors. Create a
file called users.txt that has this mapping in a format like this:
<p>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;
<p>To get a list of the author names that SVN uses, you can run this:
<p>$ svn log --xml --quiet | grep author | sort -u | \
&nbsp; perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'
<p>That generates the log output in XML format, then keeps only the lines with author information,
discards duplicates, strips out the XML tags. Obviously this only works on a machine with grep,
sort, and perl installed. Then, redirect that output into your users.txt file so you can add the
equivalent Git user data next to each entry.
<p>
<p>If you&rsquo;re trying this on a Windows machine, this is the point where you&rsquo;ll run into
trouble. Microsoft have provided some good advice and samples at
https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-
svn-to-git.
<p>417</p>
<br>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git">https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git">https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git</a>
</div>
</div>
<div class="page">
<br>
<p>You can provide this file to git svn to help it map the author data more accurately. You can also tell
git svn not to include the metadata that Subversion normally imports, by passing --no-metadata to
the clone or init command. The metadata includes a git-svn-id inside each commit message that
Git will generate during import. This can bloat your Git log and might make it a bit unclear.
<p>
You need to keep the metadata when you want to mirror commits made in the Git
repository back into the original SVN repository. If you don&rsquo;t want the
synchronization in your commit log, feel free to omit the --no-metadata parameter.
<p>This makes your import command look like this:
<p>$ git svn clone http://my-project.googlecode.com/svn/ \
&nbsp; --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project
<p>Now you should have a nicer Subversion import in your my_project directory. Instead of commits
that look like this
<p>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date: Sun May 3 00:12:22 2009 +0000
<p>&nbsp; fixed install - go to trunk
<p>&nbsp; git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
&nbsp; be05-5f7a86268029
<p>they look like this:
<p>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date: Sun May 3 00:12:22 2009 +0000
<p>&nbsp; fixed install - go to trunk
<p>Not only does the Author field look a lot better, but the git-svn-id is no longer there, either.
<p>You should also do a bit of post-import cleanup. For one thing, you should clean up the weird
references that git svn set up. First you&rsquo;ll move the tags so they&rsquo;re actual tags rather than strange
remote branches, and then you&rsquo;ll move the rest of the branches so they&rsquo;re local.
<p>To move the tags to be proper Git tags, run:
<p>$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git
tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done
<p>418</p>
<br>
</div>
<div class="page">
<br>
<p>This takes the references that were remote branches that started with refs/remotes/tags/ and
makes them real (lightweight) tags.
<p>Next, move the rest of the references under refs/remotes to be local branches:
<p>$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch
$b refs/remotes/$b &amp;&amp; git branch -D -r $b; done
<p>It may happen that you&rsquo;ll see some extra branches which are suffixed by @xxx (where xxx is a
number), while in Subversion you only see one branch. This is actually a Subversion feature called
&ldquo;peg-revisions&rdquo;, which is something that Git simply has no syntactical counterpart for. Hence, git
svn simply adds the svn version number to the branch name just in the same way as you would
have written it in svn to address the peg-revision of that branch. If you do not care anymore about
the peg-revisions, simply remove them:
<p>$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D
$p; done
<p>Now all the old branches are real Git branches and all the old tags are real Git tags.
<p>There&rsquo;s one last thing to clean up. Unfortunately, git svn creates an extra branch named trunk,
which maps to Subversion&rsquo;s default branch, but the trunk ref points to the same place as master.
Since master is more idiomatically Git, here&rsquo;s how to remove the extra branch:
<p>$ git branch -d trunk
<p>The last thing to do is add your new Git server as a remote and push to it. Here is an example of
adding your server as a remote:
<p>$ git remote add origin git@my-git-server:myrepository.git
<p>Because you want all your branches and tags to go up, you can now run this:
<p>$ git push origin --all
$ git push origin --tags
<p>All your branches and tags should be on your new Git server in a nice, clean import.
<p>Mercurial
<p>Since Mercurial and Git have fairly similar models for representing versions, and since Git is a bit
more flexible, converting a repository from Mercurial to Git is fairly straightforward, using a tool
called "hg-fast-export", which you&rsquo;ll need a copy of:
<p>419</p>
<br>
</div>
<div class="page">
<br>
<p>$ git clone https://github.com/frej/fast-export.git
<p>The first step in the conversion is to get a full clone of the Mercurial repository you want to convert:
<p>$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo
<p>The next step is to create an author mapping file. Mercurial is a bit more forgiving than Git for what
it will put in the author field for changesets, so this is a good time to clean house. Generating this is
a one-line command in a bash shell:
<p>$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors
<p>This will take a few seconds, depending on how long your project&rsquo;s history is, and afterwards the
/tmp/authors file will look something like this:
<p>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;
<p>In this example, the same person (Bob) has created changesets under four different names, one of
which actually looks correct, and one of which would be completely invalid for a Git commit. Hg-
fast-export lets us fix this by turning each line into a rule: "&lt;input&gt;"="&lt;output&gt;", mapping an &lt;input&gt;
to an &lt;output&gt;. Inside the &lt;input&gt; and &lt;output&gt; strings, all escape sequences understood by the
python string_escape encoding are supported. If the author mapping file does not contain a
matching &lt;input&gt;, that author will be sent on to Git unmodified. If all the usernames look fine, we
won&rsquo;t need this file at all. In this example, we want our file to look like this:
<p>"bob"="Bob Jones &lt;bob@company.com&gt;"
"bob@localhost"="Bob Jones &lt;bob@company.com&gt;"
"bob &lt;bob@company.com&gt;"="Bob Jones &lt;bob@company.com&gt;"
"bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;"="Bob Jones &lt;bob@company.com&gt;"
<p>The same kind of mapping file can be used to rename branches and tags when the Mercurial name
is not allowed by Git.
<p>The next step is to create our new Git repository, and run the export script:
<p>420</p>
<br>
</div>
<div class="page">
<br>
<p>$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
<p>The -r flag tells hg-fast-export where to find the Mercurial repository we want to convert, and the
-A flag tells it where to find the author-mapping file (branch and tag mapping files are specified by
the -B and -T flags respectively). The script parses Mercurial changesets and converts them into a
script for Git&rsquo;s "fast-import" feature (which we&rsquo;ll discuss in detail a bit later on). This takes a bit
(though it&rsquo;s much faster than it would be over the network), and the output is fairly verbose:
<p>421</p>
<br>
</div>
<div class="page">
<br>
<p>$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[&hellip;]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed
files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed
files
master: Exporting thorough delta revision 22208/22208 with 3/213/0
added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[&hellip;]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects: 120000
Total objects: 115032 ( 208171 duplicates )
&nbsp; blobs : 40504 ( 205320 duplicates 26117 deltas of 39602
attempts)
&nbsp; trees : 52320 ( 2851 duplicates 47467 deltas of 47599
attempts)
&nbsp; commits: 22208 ( 0 duplicates 0 deltas of 0
attempts)
&nbsp; tags : 0 ( 0 duplicates 0 deltas of 0
attempts)
Total branches: 109 ( 2 loads )
&nbsp; marks: 1048576 ( 22208 unique )
&nbsp; atoms: 1952
Memory total: 7860 KiB
&nbsp; pools: 2235 KiB
&nbsp; objects: 5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize() = 4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit = 8589934592
pack_report: pack_used_ctr = 90430
pack_report: pack_mmap_calls = 46771
pack_report: pack_open_windows = 1 / 1
pack_report: pack_mapped = 340852700 / 340852700
---------------------------------------------------------------------
<p>$ git shortlog -sn
&nbsp; 369 Bob Jones
&nbsp; 365 Joe Smith
<p>422</p>
<br>
</div>
<div class="page">
<br>
<p>That&rsquo;s pretty much all there is to it. All of the Mercurial tags have been converted to Git tags, and
Mercurial branches and bookmarks have been converted to Git branches. Now you&rsquo;re ready to
push the repository up to its new server-side home:
<p>$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all
<p>Bazaar
<p>Bazaar is a DVCS tool much like Git, and as a result it&rsquo;s pretty straightforward to convert a Bazaar
repository into a Git one. To accomplish this, you&rsquo;ll need to import the bzr-fastimport plugin.
<p>Getting the bzr-fastimport plugin
<p>The procedure for installing the fastimport plugin is different on UNIX-like operating systems and
on Windows. In the first case, the simplest is to install the bzr-fastimport package that will install
all the required dependencies.
<p>For example, with Debian and derived, you would do the following:
<p>$ sudo apt-get install bzr-fastimport
<p>With RHEL, you would do the following:
<p>$ sudo yum install bzr-fastimport
<p>With Fedora, since release 22, the new package manager is dnf:
<p>$ sudo dnf install bzr-fastimport
<p>If the package is not available, you may install it as a plugin:
<p>$ mkdir --parents ~/.bazaar/plugins # creates the necessary folders for the
plugins
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport # imports the fastimport plugin
$ cd fastimport
$ sudo python setup.py install --record=files.txt # installs the plugin
<p>For this plugin to work, you&rsquo;ll also need the fastimport Python module. You can check whether it is
present or not and install it with the following commands:
<p>423</p>
<br>
</div>
<div class="page">
<br>
<p>$ python -c "import fastimport"
Traceback (most recent call last):
&nbsp; File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport
<p>If it is not available, you can download it at address https://pypi.python.org/pypi/fastimport/.
<p>In the second case (on Windows), bzr-fastimport is automatically installed with the standalone
version and the default installation (let all the checkboxes checked). So in this case you have
nothing to do.
<p>At this point, the way to import a Bazaar repository differs according to that you have a single
branch or you are working with a repository that has several branches.
<p>Project with a single branch
<p>Now cd in the directory that contains your Bazaar repository and initialize the Git repository:
<p>$ cd /path/to/the/bzr/repository
$ git init
<p>Now, you can simply export your Bazaar repository and convert it into a Git repository using the
following command:
<p>$ bzr fast-export --plain . | git fast-import
<p>Depending on the size of the project, your Git repository is built in a lapse from a few seconds to a
few minutes.
<p>Case of a project with a main branch and a working branch
<p>You can also import a Bazaar repository that contains branches. Let us suppose that you have two
branches: one represents the main branch (myProject.trunk), the other one is the working branch
(myProject.work).
<p>$ ls
myProject.trunk myProject.work
<p>Create the Git repository and cd into it:
<p>$ git init git-repo
$ cd git-repo
<p>Pull the master branch into git:
<p>424</p>
<br>
<div class="annotation">
<a href="https://pypi.python.org/pypi/fastimport/">https://pypi.python.org/pypi/fastimport/</a>
</div>
</div>
<div class="page">
<br>
<p>$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git
<p>Pull the working branch into Git:
<p>$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git
<p>Now git branch shows you the master branch as well as the work branch. Check the logs to make
sure they&rsquo;re complete and get rid of the marks.bzr and marks.git files.
<p>Synchronizing the staging area
<p>Whatever the number of branches you had and the import method you used, your staging area is
not synchronized with HEAD, and with the import of several branches, your working directory is not
synchronized either. This situation is easily solved by the following command:
<p>$ git reset --hard HEAD
<p>Ignoring the files that were ignored with .bzrignore
<p>Now let&rsquo;s have a look at the files to ignore. The first thing to do is to rename .bzrignore into
.gitignore. If the .bzrignore file contains one or several lines starting with "!!" or "RE:", you&rsquo;ll have
to modify it and perhaps create several .gitignore files in order to ignore exactly the same files that
Bazaar was ignoring.
<p>Finally, you will have to create a commit that contains this modification for the migration:
<p>$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'
<p>Sending your repository to the server
<p>Here we are! Now you can push the repository onto its new home server:
<p>$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags
<p>Your Git repository is ready to use.
<p>425</p>
<br>
</div>
<div class="page">
<br>
<p>Perforce
<p>The next system you&rsquo;ll look at importing from is Perforce. As we discussed above, there are two
ways to let Git and Perforce talk to each other: git-p4 and Perforce Git Fusion.
<p>Perforce Git Fusion
<p>Git Fusion makes this process fairly painless. Just configure your project settings, user mappings,
and branches using a configuration file (as discussed in Git Fusion), and clone the repository. Git
Fusion leaves you with what looks like a native Git repository, which is then ready to push to a
native Git host if you desire. You could even use Perforce as your Git host if you like.
<p>Git-p4
<p>Git-p4 can also act as an import tool. As an example, we&rsquo;ll import the Jam project from the Perforce
Public Depot. To set up your client, you must export the P4PORT environment variable to point to
the Perforce depot:
<p>$ export P4PORT=public.perforce.com:1666
<p>
In order to follow along, you&rsquo;ll need a Perforce depot to connect with. We&rsquo;ll be
using the public depot at public.perforce.com for our examples, but you can use
any depot you have access to.
<p>Run the git p4 clone command to import the Jam project from the Perforce server, supplying the
depot and project path and the path into which you want to import the project:
<p>$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)
<p>This particular project has only one branch, but if you have branches that are configured with
branch views (or just a set of directories), you can use the --detect-branches flag to git p4 clone to
import all the project&rsquo;s branches as well. See Branching for a bit more detail on this.
<p>At this point you&rsquo;re almost done. If you go to the p4import directory and run git log, you can see
your imported work:
<p>426</p>
<br>
</div>
<div class="page">
<br>
<p>$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date: Wed Feb 8 03:13:27 2012 -0800
<p>&nbsp; Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.
<p>&nbsp; [git-p4: depot-paths = "//public/jam/src/": change = 8068]
<p>commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date: Tue Jul 7 01:35:51 2009 -0800
<p>&nbsp; Fix spelling error on Jam doc page (cummulative -&gt; cumulative).
<p>&nbsp; [git-p4: depot-paths = "//public/jam/src/": change = 7304]
<p>You can see that git-p4 has left an identifier in each commit message. It&rsquo;s fine to keep that identifier
there, in case you need to reference the Perforce change number later. However, if you&rsquo;d like to
remove the identifier, now is the time to do so &ndash; before you start doing work on the new repository.
You can use git filter-branch to remove the identifier strings en masse:
<p>$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten
<p>If you run git log, you can see that all the SHA-1 checksums for the commits have changed, but the
git-p4 strings are no longer in the commit messages:
<p>$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date: Wed Feb 8 03:13:27 2012 -0800
<p>&nbsp; Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.
<p>commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date: Tue Jul 7 01:35:51 2009 -0800
<p>&nbsp; Fix spelling error on Jam doc page (cummulative -&gt; cumulative).
<p>Your import is ready to push up to your new Git server.
<p>TFS
<p>If your team is converting their source control from TFVC to Git, you&rsquo;ll want the highest-fidelity
<p>427</p>
<br>
</div>
<div class="page">
<br>
<p>conversion you can get. This means that, while we covered both git-tfs and git-tf for the interop
section, we&rsquo;ll only be covering git-tfs for this part, because git-tfs supports branches, and this is
prohibitively difficult using git-tf.
<p>
This is a one-way conversion. The resulting Git repository won&rsquo;t be able to connect
with the original TFVC project.
<p>The first thing to do is map usernames. TFVC is fairly liberal with what goes into the author field for
changesets, but Git wants a human-readable name and email address. You can get this information
from the tf command-line client, like so:
<p>PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP
<p>This grabs all of the changesets in the history of the project and put it in the AUTHORS_TMP file that
we will process to extract the data of the User column (the 2nd one). Open the file and find at which
characters start and end the column and replace, in the following command-line, the parameters
11-20 of the cut command with the ones found:
<p>PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | sort | uniq &gt; AUTHORS
<p>The cut command keeps only the characters between 11 and 20 from each line. The tail command
skips the first two lines, which are field headers and ASCII-art underlines. The result of all of this is
piped to sort and uniq to eliminate duplicates, and saved to a file named AUTHORS. The next step is
manual; in order for git-tfs to make effective use of this file, each line must be in this format:
<p>DOMAIN\username = User Name &lt;email@address.com&gt;
<p>The portion on the left is the &ldquo;User&rdquo; field from TFVC, and the portion on the right side of the equals
sign is the user name that will be used for Git commits.
<p>Once you have this file, the next thing to do is make a full clone of the TFVC project you&rsquo;re
interested in:
<p>PS&gt; git tfs clone --with-branches --authors=AUTHORS
https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git
<p>Next you&rsquo;ll want to clean the git-tfs-id sections from the bottom of the commit messages. The
following command will do that:
<p>PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' '--' --all
<p>That uses the sed command from the Git-bash environment to replace any line starting with &ldquo;git-tfs-
id:&rdquo; with emptiness, which Git will then ignore.
<p>428</p>
<br>
</div>
<div class="page">
<br>
<p>Once that&rsquo;s all done, you&rsquo;re ready to add a new remote, push all your branches up, and have your
team start working from Git.
<p>A Custom Importer
<p>If your system isn&rsquo;t one of the above, you should look for an importer online &ndash; quality importers are
available for many other systems, including CVS, Clear Case, Visual Source Safe, even a directory of
archives. If none of these tools works for you, you have a more obscure tool, or you otherwise need
a more custom importing process, you should use git fast-import. This command reads simple
instructions from stdin to write specific Git data. It&rsquo;s much easier to create Git objects this way than
to run the raw Git commands or try to write the raw objects (see Git Internals for more
information). This way, you can write an import script that reads the necessary information out of
the system you&rsquo;re importing from and prints straightforward instructions to stdout. You can then
run this program and pipe its output through git fast-import.
<p>To quickly demonstrate, you&rsquo;ll write a simple importer. Suppose you work in current, you back up
your project by occasionally copying the directory into a time-stamped back_YYYY_MM_DD backup
directory, and you want to import this into Git. Your directory structure looks like this:
<p>$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current
<p>In order to import a Git directory, you need to review how Git stores its data. As you may
remember, Git is fundamentally a linked list of commit objects that point to a snapshot of content.
All you have to do is tell fast-import what the content snapshots are, what commit data points to
them, and the order they go in. Your strategy will be to go through the snapshots one at a time and
create commits with the contents of each directory, linking each commit back to the previous one.
<p>As we did in An Example Git-Enforced Policy, we&rsquo;ll write this in Ruby, because it&rsquo;s what we
generally work with and it tends to be easy to read. You can write this example pretty easily in
anything you&rsquo;re familiar with &ndash; it just needs to print the appropriate information to stdout. And, if
you are running on Windows, this means you&rsquo;ll need to take special care to not introduce carriage
returns at the end your lines &ndash; git fast-import is very particular about just wanting line feeds (LF)
not the carriage return line feeds (CRLF) that Windows uses.
<p>To begin, you&rsquo;ll change into the target directory and identify every subdirectory, each of which is a
snapshot that you want to import as a commit. You&rsquo;ll change into each subdirectory and print the
commands necessary to export it. Your basic main loop looks like this:
<p>429</p>
<br>
</div>
<div class="page">
<br>
<p>last_mark = nil
<p># loop through the directories
Dir.chdir(ARGV[0]) do
&nbsp; Dir.glob("*").each do |dir|
&nbsp; next if File.file?(dir)
<p>&nbsp; # move into the target directory
&nbsp; Dir.chdir(dir) do
&nbsp; last_mark = print_export(dir, last_mark)
&nbsp; end
&nbsp; end
end
<p>You run print_export inside each directory, which takes the manifest and mark of the previous
snapshot and returns the manifest and mark of this one; that way, you can link them properly.
&ldquo;Mark&rdquo; is the fast-import term for an identifier you give to a commit; as you create commits, you
give each one a mark that you can use to link to it from other commits. So, the first thing to do in
your print_export method is generate a mark from the directory name:
<p>mark = convert_dir_to_mark(dir)
<p>You&rsquo;ll do this by creating an array of directories and using the index value as the mark, because a
mark must be an integer. Your method looks like this:
<p>$marks = []
def convert_dir_to_mark(dir)
&nbsp; if !$marks.include?(dir)
&nbsp; $marks &lt;&lt; dir
&nbsp; end
&nbsp; ($marks.index(dir) + 1).to_s
end
<p>Now that you have an integer representation of your commit, you need a date for the commit
metadata. Because the date is expressed in the name of the directory, you&rsquo;ll parse it out. The next
line in your print_export file is:
<p>date = convert_dir_to_date(dir)
<p>where convert_dir_to_date is defined as:
<p>430</p>
<br>
</div>
<div class="page">
<br>
<p>def convert_dir_to_date(dir)
&nbsp; if dir == 'current'
&nbsp; return Time.now().to_i
&nbsp; else
&nbsp; dir = dir.gsub('back_', '')
&nbsp; (year, month, day) = dir.split('_')
&nbsp; return Time.local(year, month, day).to_i
&nbsp; end
end
<p>That returns an integer value for the date of each directory. The last piece of meta-information you
need for each commit is the committer data, which you hardcode in a global variable:
<p>$author = 'John Doe &lt;john@example.com&gt;'
<p>Now you&rsquo;re ready to begin printing out the commit data for your importer. The initial information
states that you&rsquo;re defining a commit object and what branch it&rsquo;s on, followed by the mark you&rsquo;ve
generated, the committer information and commit message, and then the previous commit, if any.
The code looks like this:
<p># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark
<p>You hardcode the time zone (-0700) because doing so is easy. If you&rsquo;re importing from another
system, you must specify the time zone as an offset. The commit message must be expressed in a
special format:
<p>data (size)\n(contents)
<p>The format consists of the word data, the size of the data to be read, a newline, and finally the data.
Because you need to use the same format to specify the file contents later, you create a helper
method, export_data:
<p>def export_data(string)
&nbsp; print "data #{string.size}\n#{string}"
end
<p>All that&rsquo;s left is to specify the file contents for each snapshot. This is easy, because you have each
one in a directory &ndash; you can print out the deleteall command followed by the contents of each file
in the directory. Git will then record each snapshot appropriately:
<p>431</p>
<br>
</div>
<div class="page">
<br>
<p>puts 'deleteall'
Dir.glob("**/*").each do |file|
&nbsp; next if !File.file?(file)
&nbsp; inline_data(file)
end
<p>Note: Because many systems think of their revisions as changes from one commit to another, fast-
import can also take commands with each commit to specify which files have been added,
removed, or modified and what the new contents are. You could calculate the differences between
snapshots and provide only this data, but doing so is more complex &ndash; you may as well give Git all
the data and let it figure it out. If this is better suited to your data, check the fast-import man page
for details about how to provide your data in this manner.
<p>The format for listing the new file contents or specifying a modified file with the new contents is as
follows:
<p>M 644 inline path/to/file
data (size)
(file contents)
<p>Here, 644 is the mode (if you have executable files, you need to detect and specify 755 instead), and
inline says you&rsquo;ll list the contents immediately after this line. Your inline_data method looks like
this:
<p>def inline_data(file, code = 'M', mode = '644')
&nbsp; content = File.read(file)
&nbsp; puts "#{code} #{mode} inline #{file}"
&nbsp; export_data(content)
end
<p>You reuse the export_data method you defined earlier, because it&rsquo;s the same as the way you
specified your commit message data.
<p>The last thing you need to do is to return the current mark so it can be passed to the next iteration:
<p>return mark
<p>
<p>If you are running on Windows you&rsquo;ll need to make sure that you add one extra
step. As mentioned before, Windows uses CRLF for new line characters while git
fast-import expects only LF. To get around this problem and make git fast-import
happy, you need to tell ruby to use LF instead of CRLF:
<p>$stdout.binmode
<p>432</p>
<br>
</div>
<div class="page">
<br>
<p>That&rsquo;s it. Here&rsquo;s the script in its entirety:
<p>#!/usr/bin/env ruby
<p>$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"
<p>$marks = []
def convert_dir_to_mark(dir)
&nbsp; if !$marks.include?(dir)
&nbsp; $marks &lt;&lt; dir
&nbsp; end
&nbsp; ($marks.index(dir)+1).to_s
end
<p>def convert_dir_to_date(dir)
&nbsp; if dir == 'current'
&nbsp; return Time.now().to_i
&nbsp; else
&nbsp; dir = dir.gsub('back_', '')
&nbsp; (year, month, day) = dir.split('_')
&nbsp; return Time.local(year, month, day).to_i
&nbsp; end
end
<p>def export_data(string)
&nbsp; print "data #{string.size}\n#{string}"
end
<p>def inline_data(file, code='M', mode='644')
&nbsp; content = File.read(file)
&nbsp; puts "#{code} #{mode} inline #{file}"
&nbsp; export_data(content)
end
<p>def print_export(dir, last_mark)
&nbsp; date = convert_dir_to_date(dir)
&nbsp; mark = convert_dir_to_mark(dir)
<p>&nbsp; puts 'commit refs/heads/master'
&nbsp; puts "mark :#{mark}"
&nbsp; puts "committer #{$author} #{date} -0700"
&nbsp; export_data("imported from #{dir}")
&nbsp; puts "from :#{last_mark}" if last_mark
<p>&nbsp; puts 'deleteall'
&nbsp; Dir.glob("**/*").each do |file|
&nbsp; next if !File.file?(file)
&nbsp; inline_data(file)
&nbsp; end
<p>433</p>
<br>
</div>
<div class="page">
<br>
<p>&nbsp; mark
end
<p># Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
&nbsp; Dir.glob("*").each do |dir|
&nbsp; next if File.file?(dir)
<p>&nbsp; # move into the target directory
&nbsp; Dir.chdir(dir) do
&nbsp; last_mark = print_export(dir, last_mark)
&nbsp; end
&nbsp; end
end
<p>If you run this script, you&rsquo;ll get content that looks something like this:
<p>$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello
<p>This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby
<p>puts "Hey there"
M 644 inline README.md
(...)
<p>To run the importer, pipe this output through git fast-import while in the Git directory you want to
import into. You can create a new directory and then run git init in it for a starting point, and
then run your script:
<p>434</p>
<br>
</div>
<div class="page">
<br>
<p>$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects: 5000
Total objects: 13 ( 6 duplicates )
&nbsp; blobs : 5 ( 4 duplicates 3 deltas of 5
attempts)
&nbsp; trees : 4 ( 1 duplicates 0 deltas of 4
attempts)
&nbsp; commits: 4 ( 1 duplicates 0 deltas of 0
attempts)
&nbsp; tags : 0 ( 0 duplicates 0 deltas of 0
attempts)
Total branches: 1 ( 1 loads )
&nbsp; marks: 1024 ( 5 unique )
&nbsp; atoms: 2
Memory total: 2344 KiB
&nbsp; pools: 2110 KiB
&nbsp; objects: 234 KiB
---------------------------------------------------------------------
pack_report: getpagesize() = 4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit = 8589934592
pack_report: pack_used_ctr = 10
pack_report: pack_mmap_calls = 5
pack_report: pack_open_windows = 2 / 2
pack_report: pack_mapped = 1457 / 1457
---------------------------------------------------------------------
<p>As you can see, when it completes successfully, it gives you a bunch of statistics about what it
accomplished. In this case, you imported 13 objects total for 4 commits into 1 branch. Now, you can
run git log to see your new history:
<p>$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date: Tue Jul 29 19:39:04 2014 -0700
<p>&nbsp; imported from current
<p>commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date: Mon Feb 3 01:00:00 2014 -0700
<p>&nbsp; imported from back_2014_02_03
<p>435</p>
<br>
</div>
<div class="page">
<br>
<p>There you go &ndash; a nice, clean Git repository. It&rsquo;s important to note that nothing is checked out &ndash; you
don&rsquo;t have any files in your working directory at first. To get them, you must reset your branch to
where master is now:
<p>$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb
<p>You can do a lot more with the fast-import tool &ndash; handle different modes, binary data, multiple
branches and merging, tags, progress indicators, and more. A number of examples of more
complex scenarios are available in the contrib/fast-import directory of the Git source code.
<p>Summary
You should feel comfortable using Git as a client for other version-control systems, or importing
nearly any existing repository into Git without losing data. In the next chapter, we&rsquo;ll cover the raw
internals of Git so you can craft every single byte, if need be.
<p>436</p>
<br>
</div>
<div class="page">
<br>
<p>Git Internals
You may have skipped to this chapter from a much earlier chapter, or you may have gotten here
after sequentially reading the entire book up to this point&thinsp;&mdash;&thinsp;in either case, this is where we&rsquo;ll go
over the inner workings and implementation of Git. We found that understanding this information
was fundamentally important to appreciating how useful and powerful Git is, but others have
argued to us that it can be confusing and unnecessarily complex for beginners. Thus, we&rsquo;ve made
this discussion the last chapter in the book so you could read it early or later in your learning
process. We leave it up to you to decide.
<p>Now that you&rsquo;re here, let&rsquo;s get started. First, if it isn&rsquo;t yet clear, Git is fundamentally a content-
addressable filesystem with a VCS user interface written on top of it. You&rsquo;ll learn more about what
this means in a bit.
<p>In the early days of Git (mostly pre 1.5), the user interface was much more complex because it
emphasized this filesystem rather than a polished VCS. In the last few years, the UI has been refined
until it&rsquo;s as clean and easy to use as any system out there; however, the stereotype lingers about the
early Git UI that was complex and difficult to learn.
<p>The content-addressable filesystem layer is amazingly cool, so we&rsquo;ll cover that first in this chapter;
then, you&rsquo;ll learn about the transport mechanisms and the repository maintenance tasks that you
may eventually have to deal with.
<p>Plumbing and Porcelain
This book covers primarily how to use Git with 30 or so subcommands such as checkout, branch,
remote, and so on. But because Git was initially a toolkit for a version control system rather than a
full user-friendly VCS, it has a number of subcommands that do low-level work and were designed
to be chained together UNIX-style or called from scripts. These commands are generally referred to
as Git&rsquo;s &ldquo;plumbing&rdquo; commands, while the more user-friendly commands are called &ldquo;porcelain&rdquo;
commands.
<p>As you will have noticed by now, this book&rsquo;s first nine chapters deal almost exclusively with
porcelain commands. But in this chapter, you&rsquo;ll be dealing mostly with the lower-level plumbing
commands, because they give you access to the inner workings of Git, and help demonstrate how
and why Git does what it does. Many of these commands aren&rsquo;t meant to be used manually on the
command line, but rather to be used as building blocks for new tools and custom scripts.
<p>When you run git init in a new or existing directory, Git creates the .git directory, which is where
almost everything that Git stores and manipulates is located. If you want to back up or clone your
repository, copying this single directory elsewhere gives you nearly everything you need. This
entire chapter basically deals with what you can see in this directory. Here&rsquo;s what a newly-
initialized .git directory typically looks like:
<p>437</p>
<br>
</div>
<div class="page">
<br>
<p>$ ls -F1
config
description
HEAD
hooks/
info/
objects/
refs/
<p>Depending on your version of Git, you may see some additional content there, but this is a fresh git
init repository&thinsp;&mdash;&thinsp;it&rsquo;s what you see by default. The description file is used only by the GitWeb
program, so don&rsquo;t worry about it. The config file contains your project-specific configuration
options, and the info directory keeps a global exclude file for ignored patterns that you don&rsquo;t want
to track in a .gitignore file. The hooks directory contains your client- or server-side hook scripts,
which are discussed in detail in Git Hooks.
<p>This leaves four important entries: the HEAD and (yet to be created) index files, and the objects and
refs directories. These are the core parts of Git. The objects directory stores all the content for your
database, the refs directory stores pointers into commit objects in that data (branches, tags,
remotes and more), the HEAD file points to the branch you currently have checked out, and the index
file is where Git stores your staging area information. You&rsquo;ll now look at each of these sections in
detail to see how Git operates.
<p>Git Objects
Git is a content-addressable filesystem. Great. What does that mean? It means that at the core of Git
is a simple key-value data store. What this means is that you can insert any kind of content into a
Git repository, for which Git will hand you back a unique key you can use later to retrieve that
content.
<p>As a demonstration, let&rsquo;s look at the plumbing command git hash-object, which takes some data,
stores it in your .git/objects directory (the object database), and gives you back the unique key that
now refers to that data object.
<p>First, you initialize a new Git repository and verify that there is (predictably) nothing in the objects
directory:
<p>$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
<p>Git has initialized the objects directory and created pack and info subdirectories in it, but there are
<p>438</p>
<br>
</div>
<div class="page">
<br>
<p>no regular files. Now, let&rsquo;s use git hash-object to create a new data object and manually store it in
your new Git database:
<p>$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
<p>In its simplest form, git hash-object would take the content you handed to it and merely return the
unique key that would be used to store it in your Git database. The -w option then tells the command
to not simply return the key, but to write that object to the database. Finally, the --stdin option tells
git hash-object to get the content to be processed from stdin; otherwise, the command would
expect a filename argument at the end of the command containing the content to be used.
<p>The output from the above command is a 40-character checksum hash. This is the SHA-1 hash&thinsp;&mdash;&thinsp;a
checksum of the content you&rsquo;re storing plus a header, which you&rsquo;ll learn about in a bit. Now you
can see how Git has stored your data:
<p>$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
<p>If you again examine your objects directory, you can see that it now contains a file for that new
content. This is how Git stores the content initially&thinsp;&mdash;&thinsp;as a single file per piece of content, named
with the SHA-1 checksum of the content and its header. The subdirectory is named with the first 2
characters of the SHA-1, and the filename is the remaining 38 characters.
<p>Once you have content in your object database, you can examine that content with the git cat-file
command. This command is sort of a Swiss army knife for inspecting Git objects. Passing -p to cat-
file instructs the command to first figure out the type of content, then display it appropriately:
<p>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
<p>Now, you can add content to Git and pull it back out again. You can also do this with content in files.
For example, you can do some simple version control on a file. First, create a new file and save its
contents in your database:
<p>$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
<p>Then, write some new content to the file, and save it again:
<p>$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
<p>439</p>
<br>
</div>
<div class="page">
<br>
<p>Your object database now contains both versions of this new file (as well as the first content you
stored there):
<p>$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
<p>At this point, you can delete your local copy of that test.txt file, then use Git to retrieve, from the
object database, either the first version you saved:
<p>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1
<p>or the second version:
<p>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2
<p>But remembering the SHA-1 key for each version of your file isn&rsquo;t practical; plus, you aren&rsquo;t storing
the filename in your system&thinsp;&mdash;&thinsp;just the content. This object type is called a blob. You can have Git tell
you the object type of any object in Git, given its SHA-1 key, with git cat-file -t:
<p>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
<p>Tree Objects
<p>The next type of Git object we&rsquo;ll examine is the tree, which solves the problem of storing the
filename and also allows you to store a group of files together. Git stores content in a manner
similar to a UNIX filesystem, but a bit simplified. All the content is stored as tree and blob objects,
with trees corresponding to UNIX directory entries and blobs corresponding more or less to inodes
or file contents. A single tree object contains one or more entries, each of which is the SHA-1 hash
of a blob or subtree with its associated mode, type, and filename. For example, the most recent tree
in a project may look something like this:
<p>$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README
100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib
<p>The master^{tree} syntax specifies the tree object that is pointed to by the last commit on your
<p>440</p>
<br>
</div>
<div class="page">
<br>
<p>master branch. Notice that the lib subdirectory isn&rsquo;t a blob but a pointer to another tree:
<p>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b simplegit.rb
<p>
<p>Depending on what shell you use, you may encounter errors when using the
master^{tree} syntax.
<p>In CMD on Windows, the ^ character is used for escaping, so you have to double it
to avoid this: git cat-file -p master^^{tree}. When using PowerShell, parameters
using {} characters have to be quoted to avoid the parameter being parsed
incorrectly: git cat-file -p 'master^{tree}'.
<p>If you&rsquo;re using ZSH, the ^ character is used for globbing, so you have to enclose the
whole expression in quotes: git cat-file -p "master^{tree}".
<p>Conceptually, the data that Git is storing looks something like this:
<p>Figure 149. Simple version of the Git data model.
<p>You can fairly easily create your own tree. Git normally creates a tree by taking the state of your
staging area or index and writing a series of tree objects from it. So, to create a tree object, you first
have to set up an index by staging some files. To create an index with a single entry&thinsp;&mdash;&thinsp;the first
version of your test.txt file&thinsp;&mdash;&thinsp;you can use the plumbing command git update-index. You use this
<p>441</p>
<br>
</div>
<div class="page">
<br>
<p>command to artificially add the earlier version of the test.txt file to a new staging area. You must
pass it the --add option because the file doesn&rsquo;t yet exist in your staging area (you don&rsquo;t even have a
staging area set up yet) and --cacheinfo because the file you&rsquo;re adding isn&rsquo;t in your directory but is
in your database. Then, you specify the mode, SHA-1, and filename:
<p>$ git update-index --add --cacheinfo 100644 \
&nbsp; 83baae61804e65cc73a7201a7252750c76066a30 test.txt
<p>In this case, you&rsquo;re specifying a mode of 100644, which means it&rsquo;s a normal file. Other options are
100755, which means it&rsquo;s an executable file; and 120000, which specifies a symbolic link. The mode is
taken from normal UNIX modes but is much less flexible&thinsp;&mdash;&thinsp;these three modes are the only ones
that are valid for files (blobs) in Git (although other modes are used for directories and
submodules).
<p>Now, you can use git write-tree to write the staging area out to a tree object. No -w option is
needed&thinsp;&mdash;&thinsp;calling this command automatically creates a tree object from the state of the index if
that tree doesn&rsquo;t yet exist:
<p>$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt
<p>You can also verify that this is a tree object using the same git cat-file command you saw earlier:
<p>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
<p>You&rsquo;ll now create a new tree with the second version of test.txt and a new file as well:
<p>$ echo 'new file' &gt; new.txt
$ git update-index --add --cacheinfo 100644 \
&nbsp; 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index --add new.txt
<p>Your staging area now has the new version of test.txt as well as the new file new.txt. Write out
that tree (recording the state of the staging area or index to a tree object) and see what it looks like:
<p>$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
<p>442</p>
<br>
</div>
<div class="page">
<br>
<p>Notice that this tree has both file entries and also that the test.txt SHA-1 is the &ldquo;version 2&rdquo; SHA-1
from earlier (1f7a7a). Just for fun, you&rsquo;ll add the first tree as a subdirectory into this one. You can
read trees into your staging area by calling git read-tree. In this case, you can read an existing tree
into your staging area as a subtree by using the --prefix option with this command:
<p>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
<p>If you created a working directory from the new tree you just wrote, you would get the two files in
the top level of the working directory and a subdirectory named bak that contained the first version
of the test.txt file. You can think of the data that Git contains for these structures as being like this:
<p>Figure 150. The content structure of your current Git data.
<p>Commit Objects
<p>If you&rsquo;ve done all of the above, you now have three trees that represent the different snapshots of
your project that you want to track, but the earlier problem remains: you must remember all three
SHA-1 values in order to recall the snapshots. You also don&rsquo;t have any information about who saved
<p>443</p>
<br>
</div>
<div class="page">
<br>
<p>the snapshots, when they were saved, or why they were saved. This is the basic information that
the commit object stores for you.
<p>To create a commit object, you call commit-tree and specify a single tree SHA-1 and which commit
objects, if any, directly preceded it. Start with the first tree you wrote:
<p>$ echo 'First commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
<p>You will get a different hash value because of different creation time and author data. Replace
commit and tag hashes with your own checksums further in this chapter. Now you can look at your
new commit object with git cat-file:
<p>$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
<p>First commit
<p>The format for a commit object is simple: it specifies the top-level tree for the snapshot of the
project at that point; the parent commits if any (the commit object described above does not have
any parents); the author/committer information (which uses your user.name and user.email
configuration settings and a timestamp); a blank line, and then the commit message.
<p>Next, you&rsquo;ll write the other two commit objects, each referencing the commit that came directly
before it:
<p>$ echo 'Second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'Third commit' | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
<p>Each of the three commit objects points to one of the three snapshot trees you created. Oddly
enough, you have a real Git history now that you can view with the git log command, if you run it
on the last commit SHA-1:
<p>444</p>
<br>
</div>
<div class="page">
<br>
<p>$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date: Fri May 22 18:15:24 2009 -0700
<p>&nbsp; Third commit
<p>&nbsp;bak/test.txt | 1 +
&nbsp;1 file changed, 1 insertion(+)
<p>commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date: Fri May 22 18:14:29 2009 -0700
<p>&nbsp; Second commit
<p>&nbsp;new.txt | 1 +
&nbsp;test.txt | 2 +-
&nbsp;2 files changed, 2 insertions(+), 1 deletion(-)
<p>commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date: Fri May 22 18:09:34 2009 -0700
<p>&nbsp; First commit
<p>&nbsp;test.txt | 1 +
&nbsp;1 file changed, 1 insertion(+)
<p>Amazing. You&rsquo;ve just done the low-level operations to build up a Git history without using any of
the front end commands. This is essentially what Git does when you run the git add and git commit
commands&thinsp;&mdash;&thinsp;it stores blobs for the files that have changed, updates the index, writes out trees, and
writes commit objects that reference the top-level trees and the commits that came immediately
before them. These three main Git objects&thinsp;&mdash;&thinsp;the blob, the tree, and the commit&thinsp;&mdash;&thinsp;are initially stored
as separate files in your .git/objects directory. Here are all the objects in the example directory
now, commented with what they store:
<p>$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
<p>445</p>
<br>
</div>
<div class="page">
<br>
<p>If you follow all the internal pointers, you get an object graph something like this:
<p>Figure 151. All the reachable objects in your Git directory.
<p>Object Storage
<p>We mentioned earlier that there is a header stored with every object you commit to your Git object
database. Let&rsquo;s take a minute to see how Git stores its objects. You&rsquo;ll see how to store a blob
object&thinsp;&mdash;&thinsp;in this case, the string &ldquo;what is up, doc?&rdquo;&thinsp;&mdash;&thinsp;interactively in the Ruby scripting language.
<p>You can start up interactive Ruby mode with the irb command:
<p>$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"
<p>Git first constructs a header which starts by identifying the type of object&thinsp;&mdash;&thinsp;in this case, a blob. To
that first part of the header, Git adds a space followed by the size in bytes of the content, and adding
a final null byte:
<p>&gt;&gt; header = "blob #{content.length}\0"
=&gt; "blob 16\u0000"
<p>446</p>
<br>
</div>
<div class="page">
<br>
<p>Git concatenates the header and the original content and then calculates the SHA-1 checksum of
that new content. You can calculate the SHA-1 value of a string in Ruby by including the SHA1
digest library with the require command and then calling Digest::SHA1.hexdigest() with the string:
<p>&gt;&gt; store = header + content
=&gt; "blob 16\u0000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
<p>Let&rsquo;s compare that to the output of git hash-object. Here we use echo -n to prevent adding a
newline to the input.
<p>$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37
<p>Git compresses the new content with zlib, which you can do in Ruby with the zlib library. First, you
need to require the library and then run Zlib::Deflate.deflate() on the content:
<p>&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
<p>Finally, you&rsquo;ll write your zlib-deflated content to an object on disk. You&rsquo;ll determine the path of the
object you want to write out (the first two characters of the SHA-1 value being the subdirectory
name, and the last 38 characters being the filename within that directory). In Ruby, you can use the
FileUtils.mkdir_p() function to create the subdirectory if it doesn&rsquo;t exist. Then, open the file with
File.open() and write out the previously zlib-compressed content to the file with a write() call on
the resulting file handle:
<p>&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32
<p>Let&rsquo;s check the content of the object using git cat-file:
<p>447</p>
<br>
</div>
<div class="page">
<br>
<p>---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---
<p>That&rsquo;s it &ndash; you&rsquo;ve created a valid Git blob object.
<p>All Git objects are stored the same way, just with different types &ndash; instead of the string blob, the
header will begin with commit or tree. Also, although the blob content can be nearly anything, the
commit and tree content are very specifically formatted.
<p>Git References
If you were interested in seeing the history of your repository reachable from commit, say, 1a410e,
you could run something like git log 1a410e to display that history, but you would still have to
remember that 1a410e is the commit you want to use as the starting point for that history. Instead, it
would be easier if you had a file in which you could store that SHA-1 value under a simple name so
you could use that simple name rather than the raw SHA-1 value.
<p>In Git, these simple names are called &ldquo;references&rdquo; or &ldquo;refs&rdquo;; you can find the files that contain those
SHA-1 values in the .git/refs directory. In the current project, this directory contains no files, but it
does contain a simple structure:
<p>$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
<p>To create a new reference that will help you remember where your latest commit is, you can
technically do something as simple as this:
<p>$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master
<p>Now, you can use the head reference you just created instead of the SHA-1 value in your Git
commands:
<p>$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
<p>You aren&rsquo;t encouraged to directly edit the reference files; instead, Git provides the safer command
git update-ref to do this if you want to update a reference:
<p>448</p>
<br>
</div>
<div class="page">
<br>
<p>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
<p>That&rsquo;s basically what a branch in Git is: a simple pointer or reference to the head of a line of work.
To create a branch back at the second commit, you can do this:
<p>$ git update-ref refs/heads/test cac0ca
<p>Your branch will contain only work from that commit down:
<p>$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
<p>Now, your Git database conceptually looks something like this:
<p>Figure 152. Git directory objects with branch head references included.
<p>When you run commands like git branch &lt;branch&gt;, Git basically runs that update-ref command to
add the SHA-1 of the last commit of the branch you&rsquo;re on into whatever new reference you want to
create.
<p>The HEAD
<p>The question now is, when you run git branch &lt;branch&gt;, how does Git know the SHA-1 of the last
commit? The answer is the HEAD file.
<p>Usually the HEAD file is a symbolic reference to the branch you&rsquo;re currently on. By symbolic
reference, we mean that unlike a normal reference, it contains a pointer to another reference.
<p>449</p>
<br>
</div>
<div class="page">
<br>
<p>However in some rare cases the HEAD file may contain the SHA-1 value of a git object. This happens
when you checkout a tag, commit, or remote branch, which puts your repository in "detached
HEAD" state.
<p>If you look at the file, you&rsquo;ll normally see something like this:
<p>$ cat .git/HEAD
ref: refs/heads/master
<p>If you run git checkout test, Git updates the file to look like this:
<p>$ cat .git/HEAD
ref: refs/heads/test
<p>When you run git commit, it creates the commit object, specifying the parent of that commit object
to be whatever SHA-1 value the reference in HEAD points to.
<p>You can also manually edit this file, but again a safer command exists to do so: git symbolic-ref.
You can read the value of your HEAD via this command:
<p>$ git symbolic-ref HEAD
refs/heads/master
<p>You can also set the value of HEAD using the same command:
<p>$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
<p>You can&rsquo;t set a symbolic reference outside of the refs style:
<p>$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
<p>Tags
<p>We just finished discussing Git&rsquo;s three main object types (blobs, trees and commits), but there is a
fourth. The tag object is very much like a commit object&thinsp;&mdash;&thinsp;it contains a tagger, a date, a message,
and a pointer. The main difference is that a tag object generally points to a commit rather than a
tree. It&rsquo;s like a branch reference, but it never moves&thinsp;&mdash;&thinsp;it always points to the same commit but
gives it a friendlier name.
<p>As discussed in Git Basics, there are two types of tags: annotated and lightweight. You can make a
lightweight tag by running something like this:
<p>450</p>
<br>
<div class="annotation">
<a href="https://git-scm.com/docs/git-checkout#_detached_head">https://git-scm.com/docs/git-checkout#_detached_head</a>
</div>
<div class="annotation">
<a href="https://git-scm.com/docs/git-checkout#_detached_head">https://git-scm.com/docs/git-checkout#_detached_head</a>
</div>
</div>
<div class="page">
<br>
<p>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
<p>That is all a lightweight tag is&thinsp;&mdash;&thinsp;a reference that never moves. An annotated tag is more complex,
however. If you create an annotated tag, Git creates a tag object and then writes a reference to
point to it rather than directly to the commit. You can see this by creating an annotated tag (using
the -a option):
<p>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'Test tag'
<p>Here&rsquo;s the object SHA-1 value it created:
<p>$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
<p>Now, run git cat-file -p on that SHA-1 value:
<p>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700
<p>Test tag
<p>Notice that the object entry points to the commit SHA-1 value that you tagged. Also notice that it
doesn&rsquo;t need to point to a commit; you can tag any Git object. In the Git source code, for example,
the maintainer has added their GPG public key as a blob object and then tagged it. You can view the
public key by running this in a clone of the Git repository:
<p>$ git cat-file blob junio-gpg-pub
<p>The Linux kernel repository also has a non-commit-pointing tag object&thinsp;&mdash;&thinsp;the first tag created points
to the initial tree of the import of the source code.
<p>Remotes
<p>The third type of reference that you&rsquo;ll see is a remote reference. If you add a remote and push to it,
Git stores the value you last pushed to that remote for each branch in the refs/remotes directory.
For instance, you can add a remote called origin and push your master branch to it:
<p>451</p>
<br>
</div>
<div class="page">
<br>
<p>$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
&nbsp; a11bef0..ca82a6d master -&gt; master
<p>Then, you can see what the master branch on the origin remote was the last time you
communicated with the server, by checking the refs/remotes/origin/master file:
<p>$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
<p>Remote references differ from branches (refs/heads references) mainly in that they&rsquo;re considered
read-only. You can git checkout to one, but Git won&rsquo;t point HEAD at one, so you&rsquo;ll never update it
with a commit command. Git manages them as bookmarks to the last known state of where those
branches were on those servers.
<p>Packfiles
If you followed all of the instructions in the example from the previous section, you should now
have a test Git repository with 11 objects&thinsp;&mdash;&thinsp;four blobs, three trees, three commits, and one tag:
<p>$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
<p>Git compresses the contents of these files with zlib, and you&rsquo;re not storing much, so all these files
collectively take up only 925 bytes. Now you&rsquo;ll add some more sizable content to the repository to
demonstrate an interesting feature of Git. To demonstrate, we&rsquo;ll add the repo.rb file from the Grit
library&thinsp;&mdash;&thinsp;this is about a 22K source code file:
<p>452</p>
<br>
</div>
<div class="page">
<br>
<p>$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt;
repo.rb
$ git checkout master
$ git add repo.rb
$ git commit -m 'Create repo.rb'
[master 484a592] Create repo.rb
&nbsp;3 files changed, 709 insertions(+), 2 deletions(-)
&nbsp;delete mode 100644 bak/test.txt
&nbsp;create mode 100644 repo.rb
&nbsp;rewrite test.txt (100%)
<p>If you look at the resulting tree, you can see the SHA-1 value that was calculated for your new
repo.rb blob object:
<p>$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b test.txt
<p>You can then use git cat-file to see how large that object is:
<p>$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044
<p>At this point, modify that file a little, and see what happens:
<p>$ echo '# testing' &gt;&gt; repo.rb
$ git commit -am 'Modify repo.rb a bit'
[master 2431da6] Modify repo.rb a bit
&nbsp;1 file changed, 1 insertion(+)
<p>Check the tree created by that last commit, and you see something interesting:
<p>$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b test.txt
<p>The blob is now a different blob, which means that although you added only a single line to the end
of a 400-line file, Git stored that new content as a completely new object:
<p>$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054
<p>453</p>
<br>
</div>
<div class="page">
<br>
<p>You have two nearly identical 22K objects on your disk (each compressed to approximately 7K).
Wouldn&rsquo;t it be nice if Git could store one of them in full but then the second object only as the delta
between it and the first?
<p>It turns out that it can. The initial format in which Git saves objects on disk is called a &ldquo;loose&rdquo; object
format. However, occasionally Git packs up several of these objects into a single binary file called a
&ldquo;packfile&rdquo; in order to save space and be more efficient. Git does this if you have too many loose
objects around, if you run the git gc command manually, or if you push to a remote server. To see
what happens, you can manually ask Git to pack up the objects by calling the git gc command:
<p>$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
<p>If you look in your objects directory, you&rsquo;ll find that most of your objects are gone, and a new pair
of files has appeared:
<p>$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
<p>The objects that remain are the blobs that aren&rsquo;t pointed to by any commit&thinsp;&mdash;&thinsp;in this case, the &ldquo;what
is up, doc?&rdquo; example and the &ldquo;test content&rdquo; example blobs you created earlier. Because you never
added them to any commits, they&rsquo;re considered dangling and aren&rsquo;t packed up in your new
packfile.
<p>The other files are your new packfile and an index. The packfile is a single file containing the
contents of all the objects that were removed from your filesystem. The index is a file that contains
offsets into that packfile so you can quickly seek to a specific object. What is cool is that although
the objects on disk before you ran the gc command were collectively about 15K in size, the new
packfile is only 7K. You&rsquo;ve cut your disk usage by half by packing your objects.
<p>How does Git do this? When Git packs objects, it looks for files that are named and sized similarly,
and stores just the deltas from one version of the file to the next. You can look into the packfile and
see what Git did to save space. The git verify-pack plumbing command allows you to see what was
packed up:
<p>454</p>
<br>
</div>
<div class="page">
<br>
<p>$ git verify-pack -v .git/objects/pack/pack-
978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag 130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree 136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree 36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree 136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree 6 17 1314 1 \
&nbsp; deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree 8 19 1331 1 \
&nbsp; deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree 71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob 10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob 9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob 22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob 9 20 7262 1 \
&nbsp; b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob 10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
<p>Here, the 033b4 blob, which if you remember was the first version of your repo.rb file, is
referencing the b042a blob, which was the second version of the file. The third column in the output
is the size of the object in the pack, so you can see that b042a takes up 22K of the file, but that 033b4
only takes up 9 bytes. What is also interesting is that the second version of the file is the one that is
stored intact, whereas the original version is stored as a delta&thinsp;&mdash;&thinsp;this is because you&rsquo;re most likely to
need faster access to the most recent version of the file.
<p>The really nice thing about this is that it can be repacked at any time. Git will occasionally repack
your database automatically, always trying to save more space, but you can also manually repack at
any time by running git gc by hand.
<p>The Refspec
Throughout this book, we&rsquo;ve used simple mappings from remote branches to local references, but
they can be more complex. Suppose you were following along with the last couple sections and had
created a small local Git repository, and now wanted to add a remote to it:
<p>$ git remote add origin https://github.com/schacon/simplegit-progit
<p>Running the command above adds a section to your repository&rsquo;s .git/config file, specifying the
<p>455</p>
<br>
</div>
<div class="page">
<br>
<p>name of the remote (origin), the URL of the remote repository, and the refspec to be used for
fetching:
<p>[remote "origin"]
&nbsp; url = https://github.com/schacon/simplegit-progit
&nbsp; fetch = +refs/heads/*:refs/remotes/origin/*
<p>The format of the refspec is, first, an optional +, followed by &lt;src&gt;:&lt;dst&gt;, where &lt;src&gt; is the pattern
for references on the remote side and &lt;dst&gt; is where those references will be tracked locally. The +
tells Git to update the reference even if it isn&rsquo;t a fast-forward.
<p>In the default case that is automatically written by a git remote add origin command, Git fetches all
the references under refs/heads/ on the server and writes them to refs/remotes/origin/ locally. So,
if there is a master branch on the server, you can access the log of that branch locally via any of the
following:
<p>$ git log origin/master
$ git log remotes/origin/master
$ git log refs/remotes/origin/master
<p>They&rsquo;re all equivalent, because Git expands each of them to refs/remotes/origin/master.
<p>If you want Git instead to pull down only the master branch each time, and not every other branch
on the remote server, you can change the fetch line to refer to that branch only:
<p>fetch = +refs/heads/master:refs/remotes/origin/master
<p>This is just the default refspec for git fetch for that remote. If you want to do a one-time only fetch,
you can specify the specific refspec on the command line, too. To pull the master branch on the
remote down to origin/mymaster locally, you can run:
<p>$ git fetch origin master:refs/remotes/origin/mymaster
<p>You can also specify multiple refspecs. On the command line, you can pull down several branches
like so:
<p>$ git fetch origin master:refs/remotes/origin/mymaster \
&nbsp; topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
&nbsp;! [rejected] master -&gt; origin/mymaster (non fast forward)
&nbsp;* [new branch] topic -&gt; origin/topic
<p>In this case, the master branch pull was rejected because it wasn&rsquo;t listed as a fast-forward reference.
You can override that by specifying the + in front of the refspec.
<p>456</p>
<br>
</div>
<div class="page">
<br>
<p>You can also specify multiple refspecs for fetching in your configuration file. If you want to always
fetch the master and experiment branches from the origin remote, add two lines:
<p>[remote "origin"]
&nbsp; url = https://github.com/schacon/simplegit-progit
&nbsp; fetch = +refs/heads/master:refs/remotes/origin/master
&nbsp; fetch = +refs/heads/experiment:refs/remotes/origin/experiment
<p>Since Git 2.6.0 you can use partial globs in the pattern to match multiple branches, so this works:
<p>fetch = +refs/heads/qa*:refs/remotes/origin/qa*
<p>Even better, you can use namespaces (or directories) to accomplish the same with more structure.
If you have a QA team that pushes a series of branches, and you want to get the master branch and
any of the QA team&rsquo;s branches but nothing else, you can use a config section like this:
<p>[remote "origin"]
&nbsp; url = https://github.com/schacon/simplegit-progit
&nbsp; fetch = +refs/heads/master:refs/remotes/origin/master
&nbsp; fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*
<p>If you have a complex workflow process that has a QA team pushing branches, developers pushing
branches, and integration teams pushing and collaborating on remote branches, you can
namespace them easily this way.
<p>Pushing Refspecs
<p>It&rsquo;s nice that you can fetch namespaced references that way, but how does the QA team get their
branches into a qa/ namespace in the first place? You accomplish that by using refspecs to push.
<p>If the QA team wants to push their master branch to qa/master on the remote server, they can run
<p>$ git push origin master:refs/heads/qa/master
<p>If they want Git to do that automatically each time they run git push origin, they can add a push
value to their config file:
<p>[remote "origin"]
&nbsp; url = https://github.com/schacon/simplegit-progit
&nbsp; fetch = +refs/heads/*:refs/remotes/origin/*
&nbsp; push = refs/heads/master:refs/heads/qa/master
<p>Again, this will cause a git push origin to push the local master branch to the remote qa/master
branch by default.
<p>457</p>
<br>
</div>
<div class="page">
<br>
<p>
You cannot use the refspec to fetch from one repository and push to another one.
For an example to do so, refer to Keep your GitHub public repository up-to-date.
<p>Deleting References
<p>You can also use the refspec to delete references from the remote server by running something like
this:
<p>$ git push origin :topic
<p>Because the refspec is &lt;src&gt;:&lt;dst&gt;, by leaving off the &lt;src&gt; part, this basically says to make the topic
branch on the remote nothing, which deletes it.
<p>Or you can use the newer syntax (available since Git v1.7.0):
<p>$ git push origin --delete topic
<p>Transfer Protocols
Git can transfer data between two repositories in two major ways: the &ldquo;dumb&rdquo; protocol and the
&ldquo;smart&rdquo; protocol. This section will quickly cover how these two main protocols operate.
<p>The Dumb Protocol
<p>If you&rsquo;re setting up a repository to be served read-only over HTTP, the dumb protocol is likely what
will be used. This protocol is called &ldquo;dumb&rdquo; because it requires no Git-specific code on the server
side during the transport process; the fetch process is a series of HTTP GET requests, where the
client can assume the layout of the Git repository on the server.
<p>
The dumb protocol is fairly rarely used these days. It&rsquo;s difficult to secure or make
private, so most Git hosts (both cloud-based and on-premises) will refuse to use it.
It&rsquo;s generally advised to use the smart protocol, which we describe a bit further on.
<p>Let&rsquo;s follow the http-fetch process for the simplegit library:
<p>$ git clone http://server/simplegit-progit.git
<p>The first thing this command does is pull down the info/refs file. This file is written by the update-
server-info command, which is why you need to enable that as a post-receive hook in order for the
HTTP transport to work properly:
<p>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949 refs/heads/master
<p>458</p>
<br>
</div>
<div class="page">
<br>
<p>Now you have a list of the remote references and SHA-1s. Next, you look for what the HEAD
reference is so you know what to check out when you&rsquo;re finished:
<p>=&gt; GET HEAD
ref: refs/heads/master
<p>You need to check out the master branch when you&rsquo;ve completed the process. At this point, you&rsquo;re
ready to start the walking process. Because your starting point is the ca82a6 commit object you saw
in the info/refs file, you start by fetching that:
<p>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
<p>You get an object back &ndash; that object is in loose format on the server, and you fetched it over a static
HTTP GET request. You can zlib-uncompress it, strip off the header, and look at the commit content:
<p>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700
<p>Change version number
<p>Next, you have two more objects to retrieve &ndash; cfda3b, which is the tree of content that the commit
we just retrieved points to; and 085bb3, which is the parent commit:
<p>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
<p>That gives you your next commit object. Grab the tree object:
<p>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
<p>Oops &ndash; it looks like that tree object isn&rsquo;t in loose format on the server, so you get a 404 response
back. There are a couple of reasons for this &ndash; the object could be in an alternate repository, or it
could be in a packfile in this repository. Git checks for any listed alternates first:
<p>=&gt; GET objects/info/http-alternates
(empty file)
<p>If this comes back with a list of alternate URLs, Git checks for loose files and packfiles there &ndash; this is
<p>459</p>
<br>
</div>
<div class="page">
<br>
<p>a nice mechanism for projects that are forks of one another to share objects on disk. However,
because no alternates are listed in this case, your object must be in a packfile. To see what packfiles
are available on this server, you need to get the objects/info/packs file, which contains a listing of
them (also generated by update-server-info):
<p>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
<p>There is only one packfile on the server, so your object is obviously in there, but you&rsquo;ll check the
index file to make sure. This is also useful if you have multiple packfiles on the server, so you can
see which packfile contains the object you need:
<p>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
<p>Now that you have the packfile index, you can see if your object is in it &ndash; because the index lists the
SHA-1s of the objects contained in the packfile and the offsets to those objects. Your object is there,
so go ahead and get the whole packfile:
<p>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
<p>You have your tree object, so you continue walking your commits. They&rsquo;re all also within the
packfile you just downloaded, so you don&rsquo;t have to do any more requests to your server. Git checks
out a working copy of the master branch that was pointed to by the HEAD reference you
downloaded at the beginning.
<p>The Smart Protocol
<p>The dumb protocol is simple but a bit inefficient, and it can&rsquo;t handle writing of data from the client
to the server. The smart protocol is a more common method of transferring data, but it requires a
process on the remote end that is intelligent about Git &ndash; it can read local data, figure out what the
client has and needs, and generate a custom packfile for it. There are two sets of processes for
transferring data: a pair for uploading data and a pair for downloading data.
<p>Uploading Data
<p>To upload data to a remote process, Git uses the send-pack and receive-pack processes. The send-
pack process runs on the client and connects to a receive-pack process on the remote side.
<p>SSH
<p>For example, say you run git push origin master in your project, and origin is defined as a URL
that uses the SSH protocol. Git fires up the send-pack process, which initiates a connection over SSH
to your server. It tries to run a command on the remote server via an SSH call that looks something
like this:
<p>460</p>
<br>
</div>
<div class="page">
<br>
<p>$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master□report-status \
&nbsp; delete-refs side-band-64k quiet ofs-delta \
&nbsp; agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000
<p>The git-receive-pack command immediately responds with one line for each reference it currently
has &ndash; in this case, just the master branch and its SHA-1. The first line also has a list of the server&rsquo;s
capabilities (here, report-status, delete-refs, and some others, including the client identifier).
<p>The data is transmitted in chunks. Each chunk starts with a 4-character hex value specifying how
long the chunk is (including the 4 bytes of the length itself). Chunks usually contain a single line of
data and a trailing linefeed. Your first chunk starts with 00a5, which is hexadecimal for 165,
meaning the chunk is 165 bytes long. The next chunk is 0000, meaning the server is done with its
references listing.
<p>Now that it knows the server&rsquo;s state, your send-pack process determines what commits it has that
the server doesn&rsquo;t. For each reference that this push will update, the send-pack process tells the
receive-pack process that information. For instance, if you&rsquo;re updating the master branch and
adding an experiment branch, the send-pack response may look something like this:
<p>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6
\
&nbsp; refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d
\
&nbsp; refs/heads/experiment
0000
<p>Git sends a line for each reference you&rsquo;re updating with the line&rsquo;s length, the old SHA-1, the new
SHA-1, and the reference that is being updated. The first line also has the client&rsquo;s capabilities. The
SHA-1 value of all '0&rsquo;s means that nothing was there before &ndash; because you&rsquo;re adding the experiment
reference. If you were deleting a reference, you would see the opposite: all '0&rsquo;s on the right side.
<p>Next, the client sends a packfile of all the objects the server doesn&rsquo;t have yet. Finally, the server
responds with a success (or failure) indication:
<p>000eunpack ok
<p>HTTP(S)
<p>This process is mostly the same over HTTP, though the handshaking is a bit different. The
connection is initiated with this request:
<p>461</p>
<br>
</div>
<div class="page">
<br>
<p>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master□report-status \
&nbsp; delete-refs side-band-64k quiet ofs-delta \
&nbsp; agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000
<p>That&rsquo;s the end of the first client-server exchange. The client then makes another request, this time a
POST, with the data that send-pack provides.
<p>=&gt; POST http://server/simplegit-progit.git/git-receive-pack
<p>The POST request includes the send-pack output and the packfile as its payload. The server then
indicates success or failure with its HTTP response.
<p>Keep in mind the HTTP protocol may further wrap this data inside a chunked transfer encoding.
<p>Downloading Data
<p>When you download data, the fetch-pack and upload-pack processes are involved. The client
initiates a fetch-pack process that connects to an upload-pack process on the remote side to
negotiate what data will be transferred down.
<p>SSH
<p>If you&rsquo;re doing the fetch over SSH, fetch-pack runs something like this:
<p>$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"
<p>After fetch-pack connects, upload-pack sends back something like this:
<p>00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
&nbsp; side-band side-band-64k ofs-delta shallow no-progress include-tag \
&nbsp; multi_ack_detailed symref=HEAD:refs/heads/master \
&nbsp; agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000
<p>This is very similar to what receive-pack responds with, but the capabilities are different. In
addition, it sends back what HEAD points to (symref=HEAD:refs/heads/master) so the client knows
what to check out if this is a clone.
<p>At this point, the fetch-pack process looks at what objects it has and responds with the objects that
it needs by sending &ldquo;want&rdquo; and then the SHA-1 it wants. It sends all the objects it already has with
&ldquo;have&rdquo; and then the SHA-1. At the end of this list, it writes &ldquo;done&rdquo; to initiate the upload-pack process
to begin sending the packfile of the data it needs:
<p>462</p>
<br>
</div>
<div class="page">
<br>
<p>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000
<p>HTTP(S)
<p>The handshake for a fetch operation takes two HTTP requests. The first is a GET to the same
endpoint used in the dumb protocol:
<p>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
&nbsp; side-band side-band-64k ofs-delta shallow no-progress include-tag \
&nbsp; multi_ack_detailed no-done symref=HEAD:refs/heads/master \
&nbsp; agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
<p>This is very similar to invoking git-upload-pack over an SSH connection, but the second exchange is
performed as a separate request:
<p>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000
<p>Again, this is the same format as above. The response to this request indicates success or failure,
and includes the packfile.
<p>Protocols Summary
<p>This section contains a very basic overview of the transfer protocols. The protocol includes many
other features, such as multi_ack or side-band capabilities, but covering them is outside the scope of
this book. We&rsquo;ve tried to give you a sense of the general back-and-forth between client and server; if
you need more knowledge than this, you&rsquo;ll probably want to take a look at the Git source code.
<p>Maintenance and Data Recovery
Occasionally, you may have to do some cleanup &ndash; make a repository more compact, clean up an
imported repository, or recover lost work. This section will cover some of these scenarios.
<p>Maintenance
<p>Occasionally, Git automatically runs a command called &ldquo;auto gc&rdquo;. Most of the time, this command
does nothing. However, if there are too many loose objects (objects not in a packfile) or too many
<p>463</p>
<br>
</div>
<div class="page">
<br>
<p>packfiles, Git launches a full-fledged git gc command. The &ldquo;gc&rdquo; stands for garbage collect, and the
command does a number of things: it gathers up all the loose objects and places them in packfiles, it
consolidates packfiles into one big packfile, and it removes objects that aren&rsquo;t reachable from any
commit and are a few months old.
<p>You can run auto gc manually as follows:
<p>$ git gc --auto
<p>Again, this generally does nothing. You must have around 7,000 loose objects or more than 50
packfiles for Git to fire up a real gc command. You can modify these limits with the gc.auto and
gc.autopacklimit config settings, respectively.
<p>The other thing gc will do is pack up your references into a single file. Suppose your repository
contains the following branches and tags:
<p>$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
<p>If you run git gc, you&rsquo;ll no longer have these files in the refs directory. Git will move them for the
sake of efficiency into a file named .git/packed-refs that looks like this:
<p>$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
<p>If you update a reference, Git doesn&rsquo;t edit this file but instead writes a new file to refs/heads. To get
the appropriate SHA-1 for a given reference, Git checks for that reference in the refs directory and
then checks the packed-refs file as a fallback. So if you can&rsquo;t find a reference in the refs directory,
it&rsquo;s probably in your packed-refs file.
<p>Notice the last line of the file, which begins with a ^. This means the tag directly above is an
annotated tag and that line is the commit that the annotated tag points to.
<p>Data Recovery
<p>At some point in your Git journey, you may accidentally lose a commit. Generally, this happens
because you force-delete a branch that had work on it, and it turns out you wanted the branch after
all; or you hard-reset a branch, thus abandoning commits that you wanted something from.
Assuming this happens, how can you get your commits back?
<p>464</p>
<br>
</div>
<div class="page">
<br>
<p>Here&rsquo;s an example that hard-resets the master branch in your test repository to an older commit
and then recovers the lost commits. First, let&rsquo;s review where your repository is at this point:
<p>$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
<p>Now, move the master branch back to the middle commit:
<p>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef Third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
<p>You&rsquo;ve effectively lost the top two commits &ndash; you have no branch from which those commits are
reachable. You need to find the latest commit SHA-1 and then add a branch that points to it. The
trick is finding that latest commit SHA-1 &ndash; it&rsquo;s not like you&rsquo;ve memorized it, right?
<p>Often, the quickest way is to use a tool called git reflog. As you&rsquo;re working, Git silently records
what your HEAD is every time you change it. Each time you commit or change branches, the reflog
is updated. The reflog is also updated by the git update-ref command, which is another reason to
use it instead of just writing the SHA-1 value to your ref files, as we covered in Git References. You
can see where you&rsquo;ve been at any time by running git reflog:
<p>$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: Modify repo.rb a bit
484a592 HEAD@{2}: commit: Create repo.rb
<p>Here we can see the two commits that we have had checked out, however there is not much
information here. To see the same information in a much more useful way, we can run git log -g,
which will give you a normal log output for your reflog.
<p>465</p>
<br>
</div>
<div class="page">
<br>
<p>$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date: Fri May 22 18:22:37 2009 -0700
<p>&nbsp; Third commit
<p>commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date: Fri May 22 18:15:24 2009 -0700
<p>&nbsp; Modify repo.rb a bit
<p>It looks like the bottom commit is the one you lost, so you can recover it by creating a new branch
at that commit. For example, you can start a branch named recover-branch at that commit (ab1afef):
<p>$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b Modify repo.rb a bit
484a59275031909e19aadb7c92262719cfcdf19a Create repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
<p>Cool &ndash; now you have a branch named recover-branch that is where your master branch used to be,
making the first two commits reachable again. Next, suppose your loss was for some reason not in
the reflog &ndash; you can simulate that by removing recover-branch and deleting the reflog. Now the first
two commits aren&rsquo;t reachable by anything:
<p>$ git branch -D recover-branch
$ rm -Rf .git/logs/
<p>Because the reflog data is kept in the .git/logs/ directory, you effectively have no reflog. How can
you recover that commit at this point? One way is to use the git fsck utility, which checks your
database for integrity. If you run it with the --full option, it shows you all objects that aren&rsquo;t
pointed to by another object:
<p>466</p>
<br>
</div>
<div class="page">
<br>
<p>$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
<p>In this case, you can see your missing commit after the string &ldquo;dangling commit&rdquo;. You can recover it
the same way, by adding a branch that points to that SHA-1.
<p>Removing Objects
<p>There are a lot of great things about Git, but one feature that can cause issues is the fact that a git
clone downloads the entire history of the project, including every version of every file. This is fine if
the whole thing is source code, because Git is highly optimized to compress that data efficiently.
However, if someone at any point in the history of your project added a single huge file, every clone
for all time will be forced to download that large file, even if it was removed from the project in the
very next commit. Because it&rsquo;s reachable from the history, it will always be there.
<p>This can be a huge problem when you&rsquo;re converting Subversion or Perforce repositories into Git.
Because you don&rsquo;t download the whole history in those systems, this type of addition carries few
consequences. If you did an import from another system or otherwise find that your repository is
much larger than it should be, here is how you can find and remove large objects.
<p>Be warned: this technique is destructive to your commit history. It rewrites every commit
object since the earliest tree you have to modify to remove a large file reference. If you do this
immediately after an import, before anyone has started to base work on the commit, you&rsquo;re fine &ndash;
otherwise, you have to notify all contributors that they must rebase their work onto your new
commits.
<p>To demonstrate, you&rsquo;ll add a large file into your test repository, remove it in the next commit, find
it, and remove it permanently from the repository. First, add a large object to your history:
<p>$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
$ git add git.tgz
$ git commit -m 'Add git tarball'
[master 7b30847] Add git tarball
&nbsp;1 file changed, 0 insertions(+), 0 deletions(-)
&nbsp;create mode 100644 git.tgz
<p>Oops &ndash; you didn&rsquo;t want to add a huge tarball to your project. Better get rid of it:
<p>467</p>
<br>
</div>
<div class="page">
<br>
<p>$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'Oops - remove large tarball'
[master dadf725] Oops - remove large tarball
&nbsp;1 file changed, 0 insertions(+), 0 deletions(-)
&nbsp;delete mode 100644 git.tgz
<p>Now, gc your database and see how much space you&rsquo;re using:
<p>$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
<p>You can run the count-objects command to quickly see how much space you&rsquo;re using:
<p>$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0
<p>The size-pack entry is the size of your packfiles in kilobytes, so you&rsquo;re using almost 5MB. Before the
last commit, you were using closer to 2K &ndash; clearly, removing the file from the previous commit
didn&rsquo;t remove it from your history. Every time anyone clones this repository, they will have to clone
all 5MB just to get this tiny project, because you accidentally added a big file. Let&rsquo;s get rid of it.
<p>First you have to find it. In this case, you already know what file it is. But suppose you didn&rsquo;t; how
would you identify what file or files were taking up so much space? If you run git gc, all the objects
are in a packfile; you can identify the big objects by running another plumbing command called git
verify-pack and sorting on the third field in the output, which is file size. You can also pipe it
through the tail command because you&rsquo;re only interested in the last few largest files:
<p>$ git verify-pack -v .git/objects/pack/pack-29&hellip;69.idx \
&nbsp; | sort -k 3 -n \
&nbsp; | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob 22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob 4975916 4976258 1438
<p>468</p>
<br>
</div>
<div class="page">
<br>
<p>The big object is at the bottom: 5MB. To find out what file it is, you&rsquo;ll use the rev-list command,
which you used briefly in Enforcing a Specific Commit-Message Format. If you pass --objects to
rev-list, it lists all the commit SHA-1s and also the blob SHA-1s with the file paths associated with
them. You can use this to find your blob&rsquo;s name:
<p>$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz
<p>Now, you need to remove this file from all trees in your past. You can easily see what commits
modified this file:
<p>$ git log --oneline --branches -- git.tgz
dadf725 Oops - remove large tarball
7b30847 Add git tarball
<p>You must rewrite all the commits downstream from 7b30847 to fully remove this file from your Git
history. To do so, you use filter-branch, which you used in Rewriting History:
<p>$ git filter-branch --index-filter \
&nbsp; 'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
<p>The --index-filter option is similar to the --tree-filter option used in Rewriting History, except
that instead of passing a command that modifies files checked out on disk, you&rsquo;re modifying your
staging area or index each time.
<p>Rather than remove a specific file with something like rm file, you have to remove it with git rm
--cached &ndash; you must remove it from the index, not from disk. The reason to do it this way is speed &ndash;
because Git doesn&rsquo;t have to check out each revision to disk before running your filter, the process
can be much, much faster. You can accomplish the same task with --tree-filter if you want. The
--ignore-unmatch option to git rm tells it not to error out if the pattern you&rsquo;re trying to remove isn&rsquo;t
there. Finally, you ask filter-branch to rewrite your history only from the 7b30847 commit up,
because you know that is where this problem started. Otherwise, it will start from the beginning
and will unnecessarily take longer.
<p>Your history no longer contains a reference to that file. However, your reflog and a new set of refs
that Git added when you did the filter-branch under .git/refs/original still do, so you have to
remove them and then repack the database. You need to get rid of anything that has a pointer to
those old commits before you repack:
<p>469</p>
<br>
</div>
<div class="page">
<br>
<p>$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
<p>Let&rsquo;s see how much space you saved.
<p>$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
<p>The packed repository size is down to 8K, which is much better than 5MB. You can see from the size
value that the big object is still in your loose objects, so it&rsquo;s not gone; but it won&rsquo;t be transferred on a
push or subsequent clone, which is what is important. If you really wanted to, you could remove
the object completely by running git prune with the --expire option:
<p>$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
<p>Environment Variables
Git always runs inside a bash shell, and uses a number of shell environment variables to determine
how it behaves. Occasionally, it comes in handy to know what these are, and how they can be used
to make Git behave the way you want it to. This isn&rsquo;t an exhaustive list of all the environment
variables Git pays attention to, but we&rsquo;ll cover the most useful.
<p>470</p>
<br>
</div>
<div class="page">
<br>
<p>Global Behavior
<p>Some of Git&rsquo;s general behavior as a computer program depends on environment variables.
<p>GIT_EXEC_PATH determines where Git looks for its sub-programs (like git-commit, git-diff, and
others). You can check the current setting by running git --exec-path.
<p>HOME isn&rsquo;t usually considered customizable (too many other things depend on it), but it&rsquo;s where Git
looks for the global configuration file. If you want a truly portable Git installation, complete with
global configuration, you can override HOME in the portable Git&rsquo;s shell profile.
<p>PREFIX is similar, but for the system-wide configuration. Git looks for this file at
$PREFIX/etc/gitconfig.
<p>GIT_CONFIG_NOSYSTEM, if set, disables the use of the system-wide configuration file. This is useful if
your system config is interfering with your commands, but you don&rsquo;t have access to change or
remove it.
<p>GIT_PAGER controls the program used to display multi-page output on the command line. If this is
unset, PAGER will be used as a fallback.
<p>GIT_EDITOR is the editor Git will launch when the user needs to edit some text (a commit message,
for example). If unset, EDITOR will be used.
<p>Repository Locations
<p>Git uses several environment variables to determine how it interfaces with the current repository.
<p>GIT_DIR is the location of the .git folder. If this isn&rsquo;t specified, Git walks up the directory tree until it
gets to ~ or /, looking for a .git directory at every step.
<p>GIT_CEILING_DIRECTORIES controls the behavior of searching for a .git directory. If you access
directories that are slow to load (such as those on a tape drive, or across a slow network
connection), you may want to have Git stop trying earlier than it might otherwise, especially if Git is
invoked when building your shell prompt.
<p>GIT_WORK_TREE is the location of the root of the working directory for a non-bare repository. If --git
-dir or GIT_DIR is specified but none of --work-tree, GIT_WORK_TREE or core.worktree is specified, the
current working directory is regarded as the top level of your working tree.
<p>GIT_INDEX_FILE is the path to the index file (non-bare repositories only).
<p>GIT_OBJECT_DIRECTORY can be used to specify the location of the directory that usually resides at
.git/objects.
<p>GIT_ALTERNATE_OBJECT_DIRECTORIES is a colon-separated list (formatted like /dir/one:/dir/two:&hellip;)
which tells Git where to check for objects if they aren&rsquo;t in GIT_OBJECT_DIRECTORY. If you happen to
have a lot of projects with large files that have the exact same contents, this can be used to avoid
storing too many copies of them.
<p>471</p>
<br>
</div>
<div class="page">
<br>
<p>Pathspecs
<p>A &ldquo;pathspec&rdquo; refers to how you specify paths to things in Git, including the use of wildcards. These
are used in the .gitignore file, but also on the command-line (git add *.c).
<p>GIT_GLOB_PATHSPECS and GIT_NOGLOB_PATHSPECS control the default behavior of wildcards in
pathspecs. If GIT_GLOB_PATHSPECS is set to 1, wildcard characters act as wildcards (which is the
default); if GIT_NOGLOB_PATHSPECS is set to 1, wildcard characters only match themselves, meaning
something like *.c would only match a file named &ldquo;*.c&rdquo;, rather than any file whose name ends with
.c. You can override this in individual cases by starting the pathspec with :(glob) or :(literal), as
in :(glob)*.c.
<p>GIT_LITERAL_PATHSPECS disables both of the above behaviors; no wildcard characters will work, and
the override prefixes are disabled as well.
<p>GIT_ICASE_PATHSPECS sets all pathspecs to work in a case-insensitive manner.
<p>Committing
<p>The final creation of a Git commit object is usually done by git-commit-tree, which uses these
environment variables as its primary source of information, falling back to configuration values
only if these aren&rsquo;t present.
<p>GIT_AUTHOR_NAME is the human-readable name in the &ldquo;author&rdquo; field.
<p>GIT_AUTHOR_EMAIL is the email for the &ldquo;author&rdquo; field.
<p>GIT_AUTHOR_DATE is the timestamp used for the &ldquo;author&rdquo; field.
<p>GIT_COMMITTER_NAME sets the human name for the &ldquo;committer&rdquo; field.
<p>GIT_COMMITTER_EMAIL is the email address for the &ldquo;committer&rdquo; field.
<p>GIT_COMMITTER_DATE is used for the timestamp in the &ldquo;committer&rdquo; field.
<p>EMAIL is the fallback email address in case the user.email configuration value isn&rsquo;t set. If this isn&rsquo;t
set, Git falls back to the system user and host names.
<p>Networking
<p>Git uses the curl library to do network operations over HTTP, so GIT_CURL_VERBOSE tells Git to emit all
the messages generated by that library. This is similar to doing curl -v on the command line.
<p>GIT_SSL_NO_VERIFY tells Git not to verify SSL certificates. This can sometimes be necessary if you&rsquo;re
using a self-signed certificate to serve Git repositories over HTTPS, or you&rsquo;re in the middle of setting
up a Git server but haven&rsquo;t installed a full certificate yet.
<p>If the data rate of an HTTP operation is lower than GIT_HTTP_LOW_SPEED_LIMIT bytes per second for
longer than GIT_HTTP_LOW_SPEED_TIME seconds, Git will abort that operation. These values override
the http.lowSpeedLimit and http.lowSpeedTime configuration values.
<p>472</p>
<br>
</div>
<div class="page">
<br>
<p>GIT_HTTP_USER_AGENT sets the user-agent string used by Git when communicating over HTTP. The
default is a value like git/2.0.0.
<p>Diffing and Merging
<p>GIT_DIFF_OPTS is a bit of a misnomer. The only valid values are -u&lt;n&gt; or --unified=&lt;n&gt;, which
controls the number of context lines shown in a git diff command.
<p>GIT_EXTERNAL_DIFF is used as an override for the diff.external configuration value. If it&rsquo;s set, Git will
invoke this program when git diff is invoked.
<p>GIT_DIFF_PATH_COUNTER and GIT_DIFF_PATH_TOTAL are useful from inside the program specified by
GIT_EXTERNAL_DIFF or diff.external. The former represents which file in a series is being diffed
(starting with 1), and the latter is the total number of files in the batch.
<p>GIT_MERGE_VERBOSITY controls the output for the recursive merge strategy. The allowed values are as
follows:
<p>&bull; 0 outputs nothing, except possibly a single error message.
<p>&bull; 1 shows only conflicts.
<p>&bull; 2 also shows file changes.
<p>&bull; 3 shows when files are skipped because they haven&rsquo;t changed.
<p>&bull; 4 shows all paths as they are processed.
<p>&bull; 5 and above show detailed debugging information.
<p>The default value is 2.
<p>Debugging
<p>Want to really know what Git is up to? Git has a fairly complete set of traces embedded, and all you
need to do is turn them on. The possible values of these variables are as follows:
<p>&bull; &ldquo;true&rdquo;, &ldquo;1&rdquo;, or &ldquo;2&rdquo; &ndash; the trace category is written to stderr.
<p>&bull; An absolute path starting with / &ndash; the trace output will be written to that file.
<p>GIT_TRACE controls general traces, which don&rsquo;t fit into any specific category. This includes the
expansion of aliases, and delegation to other sub-programs.
<p>$ GIT_TRACE=true git lga
20:12:49.877982 git.c:554 trace: exec: 'git-lga'
20:12:49.878369 run-command.c:341 trace: run_command: 'git-lga'
20:12:49.879529 git.c:282 trace: alias expansion: lga =&gt; 'log' '--graph'
'--pretty=oneline' '--abbrev-commit' '--decorate' '--all'
20:12:49.879885 git.c:349 trace: built-in: git 'log' '--graph' '--
pretty=oneline' '--abbrev-commit' '--decorate' '--all'
20:12:49.899217 run-command.c:341 trace: run_command: 'less'
20:12:49.899675 run-command.c:192 trace: exec: 'less'
<p>473</p>
<br>
</div>
<div class="page">
<br>
<p>GIT_TRACE_PACK_ACCESS controls tracing of packfile access. The first field is the packfile being
accessed, the second is the offset within that file:
<p>$ GIT_TRACE_PACK_ACCESS=true git status
20:10:12.081397 sha1_file.c:2088 .git/objects/pack/pack-c3fa...291e.pack 12
20:10:12.081886 sha1_file.c:2088 .git/objects/pack/pack-c3fa...291e.pack 34662
20:10:12.082115 sha1_file.c:2088 .git/objects/pack/pack-c3fa...291e.pack 35175
# [&hellip;]
20:10:12.087398 sha1_file.c:2088 .git/objects/pack/pack-e80e...e3d2.pack
56914983
20:10:12.087419 sha1_file.c:2088 .git/objects/pack/pack-e80e...e3d2.pack
14303666
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
<p>GIT_TRACE_PACKET enables packet-level tracing for network operations.
<p>$ GIT_TRACE_PACKET=true git ls-remote origin
20:15:14.867043 pkt-line.c:46 packet: git&lt; # service=git-upload-
pack
20:15:14.867071 pkt-line.c:46 packet: git&lt; 0000
20:15:14.867079 pkt-line.c:46 packet: git&lt;
97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-
band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done
symref=HEAD:refs/heads/master agent=git/2.0.4
20:15:14.867088 pkt-line.c:46 packet: git&lt;
0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-
name
20:15:14.867094 pkt-line.c:46 packet: git&lt;
36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config
# [&hellip;]
<p>GIT_TRACE_PERFORMANCE controls logging of performance data. The output shows how long each
particular git invocation takes.
<p>474</p>
<br>
</div>
<div class="page">
<br>
<p>$ GIT_TRACE_PERFORMANCE=true git gc
20:18:19.499676 trace.c:414 performance: 0.374835000 s: git command: 'git'
'pack-refs' '--all' '--prune'
20:18:19.845585 trace.c:414 performance: 0.343020000 s: git command: 'git'
'reflog' 'expire' '--all'
Counting objects: 170994, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (43413/43413), done.
Writing objects: 100% (170994/170994), done.
Total 170994 (delta 126176), reused 170524 (delta 125706)
20:18:23.567927 trace.c:414 performance: 3.715349000 s: git command: 'git'
'pack-objects' '--keep-true-parents' '--honor-pack-keep' '--non-empty' '--all' '--
reflog' '--unpack-unreachable=2.weeks.ago' '--local' '--delta-base-offset'
'.git/objects/pack/.tmp-49190-pack'
20:18:23.584728 trace.c:414 performance: 0.000910000 s: git command: 'git'
'prune-packed'
20:18:23.605218 trace.c:414 performance: 0.017972000 s: git command: 'git'
'update-server-info'
20:18:23.606342 trace.c:414 performance: 3.756312000 s: git command: 'git'
'repack' '-d' '-l' '-A' '--unpack-unreachable=2.weeks.ago'
Checking connectivity: 170994, done.
20:18:25.225424 trace.c:414 performance: 1.616423000 s: git command: 'git'
'prune' '--expire' '2.weeks.ago'
20:18:25.232403 trace.c:414 performance: 0.001051000 s: git command: 'git'
'rerere' 'gc'
20:18:25.233159 trace.c:414 performance: 6.112217000 s: git command: 'git'
'gc'
<p>GIT_TRACE_SETUP shows information about what Git is discovering about the repository and
environment it&rsquo;s interacting with.
<p>$ GIT_TRACE_SETUP=true git status
20:19:47.086765 trace.c:315 setup: git_dir: .git
20:19:47.087184 trace.c:316 setup: worktree: /Users/ben/src/git
20:19:47.087191 trace.c:317 setup: cwd: /Users/ben/src/git
20:19:47.087194 trace.c:318 setup: prefix: (null)
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
<p>Miscellaneous
<p>GIT_SSH, if specified, is a program that is invoked instead of ssh when Git tries to connect to an SSH
host. It is invoked like $GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;. Note that this isn&rsquo;t the
easiest way to customize how ssh is invoked; it won&rsquo;t support extra command-line parameters, so
you&rsquo;d have to write a wrapper script and set GIT_SSH to point to it. It&rsquo;s probably easier just to use the
~/.ssh/config file for that.
<p>475</p>
<br>
</div>
<div class="page">
<br>
<p>GIT_ASKPASS is an override for the core.askpass configuration value. This is the program invoked
whenever Git needs to ask the user for credentials, which can expect a text prompt as a command-
line argument, and should return the answer on stdout. (See Credential Storage for more on this
subsystem.)
<p>GIT_NAMESPACE controls access to namespaced refs, and is equivalent to the --namespace flag. This is
mostly useful on the server side, where you may want to store multiple forks of a single repository
in one repository, only keeping the refs separate.
<p>GIT_FLUSH can be used to force Git to use non-buffered I/O when writing incrementally to stdout. A
value of 1 causes Git to flush more often, a value of 0 causes all output to be buffered. The default
value (if this variable is not set) is to choose an appropriate buffering scheme depending on the
activity and the output mode.
<p>GIT_REFLOG_ACTION lets you specify the descriptive text written to the reflog. Here&rsquo;s an example:
<p>$ GIT_REFLOG_ACTION="my action" git commit --allow-empty -m 'My message'
[master 9e3d55a] My message
$ git reflog -1
9e3d55a HEAD@{0}: my action: My message
<p>Summary
At this point, you should have a pretty good understanding of what Git does in the background and,
to some degree, how it&rsquo;s implemented. This chapter has covered a number of plumbing
commands&thinsp;&mdash;&thinsp;commands that are lower level and simpler than the porcelain commands you&rsquo;ve
learned about in the rest of the book. Understanding how Git works at a lower level should make it
easier to understand why it&rsquo;s doing what it&rsquo;s doing and also to write your own tools and helper
scripts to make your specific workflow work for you.
<p>Git as a content-addressable filesystem is a very powerful tool that you can easily use as more than
just a VCS. We hope you can use your newfound knowledge of Git internals to implement your own
cool application of this technology and feel more comfortable using Git in more advanced ways.
<p>476</p>
<br>
</div>
<div class="page">
<br>
<p>Appendix A: Git in Other Environments
If you read through the whole book, you&rsquo;ve learned a lot about how to use Git at the command line.
You can work with local files, connect your repository to others over a network, and work
effectively with others. But the story doesn&rsquo;t end there; Git is usually used as part of a larger
ecosystem, and the terminal isn&rsquo;t always the best way to work with it. Now we&rsquo;ll take a look at some
of the other kinds of environments where Git can be useful, and how other applications (including
yours) work alongside Git.
<p>Graphical Interfaces
Git&rsquo;s native environment is in the terminal. New features show up there first, and only at the
command line is the full power of Git completely at your disposal. But plain text isn&rsquo;t the best
choice for all tasks; sometimes a visual representation is what you need, and some users are much
more comfortable with a point-and-click interface.
<p>It&rsquo;s important to note that different interfaces are tailored for different workflows. Some clients
expose only a carefully curated subset of Git functionality, in order to support a specific way of
working that the author considers effective. When viewed in this light, none of these tools can be
called &ldquo;better&rdquo; than any of the others, they&rsquo;re simply more fit for their intended purpose. Also note
that there&rsquo;s nothing these graphical clients can do that the command-line client can&rsquo;t; the
command-line is still where you&rsquo;ll have the most power and control when working with your
repositories.
<p>gitk and git-gui
<p>When you install Git, you also get its visual tools, gitk and git-gui.
<p>gitk is a graphical history viewer. Think of it like a powerful GUI shell over git log and git grep.
This is the tool to use when you&rsquo;re trying to find something that happened in the past, or visualize
your project&rsquo;s history.
<p>Gitk is easiest to invoke from the command-line. Just cd into a Git repository, and type:
<p>$ gitk [git log options]
<p>Gitk accepts many command-line options, most of which are passed through to the underlying git
log action. Probably one of the most useful is the --all flag, which tells gitk to show commits
reachable from any ref, not just HEAD. Gitk&rsquo;s interface looks like this:
<p>477</p>
<br>
</div>
<div class="page">
<br>
<p>Figure 153. The gitk history viewer.
<p>On the top is something that looks a bit like the output of git log --graph; each dot represents a
commit, the lines represent parent relationships, and refs are shown as colored boxes. The yellow
dot represents HEAD, and the red dot represents changes that are yet to become a commit. At the
bottom is a view of the selected commit; the comments and patch on the left, and a summary view
on the right. In between is a collection of controls used for searching history.
<p>git-gui, on the other hand, is primarily a tool for crafting commits. It, too, is easiest to invoke from
the command line:
<p>$ git gui
<p>And it looks something like this:
<p>478</p>
<br>
</div>
<div class="page">
<br>
<p>Figure 154. The git-gui commit tool.
<p>On the left is the index; unstaged changes are on top, staged changes on the bottom. You can move
entire files between the two states by clicking on their icons, or you can select a file for viewing by
clicking on its name.
<p>At top right is the diff view, which shows the changes for the currently-selected file. You can stage
individual hunks (or individual lines) by right-clicking in this area.
<p>At the bottom right is the message and action area. Type your message into the text box and click
&ldquo;Commit&rdquo; to do something similar to git commit. You can also choose to amend the last commit by
choosing the &ldquo;Amend&rdquo; radio button, which will update the &ldquo;Staged Changes&rdquo; area with the contents
of the last commit. Then you can simply stage or unstage some changes, alter the commit message,
and click &ldquo;Commit&rdquo; again to replace the old commit with a new one.
<p>gitk and git-gui are examples of task-oriented tools. Each of them is tailored for a specific purpose
(viewing history and creating commits, respectively), and omit the features not necessary for that
task.
<p>GitHub for macOS and Windows
<p>GitHub has created two workflow-oriented Git clients: one for Windows, and one for macOS. These
clients are a good example of workflow-oriented tools &ndash; rather than expose all of Git&rsquo;s functionality,
they instead focus on a curated set of commonly-used features that work well together. They look
like this:
<p>479</p>
<br>
</div>
<div class="page">
<br>
<p>Figure 155. GitHub for macOS.
<p>Figure 156. GitHub for Windows.
<p>They are designed to look and work very much alike, so we&rsquo;ll treat them like a single product in this
chapter. We won&rsquo;t be doing a detailed rundown of these tools (they have their own documentation),
but a quick tour of the &ldquo;changes&rdquo; view (which is where you&rsquo;ll spend most of your time) is in order.
<p>&bull; On the left is the list of repositories the client is tracking; you can add a repository (either by
cloning or attaching locally) by clicking the &ldquo;+&rdquo; icon at the top of this area.
<p>&bull; In the center is a commit-input area, which lets you input a commit message, and select which
files should be included. (On Windows, the commit history is displayed directly below this; on
<p>480</p>
<br>
</div>
<div class="page">
<br>
<p>macOS, it&rsquo;s on a separate tab.)
<p>&bull; On the right is a diff view, which shows what&rsquo;s changed in your working directory, or which
changes were included in the selected commit.
<p>&bull; The last thing to notice is the &ldquo;Sync&rdquo; button at the top-right, which is the primary way you
interact over the network.
<p>
You don&rsquo;t need a GitHub account to use these tools. While they&rsquo;re designed to
highlight GitHub&rsquo;s service and recommended workflow, they will happily work
with any repository, and do network operations with any Git host.
<p>Installation
<p>GitHub for Windows can be downloaded from https://windows.github.com, and GitHub for macOS
from https://mac.github.com. When the applications are first run, they walk you through all the
first-time Git setup, such as configuring your name and email address, and both set up sane
defaults for many common configuration options, such as credential caches and CRLF behavior.
<p>Both are &ldquo;evergreen&rdquo; &ndash; updates are downloaded and installed in the background while the
applications are open. This helpfully includes a bundled version of Git, which means you probably
won&rsquo;t have to worry about manually updating it again. On Windows, the client includes a shortcut
to launch PowerShell with Posh-git, which we&rsquo;ll talk more about later in this chapter.
<p>The next step is to give the tool some repositories to work with. The client shows you a list of the
repositories you have access to on GitHub, and can clone them in one step. If you already have a
local repository, just drag its directory from the Finder or Windows Explorer into the GitHub client
window, and it will be included in the list of repositories on the left.
<p>Recommended Workflow
<p>Once it&rsquo;s installed and configured, you can use the GitHub client for many common Git tasks. The
intended workflow for this tool is sometimes called the &ldquo;GitHub Flow.&rdquo; We cover this in more detail
in The GitHub Flow, but the general gist is that (a) you&rsquo;ll be committing to a branch, and (b) you&rsquo;ll
be syncing up with a remote repository fairly regularly.
<p>Branch management is one of the areas where the two tools diverge. On macOS, there&rsquo;s a button at
the top of the window for creating a new branch:
<p>Figure 157. &ldquo;Create Branch&rdquo; button on macOS.
<p>On Windows, this is done by typing the new branch&rsquo;s name in the branch-switching widget:
<p>481</p>
<br>
<div class="annotation">
<a href="https://windows.github.com">https://windows.github.com</a>
</div>
<div class="annotation">
<a href="https://mac.github.com">https://mac.github.com</a>
</div>
</div>
<div class="page">
<br>
<p>Figure 158. Creating a branch on Windows.
<p>Once your branch is created, making new commits is fairly straightforward. Make some changes in
your working directory, and when you switch to the GitHub client window, it will show you which
files changed. Enter a commit message, select the files you&rsquo;d like to include, and click the &ldquo;Commit&rdquo;
button (ctrl-enter or ⌘-enter).
<p>The main way you interact with other repositories over the network is through the &ldquo;Sync&rdquo; feature.
Git internally has separate operations for pushing, fetching, merging, and rebasing, but the GitHub
clients collapse all of these into one multi-step feature. Here&rsquo;s what happens when you click the
Sync button:
<p>1. git pull --rebase. If this fails because of a merge conflict, fall back to git pull --no-rebase.
<p>2. git push.
<p>This is the most common sequence of network commands when working in this style, so squashing
them into one command saves a lot of time.
<p>Summary
<p>These tools are very well-suited for the workflow they&rsquo;re designed for. Developers and non-
developers alike can be collaborating on a project within minutes, and many of the best practices
for this kind of workflow are baked into the tools. However, if your workflow is different, or you
want more control over how and when network operations are done, we recommend you use
another client or the command line.
<p>Other GUIs
<p>There are a number of other graphical Git clients, and they run the gamut from specialized, single-
purpose tools all the way to apps that try to expose everything Git can do. The official Git website
has a curated list of the most popular clients at https://git-scm.com/downloads/guis. A more
comprehensive list is available on the Git wiki site, at https://git.wiki.kernel.org/index.php/
Interfaces,_frontends,_and_tools#Graphical_Interfaces.
<p>Git in Visual Studio
Starting with Visual Studio 2013 Update 1, Visual Studio users have a Git client built directly into
their IDE. Visual Studio has had source-control integration features for quite some time, but they
were oriented towards centralized, file-locking systems, and Git was not a good match for this
workflow. Visual Studio 2013&rsquo;s Git support has been separated from this older feature, and the
<p>482</p>
<br>
<div class="annotation">
<a href="https://git-scm.com/downloads/guis">https://git-scm.com/downloads/guis</a>
</div>
<div class="annotation">
<a href="https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces">https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces</a>
</div>
<div class="annotation">
<a href="https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces">https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces</a>
</div>
</div>
<div class="page">
<br>
<p>result is a much better fit between Studio and Git.
<p>To locate the feature, open a project that&rsquo;s controlled by Git (or just git init an existing project),
and select View &gt; Team Explorer from the menu. You&rsquo;ll see the "Connect" view, which looks a bit
like this:
<p>Figure 159. Connecting to a Git repository from Team Explorer.
<p>Visual Studio remembers all of the projects you&rsquo;ve opened that are Git-controlled, and they&rsquo;re
available in the list at the bottom. If you don&rsquo;t see the one you want there, click the "Add" link and
type in the path to the working directory. Double clicking on one of the local Git repositories leads
you to the Home view, which looks like The "Home" view for a Git repository in Visual Studio.. This
is a hub for performing Git actions; when you&rsquo;re writing code, you&rsquo;ll probably spend most of your
time in the "Changes" view, but when it comes time to pull down changes made by your teammates,
you&rsquo;ll use the "Unsynced Commits" and "Branches" views.
<p>Figure 160. The "Home" view for a Git repository in Visual Studio.
<p>Visual Studio now has a powerful task-focused UI for Git. It includes a linear history view, a diff
viewer, remote commands, and many other capabilities. For complete documentation of this
feature (which doesn&rsquo;t fit here), go to http://msdn.microsoft.com/en-us/library/hh850437.aspx.
<p>483</p>
<br>
<div class="annotation">
<a href="http://msdn.microsoft.com/en-us/library/hh850437.aspx">http://msdn.microsoft.com/en-us/library/hh850437.aspx</a>
</div>
</div>
<div class="page">
<br>
<p>Git in Visual Studio Code
Visual Studio Code has git support built in. You will need to have git version 2.0.0 (or newer)
installed.
<p>The main features are:
<p>&bull; See the diff of the file you are editing in the gutter.
<p>&bull; The Git Status Bar (lower left) shows the current branch, dirty indicators, incoming and
outgoing commits.
<p>&bull; You can do the most common git operations from within the editor:
<p>◦ Initialize a repository.
<p>◦ Clone a repository.
<p>◦ Create branches and tags.
<p>◦ Stage and commit changes.
<p>◦ Push/pull/sync with a remote branch.
<p>◦ Resolve merge conflicts.
<p>◦ View diffs.
<p>&bull; With an extension, you can also handle GitHub Pull Requests:
https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github
<p>The official documentation can be found here: https://code.visualstudio.com/Docs/editor/
versioncontrol
<p>Git in Eclipse
Eclipse ships with a plugin called Egit, which provides a fairly-complete interface to Git operations.
It&rsquo;s accessed by switching to the Git Perspective (Window &gt; Open Perspective &gt; Other&hellip;, and select
"Git").
<p>484</p>
<br>
<div class="annotation">
<a href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github">https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github</a>
</div>
<div class="annotation">
<a href="https://code.visualstudio.com/Docs/editor/versioncontrol">https://code.visualstudio.com/Docs/editor/versioncontrol</a>
</div>
<div class="annotation">
<a href="https://code.visualstudio.com/Docs/editor/versioncontrol">https://code.visualstudio.com/Docs/editor/versioncontrol</a>
</div>
</div>
<div class="page">
<br>
<p>Figure 161. Eclipse&rsquo;s EGit environment.
<p>EGit comes with plenty of great documentation, which you can find by going to Help &gt; Help
Contents, and choosing the "EGit Documentation" node from the contents listing.
<p>Git in IntelliJ / PyCharm / WebStorm / PhpStorm /
RubyMine
JetBrains IDEs (such as IntelliJ IDEA, PyCharm, WebStorm, PhpStorm, RubyMine, and others) ship
with a Git Integration plugin. It provides a dedicated view in the IDE to work with Git and GitHub
Pull Requests.
<p>Figure 162. Version Control ToolWindow in JetBrains IDEs.
<p>The integration relies on the command-line git client, and requires one to be installed. The official
documentation is available at https://www.jetbrains.com/help/idea/using-git-integration.html.
<p>485</p>
<br>
<div class="annotation">
<a href="https://www.jetbrains.com/help/idea/using-git-integration.html">https://www.jetbrains.com/help/idea/using-git-integration.html</a>
</div>
</div>
<div class="page">
<br>
<p>Git in Sublime Text
From version 3.2 onwards, Sublime Text has git integration in the editor.
<p>The features are:
<p>&bull; The sidebar will show the git status of files and folders with a badge/icon.
<p>&bull; Files and folders that are in your .gitignore file will be faded out in the sidebar.
<p>&bull; In the status bar, you can see the current git branch and how many modifications you have
made.
<p>&bull; All changes to a file are now visible via markers in the gutter.
<p>&bull; You can use part of the Sublime Merge git client functionality from within Sublime Text. (This
requires that Sublime Merge is installed. See: https://www.sublimemerge.com/)
<p>The official documentation for Sublime Text can be found here: https://www.sublimetext.com/docs/
3/git_integration.html
<p>Git in Bash
If you&rsquo;re a Bash user, you can tap into some of your shell&rsquo;s features to make your experience with
Git a lot friendlier. Git actually ships with plugins for several shells, but it&rsquo;s not turned on by
default.
<p>First, you need to get a copy of the contrib/completion/git-completion.bash file out of the Git source
code. Copy it somewhere handy, like your home directory, and add this to your .bashrc:
<p>. ~/git-completion.bash
<p>Once that&rsquo;s done, change your directory to a Git repository, and type:
<p>$ git chec&lt;tab&gt;
<p>&hellip;and Bash will auto-complete to git checkout. This works with all of Git&rsquo;s subcommands,
command-line parameters, and remotes and ref names where appropriate.
<p>It&rsquo;s also useful to customize your prompt to show information about the current directory&rsquo;s Git
repository. This can be as simple or complex as you want, but there are generally a few key pieces
of information that most people want, like the current branch, and the status of the working
directory. To add these to your prompt, just copy the contrib/completion/git-prompt.sh file from
Git&rsquo;s source repository to your home directory, add something like this to your .bashrc:
<p>. ~/git-prompt.sh
export GIT_PS1_SHOWDIRTYSTATE=1
export PS1='\w$(__git_ps1 " (%s)")\$ '
<p>486</p>
<br>
<div class="annotation">
<a href="https://www.sublimemerge.com/">https://www.sublimemerge.com/</a>
</div>
<div class="annotation">
<a href="https://www.sublimetext.com/docs/3/git_integration.html">https://www.sublimetext.com/docs/3/git_integration.html</a>
</div>
<div class="annotation">
<a href="https://www.sublimetext.com/docs/3/git_integration.html">https://www.sublimetext.com/docs/3/git_integration.html</a>
</div>
</div>
<div class="page">
<br>
<p>The \w means print the current working directory, the \$ prints the $ part of the prompt, and
__git_ps1 " (%s)" calls the function provided by git-prompt.sh with a formatting argument. Now
your bash prompt will look like this when you&rsquo;re anywhere inside a Git-controlled project:
<p>Figure 163. Customized bash prompt.
<p>Both of these scripts come with helpful documentation; take a look at the contents of git-
completion.bash and git-prompt.sh for more information.
<p>Git in Zsh
Zsh also ships with a tab-completion library for Git. To use it, simply run autoload -Uz compinit &amp;&amp;
compinit in your .zshrc. Zsh&rsquo;s interface is a bit more powerful than Bash&rsquo;s:
<p>$ git che&lt;tab&gt;
check-attr -- display gitattributes information
check-ref-format -- ensure that a reference name is well formed
checkout -- checkout branch or paths to working tree
checkout-index -- copy files from index to working directory
cherry -- find commits not merged upstream
cherry-pick -- apply changes introduced by some existing commits
<p>Ambiguous tab-completions aren&rsquo;t just listed; they have helpful descriptions, and you can
graphically navigate the list by repeatedly hitting tab. This works with Git commands, their
arguments, and names of things inside the repository (like refs and remotes), as well as filenames
and all the other things Zsh knows how to tab-complete.
<p>Zsh ships with a framework for getting information from version control systems, called vcs_info.
To include the branch name in the prompt on the right side, add these lines to your ~/.zshrc file:
<p>autoload -Uz vcs_info
precmd_vcs_info() { vcs_info }
precmd_functions+=( precmd_vcs_info )
setopt prompt_subst
RPROMPT=\$vcs_info_msg_0_
# PROMPT=\$vcs_info_msg_0_'%# '
zstyle ':vcs_info:git:*' formats '%b'
<p>487</p>
<br>
</div>
<div class="page">
<br>
<p>This results in a display of the current branch on the right-hand side of the terminal window,
whenever your shell is inside a Git repository. (The left side is supported as well, of course; just
uncomment the assignment to PROMPT.) It looks a bit like this:
<p>Figure 164. Customized zsh prompt
<p>For more information on vcs_info, check out its documentation in the zshcontrib(1) manual page,
or online at http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-
Information.
<p>Instead of vcs_info, you might prefer the prompt customization script that ships with Git, called
git-prompt.sh; see https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh for
details. git-prompt.sh is compatible with both Bash and Zsh.
<p>Zsh is powerful enough that there are entire frameworks dedicated to making it better. One of them
is called "oh-my-zsh", and it can be found at https://github.com/robbyrussell/oh-my-zsh. oh-my-zsh&rsquo;s
plugin system comes with powerful git tab-completion, and it has a variety of prompt "themes",
many of which display version-control data. An example of an oh-my-zsh theme is just one example
of what can be done with this system.
<p>488</p>
<br>
<div class="annotation">
<a href="http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information">http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information</a>
</div>
<div class="annotation">
<a href="http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information">http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information</a>
</div>
<div class="annotation">
<a href="https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh">https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh</a>
</div>
<div class="annotation">
<a href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a>
</div>
</div>
<div class="page">
<br>
<p>Figure 165. An example of an oh-my-zsh theme
<p>Git in PowerShell
The legacy command-line terminal on Windows (cmd.exe) isn&rsquo;t really capable of a customized Git
experience, but if you&rsquo;re using PowerShell, you&rsquo;re in luck. This also works if you&rsquo;re running
PowerShell Core on Linux or macOS. A package called posh-git (https://github.com/dahlbyk/posh-
git) provides powerful tab-completion facilities, as well as an enhanced prompt to help you stay on
top of your repository status. It looks like this:
<p>Figure 166. PowerShell with Posh-git.
<p>Installation
<p>Prerequisites (Windows only)
<p>Before you&rsquo;re able to run PowerShell scripts on your machine, you need to set your local
ExecutionPolicy to RemoteSigned (basically, anything except Undefined and Restricted). If you choose
AllSigned instead of RemoteSigned, also local scripts (your own) need to be digitally signed in order
to be executed. With RemoteSigned, only scripts having the ZoneIdentifier set to Internet (were
downloaded from the web) need to be signed, others not. If you&rsquo;re an administrator and want to set
it for all users on that machine, use -Scope LocalMachine. If you&rsquo;re a normal user, without
administrative rights, you can use -Scope CurrentUser to set it only for you.
<p>More about PowerShell Scopes: https://docs.microsoft.com/en-us/powershell/module/
<p>489</p>
<br>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git">https://github.com/dahlbyk/posh-git</a>
</div>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git">https://github.com/dahlbyk/posh-git</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes</a>
</div>
</div>
<div class="page">
<br>
<p>microsoft.powershell.core/about/about_scopes
<p>More about PowerShell ExecutionPolicy: https://docs.microsoft.com/en-us/powershell/module/
microsoft.powershell.security/set-executionpolicy
<p>To set the value of ExecutionPolicy to RemoteSigned for all users use the next command:
<p>&gt; Set-ExecutionPolicy -Scope LocalMachine -ExecutionPolicy RemoteSigned -Force
<p>PowerShell Gallery
<p>If you have at least PowerShell 5 or PowerShell 4 with PackageManagement installed, you can use
the package manager to install posh-git for you.
<p>More information about PowerShell Gallery: https://docs.microsoft.com/en-us/powershell/scripting/
gallery/overview
<p>&gt; Install-Module posh-git -Scope CurrentUser -Force
&gt; Install-Module posh-git -Scope CurrentUser -AllowPrerelease -Force # Newer beta
version with PowerShell Core support
<p>If you want to install posh-git for all users, use -Scope AllUsers instead and execute the command
from an elevated PowerShell console. If the second command fails with an error like Module
'PowerShellGet' was not installed by using Install-Module, you&rsquo;ll need to run another command
first:
<p>&gt; Install-Module PowerShellGet -Force -SkipPublisherCheck
<p>Then you can go back and try again. This happens, because the modules that ship with Windows
PowerShell are signed with a different publishment certificate.
<p>Update PowerShell Prompt
<p>To include git information in your prompt, the posh-git module needs to be imported. To have posh-
git imported every time PowerShell starts, execute the Add-PoshGitToProfile command which will
add the import statement into your $profile script. This script is executed everytime you open a
new PowerShell console. Keep in mind, that there are multiple $profile scripts. E. g. one for the
console and a separate one for the ISE.
<p>&gt; Import-Module posh-git
&gt; Add-PoshGitToProfile -AllHosts
<p>From Source
<p>Just download a posh-git release from https://github.com/dahlbyk/posh-git/releases, and
uncompress it. Then import the module using the full path to the posh-git.psd1 file:
<p>490</p>
<br>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/overview">https://docs.microsoft.com/en-us/powershell/scripting/gallery/overview</a>
</div>
<div class="annotation">
<a href="https://docs.microsoft.com/en-us/powershell/scripting/gallery/overview">https://docs.microsoft.com/en-us/powershell/scripting/gallery/overview</a>
</div>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git/releases">https://github.com/dahlbyk/posh-git/releases</a>
</div>
</div>
<div class="page">
<br>
<p>&gt; Import-Module &lt;path-to-uncompress-folder&gt;\src\posh-git.psd1
&gt; Add-PoshGitToProfile -AllHosts
<p>This will add the proper line to your profile.ps1 file, and posh-git will be active the next time you
open PowerShell.
<p>For a description of the Git status summary information displayed in the prompt see:
https://github.com/dahlbyk/posh-git/blob/master/README.md#git-status-summary-information For
more details on how to customize your posh-git prompt see: https://github.com/dahlbyk/posh-git/
blob/master/README.md#customization-variables
<p>Summary
You&rsquo;ve learned how to harness Git&rsquo;s power from inside the tools that you use during your everyday
work, and also how to access Git repositories from your own programs.
<p>491</p>
<br>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git/blob/master/README.md#git-status-summary-information">https://github.com/dahlbyk/posh-git/blob/master/README.md#git-status-summary-information</a>
</div>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git/blob/master/README.md#customization-variables">https://github.com/dahlbyk/posh-git/blob/master/README.md#customization-variables</a>
</div>
<div class="annotation">
<a href="https://github.com/dahlbyk/posh-git/blob/master/README.md#customization-variables">https://github.com/dahlbyk/posh-git/blob/master/README.md#customization-variables</a>
</div>
</div>
<div class="page">
<br>
<p>Appendix B: Embedding Git in your
Applications
If your application is for developers, chances are good that it could benefit from integration with
source control. Even non-developer applications, such as document editors, could potentially
benefit from version-control features, and Git&rsquo;s model works very well for many different
scenarios.
<p>If you need to integrate Git with your application, you have essentially two options: spawn a shell
and call the git command-line program, or embed a Git library into your application. Here we&rsquo;ll
cover command-line integration and several of the most popular embeddable Git libraries.
<p>Command-line Git
One option is to spawn a shell process and use the Git command-line tool to do the work. This has
the benefit of being canonical, and all of Git&rsquo;s features are supported. This also happens to be fairly
easy, as most runtime environments have a relatively simple facility for invoking a process with
command-line arguments. However, this approach does have some downsides.
<p>One is that all the output is in plain text. This means that you&rsquo;ll have to parse Git&rsquo;s occasionally-
changing output format to read progress and result information, which can be inefficient and
error-prone.
<p>Another is the lack of error recovery. If a repository is corrupted somehow, or the user has a
malformed configuration value, Git will simply refuse to perform many operations.
<p>Yet another is process management. Git requires you to maintain a shell environment on a separate
process, which can add unwanted complexity. Trying to coordinate many of these processes
(especially when potentially accessing the same repository from several processes) can be quite a
challenge.
<p>Libgit2
Another option at your disposal is to use Libgit2. Libgit2 is a dependency-free implementation of
Git, with a focus on having a nice API for use within other programs. You can find it at
https://libgit2.org.
<p>First, let&rsquo;s take a look at what the C API looks like. Here&rsquo;s a whirlwind tour:
<p>492</p>
<br>
<div class="annotation">
<a href="https://libgit2.org">https://libgit2.org</a>
</div>
</div>
<div class="page">
<br>
<p>// Open a repository
git_repository *repo;
int error = git_repository_open(&amp;repo, "/path/to/repository");
<p>// Dereference HEAD to a commit
git_object *head_commit;
error = git_revparse_single(&amp;head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;
<p>// Print some of the commit's properties
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s &lt;%s&gt;\n", author-&gt;name, author-&gt;email);
const git_oid *tree_id = git_commit_tree_id(commit);
<p>// Cleanup
git_commit_free(commit);
git_repository_free(repo);
<p>The first couple of lines open a Git repository. The git_repository type represents a handle to a
repository with a cache in memory. This is the simplest method, for when you know the exact path
to a repository&rsquo;s working directory or .git folder. There&rsquo;s also the git_repository_open_ext which
includes options for searching, git_clone and friends for making a local clone of a remote
repository, and git_repository_init for creating an entirely new repository.
<p>The second chunk of code uses rev-parse syntax (see Branch References for more on this) to get the
commit that HEAD eventually points to. The type returned is a git_object pointer, which represents
something that exists in the Git object database for a repository. git_object is actually a &ldquo;parent&rdquo;
type for several different kinds of objects; the memory layout for each of the &ldquo;child&rdquo; types is the
same as for git_object, so you can safely cast to the right one. In this case, git_object_type(commit)
would return GIT_OBJ_COMMIT, so it&rsquo;s safe to cast to a git_commit pointer.
<p>The next chunk shows how to access the commit&rsquo;s properties. The last line here uses a git_oid type;
this is Libgit2&rsquo;s representation for a SHA-1 hash.
<p>From this sample, a couple of patterns have started to emerge:
<p>&bull; If you declare a pointer and pass a reference to it into a Libgit2 call, that call will probably
return an integer error code. A 0 value indicates success; anything less is an error.
<p>&bull; If Libgit2 populates a pointer for you, you&rsquo;re responsible for freeing it.
<p>&bull; If Libgit2 returns a const pointer from a call, you don&rsquo;t have to free it, but it will become invalid
when the object it belongs to is freed.
<p>&bull; Writing C is a bit painful.
<p>That last one means it isn&rsquo;t very probable that you&rsquo;ll be writing C when using Libgit2. Fortunately,
there are a number of language-specific bindings available that make it fairly easy to work with Git
repositories from your specific language and environment. Let&rsquo;s take a look at the above example
written using the Ruby bindings for Libgit2, which are named Rugged, and can be found at
<p>493</p>
<br>
</div>
<div class="page">
<br>
<p>https://github.com/libgit2/rugged.
<p>repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} &lt;#{commit.author[:email]}&gt;"
tree = commit.tree
<p>As you can see, the code is much less cluttered. Firstly, Rugged uses exceptions; it can raise things
like ConfigError or ObjectError to signal error conditions. Secondly, there&rsquo;s no explicit freeing of
resources, since Ruby is garbage-collected. Let&rsquo;s take a look at a slightly more complicated example:
crafting a commit from scratch
<p>blob_id = repo.write("Blob contents", :blob) ①
<p>index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path =&gt; 'newfile.txt', :oid =&gt; blob_id) ②
<p>sig = {
&nbsp; :email =&gt; "bob@example.com",
&nbsp; :name =&gt; "Bob User",
&nbsp; :time =&gt; Time.now,
}
<p>commit_id = Rugged::Commit.create(repo,
&nbsp; :tree =&gt; index.write_tree(repo), ③
&nbsp; :author =&gt; sig,
&nbsp; :committer =&gt; sig, ④
&nbsp; :message =&gt; "Add newfile.txt", ⑤
&nbsp; :parents =&gt; repo.empty? ? [] : [ repo.head.target ].compact, ⑥
&nbsp; :update_ref =&gt; 'HEAD', ⑦
)
commit = repo.lookup(commit_id) ⑧
<p>① Create a new blob, which contains the contents of a new file.
<p>② Populate the index with the head commit&rsquo;s tree, and add the new file at the path newfile.txt.
<p>③ This creates a new tree in the ODB, and uses it for the new commit.
<p>④ We use the same signature for both the author and committer fields.
<p>⑤ The commit message.
<p>⑥ When creating a commit, you have to specify the new commit&rsquo;s parents. This uses the tip of
HEAD for the single parent.
<p>⑦ Rugged (and Libgit2) can optionally update a reference when making a commit.
<p>⑧ The return value is the SHA-1 hash of a new commit object, which you can then use to get a
Commit object.
<p>494</p>
<br>
<div class="annotation">
<a href="https://github.com/libgit2/rugged">https://github.com/libgit2/rugged</a>
</div>
</div>
<div class="page">
<br>
<p>The Ruby code is nice and clean, but since Libgit2 is doing the heavy lifting, this code will run pretty
fast, too. If you&rsquo;re not a rubyist, we touch on some other bindings in Other Bindings.
<p>Advanced Functionality
<p>Libgit2 has a couple of capabilities that are outside the scope of core Git. One example is
pluggability: Libgit2 allows you to provide custom &ldquo;backends&rdquo; for several types of operation, so you
can store things in a different way than stock Git does. Libgit2 allows custom backends for
configuration, ref storage, and the object database, among other things.
<p>Let&rsquo;s take a look at how this works. The code below is borrowed from the set of backend examples
provided by the Libgit2 team (which can be found at https://github.com/libgit2/libgit2-backends).
Here&rsquo;s how a custom backend for the object database is set up:
<p>git_odb *odb;
int error = git_odb_new(&amp;odb); ①
<p>git_odb_backend *my_backend;
error = git_odb_backend_mine(&amp;my_backend, /*&hellip;*/); ②
<p>error = git_odb_add_backend(odb, my_backend, 1); ③
<p>git_repository *repo;
error = git_repository_open(&amp;repo, "some-path");
error = git_repository_set_odb(repo, odb); ④
<p>(Note that errors are captured, but not handled. We hope your code is better than ours.)
<p>① Initialize an empty object database (ODB) &ldquo;frontend,&rdquo; which will act as a container for the
&ldquo;backends&rdquo; which are the ones doing the real work.
<p>② Initialize a custom ODB backend.
<p>③ Add the backend to the frontend.
<p>④ Open a repository, and set it to use our ODB to look up objects.
<p>But what is this git_odb_backend_mine thing? Well, that&rsquo;s the constructor for your own ODB
implementation, and you can do whatever you want in there, so long as you fill in the
git_odb_backend structure properly. Here&rsquo;s what it could look like:
<p>495</p>
<br>
<div class="annotation">
<a href="https://github.com/libgit2/libgit2-backends">https://github.com/libgit2/libgit2-backends</a>
</div>
</div>
<div class="page">
<br>
<p>typedef struct {
&nbsp; git_odb_backend parent;
<p>&nbsp; // Some other stuff
&nbsp; void *custom_context;
} my_backend_struct;
<p>int git_odb_backend_mine(git_odb_backend **backend_out, /*&hellip;*/)
{
&nbsp; my_backend_struct *backend;
<p>&nbsp; backend = calloc(1, sizeof (my_backend_struct));
<p>&nbsp; backend-&gt;custom_context = &hellip;;
<p>&nbsp; backend-&gt;parent.read = &amp;my_backend__read;
&nbsp; backend-&gt;parent.read_prefix = &amp;my_backend__read_prefix;
&nbsp; backend-&gt;parent.read_header = &amp;my_backend__read_header;
&nbsp; // &hellip;
<p>&nbsp; *backend_out = (git_odb_backend *) backend;
<p>&nbsp; return GIT_SUCCESS;
}
<p>The subtlest constraint here is that my_backend_struct's first member must be a git_odb_backend
structure; this ensures that the memory layout is what the Libgit2 code expects it to be. The rest of
it is arbitrary; this structure can be as large or small as you need it to be.
<p>The initialization function allocates some memory for the structure, sets up the custom context, and
then fills in the members of the parent structure that it supports. Take a look at the
include/git2/sys/odb_backend.h file in the Libgit2 source for a complete set of call signatures; your
particular use case will help determine which of these you&rsquo;ll want to support.
<p>Other Bindings
<p>Libgit2 has bindings for many languages. Here we show a small example using a few of the more
complete bindings packages as of this writing; libraries exist for many other languages, including
C++, Go, Node.js, Erlang, and the JVM, all in various stages of maturity. The official collection of
bindings can be found by browsing the repositories at https://github.com/libgit2. The code we&rsquo;ll
write will return the commit message from the commit eventually pointed to by HEAD (sort of like
git log -1).
<p>LibGit2Sharp
<p>If you&rsquo;re writing a .NET or Mono application, LibGit2Sharp (https://github.com/libgit2/libgit2sharp)
is what you&rsquo;re looking for. The bindings are written in C#, and great care has been taken to wrap
the raw Libgit2 calls with native-feeling CLR APIs. Here&rsquo;s what our example program looks like:
<p>496</p>
<br>
<div class="annotation">
<a href="https://github.com/libgit2">https://github.com/libgit2</a>
</div>
<div class="annotation">
<a href="https://github.com/libgit2/libgit2sharp">https://github.com/libgit2/libgit2sharp</a>
</div>
</div>
<div class="page">
<br>
<p>new Repository(@"C:\path\to\repo").Head.Tip.Message;
<p>For desktop Windows applications, there&rsquo;s even a NuGet package that will help you get started
quickly.
<p>objective-git
<p>If your application is running on an Apple platform, you&rsquo;re likely using Objective-C as your
implementation language. Objective-Git (https://github.com/libgit2/objective-git) is the name of the
Libgit2 bindings for that environment. The example program looks like this:
<p>GTRepository *repo =
&nbsp; [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"]
error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];
<p>Objective-git is fully interoperable with Swift, so don&rsquo;t fear if you&rsquo;ve left Objective-C behind.
<p>pygit2
<p>The bindings for Libgit2 in Python are called Pygit2, and can be found at https://www.pygit2.org.
Our example program:
<p>pygit2.Repository("/path/to/repo") # open repository
&nbsp; .head # get the current branch
&nbsp; .peel(pygit2.Commit) # walk down to the commit
&nbsp; .message # read the message
<p>Further Reading
<p>Of course, a full treatment of Libgit2&rsquo;s capabilities is outside the scope of this book. If you want
more information on Libgit2 itself, there&rsquo;s API documentation at https://libgit2.github.com/libgit2,
and a set of guides at https://libgit2.github.com/docs. For the other bindings, check the bundled
README and tests; there are often small tutorials and pointers to further reading there.
<p>JGit
If you want to use Git from within a Java program, there is a fully featured Git library called JGit.
JGit is a relatively full-featured implementation of Git written natively in Java, and is widely used in
the Java community. The JGit project is under the Eclipse umbrella, and its home can be found at
https://www.eclipse.org/jgit/.
<p>Getting Set Up
<p>There are a number of ways to connect your project with JGit and start writing code against it.
Probably the easiest is to use Maven &ndash; the integration is accomplished by adding the following
<p>497</p>
<br>
<div class="annotation">
<a href="https://github.com/libgit2/objective-git">https://github.com/libgit2/objective-git</a>
</div>
<div class="annotation">
<a href="https://www.pygit2.org">https://www.pygit2.org</a>
</div>
<div class="annotation">
<a href="https://libgit2.github.com/libgit2">https://libgit2.github.com/libgit2</a>
</div>
<div class="annotation">
<a href="https://libgit2.github.com/docs">https://libgit2.github.com/docs</a>
</div>
<div class="annotation">
<a href="https://www.eclipse.org/jgit/">https://www.eclipse.org/jgit/</a>
</div>
</div>
<div class="page">
<br>
<p>snippet to the &lt;dependencies&gt; tag in your pom.xml file:
<p>&lt;dependency&gt;
&nbsp; &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
&nbsp; &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
&nbsp; &lt;version&gt;3.5.0.201409260305-r&lt;/version&gt;
&lt;/dependency&gt;
<p>The version will most likely have advanced by the time you read this; check
https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit for updated repository
information. Once this step is done, Maven will automatically acquire and use the JGit libraries that
you&rsquo;ll need.
<p>If you would rather manage the binary dependencies yourself, pre-built JGit binaries are available
from https://www.eclipse.org/jgit/download. You can build them into your project by running a
command like this:
<p>javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
<p>Plumbing
<p>JGit has two basic levels of API: plumbing and porcelain. The terminology for these comes from Git
itself, and JGit is divided into roughly the same kinds of areas: porcelain APIs are a friendly front-
end for common user-level actions (the sorts of things a normal user would use the Git command-
line tool for), while the plumbing APIs are for interacting with low-level repository objects directly.
<p>The starting point for most JGit sessions is the Repository class, and the first thing you&rsquo;ll want to do
is create an instance of it. For a filesystem-based repository (yes, JGit allows for other storage
models), this is accomplished using FileRepositoryBuilder:
<p>// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
&nbsp; new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();
<p>// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
&nbsp; .setGitDir(new File("my_repo/.git"))
&nbsp; .build();
<p>The builder has a fluent API for providing all the things it needs to find a Git repository, whether or
not your program knows exactly where it&rsquo;s located. It can use environment variables
(.readEnvironment()), start from a place in the working directory and search
(.setWorkTree(&hellip;).findGitDir()), or just open a known .git directory as above.
<p>Once you have a Repository instance, you can do all sorts of things with it. Here&rsquo;s a quick sampling:
<p>498</p>
<br>
<div class="annotation">
<a href="https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit">https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit</a>
</div>
<div class="annotation">
<a href="https://www.eclipse.org/jgit/download">https://www.eclipse.org/jgit/download</a>
</div>
</div>
<div class="page">
<br>
<p>// Get a reference
Ref master = repo.getRef("master");
<p>// Get the object the reference points to
ObjectId masterTip = master.getObjectId();
<p>// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");
<p>// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);
<p>// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();
<p>// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();
<p>// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
<p>There&rsquo;s quite a bit going on here, so let&rsquo;s go through it one section at a time.
<p>The first line gets a pointer to the master reference. JGit automatically grabs the actual master ref,
which lives at refs/heads/master, and returns an object that lets you fetch information about the
reference. You can get the name (.getName()), and either the target object of a direct reference
(.getObjectId()) or the reference pointed to by a symbolic ref (.getTarget()). Ref objects are also
used to represent tag refs and objects, so you can ask if the tag is &ldquo;peeled,&rdquo; meaning that it points to
the final target of a (potentially long) string of tag objects.
<p>The second line gets the target of the master reference, which is returned as an ObjectId instance.
ObjectId represents the SHA-1 hash of an object, which might or might not exist in Git&rsquo;s object
database. The third line is similar, but shows how JGit handles the rev-parse syntax (for more on
this, see Branch References); you can pass any object specifier that Git understands, and JGit will
return either a valid ObjectId for that object, or null.
<p>The next two lines show how to load the raw contents of an object. In this example, we call
ObjectLoader.copyTo() to stream the contents of the object directly to stdout, but ObjectLoader also
has methods to read the type and size of an object, as well as return it as a byte array. For large
objects (where .isLarge() returns true), you can call .openStream() to get an InputStream-like object
that can read the raw object data without pulling it all into memory at once.
<p>The next few lines show what it takes to create a new branch. We create a RefUpdate instance,
<p>499</p>
<br>
</div>
<div class="page">
<br>
<p>configure some parameters, and call .update() to trigger the change. Directly following this is the
code to delete that same branch. Note that .setForceUpdate(true) is required for this to work;
otherwise the .delete() call will return REJECTED, and nothing will happen.
<p>The last example shows how to fetch the user.name value from the Git configuration files. This
Config instance uses the repository we opened earlier for local configuration, but will automatically
detect the global and system configuration files and read values from them as well.
<p>This is only a small sampling of the full plumbing API; there are many more methods and classes
available. Also not shown here is the way JGit handles errors, which is through the use of
exceptions. JGit APIs sometimes throw standard Java exceptions (such as IOException), but there are
a host of JGit-specific exception types that are provided as well (such as
NoRemoteRepositoryException, CorruptObjectException, and NoMergeBaseException).
<p>Porcelain
<p>The plumbing APIs are rather complete, but it can be cumbersome to string them together to
achieve common goals, like adding a file to the index, or making a new commit. JGit provides a
higher-level set of APIs to help out with this, and the entry point to these APIs is the Git class:
<p>Repository repo;
// construct repo...
Git git = new Git(repo);
<p>The Git class has a nice set of high-level builder-style methods that can be used to construct some
pretty complex behavior. Let&rsquo;s take a look at an example&thinsp;&mdash;&thinsp;doing something like git ls-remote:
<p>CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username",
"p4ssw0rd");
Collection&lt;Ref&gt; remoteRefs = git.lsRemote()
&nbsp; .setCredentialsProvider(cp)
&nbsp; .setRemote("origin")
&nbsp; .setTags(true)
&nbsp; .setHeads(false)
&nbsp; .call();
for (Ref ref : remoteRefs) {
&nbsp; System.out.println(ref.getName() + " -&gt; " + ref.getObjectId().name());
}
<p>This is a common pattern with the Git class; the methods return a command object that lets you
chain method calls to set parameters, which are executed when you call .call(). In this case, we&rsquo;re
asking the origin remote for tags, but not heads. Also notice the use of a CredentialsProvider object
for authentication.
<p>Many other commands are available through the Git class, including but not limited to add, blame,
commit, clean, push, rebase, revert, and reset.
<p>500</p>
<br>
</div>
<div class="page">
<br>
<p>Further Reading
<p>This is only a small sampling of JGit&rsquo;s full capabilities. If you&rsquo;re interested and want to learn more,
here&rsquo;s where to look for information and inspiration:
<p>&bull; The official JGit API documentation can be found at https://www.eclipse.org/jgit/documentation.
These are standard Javadoc, so your favorite JVM IDE will be able to install them locally, as well.
<p>&bull; The JGit Cookbook at https://github.com/centic9/jgit-cookbook has many examples of how to do
specific tasks with JGit.
<p>go-git
In case you want to integrate Git into a service written in Golang, there also is a pure Go library
implementation. This implementation does not have any native dependencies and thus is not prone
to manual memory management errors. It is also transparent for the standard Golang performance
analysis tooling like CPU, Memory profilers, race detector, etc.
<p>go-git is focused on extensibility, compatibility and supports most of the plumbing APIs, which is
documented at https://github.com/go-git/go-git/blob/master/COMPATIBILITY.md.
<p>Here is a basic example of using Go APIs:
<p>import "github.com/go-git/go-git/v5"
<p>r, err := git.PlainClone("/tmp/foo", false, &amp;git.CloneOptions{
&nbsp; URL: "https://github.com/go-git/go-git",
&nbsp; Progress: os.Stdout,
})
<p>As soon as you have a Repository instance, you can access information and perform mutations on
it:
<p>// retrieves the branch pointed by HEAD
ref, err := r.Head()
<p>// get the commit object, pointed by ref
commit, err := r.CommitObject(ref.Hash())
<p>// retrieves the commit history
history, err := commit.History()
<p>// iterates over the commits and print each
for _, c := range history {
&nbsp; fmt.Println(c)
}
<p>501</p>
<br>
<div class="annotation">
<a href="https://www.eclipse.org/jgit/documentation">https://www.eclipse.org/jgit/documentation</a>
</div>
<div class="annotation">
<a href="https://github.com/centic9/jgit-cookbook">https://github.com/centic9/jgit-cookbook</a>
</div>
<div class="annotation">
<a href="https://github.com/go-git/go-git/blob/master/COMPATIBILITY.md">https://github.com/go-git/go-git/blob/master/COMPATIBILITY.md</a>
</div>
</div>
<div class="page">
<br>
<p>Advanced Functionality
<p>go-git has few notable advanced features, one of which is a pluggable storage system, which is
similar to Libgit2 backends. The default implementation is in-memory storage, which is very fast.
<p>r, err := git.Clone(memory.NewStorage(), nil, &amp;git.CloneOptions{
&nbsp; URL: "https://github.com/go-git/go-git",
})
<p>Pluggable storage provides many interesting options. For instance, https://github.com/go-git/go-git/
tree/master/_examples/storage allows you to store references, objects, and configuration in an
Aerospike database.
<p>Another feature is a flexible filesystem abstraction. Using https://pkg.go.dev/github.com/go-git/go-
billy/v5?tab=doc#Filesystem it is easy to store all the files in different way i.e by packing all of them
to a single archive on disk or by keeping them all in-memory.
<p>Another advanced use-case includes a fine-tunable HTTP client, such as the one found at
https://github.com/go-git/go-git/blob/master/_examples/custom_http/main.go.
<p>customClient := &amp;http.Client{
&nbsp; Transport: &amp;http.Transport{ // accept any certificate (might be useful for
testing)
&nbsp; TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
&nbsp; },
&nbsp; Timeout: 15 * time.Second, // 15 second timeout
&nbsp; CheckRedirect: func(req *http.Request, via []*http.Request) error {
&nbsp; return http.ErrUseLastResponse // don't follow redirect
&nbsp; },
}
<p>// Override http(s) default protocol to use our custom client
client.InstallProtocol("https", githttp.NewClient(customClient))
<p>// Clone repository using the new client if the protocol is https://
r, err := git.Clone(memory.NewStorage(), nil, &amp;git.CloneOptions{URL: url})
<p>Further Reading
<p>A full treatment of go-git&rsquo;s capabilities is outside the scope of this book. If you want more
information on go-git, there&rsquo;s API documentation at https://pkg.go.dev/github.com/go-git/go-git/v5,
and a set of usage examples at https://github.com/go-git/go-git/tree/master/_examples.
<p>Dulwich
There is also a pure-Python Git implementation - Dulwich. The project is hosted under
https://www.dulwich.io/ It aims to provide an interface to git repositories (both local and remote)
<p>502</p>
<br>
<div class="annotation">
<a href="https://github.com/go-git/go-git/tree/master/_examples/storage">https://github.com/go-git/go-git/tree/master/_examples/storage</a>
</div>
<div class="annotation">
<a href="https://github.com/go-git/go-git/tree/master/_examples/storage">https://github.com/go-git/go-git/tree/master/_examples/storage</a>
</div>
<div class="annotation">
<a href="https://pkg.go.dev/github.com/go-git/go-billy/v5?tab=doc#Filesystem">https://pkg.go.dev/github.com/go-git/go-billy/v5?tab=doc#Filesystem</a>
</div>
<div class="annotation">
<a href="https://pkg.go.dev/github.com/go-git/go-billy/v5?tab=doc#Filesystem">https://pkg.go.dev/github.com/go-git/go-billy/v5?tab=doc#Filesystem</a>
</div>
<div class="annotation">
<a href="https://github.com/go-git/go-git/blob/master/_examples/custom_http/main.go">https://github.com/go-git/go-git/blob/master/_examples/custom_http/main.go</a>
</div>
<div class="annotation">
<a href="https://pkg.go.dev/github.com/go-git/go-git/v5">https://pkg.go.dev/github.com/go-git/go-git/v5</a>
</div>
<div class="annotation">
<a href="https://github.com/go-git/go-git/tree/master/_examples">https://github.com/go-git/go-git/tree/master/_examples</a>
</div>
<div class="annotation">
<a href="https://www.dulwich.io/">https://www.dulwich.io/</a>
</div>
</div>
<div class="page">
<br>
<p>that doesn&rsquo;t call out to git directly but instead uses pure Python. It has an optional C extensions
though, that significantly improve the performance.
<p>Dulwich follows git design and separate two basic levels of API: plumbing and porcelain.
<p>Here is an example of using the lower level API to access the commit message of the last commit:
<p>from dulwich.repo import Repo
r = Repo('.')
r.head()
# '57fbe010446356833a6ad1600059d80b1e731e15'
<p>c = r[r.head()]
c
# &lt;Commit 015fc1267258458901a94d228e39f0a378370466&gt;
<p>c.message
# 'Add note about encoding.\n'
<p>To print a commit log using high-level porcelain API, one can use:
<p>from dulwich import porcelain
porcelain.log('.', max_entries=1)
<p>#commit: 57fbe010446356833a6ad1600059d80b1e731e15
#Author: Jelmer Vernooĳ &lt;jelmer@jelmer.uk&gt;
#Date: Sat Apr 29 2017 23:57:34 +0000
<p>Further Reading
<p>&bull; The official API documentation is available at https://www.dulwich.io/apidocs/dulwich.html
<p>&bull; Official tutorial at https://www.dulwich.io/docs/tutorial has many examples of how to do specific
tasks with Dulwich
<p>503</p>
<br>
<div class="annotation">
<a href="https://www.dulwich.io/apidocs/dulwich.html">https://www.dulwich.io/apidocs/dulwich.html</a>
</div>
<div class="annotation">
<a href="https://www.dulwich.io/docs/tutorial">https://www.dulwich.io/docs/tutorial</a>
</div>
</div>
<div class="page">
<br>
<p>Appendix C: Git Commands
Throughout the book we have introduced dozens of Git commands and have tried hard to
introduce them within something of a narrative, adding more commands to the story slowly.
However, this leaves us with examples of usage of the commands somewhat scattered throughout
the whole book.
<p>In this appendix, we&rsquo;ll go through all the Git commands we addressed throughout the book,
grouped roughly by what they&rsquo;re used for. We&rsquo;ll talk about what each command very generally
does and then point out where in the book you can find us having used it.
<p>
You can abbreviate long options. For example, you can type in git commit --a,
which acts as if you typed git commit --amend. This only works when the letters
after -- are unique for one option. Do use the full option when writing scripts.
<p>Setup and Config
There are two commands that are used quite a lot, from the first invocations of Git to common
every day tweaking and referencing, the config and help commands.
<p>git config
<p>Git has a default way of doing hundreds of things. For a lot of these things, you can tell Git to default
to doing them a different way, or set your preferences. This involves everything from telling Git
what your name is to specific terminal color preferences or what editor you use. There are several
files this command will read from and write to so you can set values globally or down to specific
repositories.
<p>The git config command has been used in nearly every chapter of the book.
<p>In First-Time Git Setup we used it to specify our name, email address and editor preference before
we even got started using Git.
<p>In Git Aliases we showed how you could use it to create shorthand commands that expand to long
option sequences so you don&rsquo;t have to type them every time.
<p>In Rebasing we used it to make --rebase the default when you run git pull.
<p>In Credential Storage we used it to set up a default store for your HTTP passwords.
<p>In Keyword Expansion we showed how to set up smudge and clean filters on content coming in and
out of Git.
<p>Finally, basically the entirety of Git Configuration is dedicated to the command.
<p>git config core.editor commands
<p>Accompanying the configuration instructions in Your Editor, many editors can be set as follows:
<p>504</p>
<br>
</div>
<div class="page">
<br>
<p>Table 4. Exhaustive list of core.editor configuration commands
<p>Editor Configuration command
<p>Atom git config --global core.editor "atom --wait"
<p>BBEdit (Mac, with command
line tools)
<p>git config --global core.editor "bbedit -w"
<p>Emacs git config --global core.editor emacs
<p>Gedit (Linux) git config --global core.editor "gedit --wait --new-window"
<p>Gvim (Windows 64-bit) git config --global core.editor "'C:\Program
Files\Vim\vim72\gvim.exe' --nofork '%*'" (Also see note below)
<p>Kate (Linux) git config --global core.editor "kate"
<p>nano git config --global core.editor "nano -w"
<p>Notepad (Windows 64-bit) git config core.editor notepad
<p>Notepad++ (Windows 64-bit) git config --global core.editor "'C:\Program
Files\Notepad++\notepad++.exe' -multiInst -notabbar -nosession
-noPlugin" (Also see note below)
<p>Scratch (Linux) git config --global core.editor "scratch-text-editor"
<p>Sublime Text (macOS) git config --global core.editor "/Applications/Sublime\
Text.app/Contents/SharedSupport/bin/subl --new-window --wait"
<p>Sublime Text (Windows 64-bit) git config --global core.editor "'C:\Program Files\Sublime
Text 3\sublime_text.exe' -w" (Also see note below)
<p>TextEdit (macOS) git config --global --add core.editor "open -W -n"
<p>Textmate git config --global core.editor "mate -w"
<p>Textpad (Windows 64-bit) git config --global core.editor "'C:\Program Files\TextPad
5\TextPad.exe' -m (Also see note below)
<p>UltraEdit (Windows 64-bit) git config --global core.editor Uedit32
<p>Vim git config --global core.editor "vim"
<p>Visual Studio Code git config --global core.editor "code --wait"
<p>VSCodium (Free/Libre Open
Source Software Binaries of
VSCode)
<p>git config --global core.editor "codium --wait"
<p>WordPad git config --global core.editor '"C:\Program Files\Windows
NT\Accessories\wordpad.exe"'"
<p>Xi git config --global core.editor "xi --wait"
<p>
If you have a 32-bit editor on a Windows 64-bit system, the program will be
installed in C:\Program Files (x86)\ rather than C:\Program Files\ as in the table
above.
<p>505</p>
<br>
</div>
<div class="page">
<br>
<p>git help
<p>The git help command is used to show you all the documentation shipped with Git about any
command. While we&rsquo;re giving a rough overview of most of the more popular ones in this appendix,
for a full listing of all of the possible options and flags for every command, you can always run git
help &lt;command&gt;.
<p>We introduced the git help command in Getting Help and showed you how to use it to find more
information about the git shell in Setting Up the Server.
<p>Getting and Creating Projects
There are two ways to get a Git repository. One is to copy it from an existing repository on the
network or elsewhere and the other is to create a new one in an existing directory.
<p>git init
<p>To take a directory and turn it into a new Git repository so you can start version controlling it, you
can simply run git init.
<p>We first introduce this in Getting a Git Repository, where we show creating a brand new repository
to start working with.
<p>We talk briefly about how you can change the default branch name from &ldquo;master&rdquo; in Remote
Branches.
<p>We use this command to create an empty bare repository for a server in Putting the Bare
Repository on a Server.
<p>Finally, we go through some of the details of what it actually does behind the scenes in Plumbing
and Porcelain.
<p>git clone
<p>The git clone command is actually something of a wrapper around several other commands. It
creates a new directory, goes into it and runs git init to make it an empty Git repository, adds a
remote (git remote add) to the URL that you pass it (by default named origin), runs a git fetch
from that remote repository and then checks out the latest commit into your working directory
with git checkout.
<p>The git clone command is used in dozens of places throughout the book, but we&rsquo;ll just list a few
interesting places.
<p>It&rsquo;s basically introduced and explained in Cloning an Existing Repository, where we go through a
few examples.
<p>In Getting Git on a Server we look at using the --bare option to create a copy of a Git repository with
no working directory.
<p>In Bundling we use it to unbundle a bundled Git repository.
<p>506</p>
<br>
</div>
<div class="page">
<br>
<p>Finally, in Cloning a Project with Submodules we learn the --recurse-submodules option to make
cloning a repository with submodules a little simpler.
<p>Though it&rsquo;s used in many other places through the book, these are the ones that are somewhat
unique or where it is used in ways that are a little different.
<p>Basic Snapshotting
For the basic workflow of staging content and committing it to your history, there are only a few
basic commands.
<p>git add
<p>The git add command adds content from the working directory into the staging area (or &ldquo;index&rdquo;)
for the next commit. When the git commit command is run, by default it only looks at this staging
area, so git add is used to craft what exactly you would like your next commit snapshot to look like.
<p>This command is an incredibly important command in Git and is mentioned or used dozens of
times in this book. We&rsquo;ll quickly cover some of the unique uses that can be found.
<p>We first introduce and explain git add in detail in Tracking New Files.
<p>We mention how to use it to resolve merge conflicts in Basic Merge Conflicts.
<p>We go over using it to interactively stage only specific parts of a modified file in Interactive Staging.
<p>Finally, we emulate it at a low level in Tree Objects, so you can get an idea of what it&rsquo;s doing behind
the scenes.
<p>git status
<p>The git status command will show you the different states of files in your working directory and
staging area. Which files are modified and unstaged and which are staged but not yet committed. In
its normal form, it also will show you some basic hints on how to move files between these stages.
<p>We first cover status in Checking the Status of Your Files, both in its basic and simplified forms.
While we use it throughout the book, pretty much everything you can do with the git status
command is covered there.
<p>git diff
<p>The git diff command is used when you want to see differences between any two trees. This could
be the difference between your working environment and your staging area (git diff by itself),
between your staging area and your last commit (git diff --staged), or between two commits (git
diff master branchB).
<p>We first look at the basic uses of git diff in Viewing Your Staged and Unstaged Changes, where we
show how to see what changes are staged and which are not yet staged.
<p>We use it to look for possible whitespace issues before committing with the --check option in
<p>507</p>
<br>
</div>
<div class="page">
<br>
<p>Commit Guidelines.
<p>We see how to check the differences between branches more effectively with the git diff A...B
syntax in Determining What Is Introduced.
<p>We use it to filter out whitespace differences with -b and how to compare different stages of
conflicted files with --theirs, --ours and --base in Advanced Merging.
<p>Finally, we use it to effectively compare submodule changes with --submodule in Starting with
Submodules.
<p>git difftool
<p>The git difftool command simply launches an external tool to show you the difference between
two trees in case you want to use something other than the built in git diff command.
<p>We only briefly mention this in Viewing Your Staged and Unstaged Changes.
<p>git commit
<p>The git commit command takes all the file contents that have been staged with git add and records
a new permanent snapshot in the database and then moves the branch pointer on the current
branch up to it.
<p>We first cover the basics of committing in Committing Your Changes. There we also demonstrate
how to use the -a flag to skip the git add step in daily workflows and how to use the -m flag to pass a
commit message in on the command line instead of firing up an editor.
<p>In Undoing Things we cover using the --amend option to redo the most recent commit.
<p>In Branches in a Nutshell, we go into much more detail about what git commit does and why it does
it like that.
<p>We looked at how to sign commits cryptographically with the -S flag in Signing Commits.
<p>Finally, we take a look at what the git commit command does in the background and how it&rsquo;s
actually implemented in Commit Objects.
<p>git reset
<p>The git reset command is primarily used to undo things, as you can possibly tell by the verb. It
moves around the HEAD pointer and optionally changes the index or staging area and can also
optionally change the working directory if you use --hard. This final option makes it possible for
this command to lose your work if used incorrectly, so make sure you understand it before using it.
<p>We first effectively cover the simplest use of git reset in Unstaging a Staged File, where we use it to
unstage a file we had run git add on.
<p>We then cover it in quite some detail in Reset Demystified, which is entirely devoted to explaining
this command.
<p>508</p>
<br>
</div>
<div class="page">
<br>
<p>We use git reset --hard to abort a merge in Aborting a Merge, where we also use git merge
--abort, which is a bit of a wrapper for the git reset command.
<p>git rm
<p>The git rm command is used to remove files from the staging area and working directory for Git. It
is similar to git add in that it stages a removal of a file for the next commit.
<p>We cover the git rm command in some detail in Removing Files, including recursively removing
files and only removing files from the staging area but leaving them in the working directory with
--cached.
<p>The only other differing use of git rm in the book is in Removing Objects where we briefly use and
explain the --ignore-unmatch when running git filter-branch, which simply makes it not error out
when the file we are trying to remove doesn&rsquo;t exist. This can be useful for scripting purposes.
<p>git mv
<p>The git mv command is a thin convenience command to move a file and then run git add on the
new file and git rm on the old file.
<p>We only briefly mention this command in Moving Files.
<p>git clean
<p>The git clean command is used to remove unwanted files from your working directory. This could
include removing temporary build artifacts or merge conflict files.
<p>We cover many of the options and scenarios in which you might used the clean command in
Cleaning your Working Directory.
<p>Branching and Merging
There are just a handful of commands that implement most of the branching and merging
functionality in Git.
<p>git branch
<p>The git branch command is actually something of a branch management tool. It can list the
branches you have, create a new branch, delete branches and rename branches.
<p>Most of Git Branching is dedicated to the branch command and it&rsquo;s used throughout the entire
chapter. We first introduce it in Creating a New Branch and we go through most of its other
features (listing and deleting) in Branch Management.
<p>In Tracking Branches we use the git branch -u option to set up a tracking branch.
<p>Finally, we go through some of what it does in the background in Git References.
<p>509</p>
<br>
</div>
<div class="page">
<br>
<p>git checkout
<p>The git checkout command is used to switch branches and check content out into your working
directory.
<p>We first encounter the command in Switching Branches along with the git branch command.
<p>We see how to use it to start tracking branches with the --track flag in Tracking Branches.
<p>We use it to reintroduce file conflicts with --conflict=diff3 in Checking Out Conflicts.
<p>We go into closer detail on its relationship with git reset in Reset Demystified.
<p>Finally, we go into some implementation detail in The HEAD.
<p>git merge
<p>The git merge tool is used to merge one or more branches into the branch you have checked out. It
will then advance the current branch to the result of the merge.
<p>The git merge command was first introduced in Basic Branching. Though it is used in various places
in the book, there are very few variations of the merge command&thinsp;&mdash;&thinsp;generally just git merge
&lt;branch&gt; with the name of the single branch you want to merge in.
<p>We covered how to do a squashed merge (where Git merges the work but pretends like it&rsquo;s just a
new commit without recording the history of the branch you&rsquo;re merging in) at the very end of
Forked Public Project.
<p>We went over a lot about the merge process and command, including the -Xignore-space-change
command and the --abort flag to abort a problem merge in Advanced Merging.
<p>We learned how to verify signatures before merging if your project is using GPG signing in Signing
Commits.
<p>Finally, we learned about Subtree merging in Subtree Merging.
<p>git mergetool
<p>The git mergetool command simply launches an external merge helper in case you have issues
with a merge in Git.
<p>We mention it quickly in Basic Merge Conflicts and go into detail on how to implement your own
external merge tool in External Merge and Diff Tools.
<p>git log
<p>The git log command is used to show the reachable recorded history of a project from the most
recent commit snapshot backwards. By default it will only show the history of the branch you&rsquo;re
currently on, but can be given different or even multiple heads or branches from which to traverse.
It is also often used to show differences between two or more branches at the commit level.
<p>510</p>
<br>
</div>
<div class="page">
<br>
<p>This command is used in nearly every chapter of the book to demonstrate the history of a project.
<p>We introduce the command and cover it in some depth in Viewing the Commit History. There we
look at the -p and --stat option to get an idea of what was introduced in each commit and the
--pretty and --oneline options to view the history more concisely, along with some simple date and
author filtering options.
<p>In Creating a New Branch we use it with the --decorate option to easily visualize where our branch
pointers are located and we also use the --graph option to see what divergent histories look like.
<p>In Private Small Team and Commit Ranges we cover the branchA..branchB syntax to use the git log
command to see what commits are unique to a branch relative to another branch. In Commit
Ranges we go through this fairly extensively.
<p>In Merge Log and Triple Dot we cover using the branchA...branchB format and the --left-right
syntax to see what is in one branch or the other but not in both. In Merge Log we also look at how
to use the --merge option to help with merge conflict debugging as well as using the --cc option to
look at merge commit conflicts in your history.
<p>In RefLog Shortnames we use the -g option to view the Git reflog through this tool instead of doing
branch traversal.
<p>In Searching we look at using the -S and -L options to do fairly sophisticated searches for something
that happened historically in the code such as seeing the history of a function.
<p>In Signing Commits we see how to use --show-signature to add a validation string to each commit in
the git log output based on if it was validly signed or not.
<p>git stash
<p>The git stash command is used to temporarily store uncommitted work in order to clean out your
working directory without having to commit unfinished work on a branch.
<p>This is basically entirely covered in Stashing and Cleaning.
<p>git tag
<p>The git tag command is used to give a permanent bookmark to a specific point in the code history.
Generally this is used for things like releases.
<p>This command is introduced and covered in detail in Tagging and we use it in practice in Tagging
Your Releases.
<p>We also cover how to create a GPG signed tag with the -s flag and verify one with the -v flag in
Signing Your Work.
<p>Sharing and Updating Projects
There are not very many commands in Git that access the network, nearly all of the commands
operate on the local database. When you are ready to share your work or pull changes from
<p>511</p>
<br>
</div>
<div class="page">
<br>
<p>elsewhere, there are a handful of commands that deal with remote repositories.
<p>git fetch
<p>The git fetch command communicates with a remote repository and fetches down all the
information that is in that repository that is not in your current one and stores it in your local
database.
<p>We first look at this command in Fetching and Pulling from Your Remotes and we continue to see
examples of its use in Remote Branches.
<p>We also use it in several of the examples in Contributing to a Project.
<p>We use it to fetch a single specific reference that is outside of the default space in Pull Request Refs
and we see how to fetch from a bundle in Bundling.
<p>We set up highly custom refspecs in order to make git fetch do something a little different than the
default in The Refspec.
<p>git pull
<p>The git pull command is basically a combination of the git fetch and git merge commands, where
Git will fetch from the remote you specify and then immediately try to merge it into the branch
you&rsquo;re on.
<p>We introduce it quickly in Fetching and Pulling from Your Remotes and show how to see what it
will merge if you run it in Inspecting a Remote.
<p>We also see how to use it to help with rebasing difficulties in Rebase When You Rebase.
<p>We show how to use it with a URL to pull in changes in a one-off fashion in Checking Out Remote
Branches.
<p>Finally, we very quickly mention that you can use the --verify-signatures option to it in order to
verify that commits you are pulling have been GPG signed in Signing Commits.
<p>git push
<p>The git push command is used to communicate with another repository, calculate what your local
database has that the remote one does not, and then pushes the difference into the other repository.
It requires write access to the other repository and so normally is authenticated somehow.
<p>We first look at the git push command in Pushing to Your Remotes. Here we cover the basics of
pushing a branch to a remote repository. In Pushing we go a little deeper into pushing specific
branches and in Tracking Branches we see how to set up tracking branches to automatically push
to. In Deleting Remote Branches we use the --delete flag to delete a branch on the server with git
push.
<p>Throughout Contributing to a Project we see several examples of using git push to share work on
branches through multiple remotes.
<p>512</p>
<br>
</div>
<div class="page">
<br>
<p>We see how to use it to share tags that you have made with the --tags option in Sharing Tags.
<p>In Publishing Submodule Changes we use the --recurse-submodules option to check that all of our
submodules work has been published before pushing the superproject, which can be really helpful
when using submodules.
<p>In Other Client Hooks we talk briefly about the pre-push hook, which is a script we can setup to run
before a push completes to verify that it should be allowed to push.
<p>Finally, in Pushing Refspecs we look at pushing with a full refspec instead of the general shortcuts
that are normally used. This can help you be very specific about what work you wish to share.
<p>git remote
<p>The git remote command is a management tool for your record of remote repositories. It allows
you to save long URLs as short handles, such as &ldquo;origin&rdquo; so you don&rsquo;t have to type them out all the
time. You can have several of these and the git remote command is used to add, change and delete
them.
<p>This command is covered in detail in Working with Remotes, including listing, adding, removing
and renaming them.
<p>It is used in nearly every subsequent chapter in the book too, but always in the standard git remote
add &lt;name&gt; &lt;url&gt; format.
<p>git archive
<p>The git archive command is used to create an archive file of a specific snapshot of the project.
<p>We use git archive to create a tarball of a project for sharing in Preparing a Release.
<p>git submodule
<p>The git submodule command is used to manage external repositories within a normal repositories.
This could be for libraries or other types of shared resources. The submodule command has several
sub-commands (add, update, sync, etc) for managing these resources.
<p>This command is only mentioned and entirely covered in Submodules.
<p>Inspection and Comparison
<p>git show
<p>The git show command can show a Git object in a simple and human readable way. Normally you
would use this to show the information about a tag or a commit.
<p>We first use it to show annotated tag information in Annotated Tags.
<p>Later we use it quite a bit in Revision Selection to show the commits that our various revision
selections resolve to.
<p>513</p>
<br>
</div>
<div class="page">
<br>
<p>One of the more interesting things we do with git show is in Manual File Re-merging to extract
specific file contents of various stages during a merge conflict.
<p>git shortlog
<p>The git shortlog command is used to summarize the output of git log. It will take many of the
same options that the git log command will but instead of listing out all of the commits it will
present a summary of the commits grouped by author.
<p>We showed how to use it to create a nice changelog in The Shortlog.
<p>git describe
<p>The git describe command is used to take anything that resolves to a commit and produces a string
that is somewhat human-readable and will not change. It&rsquo;s a way to get a description of a commit
that is as unambiguous as a commit SHA-1 but more understandable.
<p>We use git describe in Generating a Build Number and Preparing a Release to get a string to name
our release file after.
<p>Debugging
Git has a couple of commands that are used to help debug an issue in your code. This ranges from
figuring out where something was introduced to figuring out who introduced it.
<p>git bisect
<p>The git bisect tool is an incredibly helpful debugging tool used to find which specific commit was
the first one to introduce a bug or problem by doing an automatic binary search.
<p>It is fully covered in Binary Search and is only mentioned in that section.
<p>git blame
<p>The git blame command annotates the lines of any file with which commit was the last one to
introduce a change to each line of the file and what person authored that commit. This is helpful in
order to find the person to ask for more information about a specific section of your code.
<p>It is covered in File Annotation and is only mentioned in that section.
<p>git grep
<p>The git grep command can help you find any string or regular expression in any of the files in your
source code, even older versions of your project.
<p>It is covered in Git Grep and is only mentioned in that section.
<p>514</p>
<br>
</div>
<div class="page">
<br>
<p>Patching
A few commands in Git are centered around the concept of thinking of commits in terms of the
changes they introduce, as though the commit series is a series of patches. These commands help
you manage your branches in this manner.
<p>git cherry-pick
<p>The git cherry-pick command is used to take the change introduced in a single Git commit and try
to re-introduce it as a new commit on the branch you&rsquo;re currently on. This can be useful to only
take one or two commits from a branch individually rather than merging in the branch which takes
all the changes.
<p>Cherry picking is described and demonstrated in Rebasing and Cherry-Picking Workflows.
<p>git rebase
<p>The git rebase command is basically an automated cherry-pick. It determines a series of commits
and then cherry-picks them one by one in the same order somewhere else.
<p>Rebasing is covered in detail in Rebasing, including covering the collaborative issues involved with
rebasing branches that are already public.
<p>We use it in practice during an example of splitting your history into two separate repositories in
Replace, using the --onto flag as well.
<p>We go through running into a merge conflict during rebasing in Rerere.
<p>We also use it in an interactive scripting mode with the -i option in Changing Multiple Commit
Messages.
<p>git revert
<p>The git revert command is essentially a reverse git cherry-pick. It creates a new commit that
applies the exact opposite of the change introduced in the commit you&rsquo;re targeting, essentially
undoing or reverting it.
<p>We use this in Reverse the commit to undo a merge commit.
<p>Email
Many Git projects, including Git itself, are entirely maintained over mailing lists. Git has a number
of tools built into it that help make this process easier, from generating patches you can easily email
to applying those patches from an email box.
<p>git apply
<p>The git apply command applies a patch created with the git diff or even GNU diff command. It is
similar to what the patch command might do with a few small differences.
<p>515</p>
<br>
</div>
<div class="page">
<br>
<p>We demonstrate using it and the circumstances in which you might do so in Applying Patches from
Email.
<p>git am
<p>The git am command is used to apply patches from an email inbox, specifically one that is mbox
formatted. This is useful for receiving patches over email and applying them to your project easily.
<p>We covered usage and workflow around git am in Applying a Patch with am including using the
--resolved, -i and -3 options.
<p>There are also a number of hooks you can use to help with the workflow around git am and they
are all covered in Email Workflow Hooks.
<p>We also use it to apply patch formatted GitHub Pull Request changes in Email Notifications.
<p>git format-patch
<p>The git format-patch command is used to generate a series of patches in mbox format that you can
use to send to a mailing list properly formatted.
<p>We go through an example of contributing to a project using the git format-patch tool in Public
Project over Email.
<p>git imap-send
<p>The git imap-send command uploads a mailbox generated with git format-patch into an IMAP
drafts folder.
<p>We go through an example of contributing to a project by sending patches with the git imap-send
tool in Public Project over Email.
<p>git send-email
<p>The git send-email command is used to send patches that are generated with git format-patch over
email.
<p>We go through an example of contributing to a project by sending patches with the git send-email
tool in Public Project over Email.
<p>git request-pull
<p>The git request-pull command is simply used to generate an example message body to email to
someone. If you have a branch on a public server and want to let someone know how to integrate
those changes without sending the patches over email, you can run this command and send the
output to the person you want to pull the changes in.
<p>We demonstrate how to use git request-pull to generate a pull message in Forked Public Project.
<p>516</p>
<br>
</div>
<div class="page">
<br>
<p>External Systems
Git comes with a few commands to integrate with other version control systems.
<p>git svn
<p>The git svn command is used to communicate with the Subversion version control system as a
client. This means you can use Git to checkout from and commit to a Subversion server.
<p>This command is covered in depth in Git and Subversion.
<p>git fast-import
<p>For other version control systems or importing from nearly any format, you can use git fast-
import to quickly map the other format to something Git can easily record.
<p>This command is covered in depth in A Custom Importer.
<p>Administration
If you&rsquo;re administering a Git repository or need to fix something in a big way, Git provides a
number of administrative commands to help you out.
<p>git gc
<p>The git gc command runs &ldquo;garbage collection&rdquo; on your repository, removing unnecessary files in
your database and packing up the remaining files into a more efficient format.
<p>This command normally runs in the background for you, though you can manually run it if you
wish. We go over some examples of this in Maintenance.
<p>git fsck
<p>The git fsck command is used to check the internal database for problems or inconsistencies.
<p>We only quickly use this once in Data Recovery to search for dangling objects.
<p>git reflog
<p>The git reflog command goes through a log of where all the heads of your branches have been as
you work to find commits you may have lost through rewriting histories.
<p>We cover this command mainly in RefLog Shortnames, where we show normal usage to and how to
use git log -g to view the same information with git log output.
<p>We also go through a practical example of recovering such a lost branch in Data Recovery.
<p>517</p>
<br>
</div>
<div class="page">
<br>
<p>git filter-branch
<p>The git filter-branch command is used to rewrite loads of commits according to certain patterns,
like removing a file everywhere or filtering the entire repository down to a single subdirectory for
extracting a project.
<p>In Removing a File from Every Commit we explain the command and explore several different
options such as --commit-filter, --subdirectory-filter and --tree-filter.
<p>In Git-p4 and TFS we use it to fix up imported external repositories.
<p>Plumbing Commands
There were also quite a number of lower level plumbing commands that we encountered in the
book.
<p>The first one we encounter is ls-remote in Pull Request Refs which we use to look at the raw
references on the server.
<p>We use ls-files in Manual File Re-merging, Rerere and The Index to take a more raw look at what
your staging area looks like.
<p>We also mention rev-parse in Branch References to take just about any string and turn it into an
object SHA-1.
<p>However, most of the low level plumbing commands we cover are in Git Internals, which is more or
less what the chapter is focused on. We tried to avoid use of them throughout most of the rest of the
book.
<p>518</p>
<br>
</div>
<div class="page">
<br>
<p>Index
@
<p>$EDITOR, 341
$VISUAL
<p>see $EDITOR, 341
.gitignore, 342
.NET, 496
�0�, 90
�1�, 90
<p>A
<p>aliases, 59
Apache, 115
Apple, 497
archiving, 356
attributes, 350
autocorrect, 343
<p>B
<p>bash, 486
Bazaar, 423
binary files, 350
BitKeeper, 13
bitnami, 118
branches, 62
<p>basic workflow, 69
creating, 64
deleting remote, 91
diffing, 154
long-running, 79
managing, 77
merging, 73
remote, 153, 82
switching, 65
topic, 149, 80
tracking, 89
upstream, 89
<p>build numbers, 162
<p>C
<p>C, 492
C#, 496
Cocoa, 497
color, 343
commit templates, 341
contributing, 127
<p>private managed team, 136
private small team, 129
public large project, 146
public small project, 142
<p>credential caching, 19
credentials, 334
CRLF, 19
crlf, 347
CVS, 10
<p>D
<p>difftool, 344
distributed git, 124
Dulwich, 502
<p>E
<p>Eclipse, 484
editor
<p>changing default, 35
email, 148
<p>applying patches from, 150
excludes, 342, 438
<p>F
<p>files
moving, 38
removing, 37
<p>forking, 126, 170
<p>G
<p>Git as a client, 371
git commands
<p>add, 28, 28, 29
am, 151
apply, 150
archive, 163
branch, 64, 77
checkout, 65
cherry-pick, 159
clone, 26
<p>bare, 107
commit, 35, 62
config, 148, 20, 22, 340, 35, 60
credential, 334
daemon, 113
<p>519</p>
<br>
</div>
<div class="page">
<br>
<p>describe, 162
diff, 32
<p>check, 127
fast-import, 429
fetch, 51
fetch-pack, 462
filter-branch, 427
format-patch, 146
gitk, 477
gui, 477
help, 113, 23
http-backend, 115
init, 26, 28
<p>bare, 108, 111
instaweb, 117
log, 39
merge, 71
<p>squash, 145
mergetool, 76
p4, 400, 426
pull, 51
push, 52, 57, 88
rebase, 93
receive-pack, 460
remote, 49, 50, 52, 53
request-pull, 143
rerere, 161
send-pack, 460
shortlog, 163
show, 56
show-ref, 374
status, 27, 35
svn, 371
tag, 54, 55, 57
upload-pack, 462
<p>git-svn, 371
git-tf, 408
git-tfs, 408
GitHub, 165
<p>API, 212
Flow, 171
organizations, 205
pull requests, 174
user accounts, 165
<p>GitHub for macOS, 479
GitHub for Windows, 479
gitk, 477
GitLab, 118
<p>GitWeb, 116
Go, 501
go-git, 501
GPG, 342
Graphical tools, 477
GUIs, 477
<p>H
<p>hooks, 358
post-update, 104
<p>I
<p>ignoring files, 31
Importing
<p>from Bazaar, 423
from Mercurial, 419
from others, 429
from Perforce, 426
from Subversion, 417
from TFS, 427
<p>integrating work, 155
Interoperation with other VCSs
<p>Mercurial, 382
Perforce, 392
Subversion, 371
TFS, 408
<p>IRC, 23
<p>J
<p>Java, 497
jgit, 497
<p>K
<p>keyword expansion, 353
<p>L
<p>libgit2, 492
line endings, 347
Linus Torvalds, 13
Linux, 13
<p>installing, 17
log filtering, 46
log formatting, 42
<p>M
<p>macOS
installing, 18
<p>maintaining a project, 149
<p>520</p>
<br>
</div>
<div class="page">
<br>
<p>master, 63
Mercurial, 382, 419
mergetool, 344
merging, 73
<p>conflicts, 74
strategies, 358
vs. rebasing, 100
<p>Migrating to Git, 417
Mono, 496
<p>O
<p>Objective-C, 497
origin, 83
<p>P
<p>pager, 342
Perforce, 10, 13, 392, 426
<p>Git Fusion, 392
policy example, 361
posh-git, 489
PowerShell, 19, 489
protocols
<p>dumb HTTP, 104
git, 106
local, 102
smart HTTP, 104
SSH, 105
<p>pulling, 91
pushing, 88
Python, 497, 502
<p>R
<p>rebasing, 92
perils of, 97
vs. merging, 100
<p>references
remote, 82
<p>releasing, 163
rerere, 161
Ruby, 493
<p>S
<p>serving repositories, 102
git protocol, 113
GitLab, 118
GitWeb, 116
HTTP, 114
SSH, 108
<p>SHA-1, 15
shell prompts
<p>bash, 486
PowerShell, 489
zsh, 487
<p>SSH keys, 109
with GitHub, 166
<p>staging area
skipping, 36
<p>Subversion, 10, 125, 13, 371, 417
<p>T
<p>tab completion
bash, 486
PowerShell, 489
zsh, 487
<p>tags, 161, 54
annotated, 55
lightweight, 56
signing, 161
<p>TFS, 408, 427
TFVC
<p>see=TFS, 408
<p>V
<p>version control, 9
centralized, 10
distributed, 11
local, 9
<p>Visual Studio, 482
<p>W
<p>whitespace, 347
Windows
<p>installing, 18
workflows, 124
<p>centralized, 124
dictator and lieutenants, 126
integration manager, 125
merging, 156
merging (large), 158
rebasing and cherry-picking, 159
<p>X
<p>Xcode, 18
<p>Z
<p>zsh, 487
<p>521</p>
<br>
</div>
<ul> <li>Pro Git</li>
<li>Table of Contents</li>
<li>Licence</li>
<li>Preface by Scott Chacon</li>
<li>Preface by Ben Straub</li>
<li>Dedications</li>
<li>Contributors</li>
<li>Introduction</li>
<li>Getting Started</li>
<ul> <li>About Version Control</li>
<li>A Short History of Git</li>
<li>What is Git?</li>
<li>The Command Line</li>
<li>Installing Git</li>
<li>First-Time Git Setup</li>
<li>Getting Help</li>
<li>Summary</li>
</ul>
<li>Git Basics</li>
<ul> <li>Getting a Git Repository</li>
<li>Recording Changes to the Repository</li>
<li>Viewing the Commit History</li>
<li>Undoing Things</li>
<li>Working with Remotes</li>
<li>Tagging</li>
<li>Git Aliases</li>
<li>Summary</li>
</ul>
<li>Git Branching</li>
<ul> <li>Branches in a Nutshell</li>
<li>Basic Branching and Merging</li>
<li>Branch Management</li>
<li>Branching Workflows</li>
<li>Remote Branches</li>
<li>Rebasing</li>
<li>Summary</li>
</ul>
<li>Git on the Server</li>
<ul> <li>The Protocols</li>
<li>Getting Git on a Server</li>
<li>Generating Your SSH Public Key</li>
<li>Setting Up the Server</li>
<li>Git Daemon</li>
<li>Smart HTTP</li>
<li>GitWeb</li>
<li>GitLab</li>
<li>Third Party Hosted Options</li>
<li>Summary</li>
</ul>
<li>Distributed Git</li>
<ul> <li>Distributed Workflows</li>
<li>Contributing to a Project</li>
<li>Maintaining a Project</li>
<li>Summary</li>
</ul>
<li>GitHub</li>
<ul> <li>Account Setup and Configuration</li>
<li>Contributing to a Project</li>
<li>Maintaining a Project</li>
<li>Managing an organization</li>
<li>Scripting GitHub</li>
<li>Summary</li>
</ul>
<li>Git Tools</li>
<ul> <li>Revision Selection</li>
<li>Interactive Staging</li>
<li>Stashing and Cleaning</li>
<li>Signing Your Work</li>
<li>Searching</li>
<li>Rewriting History</li>
<li>Reset Demystified</li>
<li>Advanced Merging</li>
<li>Rerere</li>
<li>Debugging with Git</li>
<li>Submodules</li>
<li>Bundling</li>
<li>Replace</li>
<li>Credential Storage</li>
<li>Summary</li>
</ul>
<li>Customizing Git</li>
<ul> <li>Git Configuration</li>
<li>Git Attributes</li>
<li>Git Hooks</li>
<li>An Example Git-Enforced Policy</li>
<li>Summary</li>
</ul>
<li>Git and Other Systems</li>
<ul> <li>Git as a Client</li>
<li>Migrating to Git</li>
<li>Summary</li>
</ul>
<li>Git Internals</li>
<ul> <li>Plumbing and Porcelain</li>
<li>Git Objects</li>
<li>Git References</li>
<li>Packfiles</li>
<li>The Refspec</li>
<li>Transfer Protocols</li>
<li>Maintenance and Data Recovery</li>
<li>Environment Variables</li>
<li>Summary</li>
</ul>
<li>Appendix A: Git in Other Environments</li>
<ul> <li>Graphical Interfaces</li>
<li>Git in Visual Studio</li>
<li>Git in Visual Studio Code</li>
<li>Git in Eclipse</li>
<li>Git in IntelliJ / PyCharm / WebStorm / PhpStorm / RubyMine</li>
<li>Git in Sublime Text</li>
<li>Git in Bash</li>
<li>Git in Zsh</li>
<li>Git in PowerShell</li>
<li>Summary</li>
</ul>
<li>Appendix B: Embedding Git in your Applications</li>
<ul> <li>Command-line Git</li>
<li>Libgit2</li>
<li>JGit</li>
<li>go-git</li>
<li>Dulwich</li>
</ul>
<li>Appendix C: Git Commands</li>
<ul> <li>Setup and Config</li>
<li>Getting and Creating Projects</li>
<li>Basic Snapshotting</li>
<li>Branching and Merging</li>
<li>Sharing and Updating Projects</li>
<li>Inspection and Comparison</li>
<li>Debugging</li>
<li>Patching</li>
<li>Email</li>
<li>External Systems</li>
<li>Administration</li>
<li>Plumbing Commands</li>
</ul>
<li>Index</li>
</ul>
</body></html>