<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Untitled</title>
</head>
<body><div class="page"><p/>
<p>Graduate Texts in Physics
</p>
<p>Andrey&nbsp;Grozin
</p>
<p>Introduction to 
Mathematica&reg; 
for Physicists</p>
<p/>
</div>
<div class="page"><p/>
<p>Graduate Texts in Physics
</p>
<p>For further volumes:
</p>
<p>http://www.springer.com/series/8431</p>
<p/>
<div class="annotation"><a href="http://www.springer.com/series/8431">http://www.springer.com/series/8431</a></div>
</div>
<div class="page"><p/>
<p>Graduate Texts in Physics
</p>
<p>Graduate Texts in Physics publishes core learning/teaching material for graduate- and
</p>
<p>advanced-level undergraduate courses on topics of current and emerging fields within
</p>
<p>physics, both pure and applied. These textbooks serve students at the MS- or PhD-level and
</p>
<p>their instructors as comprehensive sources of principles, definitions, derivations, experiments
</p>
<p>and applications (as relevant) for their mastery and teaching, respectively. International
</p>
<p>in scope and relevance, the textbooks correspond to course syllabi sufficiently to serve as
</p>
<p>required reading. Their didactic style, comprehensiveness and coverage of fundamental
</p>
<p>material also make them suitable as introductions or references for scientists entering, or
</p>
<p>requiring timely knowledge of, a research field.
</p>
<p>Series Editors
</p>
<p>Professor William T. Rhodes
Department of Computer and Electrical Engineering and Computer Science
</p>
<p>Imaging Science and Technology Center
</p>
<p>Florida Atlantic University
</p>
<p>777 Glades Road SE, Room 456
</p>
<p>Boca Raton, FL 33431
</p>
<p>USA
</p>
<p>wrhodes@fau.edu
</p>
<p>Professor H. Eugene Stanley
Center for Polymer Studies Department of Physics
</p>
<p>Boston University
</p>
<p>590 Commonwealth Avenue, Room 204B
</p>
<p>Boston, MA 02215
</p>
<p>USA
</p>
<p>hes@bu.edu
</p>
<p>Professor Richard Needs
Cavendish Laboratory
</p>
<p>JJ Thomson Avenue
</p>
<p>Cambridge CB3 0HE
</p>
<p>UK
</p>
<p>rn11@cam.ac.uk
</p>
<p>Professor Martin Stutzmann
Technische Universität München
</p>
<p>Am Coulombwall
</p>
<p>85747 Garching, Germany
</p>
<p>stutz@wsi.tu-muenchen.de
</p>
<p>Professor Susan Scott
Department of Quantum Science
</p>
<p>Australian National University
</p>
<p>ACT 0200, Australia
</p>
<p>susan.scott@anu.edu.au</p>
<p/>
<div class="annotation"><a href="http://www.wrhodes@fau.edu">http://www.wrhodes@fau.edu</a></div>
<div class="annotation"><a href="http://www.hes@bu.edu">http://www.hes@bu.edu</a></div>
<div class="annotation"><a href="http://www.rn11@cam.ac.uk">http://www.rn11@cam.ac.uk</a></div>
<div class="annotation"><a href="http://www.stutz@wsi.tu-muenchen.de">http://www.stutz@wsi.tu-muenchen.de</a></div>
<div class="annotation"><a href="http://www.susan.scott@anu.edu.au">http://www.susan.scott@anu.edu.au</a></div>
</div>
<div class="page"><p/>
<p>Andrey Grozin
</p>
<p>Introduction to
Mathematica� for Physicists
</p>
<p>123</p>
<p/>
</div>
<div class="page"><p/>
<p>Andrey Grozin
Theory Division
Budker Institute of Nuclear Physics
Novosibirsk, Russia
</p>
<p>ISSN 1868-4513 ISSN 1868-4521 (electronic)
ISBN 978-3-319-00893-6 ISBN 978-3-319-00894-3 (eBook)
DOI 10.1007/978-3-319-00894-3
Springer Cham Heidelberg New York Dordrecht London
</p>
<p>Library of Congress Control Number: 2013941732
</p>
<p>&copy; Springer International Publishing Switzerland 2014
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microfilms or in any other physical way, and transmission or information
storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology
now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection
with reviews or scholarly analysis or material supplied specifically for the purpose of being entered
and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of
this publication or parts thereof is permitted only under the provisions of the Copyright Law of the
Publisher&rsquo;s location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center. Violations
are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication
does not imply, even in the absence of a specific statement, that such names are exempt from the relevant
protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of pub-
lication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any
errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect
to the material contained herein.
</p>
<p>Printed on acid-free paper
</p>
<p>Springer is part of Springer Science+Business Media (www.springer.com)</p>
<p/>
<div class="annotation"><a href="www.springer.com">www.springer.com</a></div>
</div>
<div class="page"><p/>
<p>Preface
</p>
<p>Computer algebra systems are widely used in pure and applied mathematics,
</p>
<p>physics, and other natural sciences, engineering, economics, as well as in higher
</p>
<p>and secondary education (see, e.g., [1&ndash;5]). For example, many important calcu-
</p>
<p>lations in theoretical physics could never be done by hand, without wide use of
</p>
<p>computer algebra. Polynomial or trigonometric manipulations using paper and pen
</p>
<p>are becoming as obsolete as school long division in the era of calculators.
</p>
<p>There are several powerful general-purpose computer algebra systems. The sys-
</p>
<p>temMathematica is most popular. It contains a huge amount of mathematical knowl-
</p>
<p>edge in its libraries. The fundamental book on this system [6] has more than 1,200
</p>
<p>pages. Fortunately, the same information (more up-to-date than in a printed book) is
</p>
<p>available in the help system and hence is always at the fingertips of any user. Many
</p>
<p>books about Mathematica and its application in various areas have been published;
</p>
<p>see, for example, the series [7&ndash;10] of four books (each more than 1,000 pages long)
</p>
<p>or [11]. The present book does not try to replace these manuals. Its first part is
</p>
<p>a short systematic introduction to computer algebra and Mathematica; it can (and
</p>
<p>should) be read sequentially. The second part is a set of unrelated examples from
</p>
<p>physics and mathematics which can be studied selectively and in any order. Having
</p>
<p>understood the statement of a problem, try to solve it yourself. Have a look at the
</p>
<p>book to get a hint only when you get stuck. Explanations in this part are quite short.
</p>
<p>This book1 is a result of teaching at the physics department of Novosibirsk State
</p>
<p>University. Starting from 2004, the course &ldquo;Symbolic and numeric computations in
</p>
<p>physics applications&rdquo; is given to students preparing for M.Sc., and an introduction
</p>
<p>to Mathematica is the first part of this course (the second part is mainly devoted
</p>
<p>to Monte Carlo methods). Practical computer classes form a required (and most
</p>
<p>important) part of the course. Most students have no problems with mastering the
</p>
<p>basics of Mathematica and applying it to problems in their own areas of interest.
</p>
<p>The book describes Mathematica 9. Most of the material is applicable to other
</p>
<p>versions too. The Mathematica Book (fifth edition) [6], as well as, e.g., the book
</p>
<p>1 Work partially supported by the Russian Ministry of Education and Science.
</p>
<p>v</p>
<p/>
</div>
<div class="page"><p/>
<p>vi Preface
</p>
<p>series [7&ndash;10], describes Mathematica 5. The main source of up-to-date information
</p>
<p>is the Mathematica Help system.
</p>
<p>The whole book (except Lecture 1 and Problems for students) consists of Math-
</p>
<p>ematica notebooks. They can be found at
</p>
<p>http://www.inp.nsk.su/˜grozin/mma/mma.zip
</p>
<p>The zip file is password protected. The password is the last sentence of Lecture 7
</p>
<p>(case-sensitive, including the trailing period). The reader is encouraged to experi-
</p>
<p>ment with these notebook files. In the printed version of the book, plots use different
</p>
<p>curve styles (dashed, dotted, etc.) instead of colors.
</p>
<p>The book will be useful for students, Ph.D. students, and researchers in the area
</p>
<p>of physics (and other natural sciences) and mathematics.
</p>
<p>Novosibirsk, Russia Andrey Grozin</p>
<p/>
</div>
<div class="page"><p/>
<p>Contents
</p>
<p>Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . v
</p>
<p>Part I Lectures
</p>
<p>1 Computer Algebra Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
</p>
<p>2 Overview of Mathematica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>2.1 Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
</p>
<p>2.2 Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>2.3 Polynomials and Rational Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>2.4 Elementary Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>2.5 Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>2.6 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
</p>
<p>2.7 Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
</p>
<p>2.8 Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
</p>
<p>2.9 Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
</p>
<p>3 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>3.1 Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
</p>
<p>3.2 Composite Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>3.3 Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>3.4 Forms of an Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
</p>
<p>4 Patterns and Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>4.1 Simple Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
</p>
<p>4.2 One-Shot and Repeated Substitutions . . . . . . . . . . . . . . . . . . . . . . . . . . 28
</p>
<p>4.3 Products . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
</p>
<p>4.4 Sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
</p>
<p>4.5 Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>4.6 Variable Number of Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
</p>
<p>vii</p>
<p/>
</div>
<div class="page"><p/>
<p>viii Contents
</p>
<p>5 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
</p>
<p>5.1 Immediate and Delayed Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
</p>
<p>5.2 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
</p>
<p>5.3 Functions Remembering Their Values . . . . . . . . . . . . . . . . . . . . . . . . . 36
</p>
<p>5.4 Fibonacci Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>5.5 Functions from Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>5.6 Antisymmetric Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>5.7 Functions with Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
</p>
<p>5.8 Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
</p>
<p>5.9 Upvalues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>6 Mathematica as a Programming Language . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>6.1 Compound Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
</p>
<p>6.2 Conditional Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
</p>
<p>6.3 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
</p>
<p>6.4 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
</p>
<p>6.5 Local Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
</p>
<p>6.6 Table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>6.7 Parallelization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>6.8 Functions with an Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>6.9 Hold and Evaluate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>7 Gröbner Bases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>7.1 Statement of the Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>7.2 Monomial Orders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
</p>
<p>7.3 Reduction of Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>7.4 S-Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
</p>
<p>7.5 Buchberger Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>7.6 Is the System Compatible? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
</p>
<p>7.7 Gröbner Bases with Respect to Lexicographic Order . . . . . . . . . . . . . 60
</p>
<p>7.8 Is the Number of Solutions Finite? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
</p>
<p>8 Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>8.1 Series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>8.2 Differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
</p>
<p>8.3 Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
</p>
<p>8.4 Summation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>8.5 Differentiol Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
</p>
<p>9 Numerical Calculations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
</p>
<p>9.1 Approximate Numbers in Mathematica . . . . . . . . . . . . . . . . . . . . . . . . 73
</p>
<p>9.2 Solving Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
</p>
<p>9.3 Numerical Integration and Summation . . . . . . . . . . . . . . . . . . . . . . . . . 77
</p>
<p>9.4 Differential Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78</p>
<p/>
</div>
<div class="page"><p/>
<p>Contents ix
</p>
<p>10 Risch Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>10.1 Rational Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
</p>
<p>10.2 Logarithmic Extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
</p>
<p>10.3 Exponential Extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
</p>
<p>10.4 Elementary Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
</p>
<p>11 Linear Algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
</p>
<p>11.1 Constructing Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
</p>
<p>11.2 Parts of a Matrix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
</p>
<p>11.3 Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
</p>
<p>11.4 Operations with Matrices and Vectors . . . . . . . . . . . . . . . . . . . . . . . . . . 93
</p>
<p>11.5 Eigenvalues and Eigenvectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
</p>
<p>11.6 Jordan Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
</p>
<p>11.7 Symbolic Vectors, Matrices, and Tensors . . . . . . . . . . . . . . . . . . . . . . . 97
</p>
<p>12 Input&ndash;Output and Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
</p>
<p>12.1 Reading and Writing .m Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
</p>
<p>12.2 Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
</p>
<p>12.3 C, Fortran, and TEX Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
</p>
<p>12.4 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
</p>
<p>13 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
</p>
<p>13.1 Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
</p>
<p>13.2 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
</p>
<p>13.3 Writing Your Own Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
</p>
<p>Part II Computer Classes
</p>
<p>14 Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
</p>
<p>14.1 2D Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
</p>
<p>14.2 3D Plots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
</p>
<p>15 Trigonometric Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
</p>
<p>16 Quantum Oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>16.1 Lowering and Raising Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
</p>
<p>16.2 Ground State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
</p>
<p>16.3 Excited States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
</p>
<p>16.4 Some Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
</p>
<p>17 Spherical Harmonics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
</p>
<p>17.1 Angular Momentum in Quantum Mechanics . . . . . . . . . . . . . . . . . . . . 133
</p>
<p>17.2 Yll(θ ,ϕ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
17.3 Ylm(θ ,ϕ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135</p>
<p/>
</div>
<div class="page"><p/>
<p>x Contents
</p>
<p>18 Adding Angular Momenta in QuantumMechanics . . . . . . . . . . . . . . . . . 139
</p>
<p>19 Classical Nonlinear Oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>19.1 Statement of the Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>19.2 The First Correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
</p>
<p>19.3 The Second Correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
</p>
<p>19.4 The nth Correction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
</p>
<p>20 Quantum Nonlinear Oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
</p>
<p>20.1 Perturbation Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
</p>
<p>20.2 Nonlinear Oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
</p>
<p>20.3 Energy Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
</p>
<p>20.4 Correspondence Principle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
</p>
<p>20.5 States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>21 Riemann Curvature Tensor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
</p>
<p>22 Multi-ζ Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
22.1 Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
</p>
<p>22.2 Stuffling Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
</p>
<p>22.3 Integral Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
</p>
<p>22.4 Shuffling Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
</p>
<p>22.5 Duality Relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
</p>
<p>22.6 Weight 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
</p>
<p>22.7 Weight 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
</p>
<p>23 Rainbow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
</p>
<p>23.1 Statement of the Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
</p>
<p>23.2 0 Ray Segments Inside the Drop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
</p>
<p>23.3 1 Ray Segment Inside the Drop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
</p>
<p>23.4 2 Ray Segments Inside the Drop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
</p>
<p>23.5 L Ray Segments Inside the Drop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
</p>
<p>24 Cyclohexane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
</p>
<p>24.1 Statement of the Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
</p>
<p>24.2 First Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
</p>
<p>24.3 Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
</p>
<p>24.4 Projection onto the x, y Plane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
</p>
<p>24.5 Complete Analysis of the Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
</p>
<p>24.6 Shape of the Molecule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
</p>
<p>25 Problems for Students . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
</p>
<p>References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
</p>
<p>Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215</p>
<p/>
</div>
<div class="page"><p/>
<p>Part I
</p>
<p>Lectures
</p>
<p>Catching a lion, the computer-algebra method: catch a cat, put it into the cage and
</p>
<p>lock it; then substitute a lion for the cat.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 1
</p>
<p>Computer Algebra Systems
</p>
<p>First attempts to use computers for calculations not only with numbers but also with
</p>
<p>mathematical expressions (e.g., symbolic differentiation) were made in the 1950s.
</p>
<p>In the 1960s research in this direction became rather intensive. This area was known
</p>
<p>under different names: symbolic calculations, analytic calculations, and computer
</p>
<p>algebra. Recently this last name is most widely used. Why algebra and not, say,
</p>
<p>calculus? The reason is that it is most useful to consider operations usually referred
</p>
<p>to calculus (such as differentiation) as algebraic operations in appropriate algebraic
</p>
<p>structures (differential fields).
</p>
<p>First universal (i.e., not specialized for some particular application area) com-
</p>
<p>puter algebra systems appeared at the end of the 1960s. Not many such systems
</p>
<p>have been constructed; they are shown in the Table 1.1. Creating a universal com-
</p>
<p>puter algebra system is a huge amount of work, at the scale of hundreds of man-
</p>
<p>years. Some projects of this kind were not sufficiently developed and subsequently
</p>
<p>died; they are not shown in Table 1.1.
</p>
<p>Table 1.1 Universal computer algebra systems
</p>
<p>System Year
Implementation Current
</p>
<p>Status
language name
</p>
<p>REDUCE 1968
</p>
<p>Lisp
</p>
<p>Free (BSD)
Macsyma 1969 Maxima Free (GPL)
</p>
<p>Axiom
Scratchpad 1974 OpenAxiom Free (BSD)
</p>
<p>FriCAS
muMATH 1979 Derive Dead
</p>
<p>Maple 1983
</p>
<p>C, C++
</p>
<p>Proprietary
Mathematica 1988 Proprietary
</p>
<p>MuPAD 1992
MATLAB
</p>
<p>Proprietary
symbolic toolbox
</p>
<p>Theoretical physicist A. Hearn (known to specialists for the Drell&ndash;Hearn
</p>
<p>sum rule) has written a Lisp program REDUCE to automatize some actions in
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 1, &copy; Springer International Publishing Switzerland 2014
</p>
<p>3</p>
<p/>
</div>
<div class="page"><p/>
<p>4 1 Computer Algebra Systems
</p>
<p>calculating Feynman diagrams. It quickly grew into a universal system. At first, it
</p>
<p>was distributed free (it was sufficient to ask for Hearn&rsquo;s permission) and became
</p>
<p>widely used by physicists. Later it became commercial. At the end of 2008 it has
</p>
<p>become free, with a modified BSD license.
</p>
<p>Macsyma was born in the MAC project at MIT (1969), the name means MAC
</p>
<p>SYmbolic MAnipulator. The project has nothing to do with Macintosh computers,
</p>
<p>which appeared much later. Its name had several official meanings (Multiple-Access
</p>
<p>Computer, Man And Computer, Machine Aided Cognition) and some unofficial
</p>
<p>ones (Man Against Computer, Moses And Company, Maniacs And Clowns, etc.).
</p>
<p>The work was done on a single PDP-6, later PDP-10 computer (about 1 MByte
</p>
<p>memory; there were no bytes back then, but 36-bit words). One of the first time-
</p>
<p>sharing operating systems, ITS, was written for this computer, and many users at
</p>
<p>once worked on it interactively. Later this computer became one of the first nodes
</p>
<p>of ARPANET, the ancestor if Internet, and users from other universities could use
</p>
<p>Macsyma.
</p>
<p>The company Symbolics was spun off MIT. It produced Lisp machines&mdash;
</p>
<p>computers with a hardware support of Lisp, as well as software for these computers,
</p>
<p>including Macsyma&mdash;the largest Lisp program at that time. Later production of
</p>
<p>Lisp machines became unprofitable, because general-purpose workstations (Sun,
</p>
<p>etc.) became faster and cheaper. Symbolics went bankrupt; Macsyma business was
</p>
<p>continued by Macsyma Inc., who sold Macsyma for a number of platforms and
</p>
<p>operating systems. Its market share continued to shrink because of the success of
</p>
<p>Maple and Mathematica, and finally the company was sold in 1999 to Andrew
</p>
<p>Topping. The new owner stopped Macsyma development and marketing. Then he
</p>
<p>died, and the rights to the commercial Macsyma now belong to his inheritors. All
</p>
<p>efforts spent on improving this branch of Macsyma are irreversibly lost.
</p>
<p>Fortunately, this was not the only branch. Macsyma development at MIT was
</p>
<p>largely funded by DOE, and MIT transferred this codebase to DOE who dis-
</p>
<p>tributed it. This version was ported to several platforms. All these ports died except
</p>
<p>one. Professor William Schelter ported DOE Macsyma to Common Lisp, the new
</p>
<p>Lisp standard, and developed this version until he died in 2001. This version was
</p>
<p>called Maxima, to avoid trademark problems. In 1998 he obtained permission from
</p>
<p>DOE to release Maxima under GPL. He also developed GCL (GNU Common Lisp).
</p>
<p>Currently Maxima is an active free software project and works on many Common
</p>
<p>Lisp implementations.
</p>
<p>Macsyma has played a huge role in the development of computer algebra
</p>
<p>systems. It was the first system in which modern algorithms for polynomials,
</p>
<p>integration in elementary functions, etc., were implemented (REDUCE and Mac-
</p>
<p>syma influenced each other strongly and are rather similar to each other). Macsyma
</p>
<p>was designed as an interactive system. For example, if the form of an answer
</p>
<p>depends on the sign of a parameter, it will ask the user
</p>
<p>Is a positive or negative?
</p>
<p>Scratchpad was born in IBM research laboratories (1974). At first it did not
</p>
<p>differ from other systems (Macsyma, REDUCE) very much and borrowed chunks
</p>
<p>of code from them. It was radically redesigned in the version Scratchpad II (1985).</p>
<p/>
</div>
<div class="page"><p/>
<p>1 Computer Algebra Systems 5
</p>
<p>And this design, perhaps, still remains the most beautiful one from a mathematical
</p>
<p>point of view. It is a strongly typed system (the only one among universal com-
</p>
<p>puter algebra systems). Any object (formula) in it belongs to some domain (e.g.,
</p>
<p>it is a single-variable polynomial with integer coefficients). Each domain belongs
</p>
<p>to some category (e.g., it is a ring, or a commutative group, or a totally ordered
</p>
<p>set). New domains can be constructed from existing ones. For example, a matrix
</p>
<p>of elements belonging to any ring can be constructed. It is sufficient to program a
</p>
<p>matrix multiplication algorithm once. This algorithm calls the operations of addi-
</p>
<p>tion and multiplication of the elements. If matrices of rational numbers are being
</p>
<p>multiplied, then addition and multiplication of rational numbers are called; and if
</p>
<p>matrices of polynomials&mdash;then addition and multiplication of polynomials.
</p>
<p>Scratchpad was never distributed to end users by IBM. At last, IBM decided to
</p>
<p>stop wasting money for nought (or for basic research) and sold Scratchpad II to the
</p>
<p>English company NAG (famous for its numerical libraries). It marketed this sys-
</p>
<p>tem under the name Axiom. However, the product did not bring enough profit and
</p>
<p>was withdrawn in 2001. Axiom development took about 300 man-years of work of
</p>
<p>researchers having highest qualification. All this could easily disappear without a
</p>
<p>trace. Fortunately, one of old-time Scratchpad II developers at IBM, Tim Daly, has
</p>
<p>succeeded in convincing NAG to release Axiom under the modified BSD license.
</p>
<p>Now it is a free software project and still the most beautiful system from mathemat-
</p>
<p>ical point of view. But unfortunately, due to incompatible visions of the directions
</p>
<p>of the future development, two forks appeared&mdash;OpenAxiom and FriCAS. And it is
</p>
<p>not clear which one is better.
</p>
<p>muMATH (Soft Warehouse, Hawaii, 1979) got to the list of universal computer
</p>
<p>algebra systems with some stretch. It was written for microprocessor systems with
</p>
<p>a very limited memory (later called personal computers); mu in its name, of course,
</p>
<p>means &micro; , i.e., micro. This system never implemented advanced modern algorithms.
It used heuristic methods instead, as taught in university calculus courses: let&rsquo;s try
</p>
<p>this and that, and if you can&rsquo;t get it, you can&rsquo;t get it. But it was surprisingly powerful
</p>
<p>at its humble size. The system has been essentially rewritten in 1988 and got a menu
</p>
<p>interface, graphics, and the new name, Derive. Then Soft Warehouse was bought
</p>
<p>by Texas Instruments, who presented a calculator with a (Derive-based) computer
</p>
<p>algebra system in 1995. Derive was withdrawn from market in 2007.
</p>
<p>All these systems can be referred to the first generation. They are all written
</p>
<p>in various dialects of Lisp. They were considered related to the area of artificial
</p>
<p>intelligence.
</p>
<p>The first representative of the second generation is the Canadian system Maple.
</p>
<p>It has a small kernel written in C, which implements an interpreted procedural
</p>
<p>language convenient for writing computer algebra algorithms. The major part of
</p>
<p>its mathematical knowledge is contained in the library written in this language.
</p>
<p>Maple can work on many platforms. It quickly became popular. In 2009 Maplesoft
</p>
<p>(Waterloo Maple Inc.) has been acquired by the Japanese company Cybernet Sys-
</p>
<p>tems Group; development of Maple is not affected. By the way, numerical program
</p>
<p>MathCAD used a cut-down version of Maple to provide some computer algebraic
</p>
<p>capabilities.</p>
<p/>
</div>
<div class="page"><p/>
<p>6 1 Computer Algebra Systems
</p>
<p>In the beginning of the 1980s, a young theoretical physicist Steven Wolfram, an
</p>
<p>active Macsyma user, together with a few colleagues, has written a system SMP
</p>
<p>(Symbolic Manipulation Program). The project was a failure (I still have a huge
</p>
<p>SMP manual sent to me by S. Wolfram). After that, he understood what mass users
</p>
<p>want&mdash;they want a program to look pretty. He, together with a few colleagues, has
</p>
<p>rewritten the system, paying a lot of attention to the GUI and graphics (the symbolic
</p>
<p>part was largely based on SMP). The result was Mathematica, version 1 (1988). And
</p>
<p>Wolfram got his first million in three months of selling it.
</p>
<p>Mathematica heavily relies on substitutions. Even a procedure call is a substitu-
</p>
<p>tion. Pattern matching and their replacing by right-hand sides of substitutions are
</p>
<p>highly advanced in Mathematica. Often a set of mathematical concepts can be eas-
</p>
<p>ily and compactly implemented via substitutions. On the other hand, this can lead
</p>
<p>to inefficiency: pattern matching is expensive.
</p>
<p>The latest arrival in the list of universal computer algebra systems is MuPAD
</p>
<p>(its name initially meant Multi-Processor Algebra Data tool, and indeed early
</p>
<p>versions contained experimental support of multiprocessor systems, which later
</p>
<p>disappeared). The system was designed and implemented by a research group at the
</p>
<p>University of Paderborn in Germany (this is one more meaning of PAD in the name)
</p>
<p>in 1992 and later was distributed commercially by the company SciFace. Initially,
</p>
<p>MuPAD was quite similar to Maple. Later it borrowed many ideas from Axiom (do-
</p>
<p>mains, categories; however, MuPAD is dynamically typed). During a long period, it
</p>
<p>was allowed to download and use MuPAD Light for free; it had no advanced GUI,
</p>
<p>but its symbolic functionality was not cut down. Funding of the University project
</p>
<p>was stopped in 2005; in 2008, SciFace was bought by Mathworks, the makers of
</p>
<p>MATLAB. After that, MuPAD is available only as a MATLAB addon.
</p>
<p>It seems that Mathematica dominates the market of commercial computer al-
</p>
<p>gebra systems, with Maple being number two. Mathematica is highly respected
</p>
<p>for the huge amount of mathematical knowledge accumulated in its libraries. It is
</p>
<p>not bug-free (this is true for all systems). Often it requires more resources (mem-
</p>
<p>ory, processor time) for solving a given problem than other systems. But it is very
</p>
<p>convenient and allows a user to do a lot in a single framework.
</p>
<p>In addition to universal systems, there are a lot of specialized computer alge-
</p>
<p>bra systems. Here we&rsquo;ll briefly discuss just one example important for theoretical
</p>
<p>physics.
</p>
<p>In the 1960s, a well-known Dutch theoretical physicist M. Veltman, a future
</p>
<p>Nobel prize winner, has written a system Schoonschip in the assembly language of
</p>
<p>CDC-6000 computers (in Dutch Schoonschip means &ldquo;to clean a ship,&rdquo; in a figura-
</p>
<p>tive sense &ldquo;to put something in order,&rdquo; &ldquo;to throw unneeded things overboard&rdquo;). This
</p>
<p>system was designed for handling very long sums (millions of terms) whose size
</p>
<p>can be much larger than the main memory and is limited only by the available disk
</p>
<p>space. All operations save one are local: they are substitutions which replace a single
</p>
<p>term by several new ones. The system gets a number of terms from the disk, applies
</p>
<p>the substitution to them, and puts the results back to the disk. The only unavoidable
</p>
<p>nonlocal operation is collecting similar terms; it is done with advanced disk sort-
</p>
<p>ing algorithms. Built-in mathematical knowledge of the system is very limited; the</p>
<p/>
</div>
<div class="page"><p/>
<p>1 Computer Algebra Systems 7
</p>
<p>user has to program everything from scratch. Many nontrivial algorithms, such as
</p>
<p>polynomial factorization, are highly nonlocal and impossible to implement. On the
</p>
<p>other hand, this was the only system which could work with very large expressions,
</p>
<p>orders of magnitude larger than in other systems. Later Schoonschip was ported
</p>
<p>to IBM-360 (in PL/I; you can guess that this was not done by Veltman :&ndash;). Then
</p>
<p>Veltman has rewritten it from the CDC assembly language to the 680x0 assembly
</p>
<p>language. When 680x0-based personal computers (Amiga, Atari) became extinct, it
</p>
<p>became clear that something similar but more portable is needed.
</p>
<p>In 1989 another well-known Dutch theoretical physicist, Vermaseren, has writ-
</p>
<p>ten (in C) a new system, Form. It follows the same ideology, but many details differ.
</p>
<p>It was distributed free of charge as binaries for a number of platforms; recently
</p>
<p>it became free software (GPL). Development of Form continues. A parallel ver-
</p>
<p>sion for multiprocessor computers and for clusters with fast connections now exists.
</p>
<p>Many important Feynman diagram calculations could never have been done without
</p>
<p>Schoonschip and later Form.
</p>
<p>The percentage of theoretical physicists among authors of computer algebra
</p>
<p>systems is suspiciously high. Some of them remained physicists (and even got a
</p>
<p>Nobel prize); some completely switched to development of their systems (and even
</p>
<p>became millionaires).
</p>
<p>In conclusion we&rsquo;ll discuss a couple of important computer algebra concepts.
</p>
<p>For some (sufficiently simple) classes of expressions an algorithm of reduction to
</p>
<p>a canonical form can be constructed. Two equal expressions reduce to the same
</p>
<p>canonical form. In particular, any expression equal to 0, in whatever form it is writ-
</p>
<p>ten, has the canonical form 0.
</p>
<p>For example, it is easy to define a canonical form for polynomials of several
</p>
<p>variables with integer (or rational) coefficients: one has to expand all brackets and
</p>
<p>collect similar terms. What&rsquo;s left is to agree upon an unambiguous order of terms,
</p>
<p>and we have a canonical form (this can be done in more than one way).
</p>
<p>It is more difficult, but possible, to define a canonical form for rational
</p>
<p>expressions (ratios of polynomials). One has to expand all brackets and to bring the
</p>
<p>whole expression to a common denominator (collecting similar terms, of course).
</p>
<p>However, this is not sufficient: one can multiply both the numerator and the denom-
</p>
<p>inator by the same polynomial and obtain another form of the rational expression.
</p>
<p>It is necessary to cancel the greatest common divisor (gcd) of the numerator and
</p>
<p>the denominator. Calculating polynomial gcd&rsquo;s is an algorithmic operation, but it
</p>
<p>can be computationally expensive. What&rsquo;s left is to fix some minor details&mdash;an
</p>
<p>unambiguous order of terms in both the numerator and the denominator and, say,
</p>
<p>the requirement that the coefficient of the first term in the denominator is 1, and we
</p>
<p>obtain a canonical form.
</p>
<p>A normal form for a class of expressions satisfies a weaker requirement: any
</p>
<p>expression equal to 0 must reduce to the normal form 0. For example, bringing to
</p>
<p>common denominator (without canceling gcd) defines a normal form for rational
</p>
<p>expressions.
</p>
<p>For more general classes of expressions containing elementary functions, not
</p>
<p>only canonical but even normal form does not exist. Richardson has proved that it
</p>
<p>is algorithmically undecidable if such an expression is equal to 0.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 2
</p>
<p>Overview of Mathematica
</p>
<p>2.1 Symbols
</p>
<p>Let&rsquo;s assign an expression containing a symbol x to a variable a. No value is assigned
</p>
<p>to x.
</p>
<p>In[1] := a= x&and;2&minus; 1In[1] := a= x&and;2&minus; 1In[1] := a= x&and;2&minus; 1
Out[1] =&minus;1+ x2
Now let&rsquo;s assign some value to x and see what happens to a.
</p>
<p>In[2] := x= z+ 1; aIn[2] := x= z+ 1; aIn[2] := x= z+ 1; a
Out[2] =&minus;1+(1+ z)2
The value of a has not really changed. It is still the same expression containing x.
</p>
<p>What if we assign another value to x?
</p>
<p>In[3] := x= z&minus; 1; aIn[3] := x= z&minus; 1; aIn[3] := x= z&minus; 1; a
Out[3] =&minus;1+(&minus;1+ z)2
We can delete the value of the variable x, thus returning it to its initial state in which
</p>
<p>it means just the symbol x. We see that indeed the value of a has not changed.
</p>
<p>In[4] := Clear[x]; aIn[4] := Clear[x]; aIn[4] := Clear[x]; a
Out[4] =&minus;1+ x2
Now let&rsquo;s try to assign an expression containing x to the variable x.
</p>
<p>In[5] := $RecursionLimit = 32; x= x+ 1In[5] := $RecursionLimit = 32; x= x+ 1In[5] := $RecursionLimit = 32; x= x+ 1
$RecursionLimit :: reclim : Recursion depth of 32 exceeded.
</p>
<p>Out[5] = 1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+
(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+Hold[1+
x])))))))))))))))))))))))))))))
</p>
<p>Mathematica complains. What has happened? Mathematica wants to print x, and to
</p>
<p>this end it calculates the value of x. It sees x in this value and substitutes the value of
</p>
<p>x. In this value, it again sees x and substitutes its value. And so on ad infinitum. In re-
</p>
<p>ality, the depth of such substitutions is limited; the default value of the limit is 1,024
</p>
<p>(we have temporarily changed it to 32). The value of the expression 1+ x which
failed to evaluate is returned as the function Hold; we shall discuss it in Sect. 6.9.
</p>
<p>In[6] := $RecursionLimit = 1024; Clear[x]In[6] := $RecursionLimit = 1024; Clear[x]In[6] := $RecursionLimit = 1024; Clear[x]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 2, &copy; Springer International Publishing Switzerland 2014
</p>
<p>9</p>
<p/>
</div>
<div class="page"><p/>
<p>10 2 Overview of Mathematica
</p>
<p>2.2 Numbers
</p>
<p>Mathematica can work with arbitrarily long integer numbers.
</p>
<p>In[7] := Factorial[100]In[7] := Factorial[100]In[7] := Factorial[100]
Out[7] = 933262154439441526816992388562667004907159682643816214685\
</p>
<p>9296389521759999322991560894146397615651828625369792082722375\
8251185210916864000000000000000000000000
</p>
<p>When working with a rational number, the greatest common divisors of its numera-
</p>
<p>tor and denominator are canceled.
</p>
<p>In[8] := a= 1234567890/987654321In[8] := a= 1234567890/987654321In[8] := a= 1234567890/987654321
</p>
<p>Out[8] =
137174210
</p>
<p>109739369
Calculations with rational numbers are exact.
</p>
<p>In[9] := a&and;5In[9] := a&and;5In[9] := a&and;5
Out[9] = 48569355286282885522765185491603110100000/
</p>
<p>15915207065345784618237986236670245907849
</p>
<p>How much is this numerically? Say, with 30 significant digits?
</p>
<p>In[10] := N[a,30]In[10] := N[a,30]In[10] := N[a,30]
Out[10] = 1.24999998860937500014238281250
</p>
<p>Mathematica can work with real (floating-point) numbers having arbitrarily high
</p>
<p>precision.
</p>
<p>In[11] := a= 1234567890987654321.1234567890987654321In[11] := a= 1234567890987654321.1234567890987654321In[11] := a= 1234567890987654321.1234567890987654321
Out[11] = 1.234567890987654321123456789098765432&times;1018
In[12] := a&and;5In[12] := a&and;5In[12] := a&and;5
Out[12] = 2.86797187177160567275921531725363508&times;1090
Here are π and e with 100 significant digits.
In[13] := N[Pi,100]In[13] := N[Pi,100]In[13] := N[Pi,100]
Out[13] = 3.14159265358979323846264338327950288419716939937510582097\
</p>
<p>4944592307816406286208998628034825342117068
</p>
<p>In[14] := N[E,100]In[14] := N[E,100]In[14] := N[E,100]
Out[14] = 2.71828182845904523536028747135266249775724709369995957496\
</p>
<p>6967627724076630353547594571382178525166427
</p>
<p>2.3 Polynomials and Rational Functions
</p>
<p>Let&rsquo;s take a polynomial.
</p>
<p>In[15] := a= (x+ y+ z)&and;6In[15] := a= (x+ y+ z)&and;6In[15] := a= (x+ y+ z)&and;6
Out[15] = (x+ y+ z)6
</p>
<p>Expand it.</p>
<p/>
</div>
<div class="page"><p/>
<p>2.3 Polynomials and Rational Functions 11
</p>
<p>In[16] := a= Expand[a]In[16] := a= Expand[a]In[16] := a= Expand[a]
Out[16] = x6 + 6x5y+ 15x4y2 + 20x3y3 + 15x2y4 + 6xy5 + y6 + 6x5z+ 30x4yz+
</p>
<p>60x3y2z+ 60x2y3z+ 30xy4z+ 6y5z+ 15x4z2 + 60x3yz2 + 90x2y2z2 +
60xy3z2 + 15y4z2 + 20x3z3 + 60x2yz3 + 60xy2z3 + 20y3z3 + 15x2z4 +
30xyz4 + 15y2z4 + 6xz5 + 6yz5 + z6
</p>
<p>The degree in x.
</p>
<p>In[17] := Exponent[a,x]In[17] := Exponent[a,x]In[17] := Exponent[a,x]
Out[17] = 6
The coefficient of x2.
</p>
<p>In[18] := Coefficient[a,x,2]In[18] := Coefficient[a,x,2]In[18] := Coefficient[a,x,2]
Out[18] = 15y4 + 60y3z+ 90y2z2 + 60yz3 + 15z4
</p>
<p>Collect terms with the same power of x together.
</p>
<p>In[19] := Collect[a,x]In[19] := Collect[a,x]In[19] := Collect[a,x]
Out[19] = x6 + y6 + 6y5z+ 15y4z2 + 20y3z3 + 15y2z4 + 6yz5 + z6 + x5(6y+ 6z)+
</p>
<p>x4
(
</p>
<p>15y2 + 30yz+ 15z2
)
</p>
<p>+ x3
(
</p>
<p>20y3 + 60y2z+ 60yz2 + 20z3
)
</p>
<p>+
</p>
<p>x2
(
</p>
<p>15y4 + 60y3z+ 90y2z2 + 60yz3 + 15z4
)
</p>
<p>+
</p>
<p>x
</p>
<p>(
</p>
<p>6y5 + 30y4z+ 60y3z2 + 60y2z3 + 30yz4 + 6z5
)
</p>
<p>Factorize it.
</p>
<p>In[20] := a= Factor[a]In[20] := a= Factor[a]In[20] := a= Factor[a]
Out[20] = (x+ y+ z)6
</p>
<p>Suppose we want to factorize polynomials xn&minus; 1 with various n. The parameter n
can be varied from 2 to 10 by dragging the marker with the mouse.
</p>
<p>In[21] := Manipulate[Factor[x&and;n&minus; 1],{n,2,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]In[21] := Manipulate[Factor[x&and;n&minus; 1],{n,2,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]In[21] := Manipulate[Factor[x&and;n&minus; 1],{n,2,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]
</p>
<p>n 6
</p>
<p>(&minus;1+x)(1+x)(1&minus;x+x2)(1+x+x2)
</p>
<p>Out[21] =
</p>
<p>There exists an algorithm which completely factorizes any polynomial with integer
</p>
<p>coefficients into factors which also have integer coefficients.
</p>
<p>In[22] := Factor[x&and;4&minus; 1]In[22] := Factor[x&and;4&minus; 1]In[22] := Factor[x&and;4&minus; 1]
Out[22] = (&minus;1+ x)(1+ x)
</p>
<p>(
</p>
<p>1+ x2
)
</p>
<p>If we want to get factors whose coefficients come from an extension of the ring of
</p>
<p>integers, say, by the imaginary unit i, we should say so explicitly.
</p>
<p>In[23] := Factor[x&and;4&minus; 1,Extension&minus;&gt;I]In[23] := Factor[x&and;4&minus; 1,Extension&minus;&gt;I]In[23] := Factor[x&and;4&minus; 1,Extension&minus;&gt;I]
Out[23] = (&minus;1+ x)(&minus;i+ x)(i+ x)(1+ x)
This polynomial factorizes into two factors with integer coefficients.
</p>
<p>In[24] := a= x&and;4&minus; 4; Factor[a]In[24] := a= x&and;4&minus; 4; Factor[a]In[24] := a= x&and;4&minus; 4; Factor[a]
Out[24] =
</p>
<p>(
</p>
<p>&minus;2+ x2
)(
</p>
<p>2+ x2
)
</p>
<p>If coefficients from the extension of the ring of integers by
&radic;
</p>
<p>2 are allowed&mdash;into
</p>
<p>three factors.
</p>
<p>In[25] := Factor[a,Extension&minus;&gt;Sqrt[2]]In[25] := Factor[a,Extension&minus;&gt;Sqrt[2]]In[25] := Factor[a,Extension&minus;&gt;Sqrt[2]]
Out[25] =&minus;
</p>
<p>(&radic;
2&minus; x
</p>
<p>)(&radic;
2+ x
</p>
<p>)
</p>
<p>(
</p>
<p>2+ x2
)</p>
<p/>
</div>
<div class="page"><p/>
<p>12 2 Overview of Mathematica
</p>
<p>And if the ring of coefficients is extended by both
&radic;
</p>
<p>2 and i&mdash;into four factors.
</p>
<p>In[26] := Factor[a,Extension&minus;&gt;{Sqrt[2], I}]In[26] := Factor[a,Extension&minus;&gt;{Sqrt[2], I}]In[26] := Factor[a,Extension&minus;&gt;{Sqrt[2], I}]
Out[26] =&minus;
</p>
<p>(&radic;
2&minus; x
</p>
<p>)(&radic;
2&minus; ix
</p>
<p>)(&radic;
2+ ix
</p>
<p>)(&radic;
2+ x
</p>
<p>)
</p>
<p>And this is a rational function.
</p>
<p>In[27] := (x&and;3&minus; y&and;3)/(x&and;2&minus; y&and;2)In[27] := (x&and;3&minus; y&and;3)/(x&and;2&minus; y&and;2)In[27] := (x&and;3&minus; y&and;3)/(x&and;2&minus; y&and;2)
</p>
<p>Out[27] =
x3 &minus; y3
x2 &minus; y2
</p>
<p>It is not canceled by the greatest common divisor of its numerator and denominator;
</p>
<p>this should be done explicitly.
</p>
<p>In[28] := Cancel[%]In[28] := Cancel[%]In[28] := Cancel[%]
</p>
<p>Out[28] =
x2 + xy+ y2
</p>
<p>x+ y
(% means the result of the previous calculation). A sum of rational functions.
</p>
<p>In[29] := a= x/(x+ y)+ y/(x&minus; y)In[29] := a= x/(x+ y)+ y/(x&minus; y)In[29] := a= x/(x+ y)+ y/(x&minus; y)
Out[29] =
</p>
<p>y
</p>
<p>x&minus; y +
x
</p>
<p>x+ y
Let&rsquo;s put it over the common denominator.
</p>
<p>In[30] := a= Together[a]In[30] := a= Together[a]In[30] := a= Together[a]
</p>
<p>Out[30] =
x2 + y2
</p>
<p>(x&minus; y)(x+ y)
Partial fraction decomposition with respect to x.
</p>
<p>In[31] := Apart[a,x]In[31] := Apart[a,x]In[31] := Apart[a,x]
</p>
<p>Out[31] = 1+
y
</p>
<p>x&minus; y &minus;
y
</p>
<p>x+ y
In[32] := Clear[a]In[32] := Clear[a]In[32] := Clear[a]
</p>
<p>2.4 Elementary Functions
</p>
<p>Mathematica knows some simple properties of elementary functions.
</p>
<p>In[33] := Sin[&minus;x]In[33] := Sin[&minus;x]In[33] := Sin[&minus;x]
Out[33] =&minus;Sin[x]
In[34] := Cos[Pi/4]In[34] := Cos[Pi/4]In[34] := Cos[Pi/4]
</p>
<p>Out[34] =
1&radic;
2
</p>
<p>In[35] := Sin[5 &lowast;Pi/6]In[35] := Sin[5 &lowast;Pi/6]In[35] := Sin[5 &lowast;Pi/6]
Out[35] =
</p>
<p>1
</p>
<p>2
In[36] := Log[1]In[36] := Log[1]In[36] := Log[1]
Out[36] = 0
In[37] := Log[E]In[37] := Log[E]In[37] := Log[E]
Out[37] = 1
In[38] := Exp[Log[x]]In[38] := Exp[Log[x]]In[38] := Exp[Log[x]]
Out[38] = x
In[39] := Log[Exp[x]]In[39] := Log[Exp[x]]In[39] := Log[Exp[x]]</p>
<p/>
</div>
<div class="page"><p/>
<p>2.5 Calculus 13
</p>
<p>Out[39] = Log [ex]
And why not x? Because this simplification is not always correct. Try to substi-
</p>
<p>tute 2π i.
In[40] := Sqrt[0]In[40] := Sqrt[0]In[40] := Sqrt[0]
Out[40] = 0
In[41] := Sqrt[x]&and;2In[41] := Sqrt[x]&and;2In[41] := Sqrt[x]&and;2
Out[41] = x
In[42] := Sqrt[x&and;2]In[42] := Sqrt[x&and;2]In[42] := Sqrt[x&and;2]
Out[42] =
</p>
<p>&radic;
x2
</p>
<p>And why not x? Try to substitute &minus;1.
In[43] := a= Sqrt[12 &lowast; x&and;2 &lowast; y]In[43] := a= Sqrt[12 &lowast; x&and;2 &lowast; y]In[43] := a= Sqrt[12 &lowast; x&and;2 &lowast; y]
Out[43] = 2
</p>
<p>&radic;
3
&radic;
</p>
<p>x2y
</p>
<p>This result can be improved, if we know that x&gt; 0.
In[44] := Simplify[a,x&gt; 0]In[44] := Simplify[a,x&gt; 0]In[44] := Simplify[a,x&gt; 0]
</p>
<p>Out[44] = 2
&radic;
</p>
<p>3x
&radic;
y
</p>
<p>And this is the case x&lt; 0.
In[45] := Simplify[a,x&lt; 0]In[45] := Simplify[a,x&lt; 0]In[45] := Simplify[a,x&lt; 0]
</p>
<p>Out[45] =&minus;2
&radic;
</p>
<p>3x
&radic;
y
</p>
<p>Expansion of trigonometric functions of multiple angles, sums, and differences:
</p>
<p>In[46] := TrigExpand[Cos[2 &lowast; x]]In[46] := TrigExpand[Cos[2 &lowast; x]]In[46] := TrigExpand[Cos[2 &lowast; x]]
Out[46] = Cos[x]2 &minus;Sin[x]2
In[47] := TrigExpand[Sin[x&minus; y]]In[47] := TrigExpand[Sin[x&minus; y]]In[47] := TrigExpand[Sin[x&minus; y]]
Out[47] = Cos[y]Sin[x]&minus;Cos[x]Sin[y]
The inverse operation&mdash;transformation of products and powers of trigonometric
</p>
<p>functions into linear combinations of such functions&mdash;is used more often. Let&rsquo;s take
</p>
<p>a truncated Fourier series.
</p>
<p>In[48] := a= a1&lowast;Cos[x]+ a2&lowast;Cos[2 &lowast; x]+ b1&lowast;Sin[x]+ b2&lowast;Sin[2 &lowast; x]In[48] := a= a1&lowast;Cos[x]+ a2&lowast;Cos[2 &lowast; x]+ b1&lowast;Sin[x]+ b2&lowast;Sin[2 &lowast; x]In[48] := a= a1&lowast;Cos[x]+ a2&lowast;Cos[2 &lowast; x]+ b1&lowast;Sin[x]+ b2&lowast;Sin[2 &lowast; x]
Out[48] = a1Cos[x]+ a2Cos[2x]+ b1Sin[x]+ b2Sin[2x]
Its square is again a truncated Fourier series.
</p>
<p>In[49] := TrigReduce[a&and;2]In[49] := TrigReduce[a&and;2]In[49] := TrigReduce[a&and;2]
</p>
<p>Out[49] =
1
</p>
<p>2
</p>
<p>(
</p>
<p>a12 +a22 +b12 +b22 +2a1a2Cos[x]+2b1b2Cos[x]+a12 Cos[2x]&minus;
b12 Cos[2x]+ 2a1a2Cos[3x]&minus; 2b1b2Cos[3x]+ a22 Cos[4x]&minus; b22 Cos[4x]&minus;
2a2b1Sin[x]+ 2a1b2Sin[x]+ 2a1b1Sin[2x]+ 2a2b1Sin[3x]+
2a1b2Sin[3x]+ 2a2b2Sin[4x]
</p>
<p>)
</p>
<p>2.5 Calculus
</p>
<p>Let&rsquo;s take a function.
</p>
<p>In[50] := f = Log[x&and;5+ x+ 1]+ 1/(x&and;5+ x+ 1)In[50] := f = Log[x&and;5+ x+ 1]+ 1/(x&and;5+ x+ 1)In[50] := f = Log[x&and;5+ x+ 1]+ 1/(x&and;5+ x+ 1)
</p>
<p>Out[50] =
1
</p>
<p>1+ x+ x5
+Log
</p>
<p>[
</p>
<p>1+ x+ x5
]
</p>
<p>Calculate its derivative.</p>
<p/>
</div>
<div class="page"><p/>
<p>14 2 Overview of Mathematica
</p>
<p>In[51] := g= D[ f ,x]In[51] := g= D[ f ,x]In[51] := g= D[ f ,x]
</p>
<p>Out[51] =&minus; 1+ 5x
4
</p>
<p>(1+ x+ x5)
2
+
</p>
<p>1+ 5x4
</p>
<p>1+ x+ x5
</p>
<p>Put over the common denominator.
</p>
<p>In[52] := g= Together[g]In[52] := g= Together[g]In[52] := g= Together[g]
</p>
<p>Out[52] =
</p>
<p>(
</p>
<p>1+ 5x4
)(
</p>
<p>x+ x5
)
</p>
<p>(1+ x+ x5)
2
</p>
<p>A stupid integration algorithm would try to solve the fifth degree equation in the
</p>
<p>denominator, in order to decompose the integrand into partial fractions. Mathemat-
</p>
<p>ica is more clever than that.
</p>
<p>In[53] := Integrate[g,x]In[53] := Integrate[g,x]In[53] := Integrate[g,x]
</p>
<p>Out[53] =
1
</p>
<p>1+ x+ x5
+Log
</p>
<p>[
</p>
<p>1+ x+ x5
]
</p>
<p>Let&rsquo;s expand our function in x at 0 up to x10.
</p>
<p>In[54] := Series[ f ,{x,0,10}]In[54] := Series[ f ,{x,0,10}]In[54] := Series[ f ,{x,0,10}]
</p>
<p>Out[54] = 1+
x2
</p>
<p>2
&minus; 2x
</p>
<p>3
</p>
<p>3
+
</p>
<p>3x4
</p>
<p>4
&minus; 4x
</p>
<p>5
</p>
<p>5
+
</p>
<p>11x6
</p>
<p>6
&minus; 20x
</p>
<p>7
</p>
<p>7
+
</p>
<p>31x8
</p>
<p>8
&minus; 44x
</p>
<p>9
</p>
<p>9
+
</p>
<p>32x10
</p>
<p>5
+O[x]11
</p>
<p>Mathematica can calculate many definite integrals even when the corresponding
</p>
<p>indefinite integral cannot be taken. Here is an integral from 0 to 1.
</p>
<p>In[55] := Integrate[Log[x]&and;2/(x+ 1),{x,0,1}]In[55] := Integrate[Log[x]&and;2/(x+ 1),{x,0,1}]In[55] := Integrate[Log[x]&and;2/(x+ 1),{x,0,1}]
Out[55] =
</p>
<p>3Zeta[3]
</p>
<p>2
Mathematica knows how to sum many series.
</p>
<p>In[56] := Sum[1/n&and;4,{n,1, Infinity}]In[56] := Sum[1/n&and;4,{n,1, Infinity}]In[56] := Sum[1/n&and;4,{n,1, Infinity}]
</p>
<p>Out[56] =
π4
</p>
<p>90
Let&rsquo;s clear all the garbage we have generated&mdash;a very good habit.
</p>
<p>In[57] := Clear[ f ,g]In[57] := Clear[ f ,g]In[57] := Clear[ f ,g]
</p>
<p>2.6 Lists
</p>
<p>We have already encountered this construct several times:
</p>
<p>In[58] := a= {x,y,z}In[58] := a= {x,y,z}In[58] := a= {x,y,z}
Out[58] = {x,y,z}
This is a list. And here are its elements.
</p>
<p>In[59] := a[[1]]In[59] := a[[1]]In[59] := a[[1]]
Out[59] = x
In[60] := a[[2]]In[60] := a[[2]]In[60] := a[[2]]
Out[60] = y
In[61] := a[[3]]In[61] := a[[3]]In[61] := a[[3]]
Out[61] = z
In[62] := Clear[a]In[62] := Clear[a]In[62] := Clear[a]</p>
<p/>
</div>
<div class="page"><p/>
<p>2.7 Plots 15
</p>
<p>2.7 Plots
</p>
<p>A simple plot of a function.
</p>
<p>In[63] := Plot[Sin[x]/x,{x,&minus;10,10}]In[63] := Plot[Sin[x]/x,{x,&minus;10,10}]In[63] := Plot[Sin[x]/x,{x,&minus;10,10}]
</p>
<p>Out[63] =
</p>
<p>A curve given parametrically&mdash;x and y are functions of t. This particular curve
</p>
<p>contains a parameter a, which can be adjusted by the mouse. If you click the small
</p>
<p>plus sign near the marker, a control panel will open. There you can start (and stop)
</p>
<p>animation.
</p>
<p>In[64] := Manipulate[ParametricPlot[{Exp[a &lowast; t]&lowast;Cos[t],Exp[a &lowast; t]&lowast;Sin[t]},In[64] := Manipulate[ParametricPlot[{Exp[a &lowast; t]&lowast;Cos[t],Exp[a &lowast; t]&lowast;Sin[t]},In[64] := Manipulate[ParametricPlot[{Exp[a &lowast; t]&lowast;Cos[t],Exp[a &lowast; t]&lowast;Sin[t]},
{t,0,20},PlotRange&minus;&gt;{{&minus;10,10},{&minus;10,10}}],{{a,0.1},0,0.2}]{t,0,20},PlotRange&minus;&gt;{{&minus;10,10},{&minus;10,10}}],{{a,0.1},0,0.2}]{t,0,20},PlotRange&minus;&gt;{{&minus;10,10},{&minus;10,10}}],{{a,0.1},0,0.2}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>a
</p>
<p>Out[64] =
</p>
<p>A three-dimensional plot of a function of two variables. It can be rotated by the
</p>
<p>mouse.</p>
<p/>
</div>
<div class="page"><p/>
<p>16 2 Overview of Mathematica
</p>
<p>In[65] := Plot3D[x&and;2+ y&and;2,{x,&minus;1,1},{y,&minus;1,1}]In[65] := Plot3D[x&and;2+ y&and;2,{x,&minus;1,1},{y,&minus;1,1}]In[65] := Plot3D[x&and;2+ y&and;2,{x,&minus;1,1},{y,&minus;1,1}]
</p>
<p>Out[65] =
</p>
<p>A three-dimensional curve given parametrically. The parameter a can be adjusted
</p>
<p>by the mouse.
</p>
<p>In[66] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},In[66] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},In[66] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},
PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],{{a,0.1},0,0.2}]PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],{{a,0.1},0,0.2}]PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],{{a,0.1},0,0.2}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>a
</p>
<p>Out[66] =
</p>
<p>A surface given parametrically.</p>
<p/>
</div>
<div class="page"><p/>
<p>2.8 Substitutions 17
</p>
<p>In[67] := ParametricPlot3D[{Sin[t]&lowast;Cos[u],Sin[t]&lowast;Sin[u],Cos[t]},{t,0,Pi},In[67] := ParametricPlot3D[{Sin[t]&lowast;Cos[u],Sin[t]&lowast;Sin[u],Cos[t]},{t,0,Pi},In[67] := ParametricPlot3D[{Sin[t]&lowast;Cos[u],Sin[t]&lowast;Sin[u],Cos[t]},{t,0,Pi},
{u,0,2 &lowast;Pi}]{u,0,2 &lowast;Pi}]{u,0,2 &lowast;Pi}]
</p>
<p>Out[67] =
</p>
<p>2.8 Substitutions
</p>
<p>Substitutions are a fundamental concept in Mathematica, its main working instru-
</p>
<p>ment. This substitution replaces f [x] by x2.
In[68] := S = f [x]&minus;&gt;x&and;2In[68] := S = f [x]&minus;&gt;x&and;2In[68] := S = f [x]&minus;&gt;x&and;2
Out[68] = f [x]&rarr; x2
Let&rsquo;s apply it to the expression f [x].
In[69] := f [x]/.SIn[69] := f [x]/.SIn[69] := f [x]/.S
Out[69] = x2
</p>
<p>We&rsquo;ve got x2, as expected. And what if we apply it to f [y]?
In[70] := f [y]/.SIn[70] := f [y]/.SIn[70] := f [y]/.S
Out[70] = f [y]
It hasn&rsquo;t triggered. The following substitution replaces the function f with an arbi-
</p>
<p>trary argument by the square of this argument.</p>
<p/>
</div>
<div class="page"><p/>
<p>18 2 Overview of Mathematica
</p>
<p>In[71] := S = f [x ]&minus;&gt;x&and;2In[71] := S = f [x ]&minus;&gt;x&and;2In[71] := S = f [x ]&minus;&gt;x&and;2
Out[71] = f [x ]&rarr; x2
Let&rsquo;s check.
</p>
<p>In[72] := { f [x], f [y], f [2]}/.SIn[72] := { f [x], f [y], f [2]}/.SIn[72] := { f [x], f [y], f [2]}/.S
Out[72] =
</p>
<p>{
</p>
<p>x2,y2,4
}
</p>
<p>In[73] := Clear[S]In[73] := Clear[S]In[73] := Clear[S]
</p>
<p>2.9 Equations
</p>
<p>Here is an equation.
</p>
<p>In[74] := Eq = a &lowast; x+ b== 0In[74] := Eq = a &lowast; x+ b== 0In[74] := Eq = a &lowast; x+ b== 0
Out[74] = b+ ax== 0
Let&rsquo;s solve it for x.
</p>
<p>In[75] := S = Solve[Eq,x]In[75] := S = Solve[Eq,x]In[75] := S = Solve[Eq,x]
</p>
<p>Out[75] =
</p>
<p>{{
</p>
<p>x&rarr;&minus;b
a
</p>
<p>}}
</p>
<p>We&rsquo;ve got a list of solutions, in this particular case having a single element. Each
</p>
<p>solution is a list of substitutions, which replaces our unknowns by the corresponding
</p>
<p>expressions. And how can we extract the value of x from this result? Let&rsquo;s take the
</p>
<p>first (and the only) element of the list S.
</p>
<p>In[76] := S1 = First[S]In[76] := S1 = First[S]In[76] := S1 = First[S]
</p>
<p>Out[76] =
</p>
<p>{
</p>
<p>x&rarr;&minus;b
a
</p>
<p>}
</p>
<p>And now we apply this list of substitutions (in this particular case, it&rsquo;s single
</p>
<p>element) to the unknown x.
</p>
<p>In[77] := x/.S1In[77] := x/.S1In[77] := x/.S1
</p>
<p>Out[77] =&minus;b
a
</p>
<p>Here is a more advanced example&mdash;a quadratic equation. It has two solutions.
</p>
<p>In[78] := S = Solve[a &lowast; x&and;2+ b &lowast; x+ c== 0,x]In[78] := S = Solve[a &lowast; x&and;2+ b &lowast; x+ c== 0,x]In[78] := S = Solve[a &lowast; x&and;2+ b &lowast; x+ c== 0,x]
</p>
<p>Out[78] =
</p>
<p>{{
</p>
<p>x&rarr; &minus;b&minus;
&radic;
b2 &minus; 4ac
</p>
<p>2a
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>x&rarr; &minus;b+
&radic;
b2 &minus; 4ac
</p>
<p>2a
</p>
<p>}}
</p>
<p>How can we extract the value of x in the second solution? Let&rsquo;s apply the second
</p>
<p>element of the solutions list S (which is a single-element list of substitutions) to the
</p>
<p>unknown x.
</p>
<p>In[79] := x/.S[[2]]In[79] := x/.S[[2]]In[79] := x/.S[[2]]
</p>
<p>Out[79] =
&minus;b+
</p>
<p>&radic;
b2 &minus; 4ac
</p>
<p>2a
And here is a system of 2 linear equations.
</p>
<p>In[80] := Eq = {a &lowast; x+ b &lowast; y== e,c&lowast; x+ d &lowast; y== f}In[80] := Eq = {a &lowast; x+ b &lowast; y== e,c&lowast; x+ d &lowast; y== f}In[80] := Eq = {a &lowast; x+ b &lowast; y== e,c&lowast; x+ d &lowast; y== f}
Out[80] = {ax+ by== e,cx+ dy== f}
It has a single solution.</p>
<p/>
</div>
<div class="page"><p/>
<p>2.9 Equations 19
</p>
<p>In[81] := S = Solve[Eq,{x,y}]In[81] := S = Solve[Eq,{x,y}]In[81] := S = Solve[Eq,{x,y}]
Out[81] =
</p>
<p>{{
</p>
<p>x&rarr;&minus;de&minus; b f
bc&minus; ad ,y&rarr;&minus;
</p>
<p>&minus;ce+ a f
bc&minus; ad
</p>
<p>}}
</p>
<p>This (first and the only) solution is a list of two substitutions.
</p>
<p>In[82] := S1 = S[[1]]In[82] := S1 = S[[1]]In[82] := S1 = S[[1]]
</p>
<p>Out[82] =
</p>
<p>{
</p>
<p>x&rarr;&minus;de&minus; b f
bc&minus; ad ,y&rarr;&minus;
</p>
<p>&minus;ce+ a f
bc&minus; ad
</p>
<p>}
</p>
<p>How to find the values of x and y in this solution? Apply this list of substitutions to
</p>
<p>the unknowns x and y.
</p>
<p>In[83] := {x/.S1,y/.S1}In[83] := {x/.S1,y/.S1}In[83] := {x/.S1,y/.S1}
Out[83] =
</p>
<p>{
</p>
<p>&minus;de&minus; b f
bc&minus; ad ,&minus;
</p>
<p>&minus;ce+ a f
bc&minus; ad
</p>
<p>}
</p>
<p>In[84] := Clear[Eq,S,S1]In[84] := Clear[Eq,S,S1]In[84] := Clear[Eq,S,S1]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 3
</p>
<p>Expressions
</p>
<p>All objects with which Mathematica works are expressions. There are two classes
</p>
<p>of them&mdash;atoms and composite expressions.
</p>
<p>3.1 Atoms
</p>
<p>There are three kinds of atoms&mdash;numbers, symbols, and strings.
</p>
<p>Numbers
</p>
<p>Integer numbers (of unlimited size).
</p>
<p>In[1] := 1234567890In[1] := 1234567890In[1] := 1234567890
Out[1] = 1234567890
A rational number consists of the numerator and the denominator.
</p>
<p>In[2] := 1234567890/987654321In[2] := 1234567890/987654321In[2] := 1234567890/987654321
</p>
<p>Out[2] =
137174210
</p>
<p>109739369
A complex number consists of the real and imaginary parts.
</p>
<p>In[3] := 1+ 2 &lowast; IIn[3] := 1+ 2 &lowast; IIn[3] := 1+ 2 &lowast; I
Out[3] = 1+ 2i
Real numbers can have arbitrarily high precision.
</p>
<p>In[4] := 1234567890.987654321In[4] := 1234567890.987654321In[4] := 1234567890.987654321
Out[4] = 1.23456789098765432&times;109
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 3, &copy; Springer International Publishing Switzerland 2014
</p>
<p>21</p>
<p/>
</div>
<div class="page"><p/>
<p>22 3 Expressions
</p>
<p>Symbols
</p>
<p>A variable can be in one of two states. Initially it is free&mdash;it means itself (a symbol).
</p>
<p>In[5] := xIn[5] := xIn[5] := x
Out[5] = x
Assigning a value to it, we make it bound.
</p>
<p>In[6] := x= 123In[6] := x= 123In[6] := x= 123
Out[6] = 123
Now, when we use it (e.g., just by asking Mathematica to print it), its value is
</p>
<p>substituted.
</p>
<p>In[7] := xIn[7] := xIn[7] := x
Out[7] = 123
How to make it free again?
</p>
<p>In[8] := Clear[x]In[8] := Clear[x]In[8] := Clear[x]
Let&rsquo;s check.
</p>
<p>In[9] := xIn[9] := xIn[9] := x
Out[9] = x
</p>
<p>Strings
</p>
<p>In[10] := &rdquo;This is a string&rdquo;In[10] := &rdquo;This is a string&rdquo;In[10] := &rdquo;This is a string&rdquo;
Out[10] = This is a string
</p>
<p>3.2 Composite Expressions
</p>
<p>A composite expression is a function of a number of arguments, each of which is an
</p>
<p>expression (i.e., an atom or a composite expression).
</p>
<p>In[11] := a= f [g[x,1],h[y,z,2]]In[11] := a= f [g[x,1],h[y,z,2]]In[11] := a= f [g[x,1],h[y,z,2]]
Out[11] = f [g[x,1],h[y,z,2]]
Each composite expression has a head&mdash;the function which is applied to arguments.
</p>
<p>In[12] := Head[a]In[12] := Head[a]In[12] := Head[a]
Out[12] = f
The number of arguments is given by the function Length.
</p>
<p>In[13] := Length[a]In[13] := Length[a]In[13] := Length[a]
Out[13] = 2
Arguments are extracted by the function Part.
</p>
<p>In[14] := Part[a,1]In[14] := Part[a,1]In[14] := Part[a,1]
Out[14] = g[x,1]
In[15] := Part[a,2]In[15] := Part[a,2]In[15] := Part[a,2]
Out[15] = h[y,z,2]
And this is the first part of the second part of the expression a.</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2 Composite Expressions 23
</p>
<p>In[16] := Part[a,2,1]In[16] := Part[a,2,1]In[16] := Part[a,2,1]
Out[16] = y
An alternative syntax.
</p>
<p>In[17] := a[[2,1]]In[17] := a[[2,1]]In[17] := a[[2,1]]
Out[17] = y
Zeroth part of an expression is its head.
</p>
<p>In[18] := Part[a,0]In[18] := Part[a,0]In[18] := Part[a,0]
Out[18] = f
By the way, a head can be any expression, not just a symbol.
</p>
<p>In[19] := b= f [x][y,1]In[19] := b= f [x][y,1]In[19] := b= f [x][y,1]
Out[19] = f [x][y,1]
In[20] := Head[b]In[20] := Head[b]In[20] := Head[b]
Out[20] = f [x]
Expressions are trees whose leaves are atoms.
</p>
<p>In[21] := TreeForm[a]In[21] := TreeForm[a]In[21] := TreeForm[a]
</p>
<p>f
</p>
<p>g
</p>
<p>x 1
</p>
<p>h
</p>
<p>y z 2
</p>
<p>Out[21]//TreeForm =
</p>
<p>Parts of an expressions can be changed.
</p>
<p>In[22] := a[[1,2]] = 0; aIn[22] := a[[1,2]] = 0; aIn[22] := a[[1,2]] = 0; a
Out[22] = f [g[x,0],h[y,z,2]]
In[23] := a[[0]] = j; aIn[23] := a[[0]] = j; aIn[23] := a[[0]] = j; a
Out[23] = j[g[x,0],h[y,z,2]]
</p>
<p>A group of arguments can be selected, not just a single argument.
</p>
<p>In[24] := b= f [x1,x2,x3,x4,x5,x6]In[24] := b= f [x1,x2,x3,x4,x5,x6]In[24] := b= f [x1,x2,x3,x4,x5,x6]
Out[24] = f [x1,x2,x3,x4,x5,x6]
In[25] := Part[b,Span[2,4]]In[25] := Part[b,Span[2,4]]In[25] := Part[b,Span[2,4]]
Out[25] = f [x2,x3,x4]
An alternative syntax.
</p>
<p>In[26] := b[[2; ;4]]In[26] := b[[2; ;4]]In[26] := b[[2; ;4]]
Out[26] = f [x2,x3,x4]</p>
<p/>
</div>
<div class="page"><p/>
<p>24 3 Expressions
</p>
<p>From the beginning to 3:
</p>
<p>In[27] := b[[; ;3]]In[27] := b[[; ;3]]In[27] := b[[; ;3]]
Out[27] = f [x1,x2,x3]
From 4 to the end:
</p>
<p>In[28] := b[[4; ; ]]In[28] := b[[4; ; ]]In[28] := b[[4; ; ]]
Out[28] = f [x4,x5,x6]
From 1 to 5 by 2:
</p>
<p>In[29] := b[[1; ;5; ;2]]In[29] := b[[1; ;5; ;2]]In[29] := b[[1; ;5; ;2]]
Out[29] = f [x1,x3,x5]
If such a form is used in the left-hand side of an assignment, each of the selected
</p>
<p>arguments will be replaced:
</p>
<p>In[30] := b[[1; ;5; ;2]] = x; bIn[30] := b[[1; ;5; ;2]] = x; bIn[30] := b[[1; ;5; ;2]] = x; b
Out[30] = f [x,x2,x,x4,x,x6]
In[31] := Clear[a,b]In[31] := Clear[a,b]In[31] := Clear[a,b]
</p>
<p>3.3 Queries
</p>
<p>Let&rsquo;s define an integer number, a rational number, a real (floating point) number,
</p>
<p>and a complex number.
</p>
<p>In[32] := i=&minus;1234567890; r =&minus;1234567890/987654321;In[32] := i=&minus;1234567890; r =&minus;1234567890/987654321;In[32] := i=&minus;1234567890; r =&minus;1234567890/987654321;
f =&minus;1234567890987654321.1234567890987654321; c= 1&minus; 2 &lowast; I;f =&minus;1234567890987654321.1234567890987654321; c= 1&minus; 2 &lowast; I;f =&minus;1234567890987654321.1234567890987654321; c= 1&minus; 2 &lowast; I;
</p>
<p>The query AtomQ (Q from Query) returns the symbol True if its argument is an
</p>
<p>atom and False if it is a composite expression.
</p>
<p>In[33] := {AtomQ[i],AtomQ[r],AtomQ[c],AtomQ[ f [x]]}In[33] := {AtomQ[i],AtomQ[r],AtomQ[c],AtomQ[ f [x]]}In[33] := {AtomQ[i],AtomQ[r],AtomQ[c],AtomQ[ f [x]]}
Out[33] = {True,True,True,False}
The function Head can be applied even to atoms.
</p>
<p>In[34] := {Head[i],Head[r],Head[c],Head[ f ]}In[34] := {Head[i],Head[r],Head[c],Head[ f ]}In[34] := {Head[i],Head[r],Head[c],Head[ f ]}
Out[34] = {Integer,Rational,Complex,Real}
The function FullForm shows the internal form of an expression with which Math-
</p>
<p>ematica operates (to some approximation). For example, a rational number has the
</p>
<p>head Rational and two arguments&mdash;its numerator and denominator.
</p>
<p>In[35] := FullForm[r]In[35] := FullForm[r]In[35] := FullForm[r]
Out[35]//FullForm=
</p>
<p>Rational[&minus;137174210,109739369]
A complex number has the head Complex and two arguments&mdash;its real and imagi-
</p>
<p>nary parts.
</p>
<p>In[36] := FullForm[c]In[36] := FullForm[c]In[36] := FullForm[c]
Out[36]//FullForm=
</p>
<p>Complex[1,&minus;2]
The internal representation of a floating point number is rather complicated.
</p>
<p>It contains the mantissa and the exponent and also the number of significant
</p>
<p>(decimal) digits. In this particular case, there are 37 significant digits.</p>
<p/>
</div>
<div class="page"><p/>
<p>3.4 Forms of an Expression 25
</p>
<p>In[37] := FullForm[ f ]In[37] := FullForm[ f ]In[37] := FullForm[ f ]
Out[37]//FullForm=
</p>
<p>&minus;1.2345678909876543211234567890987654321 3̀7.09151497751671&lowast;&and;18
The query IntegerQ checks if its argument is an integer number.
</p>
<p>In[38] := {IntegerQ[i], IntegerQ[r], IntegerQ[c]}In[38] := {IntegerQ[i], IntegerQ[r], IntegerQ[c]}In[38] := {IntegerQ[i], IntegerQ[r], IntegerQ[c]}
Out[38] = {True,False,False}
The functions Numerator and Denominator extract the parts of a rational number.
</p>
<p>In[39] := {Numerator[r],Denominator[r]}In[39] := {Numerator[r],Denominator[r]}In[39] := {Numerator[r],Denominator[r]}
Out[39] = {&minus;137174210,109739369}
The functions Re and Im extract the real and imaginary parts of a complex number.
</p>
<p>In[40] := {Re[c], Im[c]}In[40] := {Re[c], Im[c]}In[40] := {Re[c], Im[c]}
Out[40] = {1,&minus;2}
In[41] := Clear[i,r, f ,c]In[41] := Clear[i,r, f ,c]In[41] := Clear[i,r, f ,c]
</p>
<p>3.4 Forms of an Expression
</p>
<p>FullForm is a very useful function. It shows what Mathematica really thinks about
</p>
<p>an expression. Use it often, and you will learn a lot. For example, the following
</p>
<p>expression is a sum of 4 terms, one of which is the number &minus;1 multiplied by the
symbol z.
</p>
<p>In[42] := FullForm[x+ y&minus; z&minus; 1]In[42] := FullForm[x+ y&minus; z&minus; 1]In[42] := FullForm[x+ y&minus; z&minus; 1]
Out[42]//FullForm=
</p>
<p>Plus[&minus;1,x,y,Times[&minus;1,z]]
And this one is a product of 4 factors, among which are the rational number 2/3 and
the negative power z&minus;1.
In[43] := a= 2 &lowast; x&lowast; y/(3 &lowast; z)In[43] := a= 2 &lowast; x&lowast; y/(3 &lowast; z)In[43] := a= 2 &lowast; x&lowast; y/(3 &lowast; z)
Out[43] =
</p>
<p>2xy
</p>
<p>3z
In[44] := FullForm[a]In[44] := FullForm[a]In[44] := FullForm[a]
Out[44]//FullForm=
</p>
<p>Times[Rational[2,3],x,y,Power[z,&minus;1]]
Nevertheless, the functions Numerator and Denominator work as expected.
</p>
<p>In[45] := {Numerator[a],Denominator[a]}In[45] := {Numerator[a],Denominator[a]}In[45] := {Numerator[a],Denominator[a]}
Out[45] = {2xy,3z}
In[46] := Clear[a]In[46] := Clear[a]In[46] := Clear[a]
We have already handled lists many times. A list appears to be just the function List
</p>
<p>with arguments&mdash;elements of the list.
</p>
<p>In[47] := FullForm[{x,y,z}]In[47] := FullForm[{x,y,z}]In[47] := FullForm[{x,y,z}]
Out[47]//FullForm=
</p>
<p>List[x,y,z]
Any Mathematica command can be written as a function with arguments
</p>
<p>(sometimes, it can also be written in some other way). For example, assignment
</p>
<p>is the function Set. In order to see this, we&rsquo;ll have to put an assignment inside</p>
<p/>
</div>
<div class="page"><p/>
<p>26 3 Expressions
</p>
<p>the function Hold. Otherwise it would be executed immediately, and the function
</p>
<p>FullForm would receive only the result returned by the assignment&mdash;the symbol x.
</p>
<p>In[48] := FullForm[Hold[a= x]]In[48] := FullForm[Hold[a= x]]In[48] := FullForm[Hold[a= x]]
Out[48]//FullForm=
</p>
<p>Hold[Set[a,x]]
Here is a rational expression.
</p>
<p>In[49] := a= Together[x/(x+ y)+ y/(x&minus; y)]In[49] := a= Together[x/(x+ y)+ y/(x&minus; y)]In[49] := a= Together[x/(x+ y)+ y/(x&minus; y)]
</p>
<p>Out[49] =
x2 + y2
</p>
<p>(x&minus; y)(x+ y)
Its full form:
</p>
<p>In[50] := FullForm[a]In[50] := FullForm[a]In[50] := FullForm[a]
Out[50]//FullForm=
</p>
<p>Times[Power[Plus[x,Times[&minus;1,y]],&minus;1],Power[Plus[x,y],&minus;1],
Plus[Power[x,2],Power[y,2]]]
</p>
<p>And this is the same expression as a tree.
</p>
<p>In[51] := TreeForm[a]In[51] := TreeForm[a]In[51] := TreeForm[a]
</p>
<p>Times
</p>
<p>Power
</p>
<p>Plus
</p>
<p>x Times
</p>
<p>1 y
</p>
<p>1
</p>
<p>Power
</p>
<p>Plus
</p>
<p>x y
</p>
<p>1
</p>
<p>Plus
</p>
<p>Power
</p>
<p>x 2
</p>
<p>Power
</p>
<p>y 2
</p>
<p>Out[51]//TreeForm =
</p>
<p>In[52] := Clear[a]In[52] := Clear[a]In[52] := Clear[a]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 4
</p>
<p>Patterns and Substitutions
</p>
<p>Substitution is the most fundamental operation in Mathematica. Its left-hand side is
</p>
<p>a pattern. In a given expression, all subexpressions matching the pattern are found
</p>
<p>and replaced by the right-hand side of the substitution.
</p>
<p>4.1 Simple Patterns
</p>
<p>f [x] with a specific argument x.
In[1] := { f [x], f [y]}/. f [x]&minus;&gt;x&and;2In[1] := { f [x], f [y]}/. f [x]&minus;&gt;x&and;2In[1] := { f [x], f [y]}/. f [x]&minus;&gt;x&and;2
Out[1] =
</p>
<p>{
</p>
<p>x2, f [y]
}
</p>
<p>f with an arbitrary argument.
</p>
<p>In[2] := { f [x], f [y]}/. f [x ]&minus;&gt;x&and;2In[2] := { f [x], f [y]}/. f [x ]&minus;&gt;x&and;2In[2] := { f [x], f [y]}/. f [x ]&minus;&gt;x&and;2
Out[2] =
</p>
<p>{
</p>
<p>x2,y2
}
</p>
<p>f with two identical (arbitrary) arguments.
</p>
<p>In[3] := { f [x,x], f [x,y]}/. f [x ,x ]&minus;&gt;g[x]In[3] := { f [x,x], f [x,y]}/. f [x ,x ]&minus;&gt;g[x]In[3] := { f [x,x], f [x,y]}/. f [x ,x ]&minus;&gt;g[x]
Out[3] = {g[x], f [x,y]}
An example of a more complicated pattern.
</p>
<p>In[4] := f [g[ f [x],y],h[ f [x]]]/. f [g[x ,y],h[x ]]&minus;&gt;F [x,y]In[4] := f [g[ f [x],y],h[ f [x]]]/. f [g[x ,y],h[x ]]&minus;&gt;F[x,y]In[4] := f [g[ f [x],y],h[ f [x]]]/. f [g[x ,y],h[x ]]&minus;&gt;F[x,y]
Out[4] = F [ f [x],y]
f with an argument being an arbitrary integer number.
</p>
<p>In[5] := { f [x], f [2]}/. f [x Integer]&minus;&gt;x&and;2In[5] := { f [x], f [2]}/. f [x Integer]&minus;&gt;x&and;2In[5] := { f [x], f [2]}/. f [x Integer]&minus;&gt;x&and;2
Out[5] = { f [x],4}
In fact, such a form of an arbitrary argument checks its head. This substitution
</p>
<p>applies when the argument&rsquo;s head is g.
</p>
<p>In[6] := { f [g[x,y]], f [h[x,y]]}/. f [x g]&minus;&gt;x&and;2In[6] := { f [g[x,y]], f [h[x,y]]}/. f [x g]&minus;&gt;x&and;2In[6] := { f [g[x,y]], f [h[x,y]]}/. f [x g]&minus;&gt;x&and;2
Out[6] =
</p>
<p>{
</p>
<p>g[x,y]2, f [h[x,y]]
}
</p>
<p>And this one&mdash;when the argument is a sum.
</p>
<p>In[7] := { f [{x,y}], f [x+ y]}/. f [x Plus]&minus;&gt;x&and;2In[7] := { f [{x,y}], f [x+ y]}/. f [x Plus]&minus;&gt;x&and;2In[7] := { f [{x,y}], f [x+ y]}/. f [x Plus]&minus;&gt;x&and;2
Out[7] =
</p>
<p>{
</p>
<p>f [{x,y}],(x+ y)2
}
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 4, &copy; Springer International Publishing Switzerland 2014
</p>
<p>27</p>
<p/>
</div>
<div class="page"><p/>
<p>28 4 Patterns and Substitutions
</p>
<p>And this one&mdash;when the argument is a list. By the way, note what happens when a
</p>
<p>list is being squared.
</p>
<p>In[8] := { f [{x,y}], f [x+ y]}/. f [x List]&minus;&gt;x&and;2In[8] := { f [{x,y}], f [x+ y]}/. f [x List]&minus;&gt;x&and;2In[8] := { f [{x,y}], f [x+ y]}/. f [x List]&minus;&gt;x&and;2
Out[8] =
</p>
<p>{{
</p>
<p>x2,y2
}
</p>
<p>, f [x+ y]
}
</p>
<p>One more example.
</p>
<p>In[9] := a= Sqrt[x]/Sqrt[y]In[9] := a= Sqrt[x]/Sqrt[y]In[9] := a= Sqrt[x]/Sqrt[y]
</p>
<p>Out[9] =
</p>
<p>&radic;
x&radic;
y
</p>
<p>In[10] := a/.{Sqrt[x]&minus;&gt;u,Sqrt[y]&minus;&gt;v}In[10] := a/.{Sqrt[x]&minus;&gt;u,Sqrt[y]&minus;&gt;v}In[10] := a/.{Sqrt[x]&minus;&gt;u,Sqrt[y]&minus;&gt;v}
Out[10] =
</p>
<p>u&radic;
y
</p>
<p>Why hasn&rsquo;t the second substitution triggered?
</p>
<p>In[11] := FullForm[a]In[11] := FullForm[a]In[11] := FullForm[a]
Out[11]//FullForm=
</p>
<p>Times[Power[x,Rational[1,2]],Power[y,Rational[&minus;1,2]]]
a does not contain y1/2, only y&minus;1/2; therefore, the substitution y1/2 &rarr; v does not
work.
</p>
<p>Out[11] = Clear[a]
</p>
<p>4.2 One-Shot and Repeated Substitutions
</p>
<p>Here is an expression.
</p>
<p>In[12] := a= x&and;2+ y&and;2In[12] := a= x&and;2+ y&and;2In[12] := a= x&and;2+ y&and;2
Out[12] = x2 + y2
</p>
<p>Let&rsquo;s increase x by 1 in it. This example demonstrates that a substitution is not
</p>
<p>applied repeatedly. Mathematica searches for subexpressions matching the pattern
</p>
<p>(in this case x) in the expression a. After finding such a subexpression,Mathematica
</p>
<p>replaces it by the right-hand side. The result of such a replacement is not searched
</p>
<p>again for subexpressions matching the pattern.
</p>
<p>In[13] := a= a/.x&minus;&gt;x+ 1In[13] := a= a/.x&minus;&gt;x+ 1In[13] := a= a/.x&minus;&gt;x+ 1
Out[13] = (1+ x)2 + y2
</p>
<p>A list of substitutions can be applied to an expression. They are all applied in
</p>
<p>parallel&mdash;Mathematica searches for subexpressions matching some pattern from
</p>
<p>the list and replaces these subexpressions by the corresponding right-hand side.
</p>
<p>Therefore two symbols can be interchanged in an expression in this simple way.
</p>
<p>In[14] := a= a/.{x&minus;&gt;y,y&minus;&gt;x}In[14] := a= a/.{x&minus;&gt;y,y&minus;&gt;x}In[14] := a= a/.{x&minus;&gt;y,y&minus;&gt;x}
Out[14] = x2 +(1+ y)2
</p>
<p>In[15] := Clear[a]In[15] := Clear[a]In[15] := Clear[a]
The operator //. (in contrast to /.) applies a substitution repeatedly, while it is
</p>
<p>applicable. If several substitutions are applicable to some subexpression, Mathe-
</p>
<p>matica first applies the most specific one (it is not always easy to determine which
</p>
<p>substitution is more specific and which is more general; in simple cases, this is
</p>
<p>clear).</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3 Products 29
</p>
<p>In[16] := fac[10]//.{fac[0]&minus;&gt;1, fac[n ]&minus;&gt;n &lowast; fac[n&minus; 1]}In[16] := fac[10]//.{fac[0]&minus;&gt;1, fac[n ]&minus;&gt;n &lowast; fac[n&minus; 1]}In[16] := fac[10]//.{fac[0]&minus;&gt;1, fac[n ]&minus;&gt;n &lowast; fac[n&minus; 1]}
Out[16] = 3628800
By the way, what are the real names of /. and //. ?
In[17] := FullForm[Hold[a/.x&minus;&gt;y]]In[17] := FullForm[Hold[a/.x&minus;&gt;y]]In[17] := FullForm[Hold[a/.x&minus;&gt;y]]
Out[17]//FullForm=
</p>
<p>Hold[ReplaceAll[a,Rule[x,y]]]
In[18] := FullForm[Hold[a//.x&minus;&gt;y]]In[18] := FullForm[Hold[a//.x&minus;&gt;y]]In[18] := FullForm[Hold[a//.x&minus;&gt;y]]
Out[18]//FullForm=
</p>
<p>Hold[ReplaceRepeated[a,Rule[x,y]]]
</p>
<p>4.3 Products
</p>
<p>Let&rsquo;s take a product.
</p>
<p>In[19] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]In[19] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]In[19] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]
Out[19]//FullForm=
</p>
<p>Times[2,x,y,z]
The pattern xy is considered contained in this product, though the internal
</p>
<p>representation of a does not contain Times[x,y] explicitly.
In[20] := a/.x&lowast; y&minus;&gt;zIn[20] := a/.x&lowast; y&minus;&gt;zIn[20] := a/.x&lowast; y&minus;&gt;z
Out[20] = 2z2
</p>
<p>And this product does not contain xy.
</p>
<p>In[21] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[21] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[21] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]
Out[21]//FullForm=
</p>
<p>Times[2,Power[x,2],y,z]
In[22] := a/.x&lowast; y&minus;&gt;zIn[22] := a/.x&lowast; y&minus;&gt;zIn[22] := a/.x&lowast; y&minus;&gt;z
Out[22] = 2x2yz
</p>
<p>This product contains powers of x and y.
</p>
<p>In[23] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z]In[23] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z]In[23] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z]
Out[23]//FullForm=
</p>
<p>Times[2,Power[x,2],Power[y,3],z]
We want to replace each product of powers of x and y by the function f of these
</p>
<p>powers. Such a problem occurs very often. For example, we want to integrate some
</p>
<p>class of expressions, and we know the result of integration as a function of powers
</p>
<p>of some variables (or subexpressions).
</p>
<p>In[24] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[24] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[24] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]
Out[24] = 2z f [2,3]
This works OK. And here?
</p>
<p>In[25] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[25] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[25] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]
Out[25]//FullForm=
</p>
<p>Times[2,Power[x,2],y,z]
In[26] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[26] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[26] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]
Out[26] = 2x2yz</p>
<p/>
</div>
<div class="page"><p/>
<p>30 4 Patterns and Substitutions
</p>
<p>This doesn&rsquo;t work. The product a does not contain a product of powers of x and y:
</p>
<p>the symbol y is not in the argument of the function Power. In the next example the
</p>
<p>substitution works again&mdash;as we have seen, Mathematica considers dividing by y as
</p>
<p>multiplying by y&minus;1.
In[27] := FullForm[a= 2 &lowast; x&and;2 &lowast; z/y]In[27] := FullForm[a= 2 &lowast; x&and;2 &lowast; z/y]In[27] := FullForm[a= 2 &lowast; x&and;2 &lowast; z/y]
Out[27]//FullForm=
</p>
<p>Times[2,Power[x,2],Power[y,&minus;1],z]
In[28] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[28] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]In[28] := a/.x&and;n &lowast; y&and;m &minus;&gt; f [n,m]
Out[28] = 2z f [2,&minus;1]
Let&rsquo;s return to the previous expression. How can we instruct Mathematica to
</p>
<p>consider y as a particular case of the pattern &ldquo;y to an arbitrary power&rdquo;? This is what
</p>
<p>an optional arbitrary argument m . is for. When it is used in an exponent, its default
value (which is used when there is no power at all) is 1.
</p>
<p>In[29] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[29] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]In[29] := FullForm[a= 2 &lowast; x&and;2 &lowast; y&lowast; z]
Out[29]//FullForm=
</p>
<p>Times[2,Power[x,2],y,z]
In[30] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[30] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[30] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]
Out[30] = 2z f [2,1]
In[31] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]In[31] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]In[31] := FullForm[a= 2 &lowast; x&lowast; y&lowast; z]
Out[31]//FullForm=
</p>
<p>Times[2,x,y,z]
In[32] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[32] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[32] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]
Out[32] = 2z f [1,1]
So far so good. But what if the symbol y is absent? Will Mathematica consider this
</p>
<p>as a particular case of the pattern &ldquo;y to an arbitrary power&rdquo; with the power equal 0?
</p>
<p>It will not.
</p>
<p>In[33] := FullForm[a= 2 &lowast; x&and;2 &lowast; z]In[33] := FullForm[a= 2 &lowast; x&and;2 &lowast; z]In[33] := FullForm[a= 2 &lowast; x&and;2 &lowast; z]
Out[33]//FullForm=
</p>
<p>Times[2,Power[x,2],z]
In[34] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[34] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]In[34] := a/.x&and;n .&lowast; y&and;m .&minus;&gt; f [n,m]
Out[34] = 2x2z
</p>
<p>The following method will work always. Let&rsquo;s collect several test expressions to
</p>
<p>a list.
</p>
<p>In[35] := a= {2 &lowast; x&lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z,2 &lowast; x&and;2 &lowast; z/y,2 &lowast; x&and;2 &lowast; z,In[35] := a= {2 &lowast; x&lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z,2 &lowast; x&and;2 &lowast; z/y,2 &lowast; x&and;2 &lowast; z,In[35] := a= {2 &lowast; x&lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&lowast; z,2 &lowast; x&and;2 &lowast; y&and;3 &lowast; z,2 &lowast; x&and;2 &lowast; z/y,2 &lowast; x&and;2 &lowast; z,
2 &lowast; z}2 &lowast; z}2 &lowast; z}
</p>
<p>Out[35] =
</p>
<p>{
</p>
<p>2xyz,2x2yz,2x2y3z,
2x2z
</p>
<p>y
,2x2z,2z
</p>
<p>}
</p>
<p>The method is as follows. Multiply our expression by f [0,0], and apply a list of
substitutions. If f with some arguments is multiplied by an arbitrary power of x,
</p>
<p>then the first argument of f is increased by this power. Of course, if x is not raised
</p>
<p>to any power, we want to use the default power equal to 1. Powers of y are treated in
</p>
<p>the same way. We need to use the repeated substitution //.&mdash;after one substitution
from the list has been applied (e.g., the one about x), we want the other one to be
</p>
<p>applied to the result (to take y into account).</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4 Sums 31
</p>
<p>In[36] := s= {x&and;l .&lowast; f [n ,m ]&minus;&gt; f [n+ l,m],y&and;l .&lowast; f [n ,m ]&minus;&gt; f [n,m+ l]}In[36] := s= {x&and;l .&lowast; f [n ,m ]&minus;&gt; f [n+ l,m],y&and;l .&lowast; f [n ,m ]&minus;&gt; f [n,m+ l]}In[36] := s= {x&and;l .&lowast; f [n ,m ]&minus;&gt; f [n+ l,m],y&and;l .&lowast; f [n ,m ]&minus;&gt; f [n,m+ l]}
Out[36] =
</p>
<p>{
</p>
<p>xl . f [n ,m ]&rarr; f [l+ n,m],yl . f [n ,m ]&rarr; f [n, l+m]
}
</p>
<p>In[37] := a &lowast; f [0,0]//.sIn[37] := a &lowast; f [0,0]//.sIn[37] := a &lowast; f [0,0]//.s
Out[37] = {2z f [1,1],2z f [2,1],2z f [2,3],2z f [2,&minus;1],2z f [2,0],2z f [0,0]}
In[38] := Clear[a,s]In[38] := Clear[a,s]In[38] := Clear[a,s]
</p>
<p>4.4 Sums
</p>
<p>Substitutions for sums are similar to those for products. They are used much more
</p>
<p>rarely. Don&rsquo;t use them if you can avoid this.
</p>
<p>In[39] := FullForm[a= x+ y+ z+ 2]In[39] := FullForm[a= x+ y+ z+ 2]In[39] := FullForm[a= x+ y+ z+ 2]
Out[39]//FullForm=
</p>
<p>Plus[2,x,y,z]
In[40] := a/.x+ y&minus;&gt;zIn[40] := a/.x+ y&minus;&gt;zIn[40] := a/.x+ y&minus;&gt;z
Out[40] = 2+ 2z
In[41] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[41] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[41] := FullForm[a= 2 &lowast; x+ y+ z+ 2]
Out[41]//FullForm=
</p>
<p>Plus[2,Times[2,x],y,z]
In[42] := a/.x+ y&minus;&gt;zIn[42] := a/.x+ y&minus;&gt;zIn[42] := a/.x+ y&minus;&gt;z
Out[42] = 2+ 2x+ y+ z
This substitution replaces a sum of x and y with arbitrary coefficients by the function
</p>
<p>f of these coefficients.
</p>
<p>In[43] := FullForm[a= 2 &lowast; x+ 3 &lowast; y+ z+2]In[43] := FullForm[a= 2 &lowast; x+ 3 &lowast; y+ z+2]In[43] := FullForm[a= 2 &lowast; x+ 3 &lowast; y+ z+2]
Out[43]//FullForm=
</p>
<p>Plus[2,Times[2,x],Times[3,y],z]
In[44] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[44] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[44] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]
Out[44] = 2+ z+ f [2,3]
In[45] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[45] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[45] := FullForm[a= 2 &lowast; x+ y+ z+ 2]
Out[45]//FullForm=
</p>
<p>Plus[2,Times[2,x],y,z]
In[46] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[46] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[46] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]
Out[46] = 2+ 2x+ y+ z
In[47] := FullForm[a= 2 &lowast; x&minus; y+ z+ 2]In[47] := FullForm[a= 2 &lowast; x&minus; y+ z+ 2]In[47] := FullForm[a= 2 &lowast; x&minus; y+ z+ 2]
Out[47]//FullForm=
</p>
<p>Plus[2,Times[2,x],Times[&minus;1,y],z]
In[48] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[48] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]In[48] := a/.n &lowast; x+m &lowast; y&minus;&gt; f [n,m]
Out[48] = 2+ z+ f [2,&minus;1]
Here again an optional arbitrary argument can be used. When it is used as a factor,
</p>
<p>a subexpression is considered matching this pattern even if there is no such a factor,
</p>
<p>and its value in this case is taken to be 1.</p>
<p/>
</div>
<div class="page"><p/>
<p>32 4 Patterns and Substitutions
</p>
<p>In[49] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[49] := FullForm[a= 2 &lowast; x+ y+ z+ 2]In[49] := FullForm[a= 2 &lowast; x+ y+ z+ 2]
Out[49]//FullForm=
</p>
<p>Plus[2,Times[2,x],y,z]
In[50] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[50] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[50] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]
Out[50] = 2+ z+ f [2,1]
In[51] := FullForm[a= x+ y+ z+ 2]In[51] := FullForm[a= x+ y+ z+ 2]In[51] := FullForm[a= x+ y+ z+ 2]
Out[51]//FullForm=
</p>
<p>Plus[2,x,y,z]
In[52] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[52] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[52] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]
Out[52] = 2+ z+ f [1,1]
In[53] := FullForm[a= x+ z+ 2]In[53] := FullForm[a= x+ z+ 2]In[53] := FullForm[a= x+ z+ 2]
Out[53]//FullForm=
</p>
<p>Plus[2,x,z]
In[54] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[54] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]In[54] := a/.n .&lowast; x+m .&lowast; y&minus;&gt; f [n,m]
Out[54] = 2+ x+ z
And here is our method which always works.
</p>
<p>In[55] := a= {x+ y+ z+ 2,2 &lowast; x+ y+ z+ 2,2&lowast; x+3&lowast; y+ z+2,2&lowast; x&minus; y+ z+2,In[55] := a= {x+ y+ z+ 2,2 &lowast; x+ y+ z+2,2&lowast; x+3&lowast; y+ z+2,2&lowast; x&minus; y+ z+2,In[55] := a= {x+ y+ z+ 2,2 &lowast; x+ y+ z+2,2&lowast; x+3&lowast; y+ z+ 2,2&lowast; x&minus; y+ z+2,
x+ z+ 2,z+ 2}x+ z+ 2,z+ 2}x+ z+ 2,z+ 2}
</p>
<p>Out[55] = {2+x+y+z,2+2x+y+z,2+2x+3y+z,2+2x&minus;y+z,2+x+z,2+z}
In[56] := s= {l .&lowast; x+ f [n ,m ]&minus;&gt; f [n+ l,m], l .&lowast; y+ f [n ,m ]&minus;&gt; f [n,m+ l]}In[56] := s= {l .&lowast; x+ f [n ,m ]&minus;&gt; f [n+ l,m], l .&lowast; y+ f [n ,m ]&minus;&gt; f [n,m+ l]}In[56] := s= {l .&lowast; x+ f [n ,m ]&minus;&gt; f [n+ l,m], l .&lowast; y+ f [n ,m ]&minus;&gt; f [n,m+ l]}
Out[56] = { f [n ,m ]+ x l .&rarr; f [l+ n,m], f [n ,m ]+ y l .&rarr; f [n, l+m]}
In[57] := a+ f [0,0]//.sIn[57] := a+ f [0,0]//.sIn[57] := a+ f [0,0]//.s
Out[57] = {2+ z+ f [1,1],2+ z+ f [2,1],2+ z+ f [2,3],2+ z+ f [2,&minus;1],
</p>
<p>2+ z+ f [1,0],2+ z+ f [0,0]}
In[58] := Clear[a,s]In[58] := Clear[a,s]In[58] := Clear[a,s]
</p>
<p>4.5 Conditions
</p>
<p>Substitutions which apply only when an arbitrary variable satisfies some condition
</p>
<p>are often needed.
</p>
<p>In[59] := { f [1.5], f [3/2], f [x/2]}/. f [x ?NumberQ]&minus;&gt;x&and;2In[59] := { f [1.5], f [3/2], f [x/2]}/. f [x ?NumberQ]&minus;&gt;x&and;2In[59] := { f [1.5], f [3/2], f [x/2]}/. f [x ?NumberQ]&minus;&gt;x&and;2
Out[59] =
</p>
<p>{
</p>
<p>2.25,
9
</p>
<p>4
, f
</p>
<p>[ x
</p>
<p>2
</p>
<p>]
</p>
<p>}
</p>
<p>But this method is not very general. It checks a condition depending on a single
</p>
<p>variable. The operator /; can be applied to a pattern (or its part). It can be read as
&ldquo;such that.&rdquo; The condition in it can depend on several arbitrary variables.
</p>
<p>In[60] := s= {fac[0]&minus;&gt;1, fac[n Integer/;n&gt; 0]&minus;&gt;n &lowast; fac[n&minus; 1]}In[60] := s= {fac[0]&minus;&gt;1, fac[n Integer/;n&gt; 0]&minus;&gt;n &lowast; fac[n&minus; 1]}In[60] := s= {fac[0]&minus;&gt;1, fac[n Integer/;n&gt; 0]&minus;&gt;n &lowast; fac[n&minus; 1]}
Out[60] = {fac[0]&rarr; 1, fac[n Integer/;n&gt; 0]&rarr; n fac[&minus;1+ n]}
In[61] := {fac[10], fac[&minus;10]}//.sIn[61] := {fac[10], fac[&minus;10]}//.sIn[61] := {fac[10], fac[&minus;10]}//.s
Out[61] = {3628800, fac[&minus;10]}
Internally, this operator is the function Condition.
</p>
<p>In[62] := FullForm[s]In[62] := FullForm[s]In[62] := FullForm[s]
Out[62]//FullForm=
</p>
<p>List[Rule[fac[0],1],</p>
<p/>
</div>
<div class="page"><p/>
<p>4.6 Variable Number of Arguments 33
</p>
<p>Rule[fac[Condition[Pattern[n,Blank[Integer]],Greater[n,0]]],
Times[n, fac[Plus[&minus;1,n]]]]]
</p>
<p>In[63] := Clear[s]In[63] := Clear[s]In[63] := Clear[s]
One common case is when you want to replace f [x] by g[x] only for some
values of x.
</p>
<p>In[64] := f [a]+ f [b]+ f [c]/. f [x /;x== a||x== b]&minus;&gt;g[x]In[64] := f [a]+ f [b]+ f [c]/. f [x /;x== a||x== b]&minus;&gt;g[x]In[64] := f [a]+ f [b]+ f [c]/. f [x /;x== a||x== b]&minus;&gt;g[x]
Out[64] = f [c]+ g[a]+ g[b]
</p>
<p>4.6 Variable Number of Arguments
</p>
<p>A pattern can involve a construct which matches not a single subexpression but an
</p>
<p>arbitrary-length subsequence of arguments of a function. This is very convenient for
</p>
<p>working with functions having an arbitrary number of arguments. Let&rsquo;s consider an
</p>
<p>example. The function f has any number of arguments. We want to shuffle them in
</p>
<p>the opposite order. First, let&rsquo;s put a fence at the end of the argument list.
</p>
<p>In[65] := a= f [x,y,z]In[65] := a= f [x,y,z]In[65] := a= f [x,y,z]
Out[65] = f [x,y,z]
In[66] := a= a/. f [x ]&minus;&gt; f [x,Fence]In[66] := a= a/. f [x ]&minus;&gt; f [x,Fence]In[66] := a= a/. f [x ]&minus;&gt; f [x,Fence]
Out[66] = f [x,y,z,Fence]
Now we take the arguments from the left one by one and throw them over the fence
</p>
<p>(placing them immediately after the fence).
</p>
<p>In[67] := a= a//. f [x ,y ,Fence,z ]&minus;&gt; f [y,Fence,x,z]In[67] := a= a//. f [x ,y ,Fence,z ]&minus;&gt; f [y,Fence,x,z]In[67] := a= a//. f [x ,y ,Fence,z ]&minus;&gt; f [y,Fence,x,z]
Out[67] = f [Fence,z,y,x]
Now the fence is at the left, and the arguments are after it in the opposite order.
</p>
<p>What&rsquo;s left is to remove the fence.
</p>
<p>In[68] := a= a/. f [Fence,x ]&minus;&gt; f [x]In[68] := a= a/. f [Fence,x ]&minus;&gt; f [x]In[68] := a= a/. f [Fence,x ]&minus;&gt; f [x]
Out[68] = f [z,y,x]
</p>
<p>Of course, this method only works when the symbol Fence is not present
</p>
<p>among the arguments. Here is the method which always works. Let the part of the
</p>
<p>arguments which has not yet been processed be in the first list and the processed
</p>
<p>part&mdash;in the second one. We take the arguments one by one from the beginning of
</p>
<p>the first list and move them to the beginning of the second one.
</p>
<p>In[69] := a= a/. f [x ]&minus;&gt; f [{x},{}]In[69] := a= a/. f [x ]&minus;&gt; f [{x},{}]In[69] := a= a/. f [x ]&minus;&gt; f [{x},{}]
Out[69] = f [{z,y,x},{}]
In[70] := a= a//. f [{x ,y },{z }]&minus;&gt; f [{y},{x,z}]In[70] := a= a//. f [{x ,y },{z }]&minus;&gt; f [{y},{x,z}]In[70] := a= a//. f [{x ,y },{z }]&minus;&gt; f [{y},{x,z}]
Out[70] = f [{},{x,y,z}]
In[71] := a= a/. f [{},{x }]&minus;&gt; f [x]In[71] := a= a/. f [{},{x }]&minus;&gt; f [x]In[71] := a= a/. f [{},{x }]&minus;&gt; f [x]
Out[71] = f [x,y,z]
</p>
<p>In addition to x (with three underscores), which means an arbitrary
</p>
<p>subsequence of arguments of a function (maybe an empty one), there is also x
</p>
<p>(with two underscores)&mdash;an arbitrary nonempty subsequence of arguments. I find
</p>
<p>the first construct more useful.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 5
</p>
<p>Functions
</p>
<p>5.1 Immediate and Delayed Assignment
</p>
<p>This is an ordinary (immediate) assignment. The result of calculation of the
</p>
<p>right-hand side (in this case, a quadratic polynomial) is assigned to the variable a.
</p>
<p>In[1] := a= Expand[(x+ 1)&and;2]In[1] := a= Expand[(x+ 1)&and;2]In[1] := a= Expand[(x+ 1)&and;2]
Out[1] = 1+ 2x+ x2
</p>
<p>And this is a delayed assignment. The unevaluated right-hand side (in this case, an
</p>
<p>expression with the function Expand) is assigned to the variable b.
</p>
<p>In[2] := b := Expand[(x+ 1)&and;2]In[2] := b := Expand[(x+ 1)&and;2]In[2] := b := Expand[(x+ 1)&and;2]
Note that a delayed assignment returns no value (an ordinary assignment returns
</p>
<p>the result of calculation of its right-hand side). The difference between a and b can
</p>
<p>be seen if we assign something to the variable x. In the first case, the value of x is
</p>
<p>substituted into the quadratic polynomial.
</p>
<p>In[3] := x= z+ 1; aIn[3] := x= z+ 1; aIn[3] := x= z+ 1; a
Out[3] = 1+ 2(1+ z)+ (1+ z)2
</p>
<p>In the second case, the value of x is substituted into the expression with the function
</p>
<p>Expand, and then this expression is calculated.
</p>
<p>In[4] := bIn[4] := bIn[4] := b
Out[4] = 4+ 4z+ z2
</p>
<p>In[5] := Clear[a,b,x]In[5] := Clear[a,b,x]In[5] := Clear[a,b,x]
The real name of the operator := is SetDelayed.
In[6] := FullForm[Hold[a := x]]In[6] := FullForm[Hold[a := x]]In[6] := FullForm[Hold[a := x]]
Out[6]//FullForm =
</p>
<p>Hold[SetDelayed[a,x]]
Similarly, in addition to ordinary substitutions a&minus;&gt;b (where the right-hand side
</p>
<p>is calculated at the moment the substitution is defined), there are delayed substitu-
</p>
<p>tions a : &gt;b (where the substitution keeps the right-hand side unevaluated, and it is
calculated each time the substitution is applied).
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 5, &copy; Springer International Publishing Switzerland 2014
</p>
<p>35</p>
<p/>
</div>
<div class="page"><p/>
<p>36 5 Functions
</p>
<p>In[7] := f [z+ 1]/. f [x ]&minus;&gt;Expand[(x+ 1)&and;2]In[7] := f [z+ 1]/. f [x ]&minus;&gt;Expand[(x+ 1)&and;2]In[7] := f [z+ 1]/. f [x ]&minus;&gt;Expand[(x+ 1)&and;2]
Out[7] = 1+ 2(1+ z)+ (1+ z)2
</p>
<p>In[8] := f [z+ 1]/. f [x ] : &gt;Expand[(x+ 1)&and;2]In[8] := f [z+ 1]/. f [x ] : &gt;Expand[(x+ 1)&and;2]In[8] := f [z+ 1]/. f [x ] : &gt;Expand[(x+ 1)&and;2]
Out[8] = 4+ 4z+ z2
</p>
<p>5.2 Functions
</p>
<p>Left-hand side of an assignment can be a pattern, not just a variable. In this case,
</p>
<p>in all subsequent calculations, any subexpression matching the pattern will be re-
</p>
<p>placed by the right-hand side of the assignment. This can be canceled by the com-
</p>
<p>mand Clear. A pattern can contain arbitrary variables. This is how functions are
</p>
<p>defined. Here is an example&mdash;a function f . In all subsequent calculations, all subex-
</p>
<p>pressions of the form f [x] with arbitrary arguments x will be replaced by the right-
hand side (in this case, a quadratic polynomial), in which the value of the actual
</p>
<p>argument is substituted for x.
</p>
<p>In[9] := f [x ] = Expand[(x+ 1)&and;2]In[9] := f [x ] = Expand[(x+ 1)&and;2]In[9] := f [x ] = Expand[(x+ 1)&and;2]
Out[9] = 1+ 2x+ x2
</p>
<p>And this is another function. Its body is an unevaluated expression with Expand.
</p>
<p>Expanding brackets will take place each time the function g with some argument is
</p>
<p>calculated.
</p>
<p>In[10] := g[x ] := Expand[(x+ 1)&and;2]In[10] := g[x ] := Expand[(x+ 1)&and;2]In[10] := g[x ] := Expand[(x+ 1)&and;2]
Note the difference between them.
</p>
<p>In[11] := { f [z+ 1],g[z+ 1]}In[11] := { f [z+ 1],g[z+ 1]}In[11] := { f [z+ 1],g[z+ 1]}
Out[11] =
</p>
<p>{
</p>
<p>1+ 2(1+ z)+ (1+ z)2,4+ 4z+ z2
}
</p>
<p>In[12] := Clear[ f ,g]In[12] := Clear[ f ,g]In[12] := Clear[ f ,g]
</p>
<p>5.3 Functions Remembering Their Values
</p>
<p>Let&rsquo;s consider a useful trick&mdash;a function remembering its calculated values. If it is
</p>
<p>called again with the same argument, it will not perform calculations, but just return
</p>
<p>the remembered result. For example, take the factorial. We know fac[0].
In[13] := fac[0] = 1In[13] := fac[0] = 1In[13] := fac[0] = 1
Out[13] = 1
And now attention&mdash;the main trick. A delayed assignment to the pattern fac[n ]
(with an arbitrary n). And what do we have in the right-hand side? An immediate
</p>
<p>assignment to the pattern fac[n] (for a specific n, namely, the value of the actual argu-
ment with which the function fac was called). What happens when we call fac[10]?
If the function was never calculated with this argument, then this definition for an
</p>
<p>arbitrary argument will be used. The right-hand side with 10 substituted for n will
</p>
<p>be calculated, namely, an immediate assignment fac[10] = &middot; &middot; &middot;. Its right-hand side is
calculated (it is the factorial of 10), and it is remembered as the value of fac[10].</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4 Fibonacci Numbers 37
</p>
<p>The immediate assignment returns the calculated value of its right-hand side, and
</p>
<p>this value becomes the result of the function call. If we ask Mathematica to calculate
</p>
<p>fac[10] again, then this specific definition for fac[10] (generated during the first cal-
culation) will be used, and not the general definition for fac[n ].
In[14] := fac[n ] := fac[n] = n &lowast; fac[n&minus; 1]In[14] := fac[n ] := fac[n] = n &lowast; fac[n&minus; 1]In[14] := fac[n ] := fac[n] = n &lowast; fac[n&minus; 1]
What does Mathematica know about the symbol fac?
</p>
<p>In[15] :=?facIn[15] :=?facIn[15] :=?fac
Global̀ fac
fac[0] = 1
fac[n ] := fac[n] = n fac[n&minus; 1]
Only two definitions&mdash;for the argument 0 and for an arbitrary argument. Now let&rsquo;s
</p>
<p>calculate the factorial of 10.
</p>
<p>In[16] := fac[10]In[16] := fac[10]In[16] := fac[10]
Out[16] = 3628800
And what does Mathematica know about this symbol now?
</p>
<p>In[17] :=?facIn[17] :=?facIn[17] :=?fac
Global̀ fac
fac[0] = 1
fac[1] = 1
fac[2] = 2
fac[3] = 6
fac[4] = 24
fac[5] = 120
fac[6] = 720
fac[7] = 5040
fac[8] = 40320
fac[9] = 362880
fac[10] = 3628800
fac[n ] := fac[n] = n fac[n&minus; 1]
In addition to the general definition, we see also specific ones for all integer values of
</p>
<p>the argument from 0 to 10. If we ask for the value of fac for one of these arguments,
</p>
<p>then the corresponding specific definition will be used, and the calculation will not
</p>
<p>be performed again.
</p>
<p>In[18] := Clear[fac]In[18] := Clear[fac]In[18] := Clear[fac]
</p>
<p>5.4 Fibonacci Numbers
</p>
<p>This method is useful but not vital for the factorial, because the time of calculation
</p>
<p>of fac[n] grows linearly with n. For Fibonacci numbers the difference is crucial. For
a naive definition, the calculation time grows exponentially. This means you will
</p>
<p>never get a Fibonacci number with a large n. When results are remembered, the
</p>
<p>calculation time grows linearly&mdash;the result for each value of the argument from 2 to
</p>
<p>n is calculated once.</p>
<p/>
</div>
<div class="page"><p/>
<p>38 5 Functions
</p>
<p>In[19] := fib[0] = fib[1] = 1In[19] := fib[0] = fib[1] = 1In[19] := fib[0] = fib[1] = 1
Out[19] = 1
In[20] := fib[n ] := fib[n] = fib[n&minus; 1]+fib[n&minus; 2]In[20] := fib[n ] := fib[n] = fib[n&minus; 1]+fib[n&minus; 2]In[20] := fib[n ] := fib[n] = fib[n&minus; 1]+fib[n&minus; 2]
In[21] :=?fibIn[21] :=?fibIn[21] :=?fib
Global̀ fib
fib[0] = 1
fib[1] = 1
fib[n ] := fib[n] = fib[n&minus; 1]+fib[n&minus; 2]
In[22] := fib[10]In[22] := fib[10]In[22] := fib[10]
Out[22] = 89
In[23] :=?fibIn[23] :=?fibIn[23] :=?fib
Global̀ fib
fib[0] = 1
fib[1] = 1
fib[2] = 2
fib[3] = 3
fib[4] = 5
fib[5] = 8
fib[6] = 13
fib[7] = 21
fib[8] = 34
fib[9] = 55
fib[10] = 89
fib[n ] := fib[n] = fib[n&minus; 1]+fib[n&minus; 2]
In[24] := Clear[fib]In[24] := Clear[fib]In[24] := Clear[fib]
</p>
<p>5.5 Functions from Expressions
</p>
<p>In most cases, a delayed assignment is used when defining a function. But there
</p>
<p>are situations when an immediate assignment is needed. Here is one of them.
</p>
<p>Suppose you have derived an expression a containing a symbol x as a result of
</p>
<p>some calculation.
</p>
<p>In[25] := a= D[Expand[(x+ 1)&and;3],x]In[25] := a= D[Expand[(x+ 1)&and;3],x]In[25] := a= D[Expand[(x+ 1)&and;3],x]
Out[25] = 3+ 6x+ 3x2
</p>
<p>Now you want to calculate it many times with different values of x. This can be done
</p>
<p>by substitutions.
</p>
<p>In[26] := a/.x&minus;&gt;z+ 1In[26] := a/.x&minus;&gt;z+ 1In[26] := a/.x&minus;&gt;z+ 1
Out[26] = 3+ 6(1+ z)+ 3(1+ z)2
</p>
<p>But this is not very convenient. It would be nice to have a function f with the
</p>
<p>argument x which is given by the calculated expression a. Such a function can be
</p>
<p>defined by an immediate assignment. The calculated value is substituted for a in
</p>
<p>the right-hand side.</p>
<p/>
</div>
<div class="page"><p/>
<p>5.6 Antisymmetric Functions 39
</p>
<p>In[27] := f [x ] = aIn[27] := f [x ] = aIn[27] := f [x ] = a
Out[27] = 3+ 6x+ 3x2
</p>
<p>In[28] := f [z+ 1]In[28] := f [z+ 1]In[28] := f [z+ 1]
Out[28] = 3+ 6(1+ z)+ 3(1+ z)2
</p>
<p>In[29] := Clear[a, f ]In[29] := Clear[a, f ]In[29] := Clear[a, f ]
</p>
<p>5.6 Antisymmetric Functions
</p>
<p>It is often useful to give a partial definition of a function. To this end we write
</p>
<p>not just a function with all arguments being arbitrary but a more restrictive pattern
</p>
<p>in the left-hand side of an assignment. Then, if the values of the actual arguments
</p>
<p>match the pattern, the function is calculated (i.e., replaced by the right-hand side
</p>
<p>of the assignment). Otherwise the function remains unevaluated. Here is a simple
</p>
<p>example. Let&rsquo;s define an antisymmetric function of two arguments. If the arguments
</p>
<p>are equal, it vanishes.
</p>
<p>In[30] := f [x ,x ] := 0In[30] := f [x ,x ] := 0In[30] := f [x ,x ] := 0
If they are not equal, we have to decide if they need to be interchanged. The
</p>
<p>expressions f [x,y] and f [y,x] should reduce to either the first form or the second
one, for any x and y. It does not matter to which form, as long as the result is
</p>
<p>always the same. To this end the function OrderedQ is useful. Its argument is a
</p>
<p>list. It returns True if the list is ordered, i.e., each element is &ldquo;greater than or equal
</p>
<p>to&rdquo; the previous one in the sense of some internal ordering Mathematica uses for
</p>
<p>expressions. Details of this ordering are not important.
</p>
<p>In[31] := {OrderedQ[{x,y}],OrderedQ[{y,x}],OrderedQ[{x,x}]}In[31] := {OrderedQ[{x,y}],OrderedQ[{y,x}],OrderedQ[{x,x}]}In[31] := {OrderedQ[{x,y}],OrderedQ[{y,x}],OrderedQ[{x,x}]}
Out[31] = {True,False,True}
Now it is easy to write a substitution which interchanges the arguments if they are
</p>
<p>not properly ordered.
</p>
<p>In[32] := f [x ,y ]/;Not[OrderedQ[{x,y}]] :=&minus; f [y,x]In[32] := f [x ,y ]/;Not[OrderedQ[{x,y}]] :=&minus; f [y,x]In[32] := f [x ,y ]/;Not[OrderedQ[{x,y}]] :=&minus; f [y,x]
In[33] := { f [a,a], f [a,b], f [b,a]}In[33] := { f [a,a], f [a,b], f [b,a]}In[33] := { f [a,a], f [a,b], f [b,a]}
Out[33] = {0, f [a,b],&minus; f [a,b]}
In[34] := { f [a+ b,a&minus; b], f [a&minus; b,a+b]}In[34] := { f [a+ b,a&minus; b], f [a&minus; b,a+b]}In[34] := { f [a+ b,a&minus; b], f [a&minus; b,a+b]}
Out[34] = {&minus; f [a&minus; b,a+ b], f [a&minus; b,a+b]}
In[35] := Clear[ f ]In[35] := Clear[ f ]In[35] := Clear[ f ]
</p>
<p>Of course, a symmetric function can be defined similarly. An odd function of a
</p>
<p>single argument can be defined in the same way.
</p>
<p>In[36] := f [0] = 0In[36] := f [0] = 0In[36] := f [0] = 0
Out[36] = 0
In[37] := f [x ]/;Not[OrderedQ[{&minus;x,x}]] :=&minus; f [&minus;x]In[37] := f [x ]/;Not[OrderedQ[{&minus;x,x}]] :=&minus; f [&minus;x]In[37] := f [x ]/;Not[OrderedQ[{&minus;x,x}]] :=&minus; f [&minus;x]
In[38] := { f [0], f [a], f [&minus;a]}In[38] := { f [0], f [a], f [&minus;a]}In[38] := { f [0], f [a], f [&minus;a]}
Out[38] = {0, f [a],&minus; f [a]}
In[39] := { f [a&minus; b], f [b&minus; a]}In[39] := { f [a&minus; b], f [b&minus; a]}In[39] := { f [a&minus; b], f [b&minus; a]}
Out[39] = {&minus; f [&minus;a+ b], f [&minus;a+ b]}
In[40] := Clear[ f ]In[40] := Clear[ f ]In[40] := Clear[ f ]
Of course, an even function can be defined similarly.</p>
<p/>
</div>
<div class="page"><p/>
<p>40 5 Functions
</p>
<p>5.7 Functions with Options
</p>
<p>You have undoubtedly noted that many Mathematica functions (e.g., Plot) have
</p>
<p>options. They can be specified in any order; each option is given by a substitu-
</p>
<p>tion with its name in the left-hand side and its value in the right-hand side. If they
</p>
<p>are not given, their default values are used. Suppose you want your own function f
</p>
<p>to have options. This can be done in the following way. Let&rsquo;s assign a list of sub-
</p>
<p>stitutions giving default values of all options to Options[ f ]. Define the function f
with some mandatory arguments and an arbitrary sequence of arguments opts
</p>
<p>(it may be empty). At the point in the function body where you need the value of
</p>
<p>the option opt1 use opt1/.{opts}/.Options[ f ]. The operations /. are executed left
to right. Therefore, if the user has included a substitution opt1 &rarr; &middot;&middot;&middot; among the
arguments, the left /. will trigger, and the result will be some value which contains
no option names; the right /. will not change it. If the user has not given such a
substitution, the left /. will do nothing, and the right one will replace opt1 by the
default value of this option.
</p>
<p>In[41] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2}In[41] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2}In[41] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2}
Out[41] = {opt1 &rarr; 1,opt2 &rarr; 2}
In[42] := f [x ,opts ] := g[x,opt1/.{opts}/.Options[ f ],In[42] := f [x ,opts ] := g[x,opt1/.{opts}/.Options[ f ],In[42] := f [x ,opts ] := g[x,opt1/.{opts}/.Options[ f ],
</p>
<p>opt2/.{opts}/.Options[ f ]]opt2/.{opts}/.Options[ f ]]opt2/.{opts}/.Options[ f ]]
In[43] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}In[43] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}In[43] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}
Out[43] = {g[a,1,2],g[a,1,0],g[a,c,b]}
In[44] := Clear[ f ]In[44] := Clear[ f ]In[44] := Clear[ f ]
In recent versions of Mathematica this can also be written as follows:
</p>
<p>In[45] := f [x ,OptionsPattern[ f ]] := g[x,OptionValue[opt1],OptionValue[opt2]]In[45] := f [x ,OptionsPattern[ f ]] := g[x,OptionValue[opt1],OptionValue[opt2]]In[45] := f [x ,OptionsPattern[ f ]] := g[x,OptionValue[opt1],OptionValue[opt2]]
In[46] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2};In[46] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2};In[46] := Options[ f ] = {opt1&minus;&gt;1,opt2&minus;&gt;2};
In[47] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}In[47] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}In[47] := { f [a], f [a,opt2&minus;&gt;0], f [a,opt2&minus;&gt;b,opt1&minus;&gt;c]}
Out[47] = {g[a,1,2],g[a,1,0],g[a,c,b]}
In[48] := Clear[ f ]In[48] := Clear[ f ]In[48] := Clear[ f ]
</p>
<p>5.8 Attributes
</p>
<p>A function can have attributes which affect simplification of expressions with this
</p>
<p>function. The attribute Flat removes nested function calls (e.g., Plus and Times have
</p>
<p>this attribute).
</p>
<p>In[49] := Attributes[ f ] = {Flat}In[49] := Attributes[ f ] = {Flat}In[49] := Attributes[ f ] = {Flat}
Out[49] = {Flat}
In[50] := f [x, f [y,z],u]In[50] := f [x, f [y,z],u]In[50] := f [x, f [y,z],u]
Out[50] = f [x,y,z,u]
The attribute Orderless means that the function is symmetric in all arguments, and
</p>
<p>Mathematica may interchange them at will (Plus and Times have also this attribute).</p>
<p/>
</div>
<div class="page"><p/>
<p>5.9 Upvalues 41
</p>
<p>In[51] := Attributes[ f ] = {Orderless}In[51] := Attributes[ f ] = {Orderless}In[51] := Attributes[ f ] = {Orderless}
Out[51] = {Orderless}
In[52] := { f [x,y,z], f [z,x,y], f [y,z,x]}In[52] := { f [x,y,z], f [z,x,y], f [y,z,x]}In[52] := { f [x,y,z], f [z,x,y], f [y,z,x]}
Out[52] = { f [x,y,z], f [x,y,z], f [x,y,z]}
The attribute Listable means that if the first argument is a list, then the function is
</p>
<p>applied to each element, and the list of results is returned (Plus and Times have this
</p>
<p>attribute, too).
</p>
<p>In[53] := Attributes[ f ] = {Listable}In[53] := Attributes[ f ] = {Listable}In[53] := Attributes[ f ] = {Listable}
Out[53] = {Listable}
In[54] := f [{x,y,z}]In[54] := f [{x,y,z}]In[54] := f [{x,y,z}]
Out[54] = { f [x], f [y], f [z]}
In[55] := f [{x,y,z},a]In[55] := f [{x,y,z},a]In[55] := f [{x,y,z},a]
Out[55] = { f [x,a], f [y,a], f [z,a]}
There exist a few attributes more. Of course, a function can have several attributes at
</p>
<p>once. The command Clear[ f ] removes only substitutions for f (with any arguments),
but not its attributes. In order to remove attributes too, use ClearAll.
</p>
<p>In[56] := ClearAll[ f ]; Attributes[ f ]In[56] := ClearAll[ f ]; Attributes[ f ]In[56] := ClearAll[ f ]; Attributes[ f ]
Out[56] = {}
</p>
<p>5.9 Upvalues
</p>
<p>Suppose we want to define a function f such that f [x]&lowast; f [y] is replaced by f [x+ y]
for arbitrary x and y. This can be done by the assignment f [x ] &lowast; f [y ] := f [x+ y].
This definition will be associated with the function Times; Mathematica will have
</p>
<p>to check it each time it multiplies something, i.e., very often, and performance will
</p>
<p>degrade. It is possible to associate this definition with the function f instead. Then
</p>
<p>it will be used only when processing a product containing at least one function f .
</p>
<p>In[57] := f [x ]&lowast; f [y ]&and; := f [Expand[x+ y]]In[57] := f [x ]&lowast; f [y ]&and; := f [Expand[x+ y]]In[57] := f [x ]&lowast; f [y ]&and; := f [Expand[x+ y]]
In[58] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]In[58] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]In[58] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]
Out[58] = f
</p>
<p>[
</p>
<p>3x2 + 2y2
]
</p>
<p>g
[
</p>
<p>y2
]
</p>
<p>Here the left-hand side is Times[ f [x ], f [y ]], and the definition is associated with f .
If we want a definition for Times[ f [x ],g[y ]], we can associate it with either f or g.
In[59] := f/ : f [x ]&lowast; g[y ] := f [Expand[x&minus; y]]In[59] := f/ : f [x ]&lowast; g[y ] := f [Expand[x&minus; y]]In[59] := f/ : f [x ]&lowast; g[y ] := f [Expand[x&minus; y]]
In[60] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]In[60] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]In[60] := f [(x+ y)&and;2]&lowast; f [(x&minus; y)&and;2]&lowast; f [x&and;2]&lowast; g[y&and;2]
Out[60] = f
</p>
<p>[
</p>
<p>3x2 + y2
]
</p>
<p>In[61] :=? fIn[61] :=? fIn[61] :=? f
Global̀ f
f [x ] f [y ]&and; := f [Expand[x+ y]]
f/ : f [x ]g[y ] := f [Expand[x&minus; y]]
</p>
<p>When processing an expression f [g1[. . .],g2[. . .],g3[. . .]], Mathematica uses
definitions associated with f and also definitions associated with g1, g2, g3, and</p>
<p/>
</div>
<div class="page"><p/>
<p>42 5 Functions
</p>
<p>having the form f [. . .] := &middot; &middot; &middot; (upvalues of g1, g2, g3). It does not look deeper,
into arguments of g1, g2, and g3&mdash;this would be too inefficient. In addition to the
</p>
<p>delayed assignments &and; := and f/ : lhs := rhs there are also immediate assignments
&and; = and f/ : lhs = rhs.
In[62] := Clear[ f ]In[62] := Clear[ f ]In[62] := Clear[ f ]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 6
</p>
<p>Mathematica as a Programming Language
</p>
<p>6.1 Compound Expressions
</p>
<p>A compound expression consists of several expressions separated by the operator ;.
</p>
<p>They are calculated left to right. The value of a compound expression is the value
</p>
<p>of the last (rightmost) expression. The values of all the other expressions are thrown
</p>
<p>away; they are calculated only for side effects. The operator ; has a low priority,
</p>
<p>so that it is often necessary to put a compound expression inside brackets. The last
</p>
<p>expression may be empty. Its value (and hence the value of the compound expres-
</p>
<p>sion) is the symbol Null which is not printed. Therefore, if you want to suppress
</p>
<p>printing of the result of some calculation (e.g., because it is lengthy), put ; after it.
</p>
<p>In[1] := fac[0] = 1;In[1] := fac[0] = 1;In[1] := fac[0] = 1;
In[2] := fac[n ] := (Print[&rdquo;n=&rdquo;,n]; n &lowast; fac[n&minus; 1])In[2] := fac[n ] := (Print[&rdquo;n=&rdquo;,n]; n &lowast; fac[n&minus; 1])In[2] := fac[n ] := (Print[&rdquo;n=&rdquo;,n]; n &lowast; fac[n&minus; 1])
In[3] := fac[4]In[3] := fac[4]In[3] := fac[4]
n=4
</p>
<p>n=3
</p>
<p>n=2
</p>
<p>n=1
</p>
<p>Out[3] = 24
In[4] := Clear[fac]In[4] := Clear[fac]In[4] := Clear[fac]
In[5] := NullIn[5] := NullIn[5] := Null
In[6] := FullForm[x; ]In[6] := FullForm[x; ]In[6] := FullForm[x; ]
Out[6]//FullForm =
</p>
<p>Null
</p>
<p>In[7] := FullForm[Hold[a;b]]In[7] := FullForm[Hold[a;b]]In[7] := FullForm[Hold[a;b]]
Out[7]//FullForm =
</p>
<p>Hold[CompoundExpression[a,b]]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 6, &copy; Springer International Publishing Switzerland 2014
</p>
<p>43</p>
<p/>
</div>
<div class="page"><p/>
<p>44 6 Mathematica as a Programming Language
</p>
<p>6.2 Conditional Expressions
</p>
<p>If
</p>
<p>In[8] := del[x ,y ] := If[x== y,1,0]In[8] := del[x ,y ] := If[x== y,1,0]In[8] := del[x ,y ] := If[x== y,1,0]
In[9] := del[a,a]In[9] := del[a,a]In[9] := del[a,a]
Out[9] = 1
In[10] := del[1,2]In[10] := del[1,2]In[10] := del[1,2]
Out[10] = 0
When Mathematica cannot determine if the condition is true, a conditional
</p>
<p>expression is returned unevaluated. If such a possibility will appear later, an
</p>
<p>unevaluated If will be simplified.
</p>
<p>In[11] := u= del[a,b]In[11] := u= del[a,b]In[11] := u= del[a,b]
Out[11] = If[a== b,1,0]
In[12] := a= b= x; uIn[12] := a= b= x; uIn[12] := a= b= x; u
Out[12] = 1
And what to do if several actions should be performed in the branches of If? Use
</p>
<p>compound expressions, of course! The priority of the operator; is higher than that
</p>
<p>of, (which separates function arguments, in particular, those of If).
</p>
<p>In[13] := f [x ] := If[x&gt; 0,Print[&rdquo;x&gt;0&rdquo;]; 1,Print[&rdquo;x&lt;=0&rdquo;]; 0]In[13] := f [x ] := If[x&gt; 0,Print[&rdquo;x&gt;0&rdquo;]; 1,Print[&rdquo;x&lt;=0&rdquo;]; 0]In[13] := f [x ] := If[x&gt; 0,Print[&rdquo;x&gt;0&rdquo;]; 1,Print[&rdquo;x&lt;=0&rdquo;]; 0]
In[14] := f [1]In[14] := f [1]In[14] := f [1]
x&gt;0
Out[14] = 1
In[15] := Clear[a,b,u,del, f ]In[15] := Clear[a,b,u,del, f ]In[15] := Clear[a,b,u,del, f ]
</p>
<p>Which
</p>
<p>This is a choice with many branches. Arguments of the function Which form pairs:
</p>
<p>a condition and a result. The conditions are evaluated left to right. As soon as a
</p>
<p>true one is found, the corresponding result is evaluated and returned. Often (but
</p>
<p>not always) the last condition is True; the corresponding result is returned when
</p>
<p>none of the previous conditions is satisfied. When Mathematica cannot decide if the
</p>
<p>conditions are true, the function Which returns unevaluated.
</p>
<p>In[16] := sign[x ] := Which[x&gt; 0,1,x&lt; 0,&minus;1]In[16] := sign[x ] := Which[x&gt; 0,1,x&lt; 0,&minus;1]In[16] := sign[x ] := Which[x&gt; 0,1,x&lt; 0,&minus;1]
In[17] := sign[0.1]In[17] := sign[0.1]In[17] := sign[0.1]
Out[17] = 1
In[18] := sign[0]In[18] := sign[0]In[18] := sign[0]
In[19] := sign[a]In[19] := sign[a]In[19] := sign[a]
Out[19] = Which[a&gt; 0,1,a&lt; 0,&minus;1]
In[20] := Clear[sign]In[20] := Clear[sign]In[20] := Clear[sign]</p>
<p/>
</div>
<div class="page"><p/>
<p>6.2 Conditional Expressions 45
</p>
<p>Conditions
</p>
<p>What can be used as conditions in If and Which? The operator== returns True if its
left-hand side and right-hand side are the same expression. Let&rsquo;s stress: mathemati-
</p>
<p>cally equivalent expressions written in different forms don&rsquo;t qualify. If the left-hand
</p>
<p>side and the right-hand one are not identical, this operator returns unevaluated. It is
</p>
<p>used for writing equations, for example, for the function Solve.
</p>
<p>In[21] := {a== a,a== b}In[21] := {a== a,a== b}In[21] := {a== a,a== b}
Out[21] = {True,a== b}
In contrast to this, the operator === returns False if its arguments are not identical
(even if they are mathematically equivalent).
</p>
<p>In[22] := {a=== a,a=== b}In[22] := {a=== a,a=== b}In[22] := {a=== a,a=== b}
Out[22] = {True,False}
Not[a== b] is written as a!=b, and Not[a=== b] as a=!=b.
</p>
<p>The function NumberQ checks if its argument is a number (integer, rational, real,
</p>
<p>complex).
</p>
<p>In[23] := {NumberQ[3.14],NumberQ[Pi]}In[23] := {NumberQ[3.14],NumberQ[Pi]}In[23] := {NumberQ[3.14],NumberQ[Pi]}
Out[23] = {True,False}
The function NumericQ returns True also for symbolic mathematical constants.
</p>
<p>In[24] := {NumericQ[3.14],NumericQ[Pi]}In[24] := {NumericQ[3.14],NumericQ[Pi]}In[24] := {NumericQ[3.14],NumericQ[Pi]}
Out[24] = {True,True}
</p>
<p>The function FreeQ returns True if its first argument contains no subexpressions
</p>
<p>given by the second argument. It is often used to check if an expression contains a
</p>
<p>given symbol.
</p>
<p>In[25] := {FreeQ[Sin[a+ b],a],FreeQ[Sin[b+ c],a]}In[25] := {FreeQ[Sin[a+ b],a],FreeQ[Sin[b+ c],a]}In[25] := {FreeQ[Sin[a+ b],a],FreeQ[Sin[b+ c],a]}
Out[25] = {False,True}
The function MatchQ checks if the expression&mdash;its first argument&mdash; matches the
</p>
<p>pattern, its second argument. When designing a system of substitutions, use this
</p>
<p>function often in order to check if your ideas about the structure of expressions
</p>
<p>agree with those of Mathematica.
</p>
<p>In[26] := MatchQ[x&and;2,a &and;b ]In[26] := MatchQ[x&and;2,a &and;b ]In[26] := MatchQ[x&and;2,a &and;b ]
Out[26] = True
In[27] := MatchQ[1/x,a &and;b ]In[27] := MatchQ[1/x,a &and;b ]In[27] := MatchQ[1/x,a &and;b ]
Out[27] = True
In[28] := MatchQ[x,a &and;b ]In[28] := MatchQ[x,a &and;b ]In[28] := MatchQ[x,a &and;b ]
Out[28] = False
</p>
<p>Switch
</p>
<p>The function Switch starts from evaluating its first argument. All the remaining
</p>
<p>arguments form couples: a pattern and a result. The first argument is matched against
</p>
<p>the patterns from left to right. As soon as a match is found, the corresponding result
</p>
<p>is evaluated and returned. Often (but not always) the last pattern is x (or just
</p>
<p>because we don&rsquo;t need the value of x).</p>
<p/>
</div>
<div class="page"><p/>
<p>46 6 Mathematica as a Programming Language
</p>
<p>In[29] := f [x ] := Switch[x, Plus,&rdquo;A sum&rdquo;, Times,&rdquo;A product&rdquo;, ,In[29] := f [x ] := Switch[x, Plus,&rdquo;A sum&rdquo;, Times,&rdquo;A product&rdquo;, ,In[29] := f [x ] := Switch[x, Plus,&rdquo;A sum&rdquo;, Times,&rdquo;A product&rdquo;, ,
&rdquo;Neither a sum nor a product&rdquo;]&rdquo;Neither a sum nor a product&rdquo;]&rdquo;Neither a sum nor a product&rdquo;]
</p>
<p>In[30] := f [a+ b]In[30] := f [a+ b]In[30] := f [a+ b]
Out[30] = A sum
In[31] := f [a &lowast; b]In[31] := f [a &lowast; b]In[31] := f [a &lowast; b]
Out[31] = A product
In[32] := f [a&and;b]In[32] := f [a&and;b]In[32] := f [a&and;b]
Out[32] = Neither a sum nor a product
In[33] := Clear[ f ]In[33] := Clear[ f ]In[33] := Clear[ f ]
</p>
<p>6.3 Loops
</p>
<p>Do
</p>
<p>This loop is very convenient to those pupils who were ordered by a teacher to write
</p>
<p>&ldquo;I shall behave well&rdquo; 100 times.
</p>
<p>In[34] := Do[Print[&rdquo;OK&rdquo;],{4}]In[34] := Do[Print[&rdquo;OK&rdquo;],{4}]In[34] := Do[Print[&rdquo;OK&rdquo;],{4}]
OK
</p>
<p>OK
</p>
<p>OK
</p>
<p>OK
</p>
<p>In this loop the parameter varies from 1 to an upper limit.
</p>
<p>In[35] := Do[Print[x&and;i],{i,4}]In[35] := Do[Print[x&and;i],{i,4}]In[35] := Do[Print[x&and;i],{i,4}]
x
</p>
<p>x2
</p>
<p>x3
</p>
<p>x4
</p>
<p>And here&mdash;from a lower limit to an upper one.
</p>
<p>In[36] := Do[Print[x&and;i],{i,0,4}]In[36] := Do[Print[x&and;i],{i,0,4}]In[36] := Do[Print[x&and;i],{i,0,4}]
1
</p>
<p>x
</p>
<p>x2
</p>
<p>x3
</p>
<p>x4
</p>
<p>And now with a given step.
</p>
<p>In[37] := Do[Print[x&and;i],{i,0,4,2}]In[37] := Do[Print[x&and;i],{i,0,4,2}]In[37] := Do[Print[x&and;i],{i,0,4,2}]
1
</p>
<p>x2
</p>
<p>x4
</p>
<p>This loop takes the elements of a list.
</p>
<p>In[38] := Do[Print[x&and;i],{i,{0,1,4}}]In[38] := Do[Print[x&and;i],{i,{0,1,4}}]In[38] := Do[Print[x&and;i],{i,{0,1,4}}]
1
</p>
<p>x
</p>
<p>x4</p>
<p/>
</div>
<div class="page"><p/>
<p>6.4 Functions 47
</p>
<p>While
</p>
<p>While the list is not empty, we print and remove its first element.
</p>
<p>In[39] := l = {a,b,c};In[39] := l = {a,b,c};In[39] := l = {a,b,c};
In[40] := While[l!={},Print[First[l]]; l = Rest[l]]In[40] := While[l!={},Print[First[l]]; l = Rest[l]]In[40] := While[l!={},Print[First[l]]; l = Rest[l]]
a
</p>
<p>b
</p>
<p>c
</p>
<p>In[41] := lIn[41] := lIn[41] := l
Out[41] = {}
In[42] := Clear[l]In[42] := Clear[l]In[42] := Clear[l]
</p>
<p>For
</p>
<p>This is a C style loop. First the initialization (the first argument) is executed.
</p>
<p>If the condition (the second argument) is satisfied, then the loop body (the fourth
</p>
<p>argument) is executed. Then the increment (the third argument) is performed. The
</p>
<p>condition is checked again, and so on.
</p>
<p>In[43] := For[i= 0, i&lt; 5, i++,Print[x&and;i]]In[43] := For[i= 0, i&lt; 5, i++,Print[x&and;i]]In[43] := For[i= 0, i&lt; 5, i++,Print[x&and;i]]
1
</p>
<p>x
</p>
<p>x2
</p>
<p>x3
</p>
<p>x4
</p>
<p>In[44] := iIn[44] := iIn[44] := i
Out[44] = 5
A loop running through several parameters (or data structures) in parallel can be
</p>
<p>easily written.
</p>
<p>In[45] := For[i= 0; j = 1, i+ j&lt; 20, i++; j&lowast;= 2,Print[x&and;i+ y&and; j]]In[45] := For[i= 0; j = 1, i+ j&lt; 20, i++; j&lowast;= 2,Print[x&and;i+ y&and; j]]In[45] := For[i= 0; j = 1, i+ j&lt; 20, i++; j&lowast;= 2,Print[x&and;i+ y&and; j]]
1+ y
x+ y2
</p>
<p>x2 + y4
</p>
<p>x3 + y8
</p>
<p>In[46] := Clear[i, j]In[46] := Clear[i, j]In[46] := Clear[i, j]
</p>
<p>6.4 Functions
</p>
<p>The function Function returns an anonymous function. Its first argument is a formal
</p>
<p>parameter (or a list of formal parameters), and the second one is an expression con-
</p>
<p>taining these formal parameters. When the function is called, the actual parameters
</p>
<p>are substituted for the formal ones in this expression, and the result of its evaluation
</p>
<p>is returned as the value of the function. A note for experts: the function Function</p>
<p/>
</div>
<div class="page"><p/>
<p>48 6 Mathematica as a Programming Language
</p>
<p>is a λ -expression. Of course, an anonymous function can be assigned to a variable.
This is similar to a function defined by f [x ] := &middot; &middot; &middot;, but more efficient. The usual
method of assigning a function body to a pattern is more general, because it is pos-
</p>
<p>sible to construct a function which is defined only for arguments which satisfy some
</p>
<p>condition (such a function returns unevaluated if the conditions are not satisfied).
</p>
<p>This is not possible in the case of Function.
</p>
<p>In[47] := f = Function[x,x&and;2]In[47] := f = Function[x,x&and;2]In[47] := f = Function[x,x&and;2]
Out[47] = Function
</p>
<p>[
</p>
<p>x,x2
]
</p>
<p>An anonymous function can be just applied to some arguments.
</p>
<p>In[48] := Function[{x,y},x&and;2+ y&and;3][a,b]In[48] := Function[{x,y},x&and;2+ y&and;3][a,b]In[48] := Function[{x,y},x&and;2+ y&and;3][a,b]
Out[48] = a2 + b3
</p>
<p>The function Map applies the function given by its first argument to each element
</p>
<p>of the list given by the second argument and returns the list of results.
</p>
<p>In[49] := Map[ f ,{a,b,c}]In[49] := Map[ f ,{a,b,c}]In[49] := Map[ f ,{a,b,c}]
Out[49] =
</p>
<p>{
</p>
<p>a2,b2,c2
}
</p>
<p>In[50] := Clear[ f ]In[50] := Clear[ f ]In[50] := Clear[ f ]
An anonymous function can be the first argument of Map. Any function with argu-
</p>
<p>ments (e.g., Plus) can be the second argument, not just a list. The function given
</p>
<p>by the first argument is applied to each argument of the expression&mdash;the second
</p>
<p>argument. An expression having the same Head (as the second argument) and the
</p>
<p>calculated results is constructed and returned.
</p>
<p>In[51] := Map[Function[x,x&and;2],a+ b+ c]In[51] := Map[Function[x,x&and;2],a+ b+ c]In[51] := Map[Function[x,x&and;2],a+ b+ c]
Out[51] = a2 + b2 + c2
</p>
<p>The function Apply[ f , l] applies f to the list of arguments l; this simply means
that the Head of l is replaced by f .
</p>
<p>In[52] := Apply[ f ,{a,b,c}]In[52] := Apply[ f ,{a,b,c}]In[52] := Apply[ f ,{a,b,c}]
Out[52] = f [a,b,c]
In[53] := Apply[Times,a+ b+ c]In[53] := Apply[Times,a+ b+ c]In[53] := Apply[Times,a+ b+ c]
Out[53] = abc
</p>
<p>The first argument of the function Select is a list. It returns the list of those
</p>
<p>elements which satisfy the condition given by the second argument. In order to
</p>
<p>avoid inventing names for such disposable things, anonymous functions are often
</p>
<p>used as the second argument.
</p>
<p>In[54] := Select[{1,5,3,6},Function[x,x&gt; 4]]In[54] := Select[{1,5,3,6},Function[x,x&gt; 4]]In[54] := Select[{1,5,3,6},Function[x,x&gt; 4]]
Out[54] = {5,6}
</p>
<p>Function Generator
</p>
<p>Here&rsquo;s an interesting example. The function Adder has a formal parameter n and re-
</p>
<p>turns a function which adds n to its argument, that is, Adder is a function generator.
</p>
<p>In[55] := Adder = Function[n,Function[x,x+ n]]In[55] := Adder = Function[n,Function[x,x+ n]]In[55] := Adder = Function[n,Function[x,x+ n]]
Out[55] = Function[n,Function[x,x+ n]]
Specific functions can be obtained from it. This one, for example, adds 2 to its
</p>
<p>argument.</p>
<p/>
</div>
<div class="page"><p/>
<p>6.5 Local Variables 49
</p>
<p>In[56] := Add2 = Adder[2]In[56] := Add2 = Adder[2]In[56] := Add2 = Adder[2]
Out[56] = Function[x$,x$+ 2]
In[57] := Map[Add2,{3,x}]In[57] := Map[Add2,{3,x}]In[57] := Map[Add2,{3,x}]
Out[57] = {5,2+ x}
In[58] := Clear[Add2,Adder]In[58] := Clear[Add2,Adder]In[58] := Clear[Add2,Adder]
</p>
<p>6.5 Local Variables
</p>
<p>When writing a function which can be used as a black box by a user, it is crucial to
</p>
<p>use local variables. Assigning a value to a local variable does not change the global
</p>
<p>one with the same name (which can store some value precious for the user). To this
</p>
<p>end the function Module is used. Its first argument is a list of local variables.
</p>
<p>In[59] := x= 1In[59] := x= 1In[59] := x= 1
Out[59] = 1
In[60] := Module[{x},x= 2;x]In[60] := Module[{x},x= 2;x]In[60] := Module[{x},x= 2;x]
Out[60] = 2
In[61] := xIn[61] := xIn[61] := x
Out[61] = 1
In[62] := Clear[x]In[62] := Clear[x]In[62] := Clear[x]
</p>
<p>Coding functions like this means inviting big troubles.
</p>
<p>In[63] := f = Function[{a,b},x= a;x&lowast; b]In[63] := f = Function[{a,b},x= a;x&lowast; b]In[63] := f = Function[{a,b},x= a;x&lowast; b]
Out[63] = Function[{a,b},x= a;xb]
In[64] := f [c,x]In[64] := f [c,x]In[64] := f [c,x]
Out[64] = c2
</p>
<p>In[65] := xIn[65] := xIn[65] := x
Out[65] = c
In[66] := Clear[ f ,x]In[66] := Clear[ f ,x]In[66] := Clear[ f ,x]
This is much better.
</p>
<p>In[67] := f = Function[{a,b},Module[{x= a},x&lowast; b]]In[67] := f = Function[{a,b},Module[{x= a},x&lowast; b]]In[67] := f = Function[{a,b},Module[{x= a},x&lowast; b]]
Out[67] = Function[{a,b},Module[{x= a},xb]]
In[68] := f [c,x]In[68] := f [c,x]In[68] := f [c,x]
Out[68] = cx
In[69] := xIn[69] := xIn[69] := x
Out[69] = x
In[70] := Clear[ f ]In[70] := Clear[ f ]In[70] := Clear[ f ]
</p>
<p>What happens if a local variable escapes from its scope? We can see that Mathe-
</p>
<p>matica implements local variables in the most trivial way&mdash;by renaming.
</p>
<p>In[71] := Module[{x},x]In[71] := Module[{x},x]In[71] := Module[{x},x]
Out[71] = x$103
</p>
<p>The function Block introduces another kind of local variables. As you value your
</p>
<p>life or your reason keep away from the function Block. Especially in those dark
</p>
<p>hours when the powers of evil are exalted.</p>
<p/>
</div>
<div class="page"><p/>
<p>50 6 Mathematica as a Programming Language
</p>
<p>Local Constants
</p>
<p>Local variables which cannot be changed after initialization can be introduced. This
</p>
<p>is done by the function With. Such local constants can be considered temporary
</p>
<p>notations introduced to make writing a single expression easier.
</p>
<p>In[72] := x= 1In[72] := x= 1In[72] := x= 1
Out[72] = 1
In[73] := With[{x= a+ 1},Print[x&and;2]]In[73] := With[{x= a+ 1},Print[x&and;2]]In[73] := With[{x= a+ 1},Print[x&and;2]]
Out[73] = (1+ a)2
</p>
<p>In[74] := xIn[74] := xIn[74] := x
Out[74] = 1
In[75] := Clear[x]In[75] := Clear[x]In[75] := Clear[x]
</p>
<p>6.6 Table
</p>
<p>The function Table constructs a list of values of an expression where a parameter
</p>
<p>varies in a given way (like in the Do loop).
</p>
<p>In[76] := Table[0,{4}]In[76] := Table[0,{4}]In[76] := Table[0,{4}]
Out[76] = {0,0,0,0}
In[77] := Table[x&and;i,{i,4}]In[77] := Table[x&and;i,{i,4}]In[77] := Table[x&and;i,{i,4}]
Out[77] =
</p>
<p>{
</p>
<p>x,x2,x3,x4
}
</p>
<p>In[78] := Table[x&and;i,{i,0,4}]In[78] := Table[x&and;i,{i,0,4}]In[78] := Table[x&and;i,{i,0,4}]
Out[78] =
</p>
<p>{
</p>
<p>1,x,x2,x3,x4
}
</p>
<p>In[79] := Table[x&and;i,{i,0,4,2}]In[79] := Table[x&and;i,{i,0,4,2}]In[79] := Table[x&and;i,{i,0,4,2}]
Out[79] =
</p>
<p>{
</p>
<p>1,x2,x4
}
</p>
<p>In[80] := Table[x&and;i,{i,{0,1,4}}]In[80] := Table[x&and;i,{i,{0,1,4}}]In[80] := Table[x&and;i,{i,{0,1,4}}]
Out[80] =
</p>
<p>{
</p>
<p>1,x,x4
}
</p>
<p>Let&rsquo;s turn the list into a product.
</p>
<p>In[81] := Table[x+ i,{i,0,4}]/.List&minus;&gt;TimesIn[81] := Table[x+ i,{i,0,4}]/.List&minus;&gt;TimesIn[81] := Table[x+ i,{i,0,4}]/.List&minus;&gt;Times
Out[81] = x(1+ x)(2+ x)(3+ x)(4+ x)
</p>
<p>6.7 Parallelization
</p>
<p>Now most computers have multi-core processors. The function Parallelize tries to
</p>
<p>calculate its argument faster by starting several Mathematica kernels and ordering
</p>
<p>them to calculate parts of the expression and then collecting these parts together.
</p>
<p>In[82] := Parallelize[Table[$KernelID,{n,0,7}]]In[82] := Parallelize[Table[$KernelID,{n,0,7}]]In[82] := Parallelize[Table[$KernelID,{n,0,7}]]
Out[82] = {4,4,3,3,2,2,1,1}
($KernelID is the number of the kernel in which a particular list element has been
</p>
<p>evaluated). In addition to Table, it can handle Map[ f ,{. . .}] (or f [{. . .}] where f
is a Listable function) and some other cases. Note that the slave Mathematica</p>
<p/>
</div>
<div class="page"><p/>
<p>6.9 Hold and Evaluate 51
</p>
<p>kernels started by Parallelize don&rsquo;t know definitions made in the master process;
</p>
<p>only built-in functions can be used. If you need a user-defined function f to be
</p>
<p>available in slave processes, you should explicitly distribute it.
</p>
<p>In[83] := f [n ] := Integrate[x&and;n &lowast;Sin[x],{x,0,Pi}]In[83] := f [n ] := Integrate[x&and;n &lowast;Sin[x],{x,0,Pi}]In[83] := f [n ] := Integrate[x&and;n &lowast;Sin[x],{x,0,Pi}]
In[84] := DistributeDefinitions[ f ]In[84] := DistributeDefinitions[ f ]In[84] := DistributeDefinitions[ f ]
Out[84] = { f}
In[85] := Parallelize[Table[{ f [n],$KernelID},{n,0,7}]]In[85] := Parallelize[Table[{ f [n],$KernelID},{n,0,7}]]In[85] := Parallelize[Table[{ f [n],$KernelID},{n,0,7}]]
Out[85] =
</p>
<p>{
</p>
<p>{2,4},{π ,4},
{
</p>
<p>&minus;4+π2,3
}
</p>
<p>,
{
</p>
<p>π
(
</p>
<p>&minus;6+π2
)
</p>
<p>,3
}
</p>
<p>,
{
</p>
<p>48&minus; 12π2+π4,2
}
</p>
<p>,
{
</p>
<p>π
(
</p>
<p>120&minus; 20π2+π4
)
</p>
<p>,2
}
</p>
<p>,
{
</p>
<p>&minus;1440+ 360π2&minus; 30π4+π6,1
}
</p>
<p>,
{
</p>
<p>π
(
</p>
<p>&minus;5040+ 840π2&minus; 42π4+π6
)
</p>
<p>,1
}}
</p>
<p>In[86] := Clear[ f ]In[86] := Clear[ f ]In[86] := Clear[ f ]
</p>
<p>6.8 Functions with an Index
</p>
<p>Something like an array of functions can be constructed. Let f [1] be the function
adding 1 to its argument and f [2]&mdash;the function adding 2 to its argument; f [n] is
undefined for other values of n.
</p>
<p>In[87] := f [1] = Function[x,x+ 1]In[87] := f [1] = Function[x,x+ 1]In[87] := f [1] = Function[x,x+ 1]
Out[87] = Function[x,x+ 1]
In[88] := f [2] = Function[x,x+ 2]In[88] := f [2] = Function[x,x+ 2]In[88] := f [2] = Function[x,x+ 2]
Out[88] = Function[x,x+ 2]
In[89] := { f [1][a], f [2][a], f [n][a]}In[89] := { f [1][a], f [2][a], f [n][a]}In[89] := { f [1][a], f [2][a], f [n][a]}
Out[89] = {1+ a,2+ a, f [n][a]}
In[90] := Clear[ f ]In[90] := Clear[ f ]In[90] := Clear[ f ]
</p>
<p>6.9 Hold and Evaluate
</p>
<p>Assignment
</p>
<p>Assignment does not evaluate its left-hand side. This is natural: the value of the
</p>
<p>right-hand side is assigned to the variable given by the left-hand side, not to its
</p>
<p>value.
</p>
<p>In[91] := a= xIn[91] := a= xIn[91] := a= x
Out[91] = x
In[92] := a= yIn[92] := a= yIn[92] := a= y
Out[92] = y
In[93] := aIn[93] := aIn[93] := a
Out[93] = y
In[94] := xIn[94] := xIn[94] := x
Out[94] = x</p>
<p/>
</div>
<div class="page"><p/>
<p>52 6 Mathematica as a Programming Language
</p>
<p>The attribute HoldFirst is responsible for this.
</p>
<p>In[95] := Attributes[Set]In[95] := Attributes[Set]In[95] := Attributes[Set]
Out[95] = {HoldFirst,Protected,SequenceHold}
</p>
<p>Evaluate
</p>
<p>It is possible to assign a value to the value of the left-hand side. To this end the
</p>
<p>function Evaluate is used.
</p>
<p>In[96] := a= xIn[96] := a= xIn[96] := a= x
Out[96] = x
In[97] := Evaluate[a] = yIn[97] := Evaluate[a] = yIn[97] := Evaluate[a] = y
Out[97] = y
In[98] := xIn[98] := xIn[98] := x
Out[98] = y
In[99] := aIn[99] := aIn[99] := a
Out[99] = y
In[100] := Clear[x]; aIn[100] := Clear[x]; aIn[100] := Clear[x]; a
Out[100] = x
In[101] := Clear[a]In[101] := Clear[a]In[101] := Clear[a]
</p>
<p>Delayed Assignment
</p>
<p>Delayed assignment does not evaluate also its right-hand side. The attribute HoldAll
</p>
<p>is responsible for this.
</p>
<p>In[102] := Attributes[SetDelayed]In[102] := Attributes[SetDelayed]In[102] := Attributes[SetDelayed]
Out[102] = {HoldAll,Protected,SequenceHold}
You can use these attributes for your functions, too.
</p>
<p>In[103] := x= 1; y= 2; z= 3;In[103] := x= 1; y= 2; z= 3;In[103] := x= 1; y= 2; z= 3;
In[104] := Attributes[ f ] = {HoldAll}; f [x,y,z]In[104] := Attributes[ f ] = {HoldAll}; f [x,y,z]In[104] := Attributes[ f ] = {HoldAll}; f [x,y,z]
Out[104] = f [x,y,z]
In[105] := Attributes[ f ] = {HoldFirst}; f [x,y,z]In[105] := Attributes[ f ] = {HoldFirst}; f [x,y,z]In[105] := Attributes[ f ] = {HoldFirst}; f [x,y,z]
Out[105] = f [x,2,3]
In[106] := Clear[x,y,z]In[106] := Clear[x,y,z]In[106] := Clear[x,y,z]
In[107] := ClearAll[ f ]In[107] := ClearAll[ f ]In[107] := ClearAll[ f ]
</p>
<p>The First Argument of the Function Plot
</p>
<p>The function Plot does not evaluate its arguments.
</p>
<p>In[108] := Attributes[Plot]In[108] := Attributes[Plot]In[108] := Attributes[Plot]
Out[108] = {HoldAll,Protected}
The first argument f [x] can be meaningful only for numerical values of x, not for
symbolic x. Therefore it is better not to evaluate f [x] before the function Plot will</p>
<p/>
</div>
<div class="page"><p/>
<p>6.9 Hold and Evaluate 53
</p>
<p>call it for numerical values of x. But if the first argument is a command which
</p>
<p>generates the list of expressions to draw, it will not work. We want the command to
</p>
<p>be executed; to this end Evaluate is used.
</p>
<p>In[109] := Plot[Evaluate[Table[Sin[n &lowast; x],{n,1,3}]],{x,0,2 &lowast;Pi}]In[109] := Plot[Evaluate[Table[Sin[n &lowast; x],{n,1,3}]],{x,0,2 &lowast;Pi}]In[109] := Plot[Evaluate[Table[Sin[n &lowast; x],{n,1,3}]],{x,0,2 &lowast;Pi}]
</p>
<p>1 2 3 4 5 6
</p>
<p>1.0
</p>
<p>0.5
</p>
<p>0.5
</p>
<p>1.0
</p>
<p>Out[109] =
</p>
<p>Hold
</p>
<p>The function Hold suppresses evaluation of its argument.
</p>
<p>In[110] := a= xIn[110] := a= xIn[110] := a= x
Out[110] = x
In[111] := b= Hold[a]In[111] := b= Hold[a]In[111] := b= Hold[a]
Out[111] = Hold[a]
This suppression can be removed by the function ReleaseHold.
</p>
<p>In[112] := ReleaseHold[b]In[112] := ReleaseHold[b]In[112] := ReleaseHold[b]
Out[112] = x
The function Hold is simple&mdash;it has the attribute HoldAll, i.e., it does not evaluate
</p>
<p>its arguments.
</p>
<p>In[113] := Attributes[Hold]In[113] := Attributes[Hold]In[113] := Attributes[Hold]
Out[113] = {HoldAll,Protected}
In[114] := Clear[a,b]In[114] := Clear[a,b]In[114] := Clear[a,b]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 7
</p>
<p>Gröbner Bases
</p>
<p>7.1 Statement of the Problem
</p>
<p>In this lecture we shall consider (in a slightly vulgarized form, without rigorous
</p>
<p>mathematical terms) an important mathematical achievement of the second half of
</p>
<p>the last century&mdash;Gröbner bases, the Buchberger algorithm (which constructs them),
</p>
<p>and their applications (see [12, 13] for an introduction).
</p>
<p>Suppose we have n variables x1, . . . , xn. They are not independent, but satisfy
</p>
<p>some polynomial equations p1 = 0, . . . , pm = 0 (p j are polynomials of xi). Let&rsquo;s
consider some polynomial q of the same variables. It is natural to ask if this poly-
</p>
<p>nomial is equal to 0 due to the constraints on our variables or not. If there is another
</p>
<p>polynomial q2, there is the question of their equality.
</p>
<p>These questions would become very easy if we had an algorithm reducing
</p>
<p>polynomials of dependent variables to a canonical form. Two equal polynomials
</p>
<p>reduce to the same canonical form; a polynomial equal to 0 reduces to the canonical
</p>
<p>form 0.
</p>
<p>We can try to use the equations p j = 0 for simplifying the polynomial q, i.e., for
replacing its more complicated terms by combinations of simpler ones. But to do so
</p>
<p>we first have to accept some convention in which terms are more complicated and
</p>
<p>which are more simple.
</p>
<p>7.2 Monomial Orders
</p>
<p>We need a total order of monomials (i.e., products of powers of the variables
</p>
<p>x
n1
1 &middot; &middot; &middot;xnnn ). An order is total if for any monomials s and t either s &lt; t or s &gt; t or
s= t is true. An order is admissible if two properties are satisfied:
</p>
<p>&bull; 1 � s for any monomial s.
&bull; If s&lt; t then su &lt; t u for any monomial u.
</p>
<p>Three admissible orders are most popular.
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 7, &copy; Springer International Publishing Switzerland 2014
</p>
<p>55</p>
<p/>
</div>
<div class="page"><p/>
<p>56 7 Gröbner Bases
</p>
<p>Lexicographic
</p>
<p>Anybody who has ever seen a dictionary knows what is lexicographic order. We are
</p>
<p>comparing two monomials: s= xn11 x
n2
2 &middot; &middot; &middot;xnnn and t = x
</p>
<p>m1
1 x
</p>
<p>m2
2 &middot; &middot; &middot;xmnn . If the degree of
</p>
<p>the main variable x1 in s is larger than in t (n1 &gt; m1), then s &gt; t. If it is smaller
(n1 &lt; m1), then s&lt; t. If n1 = m1, we compare the degrees of the next variable x2: if
n2 &gt; m2, then s &gt; t; if n2 &lt; m2, then s &lt; t; if n2 = m2, we compare the degrees of
x3; and so on.
</p>
<p>By Total Degree than Lexicographic
</p>
<p>First we compare the total degree n = n1 + n2 + &middot; &middot; &middot;+ nn of the monomial s and the
total degree m=m1 +m2+ &middot; &middot; &middot;+mn of the monomial t. If n&gt;m then s&gt; t; if n&lt;m
then s&lt; t; if the total degrees are equal, we compare s and t lexicographically.
</p>
<p>By Total Degree than Reverse Lexicographic
</p>
<p>First we compare the total degrees. If they are equal, then we begin from the junior
</p>
<p>variable xn: if its degree in s is larger than in t (nn &gt; mn), then s&lt; t; if it is smaller
(nn &lt; mn), then s &gt; t; if nn = mn, we compare the degrees of the previous variable
xn&minus;1; and so on, that is, this is (within some total degree) the reverse lexicographic
order with respect to the reverse list of variables.
</p>
<p>7.3 Reduction of Polynomials
</p>
<p>Let&rsquo;s fix some admissible monomial order. We&rsquo;ll write polynomials in descending
</p>
<p>order: the leading term first, followed by the rest ones. We&rsquo;ll normalize all
</p>
<p>polynomials pi in such a way that the coefficient of the leading term is 1. Now
</p>
<p>they can be used as substitutions which replace the leading term by minus sum
</p>
<p>of the remaining ones, that is, if some term of a polynomial q is divisible by the
</p>
<p>leading term of some polynomial pi, we remove this leading term and insert minus
</p>
<p>sum of the remainder terms of pi instead. This is called reduction of the polynomial
</p>
<p>q with respect to the set of polynomials pi; if none of the substitutions is applicable,
</p>
<p>the polynomial q is called reduced. For example, let&rsquo;s consider a set of polynomials
</p>
<p>In[1] := p1 = x&and;2+ y&and;2&minus; 1; p2 = x&lowast; y&minus; 1/4;In[1] := p1 = x&and;2+ y&and;2&minus; 1; p2 = x&lowast; y&minus; 1/4;In[1] := p1 = x&and;2+ y&and;2&minus; 1; p2 = x&lowast; y&minus; 1/4;
Let&rsquo;s try to reduce the polynomial
</p>
<p>In[2] := q= x&and;2 &lowast; y;In[2] := q= x&and;2 &lowast; y;In[2] := q= x&and;2 &lowast; y;
(we use the lexicographic order with x&gt; y). This can be done in different ways.</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4 S-Polynomials 57
</p>
<p>Let&rsquo;s first reduce q with respect to p1:
</p>
<p>In[3] := PolynomialReduce[q,{p1},{x,y}]In[3] := PolynomialReduce[q,{p1},{x,y}]In[3] := PolynomialReduce[q,{p1},{x,y}]
Out[3] =
</p>
<p>{
</p>
<p>{y},y&minus; y3
}
</p>
<p>The result means that if we subtract the polynomial p1 multiplied by y from q, then
</p>
<p>the reduced polynomial y&minus; y3 is obtained. This is what we are interested in.
In[4] := q1 = %[[2]]In[4] := q1 = %[[2]]In[4] := q1 = %[[2]]
Out[4] = y&minus; y3
Now let&rsquo;s reduce q with respect to p2:
</p>
<p>In[5] := PolynomialReduce[q,{p2},{x,y}]In[5] := PolynomialReduce[q,{p2},{x,y}]In[5] := PolynomialReduce[q,{p2},{x,y}]
Out[5] =
</p>
<p>{
</p>
<p>{x}, x
4
</p>
<p>}
</p>
<p>In[6] := q2 = %[[2]]In[6] := q2 = %[[2]]In[6] := q2 = %[[2]]
</p>
<p>Out[6] =
x
</p>
<p>4
So, we have obtained two different results, q1 and q2. In fact they are equal due to
</p>
<p>p1 = 0 and p2 = 0, but this is not evident. Every time when more than one substi-
tution can be applied to a term of a polynomial q (in this particular case, we can
</p>
<p>replace either x2 or xy in x2 y), a fork appears; maybe, its branches join later, but
</p>
<p>maybe, they don&rsquo;t (as in this case).
</p>
<p>A set of polynomials p1, . . . , pn is called a Gröbner basis (for a given monomial
</p>
<p>order) if reduction of any polynomial q with respect to this set is unique.
</p>
<p>This definition is not constructive: it does not say how to check if a given set
</p>
<p>of polynomials forms a Gröbner basis. Presently we shall formulate Buchberger
</p>
<p>algorithm which transforms a set of polynomials (constraints on variables) into an
</p>
<p>equivalent system of constraints which is a Gröbner basis.
</p>
<p>7.4 S-Polynomials
</p>
<p>In our example, the constraints p1 = 0 and p2 = 0 allow us to simplify the
monomials x2 and xy. Do these constraints contain an extra information usable for
</p>
<p>simplification but not obvious? Yes, they do! Let&rsquo;s multiply p1 and p2 by monomials
</p>
<p>(i.e., products of powers of variables) in such a way that their leading terms become
</p>
<p>identical (equal to the least common multiple of the leading terms of p1 and p2).
</p>
<p>Then we subtract the second polynomial from the first one. The leading terms can-
</p>
<p>cel, and we get a new polynomial with a new leading term which can be used for
</p>
<p>simplifying terms in q (because this new polynomial also vanishes). This polynomial
</p>
<p>is called the S-polynomial S [p1, p2] (from the word subtraction). In our example
In[7] := S= Expand[y&lowast; p1&minus; x&lowast; p2]In[7] := S = Expand[y&lowast; p1&minus; x&lowast; p2]In[7] := S = Expand[y&lowast; p1&minus; x&lowast; p2]
Out[7] =
</p>
<p>x
</p>
<p>4
&minus; y+ y3
</p>
<p>This polynomial can be added to the system of constraints p1 = 0, p2 = 0. Let&rsquo;s
normalize its leading coefficient to 1:
</p>
<p>In[8] := p3 = Expand[4 &lowast; S]In[8] := p3 = Expand[4 &lowast; S]In[8] := p3 = Expand[4 &lowast; S]
Out[8] = x&minus; 4y+ 4y3
In[9] := Clear[S]In[9] := Clear[S]In[9] := Clear[S]</p>
<p/>
</div>
<div class="page"><p/>
<p>58 7 Gröbner Bases
</p>
<p>Now we have a new possibility for reduction:
</p>
<p>In[10] := PolynomialReduce[q2,{p3},{x,y}]In[10] := PolynomialReduce[q2,{p3},{x,y}]In[10] := PolynomialReduce[q2,{p3},{x,y}]
Out[10] =
</p>
<p>{{
</p>
<p>1
</p>
<p>4
</p>
<p>}
</p>
<p>,y&minus; y3
}
</p>
<p>Now we&rsquo;ve got the same result q1. The polynomials {p1, p2, p3} form a Gröbner
basis. This set can be simplified by reducing them with respect to each other:
</p>
<p>In[11] := PolynomialReduce[p1,{p3},{x,y}]In[11] := PolynomialReduce[p1,{p3},{x,y}]In[11] := PolynomialReduce[p1,{p3},{x,y}]
Out[11] =
</p>
<p>{
</p>
<p>{
</p>
<p>x+ 4y&minus; 4y3
}
</p>
<p>,&minus;1+ 17y2&minus; 32y4+ 16y6
}
</p>
<p>In[12] := p1a = Expand[%[[2]]/16]In[12] := p1a = Expand[%[[2]]/16]In[12] := p1a = Expand[%[[2]]/16]
</p>
<p>Out[12] =&minus; 1
16
</p>
<p>+
17y2
</p>
<p>16
&minus; 2y4 + y6
</p>
<p>In[13] := PolynomialReduce[p2,{p3},{x,y}]In[13] := PolynomialReduce[p2,{p3},{x,y}]In[13] := PolynomialReduce[p2,{p3},{x,y}]
Out[13] =
</p>
<p>{
</p>
<p>{y}, 1
4
</p>
<p>(
</p>
<p>&minus;1+ 16y2&minus; 16y4
)
</p>
<p>}
</p>
<p>In[14] := p2a = Expand[&minus;%[[2]]/4]In[14] := p2a = Expand[&minus;%[[2]]/4]In[14] := p2a = Expand[&minus;%[[2]]/4]
Out[14] =
</p>
<p>1
</p>
<p>16
&minus; y2 + y4
</p>
<p>In[15] := PolynomialReduce[p1a,p2a,{x,y}]In[15] := PolynomialReduce[p1a,p2a,{x,y}]In[15] := PolynomialReduce[p1a,p2a,{x,y}]
Out[15] =
</p>
<p>{{
</p>
<p>&minus;1+ y2
}
</p>
<p>,0
}
</p>
<p>The polynomial p1a reduces to 0, and hence it can be excluded from the system
</p>
<p>of constraints on our variables x, y. The polynomials p2a and p3 form a reduced
</p>
<p>Gröbner basis (with respect to the lexicographic order with x&gt; y). Reduced Gröbner
basis is unique (for a given monomial order), if we accept the convention that the
</p>
<p>coefficients of the leading terms are 1.
</p>
<p>7.5 Buchberger Algorithm
</p>
<p>Generalizing this example, we can formulate an algorithm for construction of the
</p>
<p>Gröbner basis of a set of n polynomials P= {pi}:
</p>
<p>1. S = {the set of pairs (pi, p j) of these polynomials with i&lt; j � n}
2. while S is not empty
</p>
<p>3. choose and remove some pair (pi, p j) from S;
4. calculate the S-polynomial S [pi, p j];
5. reduce it with respect to P;
</p>
<p>6. if the result is not 0, add this polynomial to P,
</p>
<p>and the corresponding pairs to S.
</p>
<p>The set of pairs S alternatingly shrinks and grows. But it can be proved that this
</p>
<p>process terminates after a finite number of steps and produces a Gröbner basis P.
</p>
<p>Reducing these polynomials with respect to each other and throwing zeros away,
</p>
<p>one can get the reduced Gröbner basis. Some variations can improve the efficiency
</p>
<p>of the algorithm. For example, when adding a new polynomial to the set P, we
</p>
<p>can reduce all polynomials already in P with respect to the new one; if some of</p>
<p/>
</div>
<div class="page"><p/>
<p>7.6 Is the System Compatible? 59
</p>
<p>them changes, reduce other ones with respect to them, and so on (throwing zeros
</p>
<p>away while doing so). The order in which pairs are selected from the set S is very
</p>
<p>important&mdash;a good choice can reduce the amount of computations drastically.
</p>
<p>Let&rsquo;s ask Mathematica to construct the Gröbner basis for the system {p1, p2}
with respect to the lexicographic order with x&gt; y:
In[16] := B= GroebnerBasis[{p1,p2},{x,y}]In[16] := B= GroebnerBasis[{p1,p2},{x,y}]In[16] := B= GroebnerBasis[{p1,p2},{x,y}]
Out[16] =
</p>
<p>{
</p>
<p>1&minus; 16y2+ 16y4,x&minus; 4y+ 4y3
}
</p>
<p>Let&rsquo;s reduce the polynomial q to the canonical form, i.e., reduce it with respect to
</p>
<p>the Gröbner basis (the result is unique).
</p>
<p>In[17] := PolynomialReduce[q,B,{x,y}]In[17] := PolynomialReduce[q,B,{x,y}]In[17] := PolynomialReduce[q,B,{x,y}]
Out[17] =
</p>
<p>{{
</p>
<p>&minus; x
4
,
</p>
<p>1
</p>
<p>4
+ xy
</p>
<p>}
</p>
<p>,y&minus; y3
}
</p>
<p>It is difficult to predict the complexity of the Buchberger algorithm. In worst
</p>
<p>cases it can be very high, i.e., constructing the Gröbner basis of a moderately large
</p>
<p>system can require a huge amount of calculations. The complexity strongly depends
</p>
<p>on the monomial order being used. In the case of ordering by the total degree (and
</p>
<p>then something) reduction tries to lower the total degree of a polynomial. The num-
</p>
<p>ber of possible terms in a polynomial of a low total degree is small. In the case of the
</p>
<p>lexicographic order, a polynomial of y of an arbitrarily large degree is considered
</p>
<p>simpler than x to the first power. Therefore reduction does not lower the number of
</p>
<p>terms in a polynomial as strongly as in the case of total-degree orders, and the com-
</p>
<p>plexity of Gröbner basis calculations is higher. On the other hand, a reduced Gröbner
</p>
<p>basis with respect to a lexicographic order provides more information useful for
</p>
<p>solving the system, as we shall see soon. Mathematica knows how to construct
</p>
<p>Gröbner bases with respect to monomial orders we discussed.
</p>
<p>In[18] := B= GroebnerBasis[{p1,p2},{x,y},In[18] := B= GroebnerBasis[{p1,p2},{x,y},In[18] := B= GroebnerBasis[{p1,p2},{x,y},
MonomialOrder&rarr; DegreeLexicographic]MonomialOrder&rarr; DegreeLexicographic]MonomialOrder&rarr; DegreeLexicographic]
</p>
<p>Out[18] =
{
</p>
<p>&minus;1+ 4xy,&minus;1+ x2+ y2,x&minus; 4y+ 4y3
}
</p>
<p>In[19] := PolynomialReduce[q,B,MonomialOrder&rarr; DegreeLexicographic]In[19] := PolynomialReduce[q,B,MonomialOrder&rarr; DegreeLexicographic]In[19] := PolynomialReduce[q,B,MonomialOrder&rarr; DegreeLexicographic]
Out[19] =
</p>
<p>{{ x
</p>
<p>4
,0,0
</p>
<p>}
</p>
<p>,
x
</p>
<p>4
</p>
<p>}
</p>
<p>In[20] := Clear[p1,p2,p3,p1a,p2a,q,q1,q2,B]In[20] := Clear[p1,p2,p3,p1a,p2a,q,q1,q2,B]In[20] := Clear[p1,p2,p3,p1a,p2a,q,q1,q2,B]
</p>
<p>7.6 Is the System Compatible?
</p>
<p>Consider the system
</p>
<p>In[21] := p1 = x&and;2 &lowast; y+ 4 &lowast; y&and;2&minus; 17; p2 = 2 &lowast; x&lowast; y&minus; 3 &lowast; y&and;3+ 8;In[21] := p1 = x&and;2 &lowast; y+ 4 &lowast; y&and;2&minus; 17; p2 = 2 &lowast; x&lowast; y&minus; 3 &lowast; y&and;3+ 8;In[21] := p1 = x&and;2 &lowast; y+ 4 &lowast; y&and;2&minus; 17; p2 = 2 &lowast; x&lowast; y&minus; 3 &lowast; y&and;3+ 8;
p3 = x&lowast; y&and;2&minus; 5 &lowast; x&lowast; y+1;p3 = x&lowast; y&and;2&minus; 5 &lowast; x&lowast; y+1;p3 = x&lowast; y&and;2&minus; 5 &lowast; x&lowast; y+1;
</p>
<p>Let&rsquo;s construct its Gröbner basis&mdash;an equivalent system of equations.
</p>
<p>In[22] := GroebnerBasis[{p1,p2,p3},{x,y,z}]In[22] := GroebnerBasis[{p1,p2,p3},{x,y,z}]In[22] := GroebnerBasis[{p1,p2,p3},{x,y,z}]
Out[22] = {1}
This system contains the equation 1 = 0. This means that it has no solutions. If the
Gröbner basis contains 1, the system is incompatible. The inverse statement can be</p>
<p/>
</div>
<div class="page"><p/>
<p>60 7 Gröbner Bases
</p>
<p>also proved&mdash;the Gröbner basis of an incompatible system always contains 1 (if we
</p>
<p>normalize all leading coefficients to 1; otherwise, just some nonzero constant).
</p>
<p>In[23] := Clear[p1,p2,p3]In[23] := Clear[p1,p2,p3]In[23] := Clear[p1,p2,p3]
</p>
<p>7.7 Gröbner Bases with Respect to Lexicographic Order
</p>
<p>Reduction with respect to the lexicographic order first of all tries to lower the degree
</p>
<p>of the main variable (x in our examples), and if possible, down to 0. Therefore
</p>
<p>usually there is a subset of polynomials in a reduced Gröbner bases which don&rsquo;t
</p>
<p>contain x. When x is absent, reduction tries to lower the degree of y, and if possible,
</p>
<p>down to 0. Therefore usually among these polynomials there are those which don&rsquo;t
</p>
<p>contain y, and so on. In other words, a lexicographic Gröbner bases has a triangular
</p>
<p>structure. For example,
</p>
<p>In[24] := B= GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z}]In[24] := B= GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z}]In[24] := B= GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z}]
Out[24] =
</p>
<p>{
</p>
<p>z2 + z3 + z4,y+ z2,x&minus; z&minus; z2
}
</p>
<p>The polynomial
</p>
<p>In[25] := p1 = B[[1]]In[25] := p1 = B[[1]]In[25] := p1 = B[[1]]
Out[25] = z2 + z3 + z4
</p>
<p>depends only on the most junior variable z. This means that projections of all
</p>
<p>solutions of our system on the z axis form a finite set of points&mdash;roots of this equa-
</p>
<p>tion. In our example, they are z= 0 and
In[26] := p1 = Expand[p1/z&and;2]; s= Solve[p1 == 0,z]In[26] := p1 = Expand[p1/z&and;2]; s= Solve[p1 == 0,z]In[26] := p1 = Expand[p1/z&and;2]; s= Solve[p1 == 0,z]
</p>
<p>Out[26] =
{{
</p>
<p>z&rarr;&minus;(&minus;1)1/3
}
</p>
<p>,
{
</p>
<p>z&rarr; (&minus;1)2/3
}}
</p>
<p>In[27] := z1 = ComplexExpand[z/.s[[1]]]In[27] := z1 = ComplexExpand[z/.s[[1]]]In[27] := z1 = ComplexExpand[z/.s[[1]]]
</p>
<p>Out[27] =&minus;1
2
&minus; i
</p>
<p>&radic;
3
</p>
<p>2
In[28] := z2 = ComplexExpand[z/.s[[2]]]In[28] := z2 = ComplexExpand[z/.s[[2]]]In[28] := z2 = ComplexExpand[z/.s[[2]]]
</p>
<p>Out[28] =&minus;1
2
+
</p>
<p>i
&radic;
</p>
<p>3
</p>
<p>2
Substituting any of these z values to
</p>
<p>In[29] := p2 = B[[2]]In[29] := p2 = B[[2]]In[29] := p2 = B[[2]]
Out[29] = y+ z2
</p>
<p>we find the corresponding y value. Substituting these z and y into
</p>
<p>In[30] := p3 = B[[3]]In[30] := p3 = B[[3]]In[30] := p3 = B[[3]]
Out[30] = x&minus; z&minus; z2
we find the corresponding x value. Thus solving any system of polynomial equations
</p>
<p>with several unknowns reduces to solving single-variable polynomial equations
</p>
<p>sequentially, thanks to lexicographic Gröbner bases. Even when some of them
</p>
<p>cannot be solved in radicals, it is easy to solve them numerically to any desired
</p>
<p>precision.
</p>
<p>In[31] := Clear[B,p1,p2,p3,z1,z2]In[31] := Clear[B,p1,p2,p3,z1,z2]In[31] := Clear[B,p1,p2,p3,z1,z2]
And here is another example.</p>
<p/>
</div>
<div class="page"><p/>
<p>7.8 Is the Number of Solutions Finite? 61
</p>
<p>In[32] := B= GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,In[32] := B= GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,In[32] := B= GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,
x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z}]x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z}]x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z}]
</p>
<p>Out[32] =
{
</p>
<p>1&minus; y2 &minus; 2z2 + y2z2 + z4,&minus;y+ y3 + z&minus; y2z+ yz2 &minus; z3,
x&minus; y&minus; 2z+ y2z+ z3
</p>
<p>}
</p>
<p>Now we have no equations with a single variable z; there are 2 equations containing
</p>
<p>z and y:
</p>
<p>In[33] := p1 = Factor[B[[1]]]In[33] := p1 = Factor[B[[1]]]In[33] := p1 = Factor[B[[1]]]
Out[33] = (&minus;1+ z)(1+ z)
</p>
<p>(
</p>
<p>&minus;1+ y2+ z2
)
</p>
<p>In[34] := p2 = Factor[B[[2]]]In[34] := p2 = Factor[B[[2]]]In[34] := p2 = Factor[B[[2]]]
Out[34] = (y&minus; z)
</p>
<p>(
</p>
<p>&minus;1+ y2+ z2
)
</p>
<p>The common set of their solutions is the circle y2 + z2 = 1. Substituting a point on
this circle into
</p>
<p>In[35] := p3 = B[[3]]In[35] := p3 = B[[3]]In[35] := p3 = B[[3]]
Out[35] = x&minus; y&minus; 2z+ y2z+ z3
we find the corresponding x value, that is, the set of solutions of this system is
</p>
<p>one-dimensional.
</p>
<p>In[36] := Clear[B,p1,p2,p3]In[36] := Clear[B,p1,p2,p3]In[36] := Clear[B,p1,p2,p3]
For solving a system of polynomial equations it is useful to construct its Gröbner
</p>
<p>basis and then to factorize its elements.
</p>
<p>7.8 Is the Number of Solutions Finite?
</p>
<p>Gröbner bases with respect to other monomial orders don&rsquo;t have such simple
</p>
<p>triangular structure. But any Gröbner basis can tell us not only if the system is
</p>
<p>compatible but also if the number of its solutions is finite. Let&rsquo;s consider the same
</p>
<p>examples.
</p>
<p>In[37] := GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z},In[37] := GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z},In[37] := GroebnerBasis[{x&and;2+ y&and;2+ z&and;2,x+ y&minus; z,y+ z&and;2},{x,y,z},
MonomialOrder&rarr; DegreeLexicographic]MonomialOrder&rarr; DegreeLexicographic]MonomialOrder&rarr; DegreeLexicographic]
</p>
<p>Out[37] =
{
</p>
<p>x+ y&minus; z,y+ z2,&minus;y+ y2 &minus; yz
}
</p>
<p>The leading terms of the polynomials forming this basis are x, z2, and y2. What is the
</p>
<p>dimensionality of the space of polynomials which cannot be reduced with respect to
</p>
<p>this basis? Only monomials which are not divisible by these leading terms cannot be
</p>
<p>reduced, namely, 1, y, and z. So the space of polynomials reduced to the canonical
</p>
<p>form is three-dimensional for our system of constraints on the variables. Therefore
</p>
<p>our system has 3 solutions (there explicit form can be obtained more easily from the
</p>
<p>lexicographic Gröbner basis, as we have seen).
</p>
<p>If each variable raised to some power is the leading term of some element of a
</p>
<p>Gröbner basis, then any monomials with this (or higher) degree of this variable are
</p>
<p>reducible. Irreducible monomials are inside the parallelepiped bounded by these
</p>
<p>powers, and their number is finite. Therefore the space of polynomials reduced
</p>
<p>to the canonical form is finite-dimensional, and the system has a finite number of
</p>
<p>solutions.</p>
<p/>
</div>
<div class="page"><p/>
<p>62 7 Gröbner Bases
</p>
<p>And here is our second example:
</p>
<p>In[38] := GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+ 2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,In[38] := GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+ 2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,In[38] := GroebnerBasis[{x&and;2&minus; 2 &lowast; x&lowast; y+2&lowast; y&and;2&minus; 1,x&lowast; y&minus; y&lowast; z+ z&and;2&minus; 1,
x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z},MonomialOrder&rarr; DegreeLexicographic]x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z},MonomialOrder&rarr; DegreeLexicographic]x&lowast; z+ y&and;2&minus; y&lowast; z&minus; 1},{x,y,z},MonomialOrder&rarr; DegreeLexicographic]
</p>
<p>Out[38] =
{
</p>
<p>&minus;1+ y2+ xz&minus; yz,&minus;1+ xy&minus; yz+ z2,&minus;3+ x2 + 2y2 &minus; 2yz+ 2z2,
x&minus; y&minus; 2z+ y2z+ z3,x&minus; 2y+ y3&minus; z+ yz2
</p>
<p>}
</p>
<p>The leading terms are xz, xy, x2, y2 z, and y3. Among them there are powers of x
</p>
<p>and of y, but not of z. Therefore the space of polynomials in the canonical form (i.e.,
</p>
<p>reduced with respect to this basis) is infinite-dimensional. This space contains, e.g.,
</p>
<p>the directions 1, z, z2, z3. . . (and not only them). This means that the set of solutions
</p>
<p>of our system is infinite.
</p>
<p>So, the criterion works in the opposite direction, too. If there exists a variable
</p>
<p>no power of which appears as the leading term of some element of the Gröbner
</p>
<p>basis (not being multiplied by some other variable), then all powers of this variable
</p>
<p>are irreducible, and the space of polynomials in the canonical form is infinite-
</p>
<p>dimensional. And hence the set of solutions of the equation system is infinite.
</p>
<p>Knowing the reduced Gröbner basis (for any monomial order) one can also find
</p>
<p>the dimensionality of the set of solutions [14]. Consider sets of variables satisfying
</p>
<p>the following condition: none of the leading terms of the elements of the basis is
</p>
<p>a product of powers of these variables. The number of variables in the longest set
</p>
<p>gives the dimensionality of the set of solutions. In our example there is just one such
</p>
<p>set&mdash;{z}. Therefore the set of solutions of this system is one-dimensional.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 8
</p>
<p>Calculus
</p>
<p>8.1 Series
</p>
<p>Let&rsquo;s expand a function in x at the point x= 0 up to the fifth order.
In[1] := s= Series[Exp[x],{x,0,5}]In[1] := s= Series[Exp[x],{x,0,5}]In[1] := s= Series[Exp[x],{x,0,5}]
</p>
<p>Out[1] = 1+ x+
x2
</p>
<p>2
+
</p>
<p>x3
</p>
<p>6
+
</p>
<p>x4
</p>
<p>24
+
</p>
<p>x5
</p>
<p>120
+O[x]6
</p>
<p>How are series represented in Mathematica? By the function SeriesData. Its first ar-
</p>
<p>gument is the expansion variable; the second one&mdash;the expansion point; the third
</p>
<p>one&mdash;the list of coefficients; the fourth one&mdash;the minimum degree (here 0); the
</p>
<p>fifth one&mdash;the power of O[x]; the sixth one is 1 for series with integer degrees (all
degrees are divided by it if it&rsquo;s not 1). Thus a series is not a sum (Plus) in spite of its
</p>
<p>appearance.
</p>
<p>In[2] := FullForm[s]In[2] := FullForm[s]In[2] := FullForm[s]
Out[2]//FullForm =
</p>
<p>SeriesData[x,0,List[1,1,Rational[1,2],Rational[1,6],Rational[1,24],
Rational[1,120]],0,6,1]
</p>
<p>Coefficients are extracted by the function SeriesCoefficient.
</p>
<p>In[3] := Do[Print[SeriesCoefficient[s,n]],{n,0,5}]In[3] := Do[Print[SeriesCoefficient[s,n]],{n,0,5}]In[3] := Do[Print[SeriesCoefficient[s,n]],{n,0,5}]
1
</p>
<p>1
1
</p>
<p>2
1
</p>
<p>6
1
</p>
<p>24
1
</p>
<p>120
This series begins with degree &minus;1.
</p>
<p>In[4] := s= Series[Cot[x],{x,0,5}]In[4] := s= Series[Cot[x],{x,0,5}]In[4] := s= Series[Cot[x],{x,0,5}]
</p>
<p>Out[4] =
1
</p>
<p>x
&minus; x
</p>
<p>3
&minus; x
</p>
<p>3
</p>
<p>45
&minus; 2x
</p>
<p>5
</p>
<p>945
+O[x]6
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 8, &copy; Springer International Publishing Switzerland 2014
</p>
<p>63</p>
<p/>
</div>
<div class="page"><p/>
<p>64 8 Calculus
</p>
<p>In[5] := FullForm[s]In[5] := FullForm[s]In[5] := FullForm[s]
Out[5]//FullForm =
</p>
<p>SeriesData[x,0,List[1,0,Rational[&minus;1,3],0,Rational[&minus;1,45],0,
Rational[&minus;2,945]],&minus;1,6,1]
</p>
<p>This is a series with half-integer degrees.
</p>
<p>In[6] := s= Series[Sqrt[x&lowast; (1&minus; x)],{x,0,5}]In[6] := s= Series[Sqrt[x&lowast; (1&minus; x)],{x,0,5}]In[6] := s= Series[Sqrt[x&lowast; (1&minus; x)],{x,0,5}]
</p>
<p>Out[6] =
&radic;
x&minus; x
</p>
<p>3/2
</p>
<p>2
&minus; x
</p>
<p>5/2
</p>
<p>8
&minus; x
</p>
<p>7/2
</p>
<p>16
&minus; 5x
</p>
<p>9/2
</p>
<p>128
+O[x]11/2
</p>
<p>In[7] := FullForm[s]In[7] := FullForm[s]In[7] := FullForm[s]
Out[7]//FullForm =
</p>
<p>SeriesData[x,0,List[1,0,Rational[&minus;1,2],0,Rational[&minus;1,8],0,
Rational[&minus;1,16],0,Rational[&minus;5,128]],1,11,2]
</p>
<p>This is an expansion at infinity.
</p>
<p>In[8] := s= Series[Log[x+ 1],{x, Infinity,4}]In[8] := s= Series[Log[x+ 1],{x, Infinity,4}]In[8] := s= Series[Log[x+ 1],{x, Infinity,4}]
</p>
<p>Out[8] =&minus;Log
[
</p>
<p>1
</p>
<p>x
</p>
<p>]
</p>
<p>+
1
</p>
<p>x
&minus; 1
</p>
<p>2x2
+
</p>
<p>1
</p>
<p>3x3
&minus; 1
</p>
<p>4x4
+O
</p>
<p>[
</p>
<p>1
</p>
<p>x
</p>
<p>]5
</p>
<p>In[9] := FullForm[s]In[9] := FullForm[s]In[9] := FullForm[s]
Out[9]//FullForm =
</p>
<p>SeriesData[x,DirectedInfinity[1],List[Times[&minus;1,Log[Power[x,&minus;1]]],1,
Rational[&minus;1,2],Rational[1,3],Rational[&minus;1,4]],0,5,1]
</p>
<p>Coefficients of a series in x may depend on x, but only weakly, weaker than any
</p>
<p>degree.
</p>
<p>In[10] := s= Series[x&and;x,{x,0,3}]In[10] := s= Series[x&and;x,{x,0,3}]In[10] := s= Series[x&and;x,{x,0,3}]
Out[10] = 1+Log[x]x+
</p>
<p>1
</p>
<p>2
Log[x]2x2 +
</p>
<p>1
</p>
<p>6
Log[x]3x3 +O[x]4
</p>
<p>In[11] := FullForm[s]In[11] := FullForm[s]In[11] := FullForm[s]
Out[11]//FullForm=
</p>
<p>SeriesData[x,0,List[1,Log[x],Times[Rational[1,2],Power[Log[x],2]],
Times[Rational[1,6],Power[Log[x],3]]],0,4,1]
</p>
<p>In[12] := Clear[s]In[12] := Clear[s]In[12] := Clear[s]
</p>
<p>Operations with Series
</p>
<p>Let&rsquo;s take three series.
</p>
<p>In[13] := sinx = Series[Sin[x],{x,0,7}]In[13] := sinx = Series[Sin[x],{x,0,7}]In[13] := sinx = Series[Sin[x],{x,0,7}]
</p>
<p>Out[13] = x&minus; x
3
</p>
<p>6
+
</p>
<p>x5
</p>
<p>120
&minus; x
</p>
<p>7
</p>
<p>5040
+O[x]8
</p>
<p>In[14] := cosx = Series[Cos[x],{x,0,7}]In[14] := cosx = Series[Cos[x],{x,0,7}]In[14] := cosx = Series[Cos[x],{x,0,7}]
</p>
<p>Out[14] = 1&minus; x
2
</p>
<p>2
+
</p>
<p>x4
</p>
<p>24
&minus; x
</p>
<p>6
</p>
<p>720
+O[x]8
</p>
<p>In[15] := tanx = Series[Tan[x],{x,0,7}]In[15] := tanx = Series[Tan[x],{x,0,7}]In[15] := tanx = Series[Tan[x],{x,0,7}]
</p>
<p>Out[15] = x+
x3
</p>
<p>3
+
</p>
<p>2x5
</p>
<p>15
+
</p>
<p>17x7
</p>
<p>315
+O[x]8</p>
<p/>
</div>
<div class="page"><p/>
<p>8.1 Series 65
</p>
<p>Series can be added, multiplied, divided, etc.
</p>
<p>In[16] := tanx&lowast; cosxIn[16] := tanx&lowast; cosxIn[16] := tanx&lowast; cosx
</p>
<p>Out[16] = x&minus; x
3
</p>
<p>6
+
</p>
<p>x5
</p>
<p>120
&minus; x
</p>
<p>7
</p>
<p>5040
+O[x]8
</p>
<p>In[17] := sinx/cosxIn[17] := sinx/cosxIn[17] := sinx/cosx
</p>
<p>Out[17] = x+
x3
</p>
<p>3
+
</p>
<p>2x5
</p>
<p>15
+
</p>
<p>17x7
</p>
<p>315
+O[x]8
</p>
<p>In[18] := sinx&and;2+ cosx&and;2In[18] := sinx&and;2+ cosx&and;2In[18] := sinx&and;2+ cosx&and;2
Out[18] = 1+O[x]8
</p>
<p>If a series occurs as an argument of a function, the function is expanded
</p>
<p>automatically.
</p>
<p>In[19] := Exp[sinx]In[19] := Exp[sinx]In[19] := Exp[sinx]
</p>
<p>Out[19] = 1+ x+
x2
</p>
<p>2
&minus; x
</p>
<p>4
</p>
<p>8
&minus; x
</p>
<p>5
</p>
<p>15
&minus; x
</p>
<p>6
</p>
<p>240
+
</p>
<p>x7
</p>
<p>90
+O[x]8
</p>
<p>In[20] := (1&minus; cosx)/x&and;2In[20] := (1&minus; cosx)/x&and;2In[20] := (1&minus; cosx)/x&and;2
</p>
<p>Out[20] =
1
</p>
<p>2
&minus; x
</p>
<p>2
</p>
<p>24
+
</p>
<p>x4
</p>
<p>720
+O[x]6
</p>
<p>Here is an interesting method to expand a function in x.
</p>
<p>In[21] := X = Series[x,{x,0,7}]In[21] := X = Series[x,{x,0,7}]In[21] := X = Series[x,{x,0,7}]
Out[21] = x+O[x]8
</p>
<p>In[22] := Sin[X ]In[22] := Sin[X ]In[22] := Sin[X ]
</p>
<p>Out[22] = x&minus; x
3
</p>
<p>6
+
</p>
<p>x5
</p>
<p>120
&minus; x
</p>
<p>7
</p>
<p>5040
+O[x]8
</p>
<p>In[23] := Clear[X ]In[23] := Clear[X ]In[23] := Clear[X ]
Series can be differentiated and integrated.
</p>
<p>In[24] := D[cosx,x]In[24] := D[cosx,x]In[24] := D[cosx,x]
</p>
<p>Out[24] =&minus;x+ x
3
</p>
<p>6
&minus; x
</p>
<p>5
</p>
<p>120
+O[x]7
</p>
<p>In[25] := Integrate[tanx,x]In[25] := Integrate[tanx,x]In[25] := Integrate[tanx,x]
</p>
<p>Out[25] =
x2
</p>
<p>2
+
</p>
<p>x4
</p>
<p>12
+
</p>
<p>x6
</p>
<p>45
+
</p>
<p>17x8
</p>
<p>2520
+O[x]9
</p>
<p>A series (beginning from a small term) can be substituted for the expansion
</p>
<p>variable of another series. This is Sin[Tan[x]].
In[26] := st = sinx/.x&minus;&gt;tanxIn[26] := st = sinx/.x&minus;&gt;tanxIn[26] := st = sinx/.x&minus;&gt;tanx
</p>
<p>Out[26] = x+
x3
</p>
<p>6
&minus; x
</p>
<p>5
</p>
<p>40
&minus; 55x
</p>
<p>7
</p>
<p>1008
+O[x]8
</p>
<p>An alternative syntax.
</p>
<p>In[27] := ComposeSeries[sinx, tanx]In[27] := ComposeSeries[sinx, tanx]In[27] := ComposeSeries[sinx, tanx]
</p>
<p>Out[27] = x+
x3
</p>
<p>6
&minus; x
</p>
<p>5
</p>
<p>40
&minus; 55x
</p>
<p>7
</p>
<p>1008
+O[x]8
</p>
<p>Let&rsquo;s subtract Tan[Sin[x]]; this expression is expanded automatically, i.e., series are
</p>
<p>contagious.
</p>
<p>In[28] := st&minus;Tan[Sin[x]]In[28] := st&minus;Tan[Sin[x]]In[28] := st&minus;Tan[Sin[x]]
</p>
<p>Out[28] =&minus; x
7
</p>
<p>30
+O[x]8
</p>
<p>In[29] := Clear[st]In[29] := Clear[st]In[29] := Clear[st]</p>
<p/>
</div>
<div class="page"><p/>
<p>66 8 Calculus
</p>
<p>Series inversion&mdash;solving the equation tanx = y for x as a series in y.
In[30] := atany = InverseSeries[tanx,y]In[30] := atany = InverseSeries[tanx,y]In[30] := atany = InverseSeries[tanx,y]
</p>
<p>Out[30] = y&minus; y
3
</p>
<p>3
+
</p>
<p>y5
</p>
<p>5
&minus; y
</p>
<p>7
</p>
<p>7
+O[y]8
</p>
<p>The result should be the arctangent.
</p>
<p>In[31] := Series[ArcTan[y],{y,0,7}]In[31] := Series[ArcTan[y],{y,0,7}]In[31] := Series[ArcTan[y],{y,0,7}]
</p>
<p>Out[31] = y&minus; y
3
</p>
<p>3
+
</p>
<p>y5
</p>
<p>5
&minus; y
</p>
<p>7
</p>
<p>7
+O[y]8
</p>
<p>In[32] := ComposeSeries[tanx,atany]In[32] := ComposeSeries[tanx,atany]In[32] := ComposeSeries[tanx,atany]
Out[32] = y+O[y]8
</p>
<p>It is not allowed to substitute a numerical value for the expansion variable into a
</p>
<p>series. The function Normal converts a series into a normal expression by dropping
</p>
<p>+O[x]n. Here is a plot of sine and a few truncations of its series.
In[33] := Plot[Evaluate[Prepend[Table[Normal[Series[Sin[x],{x,0,n}]],{n,1,5,2}],In[33] := Plot[Evaluate[Prepend[Table[Normal[Series[Sin[x],{x,0,n}]],{n,1,5,2}],In[33] := Plot[Evaluate[Prepend[Table[Normal[Series[Sin[x],{x,0,n}]],{n,1,5,2}],
</p>
<p>Sin[x]]],{x,&minus;Pi,Pi}]Sin[x]]],{x,&minus;Pi,Pi}]Sin[x]]],{x,&minus;Pi,Pi}]
</p>
<p>3 2 1 1 2 3
</p>
<p>3
</p>
<p>2
</p>
<p>1
</p>
<p>1
</p>
<p>2
</p>
<p>3
</p>
<p>Out[33] =
</p>
<p>In[34] := Clear[sinx,cosx, tanx,atany]In[34] := Clear[sinx,cosx, tanx,atany]In[34] := Clear[sinx,cosx, tanx,atany]
You should work with series as long as possible, converting them into normal
</p>
<p>polynomials only at the very end. Then terms of too high orders of smallness are
</p>
<p>dropped automatically. At any moment you know exactly what is the order of the
</p>
<p>neglected term O[x]n.
</p>
<p>Arbitrary-Order Term
</p>
<p>The function SeriesCoefficient can also be used in this way.
</p>
<p>In[35] := SeriesCoefficient[Exp[x],{x,0,4}]In[35] := SeriesCoefficient[Exp[x],{x,0,4}]In[35] := SeriesCoefficient[Exp[x],{x,0,4}]
Out[35] =
</p>
<p>1
</p>
<p>24
This is the 4th coefficient in the expansion of Exp[x] in x at 0. The number of the
series term can be given symbolically.</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2 Differentiation 67
</p>
<p>In[36] := cn = SeriesCoefficient[Exp[x],{x,0,n}]In[36] := cn = SeriesCoefficient[Exp[x],{x,0,n}]In[36] := cn = SeriesCoefficient[Exp[x],{x,0,n}]
Out[36] =
</p>
<p>{
</p>
<p>1
n! n&ge; 0
0 True
</p>
<p>In[37] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]In[37] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]In[37] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]
Out[37] = ex
</p>
<p>In[38] := cn = SeriesCoefficient[Cos[x],{x,0,n}]In[38] := cn = SeriesCoefficient[Cos[x],{x,0,n}]In[38] := cn = SeriesCoefficient[Cos[x],{x,0,n}]
</p>
<p>Out[38] =
</p>
<p>{
</p>
<p>in(1+(&minus;1)n)
2n! n&ge; 0
</p>
<p>0 True
</p>
<p>In[39] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]In[39] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]In[39] := Sum[cn&lowast; x&and;n,{n,0, Infinity}]
Out[39] = Cos[x]
In[40] := Clear[cn]In[40] := Clear[cn]In[40] := Clear[cn]
</p>
<p>8.2 Differentiation
</p>
<p>In[41] := f = x&lowast;Sin[x+ y]In[41] := f = x&lowast;Sin[x+ y]In[41] := f = x&lowast;Sin[x+ y]
Out[41] = xSin[x+ y]
The derivative in x; in y; in x and y; the second derivative in x; the second derivative
</p>
<p>in x and the first one in y:
</p>
<p>In[42] := {D[ f ,x],D[ f ,y],D[ f ,x,y],D[ f ,{x,2}],D[ f ,{x,2},y]}In[42] := {D[ f ,x],D[ f ,y],D[ f ,x,y],D[ f ,{x,2}],D[ f ,{x,2},y]}In[42] := {D[ f ,x],D[ f ,y],D[ f ,x,y],D[ f ,{x,2}],D[ f ,{x,2},y]}
Out[42] = {xCos[x+ y]+Sin[x+ y],xCos[x+ y],Cos[x+ y]&minus; xSin[x+ y],
</p>
<p>2Cos[x+ y]&minus; xSin[x+ y],&minus;xCos[x+ y]&minus; 2Sin[x+ y]}
In[43] := Clear[ f ]In[43] := Clear[ f ]In[43] := Clear[ f ]
</p>
<p>Unknown Functions
</p>
<p>Expressions with unknown functions can be differentiated.
</p>
<p>In[44] := D[x&lowast; f [x&and;2],x]In[44] := D[x&lowast; f [x&and;2],x]In[44] := D[x&lowast; f [x&and;2],x]
Out[44] = f
</p>
<p>[
</p>
<p>x2
]
</p>
<p>+ 2x2 f &prime;
[
</p>
<p>x2
]
</p>
<p>Mathematica represents the first derivative of an unknown function f as the operator
</p>
<p>Derivative[1] applied to f .
In[45] := FullForm[%]In[45] := FullForm[%]In[45] := FullForm[%]
Out[45]//FullForm=
</p>
<p>Plus[ f [Power[x,2]],Times[2,Power[x,2],Derivative[1][ f ][Power[x,2]]]]
And this is the second derivative.
</p>
<p>In[46] := Expand[D[x&lowast; f [x&and;2],{x,2}]]In[46] := Expand[D[x&lowast; f [x&and;2],{x,2}]]In[46] := Expand[D[x&lowast; f [x&and;2],{x,2}]]
Out[46] = 6x f &prime;
</p>
<p>[
</p>
<p>x2
]
</p>
<p>+ 4x3 f &prime;&prime;
[
</p>
<p>x2
]
</p>
<p>In[47] := FullForm[%]In[47] := FullForm[%]In[47] := FullForm[%]
Out[47]//FullForm=
</p>
<p>Plus[Times[6,x,Derivative[1][ f ][Power[x,2]]],
Times[4,Power[x,3],Derivative[2][ f ][Power[x,2]]]]</p>
<p/>
</div>
<div class="page"><p/>
<p>68 8 Calculus
</p>
<p>Derivative[2,3] means the second derivative in the first argument and the third one
in the second.
</p>
<p>In[48] := D[ f [x,y],{x,2},{y,3}]In[48] := D[ f [x,y],{x,2},{y,3}]In[48] := D[ f [x,y],{x,2},{y,3}]
Out[48] = f (2,3)[x,y]
In[49] := FullForm[%]In[49] := FullForm[%]In[49] := FullForm[%]
Out[49]//FullForm=
</p>
<p>Derivative[2,3][ f ][x,y]
</p>
<p>Defining Derivatives
</p>
<p>Let&rsquo;s tell Mathematica that the derivative of the function f is g.
</p>
<p>In[50] := f &prime;[x ] := g[x]In[50] := f &prime;[x ] := g[x]In[50] := f &prime;[x ] := g[x]
In[51] := D[x&lowast; f [x&and;2],x]In[51] := D[x&lowast; f [x&and;2],x]In[51] := D[x&lowast; f [x&and;2],x]
Out[51] = f
</p>
<p>[
</p>
<p>x2
]
</p>
<p>+ 2x2g
[
</p>
<p>x2
]
</p>
<p>The second derivative is not substituted automatically.
</p>
<p>In[52] := Expand[D[x&lowast; f [x&and;2],{x,2}]]In[52] := Expand[D[x&lowast; f [x&and;2],{x,2}]]In[52] := Expand[D[x&lowast; f [x&and;2],{x,2}]]
Out[52] = 6xg
</p>
<p>[
</p>
<p>x2
]
</p>
<p>+ 4x3 f &prime;&prime;
[
</p>
<p>x2
]
</p>
<p>we can tell Mathematica that
&part; 3 f [x,y]
&part;x&part; 2y is a function g.
</p>
<p>In[53] := Derivative[1,2][ f ][x ,y ] := g[x,y]In[53] := Derivative[1,2][ f ][x ,y ] := g[x,y]In[53] := Derivative[1,2][ f ][x ,y ] := g[x,y]
In[54] := D[x&lowast; f [x,y],{x,2},{y,2}]In[54] := D[x&lowast; f [x,y],{x,2},{y,2}]In[54] := D[x&lowast; f [x,y],{x,2},{y,2}]
Out[54] = 2g[x,y]+ x f (2,2)[x,y]
</p>
<p>8.3 Integration
</p>
<p>Indefinite Integrals
</p>
<p>In[55] := Integrate[1/(x&lowast; (x&and;2&minus; 2)&and;2),x]In[55] := Integrate[1/(x&lowast; (x&and;2&minus; 2)&and;2),x]In[55] := Integrate[1/(x&lowast; (x&and;2&minus; 2)&and;2),x]
Out[55] =&minus; 1
</p>
<p>4(&minus;2+ x2) +
Log[x]
</p>
<p>4
&minus; 1
</p>
<p>8
Log
</p>
<p>[
</p>
<p>2&minus; x2
]
</p>
<p>In[56] := Integrate[1/(Exp[x]+ 1),x]In[56] := Integrate[1/(Exp[x]+ 1),x]In[56] := Integrate[1/(Exp[x]+ 1),x]
Out[56] = x&minus;Log[1+ ex]
In[57] := Integrate[x/(Exp[x]+ 1),x]In[57] := Integrate[x/(Exp[x]+ 1),x]In[57] := Integrate[x/(Exp[x]+ 1),x]
</p>
<p>Out[57] =
x2
</p>
<p>2
&minus; xLog [1+ ex]&minus;PolyLog[2,&minus;ex]
</p>
<p>In[58] := Integrate[Log[x],x]In[58] := Integrate[Log[x],x]In[58] := Integrate[Log[x],x]
Out[58] =&minus;x+ xLog[x]
In[59] := Integrate[1/Log[x],x]In[59] := Integrate[1/Log[x],x]In[59] := Integrate[1/Log[x],x]
Out[59] = LogIntegral[x]</p>
<p/>
</div>
<div class="page"><p/>
<p>8.3 Integration 69
</p>
<p>In[60] := Integrate[Exp[x&and;2],x]In[60] := Integrate[Exp[x&and;2],x]In[60] := Integrate[Exp[x&and;2],x]
</p>
<p>Out[60] =
1
</p>
<p>2
</p>
<p>&radic;
π Erfi[x]
</p>
<p>In[61] := Integrate[x&lowast;Exp[x&and;2],x]In[61] := Integrate[x&lowast;Exp[x&and;2],x]In[61] := Integrate[x&lowast;Exp[x&and;2],x]
</p>
<p>Out[61] =
ex
</p>
<p>2
</p>
<p>2
In[62] := Integrate[1/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x]In[62] := Integrate[1/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x]In[62] := Integrate[1/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x]
</p>
<p>Out[62] =
</p>
<p>&radic;
1&minus; x2
</p>
<p>&radic;
1&minus; k2x2 EllipticF
</p>
<p>[
</p>
<p>ArcSin[x],k2
]
</p>
<p>&radic;
</p>
<p>(&minus;1+ x2)(&minus;1+ k2x2)
In[63] := Simplify[Integrate[x/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x],x&gt; 1]In[63] := Simplify[Integrate[x/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x],x&gt; 1]In[63] := Simplify[Integrate[x/Sqrt[(1&minus; x&and;2)&lowast; (1&minus; k&and;2 &lowast; x&and;2)],x],x&gt; 1]
</p>
<p>Out[63] =
Log
</p>
<p>[
</p>
<p>k
(
</p>
<p>k
&radic;
&minus;1+ x2+
</p>
<p>&radic;
&minus;1+ k2x2
</p>
<p>)]
</p>
<p>k
</p>
<p>Definite Integrals
</p>
<p>Here Mathematica produces a result with some assumptions about the parameter n.
</p>
<p>In[64] := Integrate[x&and;n,{x,0,1}]In[64] := Integrate[x&and;n,{x,0,1}]In[64] := Integrate[x&and;n,{x,0,1}]
Out[64] = ConditionalExpression
</p>
<p>[
</p>
<p>1
</p>
<p>1+ n
,Re[n]&gt;&minus;1
</p>
<p>]
</p>
<p>Let&rsquo;s tell it that n&gt;&minus;1.
In[65] := Integrate[x&and;n,{x,0,1},Assumptions&minus;&gt;{n&gt;&minus;1}]In[65] := Integrate[x&and;n,{x,0,1},Assumptions&minus;&gt;{n&gt;&minus;1}]In[65] := Integrate[x&and;n,{x,0,1},Assumptions&minus;&gt;{n&gt;&minus;1}]
Out[65] =
</p>
<p>1
</p>
<p>1+ n
In[66] := Integrate[Exp[a &lowast;Sin[x]],{x,0,2 &lowast;Pi}]In[66] := Integrate[Exp[a &lowast;Sin[x]],{x,0,2 &lowast;Pi}]In[66] := Integrate[Exp[a &lowast;Sin[x]],{x,0,2 &lowast;Pi}]
Out[66] = 2πBesselI[0,a]
In[67] := Integrate[Log[x]/(1&minus; x),{x,0,1}]In[67] := Integrate[Log[x]/(1&minus; x),{x,0,1}]In[67] := Integrate[Log[x]/(1&minus; x),{x,0,1}]
</p>
<p>Out[67] =&minus;π
2
</p>
<p>6
The default value of the option Assumptions for Simplify, Integrate, etc. can be
</p>
<p>given in the variable $Assumptions.
</p>
<p>In[68] := $Assumptions = {t &gt; 0, t &lt; 1,a&gt;&minus;1,b&gt;&minus;1};In[68] := $Assumptions = {t &gt; 0, t &lt; 1,a&gt;&minus;1,b&gt;&minus;1};In[68] := $Assumptions = {t &gt; 0, t &lt; 1,a&gt;&minus;1,b&gt;&minus;1};
In[69] := Integrate[x&and;a &lowast; (1&minus; x)&and;b &lowast; (1&minus; t &lowast; x)&and;c,{x,0,1}]In[69] := Integrate[x&and;a &lowast; (1&minus; x)&and;b &lowast; (1&minus; t &lowast; x)&and;c,{x,0,1}]In[69] := Integrate[x&and;a &lowast; (1&minus; x)&and;b &lowast; (1&minus; t &lowast; x)&and;c,{x,0,1}]
Out[69] = &minus;(πCsc[aπ ]Gamma[1 + b]Hypergeometric2F1Regularized[1 + a,&minus;c,
2+ a+ b, t])/Gamma[&minus;a]
Now we can clear $Assumptions.
</p>
<p>In[70] := $Assumptions = True;In[70] := $Assumptions = True;In[70] := $Assumptions = True;
Multiple integral
</p>
<p>In[71] := Integrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1}]In[71] := Integrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1}]In[71] := Integrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1}]
</p>
<p>Out[71] =
π2
</p>
<p>12</p>
<p/>
</div>
<div class="page"><p/>
<p>70 8 Calculus
</p>
<p>8.4 Summation
</p>
<p>Finite Sums
</p>
<p>In[72] := Sum[n,{n,0,k}]In[72] := Sum[n,{n,0,k}]In[72] := Sum[n,{n,0,k}]
Out[72] =
</p>
<p>1
</p>
<p>2
k(1+ k)
</p>
<p>In[73] := Sum[n&and;2,{n,0,k}]In[73] := Sum[n&and;2,{n,0,k}]In[73] := Sum[n&and;2,{n,0,k}]
Out[73] =
</p>
<p>1
</p>
<p>6
k(1+ k)(1+ 2k)
</p>
<p>In[74] := Sum[x&and;n,{n,0,k}]In[74] := Sum[x&and;n,{n,0,k}]In[74] := Sum[x&and;n,{n,0,k}]
</p>
<p>Out[74] =
&minus;1+ x1+k
&minus;1+ x
</p>
<p>In[75] := Sum[Binomial[k,n],{n,0,k}]In[75] := Sum[Binomial[k,n],{n,0,k}]In[75] := Sum[Binomial[k,n],{n,0,k}]
Out[75] = 2k
</p>
<p>In[76] := Sum[(&minus;1)&and;n &lowast;Binomial[k,n],{n,0,k}]In[76] := Sum[(&minus;1)&and;n &lowast;Binomial[k,n],{n,0,k}]In[76] := Sum[(&minus;1)&and;n &lowast;Binomial[k,n],{n,0,k}]
Out[76] = KroneckerDelta[k]
In[77] := Sum[Binomial[k,n]&and;2,{n,0,k}]In[77] := Sum[Binomial[k,n]&and;2,{n,0,k}]In[77] := Sum[Binomial[k,n]&and;2,{n,0,k}]
Out[77] = Binomial[2k,k]
</p>
<p>Series
</p>
<p>In[78] := Sum[1/n&and;2,{n,1, Infinity}]In[78] := Sum[1/n&and;2,{n,1, Infinity}]In[78] := Sum[1/n&and;2,{n,1, Infinity}]
</p>
<p>Out[78] =
π2
</p>
<p>6
In[79] := Sum[1/n&and;4,{n,1, Infinity}]In[79] := Sum[1/n&and;4,{n,1, Infinity}]In[79] := Sum[1/n&and;4,{n,1, Infinity}]
</p>
<p>Out[79] =
π4
</p>
<p>90
In[80] := Sum[(&minus;1)&and;n/n&and;2,{n,1, Infinity}]In[80] := Sum[(&minus;1)&and;n/n&and;2,{n,1, Infinity}]In[80] := Sum[(&minus;1)&and;n/n&and;2,{n,1, Infinity}]
</p>
<p>Out[80] =&minus;π
2
</p>
<p>12
In[81] := Sum[x&and;n/n!,{n,0, Infinity}]In[81] := Sum[x&and;n/n!,{n,0, Infinity}]In[81] := Sum[x&and;n/n!,{n,0, Infinity}]
Out[81] = ex
</p>
<p>8.5 Differentiol Equations
</p>
<p>A first-order differential equation.
</p>
<p>In[82] := DSolve[D[x[t], t]+ x[t] == 0,x[t], t]In[82] := DSolve[D[x[t], t]+ x[t] == 0,x[t], t]In[82] := DSolve[D[x[t], t]+ x[t] == 0,x[t], t]
Out[82] =
</p>
<p>{{
</p>
<p>x[t]&rarr; e&minus;tC[1]
}}
</p>
<p>The solution contains an arbitrary constant C[1]. Let&rsquo;s add an initial condition:</p>
<p/>
</div>
<div class="page"><p/>
<p>8.5 Differentiol Equations 71
</p>
<p>In[83] := DSolve[{D[x[t], t]+ x[t] == 0,x[0] == 1},x[t], t]In[83] := DSolve[{D[x[t], t]+ x[t] == 0,x[0] == 1},x[t], t]In[83] := DSolve[{D[x[t], t]+ x[t] == 0,x[0] == 1},x[t], t]
Out[83] =
</p>
<p>{{
</p>
<p>x[t]&rarr; e&minus;t
}}
</p>
<p>A second-order differential equation.
</p>
<p>In[84] := DSolve[D[x[t],{t,2}]+ x[t] == 0,x[t], t]In[84] := DSolve[D[x[t],{t,2}]+ x[t] == 0,x[t], t]In[84] := DSolve[D[x[t],{t,2}]+ x[t] == 0,x[t], t]
Out[84] = {{x[t]&rarr;C[1]Cos[t]+C[2]Sin[t]}}
Initial conditions.
</p>
<p>In[85] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x&prime;[0] == 1},x[t], t]In[85] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x&prime;[0] == 1},x[t], t]In[85] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x&prime;[0] == 1},x[t], t]
Out[85] = {{x[t]&rarr; Sin[t]}}
Boundary conditions.
</p>
<p>In[86] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x[1] == 1},x[t], t]In[86] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x[1] == 1},x[t], t]In[86] := DSolve[{D[x[t],{t,2}]+ x[t] == 0,x[0] == 0,x[1] == 1},x[t], t]
Out[86] = {{x[t]&rarr; Csc[1]Sin[t]}}
</p>
<p>A system of differential equations.
</p>
<p>In[87] := DSolve[{D[x[t], t] == p[t],D[p[t], t] ==&minus;x[t]},{x[t], p[t]}, t]In[87] := DSolve[{D[x[t], t] == p[t],D[p[t], t] ==&minus;x[t]},{x[t], p[t]}, t]In[87] := DSolve[{D[x[t], t] == p[t],D[p[t], t] ==&minus;x[t]},{x[t], p[t]}, t]
Out[87] = {{p[t]&rarr;C[1]Cos[t]&minus;C[2]Sin[t],x[t]&rarr;C[2]Cos[t]+C[1]Sin[t]}}</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 9
</p>
<p>Numerical Calculations
</p>
<p>9.1 Approximate Numbers in Mathematica
</p>
<p>Mathematica usually works with exact numbers, either symbolic (π , e) or rational,
and derives exact analytical results. However, it can also perform approximate
</p>
<p>numerical calculations. Many problems cannot be solved analytically, but numerical
</p>
<p>solution is possible. On the other side, an analytical result can depend on symbolic
</p>
<p>parameters; in order to do a numerical calculation, you have to substitute some
</p>
<p>numerical values for all parameters. It is often useful to check the correctness of
</p>
<p>a complicated analytical derivation by a direct numerical calculation for a few sets
</p>
<p>of values of the parameters.
</p>
<p>There are two kinds of approximate real numbers in Mathematica. The first one
</p>
<p>is machine numbers.
</p>
<p>In[1] := p= N[Pi]In[1] := p= N[Pi]In[1] := p= N[Pi]
Out[1] = 3.14159
In[2] := FullForm[p]In[2] := FullForm[p]In[2] := FullForm[p]
Out[2]//FullForm =
</p>
<p>3.141592653589793`
Precision is the number of significant decimal digits. For machine numbers it is
</p>
<p>a symbolic constant:
</p>
<p>In[3] := Precision[p]In[3] := Precision[p]In[3] := Precision[p]
Out[3] = MachinePrecision
In[4] := N[MachinePrecision]In[4] := N[MachinePrecision]In[4] := N[MachinePrecision]
Out[4] = 15.9546
It is 53 bits (or about 16 decimal digits) of precision. In other languages (C, Fortran)
</p>
<p>such numbers are usually called double precision. Operations with such numbers in
</p>
<p>Mathematica are performed by hardware, as in C or Fortran. They are less efficient
</p>
<p>than in these languages, but nevertheless rather efficient.
</p>
<p>In[5] := MachineNumberQ[p]In[5] := MachineNumberQ[p]In[5] := MachineNumberQ[p]
Out[5] = True
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 9, &copy; Springer International Publishing Switzerland 2014
</p>
<p>73</p>
<p/>
</div>
<div class="page"><p/>
<p>74 9 Numerical Calculations
</p>
<p>There are also arbitrary-precision numbers. Operations with them are imple-
</p>
<p>mented in software and are far less efficient.
</p>
<p>In[6] := p= N[Pi,25]In[6] := p= N[Pi,25]In[6] := p= N[Pi,25]
Out[6] = 3.141592653589793238462643
In[7] := FullForm[p]In[7] := FullForm[p]In[7] := FullForm[p]
Out[7]//FullForm =
</p>
<p>3.141592653589793238462643 2̀5.
In[8] := Precision[p]In[8] := Precision[p]In[8] := Precision[p]
Out[8] = 25.
</p>
<p>Precision is a part of a value, not of a variable, as in some other languages. If it
</p>
<p>is equal to n, then the estimated relative error of the value is 10&minus;n. There is also
accuracy&mdash;the number of significant decimal digits after the point. If it is equal to
</p>
<p>m, then the estimated absolute error of the value is 10&minus;m.
In[9] := Accuracy[p]In[9] := Accuracy[p]In[9] := Accuracy[p]
Out[9] = 24.5029
</p>
<p>When approximate numbers are added or subtracted, the absolute errors are
</p>
<p>added. The difference of two approximately equal numbers has a lower precision
</p>
<p>than the operands.
</p>
<p>In[10] := q= N[355/113,20]In[10] := q= N[355/113,20]In[10] := q= N[355/113,20]
Out[10] = 3.1415929203539823009
In[11] := Accuracy[q]In[11] := Accuracy[q]In[11] := Accuracy[q]
Out[11] = 19.5029
In[12] := d = p&minus; qIn[12] := d = p&minus; qIn[12] := d = p&minus; q
Out[12] =&minus;2.667641890624&times;10&minus;7
In[13] := {Precision[d],Accuracy[d]}In[13] := {Precision[d],Accuracy[d]}In[13] := {Precision[d],Accuracy[d]}
Out[13] = {12.929,19.5028}
When approximate numbers are multiplied or divided, the relative errors are added.
</p>
<p>In[14] := r = p/qIn[14] := r = p/qIn[14] := r = p/q
Out[14] = 0.9999999150863285520
In[15] := {Precision[r],Accuracy[r]}In[15] := {Precision[r],Accuracy[r]}In[15] := {Precision[r],Accuracy[r]}
Out[15] = {20.,20.}
In[16] := Clear[p,q,d,r]In[16] := Clear[p,q,d,r]In[16] := Clear[p,q,d,r]
</p>
<p>This error handling sometimes may be too pessimistic. Let&rsquo;s consider an
</p>
<p>example [15]. The sequence xn = f (xn&minus;1), x1 = 1,
In[17] := f [x ] := (x&and;2+ 4)/(2 &lowast; x)In[17] := f [x ] := (x&and;2+ 4)/(2 &lowast; x)In[17] := f [x ] := (x&and;2+ 4)/(2 &lowast; x)
converges to 2. With machine numbers
</p>
<p>In[18] := f [x ,n ] := Module[{t = Table[x,{n}]},In[18] := f [x ,n ] := Module[{t = Table[x,{n}]},In[18] := f [x ,n ] := Module[{t = Table[x,{n}]},
Do[t[[i]] = f [t[[i&minus; 1]]],{i,2,n}]; t]Do[t[[i]] = f [t[[i&minus; 1]]],{i,2,n}]; t]Do[t[[i]] = f [t[[i&minus; 1]]],{i,2,n}]; t]
</p>
<p>In[19] := x= f [1.0,60];In[19] := x= f [1.0,60];In[19] := x= f [1.0,60];</p>
<p/>
</div>
<div class="page"><p/>
<p>9.1 Approximate Numbers in Mathematica 75
</p>
<p>In[20] := ListPlot[x,PlotRange&minus;&gt;{0.95,2.55},In[20] := ListPlot[x,PlotRange&minus;&gt;{0.95,2.55},In[20] := ListPlot[x,PlotRange&minus;&gt;{0.95,2.55},
PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]
</p>
<p>Out[20] =
</p>
<p>this is indeed so. Now let x1 be 1.0 with 17-digits precision:
</p>
<p>In[21] := x= f [1.0`17,60];In[21] := x= f [1.0`17,60];In[21] := x= f [1.0`17,60];
In[22] := ListPlot[x,PlotRange&minus;&gt;{&minus;0.05,2.55},In[22] := ListPlot[x,PlotRange&minus;&gt;{&minus;0.05,2.55},In[22] := ListPlot[x,PlotRange&minus;&gt;{&minus;0.05,2.55},
</p>
<p>PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]
</p>
<p>Out[22] =
</p>
<p>In[23] := ListPlot[Map[Precision,x],In[23] := ListPlot[Map[Precision,x],In[23] := ListPlot[Map[Precision,x],
PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]PlotMarkers&minus;&gt;{Automatic,Medium}]
</p>
<p>Out[23] =</p>
<p/>
</div>
<div class="page"><p/>
<p>76 9 Numerical Calculations
</p>
<p>The tail of this list is
</p>
<p>In[24] := x[[55; ;60]]In[24] := x[[55; ;60]]In[24] := x[[55; ;60]]
Out[24] = {2.,2.,0.,0.,ComplexInfinity, Indeterminate}
In[25] := Map[Precision,x[[55; ;60]]]In[25] := Map[Precision,x[[55; ;60]]]In[25] := Map[Precision,x[[55; ;60]]]
Out[25] = {0.84866,0.54763,0.2466,0.,&infin;,&infin;}
The initial precision is completely lost in 58 iterations.
</p>
<p>In[26] := Clear[ f ,x]In[26] := Clear[ f ,x]In[26] := Clear[ f ,x]
</p>
<p>9.2 Solving Equations
</p>
<p>NSolve tries to solve equations numerically. They must not contain symbolic
</p>
<p>parameters, only numbers and unknowns. Only very limited classes of equations
</p>
<p>can be solved analytically; numerical solution is possible nearly always. The option
</p>
<p>Reals says to find only real roots.
</p>
<p>In[27] := NSolve[x&and;5+ x+ 1== 0,x]In[27] := NSolve[x&and;5+ x+ 1== 0,x]In[27] := NSolve[x&and;5+ x+ 1== 0,x]
Out[27] = {{x&rarr;&minus;0.754878},{x&rarr;&minus;0.5&minus;0.866025i},{x&rarr;&minus;0.5+0.866025i},
</p>
<p>{x&rarr; 0.877439&minus; 0.744862i},{x&rarr; 0.877439+ 0.744862i}}
In[28] := NSolve[x&and;5+ x+ 1== 0,x,Reals]In[28] := NSolve[x&and;5+ x+ 1== 0,x,Reals]In[28] := NSolve[x&and;5+ x+ 1== 0,x,Reals]
Out[28] = {{x&rarr;&minus;0.754878}}
We can add an interval in which we want to find solutions.
</p>
<p>In[29] := NSolve[{Exp[&minus;x] == Sin[x],0 &lt; x&lt; Pi},x]In[29] := NSolve[{Exp[&minus;x] == Sin[x],0 &lt; x&lt; Pi},x]In[29] := NSolve[{Exp[&minus;x] == Sin[x],0 &lt; x&lt; Pi},x]
Out[29] = {{x&rarr; 0.588533},{x&rarr; 3.09636}}
In[30] := Plot[{Exp[&minus;x],Sin[x]},{x,0,Pi}]In[30] := Plot[{Exp[&minus;x],Sin[x]},{x,0,Pi}]In[30] := Plot[{Exp[&minus;x],Sin[x]},{x,0,Pi}]
</p>
<p>Out[30] =</p>
<p/>
</div>
<div class="page"><p/>
<p>9.3 Numerical Integration and Summation 77
</p>
<p>9.3 Numerical Integration and Summation
</p>
<p>The function NIntegrate integrates numerically, without trying to do it analytically
</p>
<p>first&mdash;it uses an appropriate numerical method right away. Of course, integration
</p>
<p>limits must be numbers, and there must be no symbolic parameters.
</p>
<p>In[31] := NIntegrate[Sin[x]/x,{x,0, Infinity}]In[31] := NIntegrate[Sin[x]/x,{x,0, Infinity}]In[31] := NIntegrate[Sin[x]/x,{x,0, Infinity}]
Out[31] = 1.5708
The option PrecisionGoal states the desired precision of the result. If the result is
</p>
<p>close to 0 due to strong cancellations, it may be difficult to attain a high precision
</p>
<p>(i.e., a small relative error). Then it is better to specify AccuracyGoal, i.e., the
</p>
<p>desired absolute error. The option WorkingPrecision specifies the precision level
</p>
<p>at which internal calculations are done; it must be � PrecisionGoal.
</p>
<p>In[32] := NIntegrate[Exp[&minus;x&and;2],{x,0, Infinity},WorkingPrecision&minus;&gt;30]In[32] := NIntegrate[Exp[&minus;x&and;2],{x,0, Infinity},WorkingPrecision&minus;&gt;30]In[32] := NIntegrate[Exp[&minus;x&and;2],{x,0, Infinity},WorkingPrecision&minus;&gt;30]
Out[32] = 0.886226925452758013649083741785
The integration method is selected automatically; however, we can specify it:
</p>
<p>In[33] := NIntegrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1},In[33] := NIntegrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1},In[33] := NIntegrate[1/(1+ x&lowast; y),{x,0,1},{y,0,1},
Method&minus;&gt;&ldquo;AdaptiveMonteCarlo&rdquo;]Method&minus;&gt;&ldquo;AdaptiveMonteCarlo&rdquo;]Method&minus;&gt;&ldquo;AdaptiveMonteCarlo&rdquo;]
</p>
<p>Out[33] = 0.822237
In[34] := i= NIntegrate[Log[x]&and;2/(x+ 1),{x,0,1},PrecisionGoal&minus;&gt;30,In[34] := i= NIntegrate[Log[x]&and;2/(x+ 1),{x,0,1},PrecisionGoal&minus;&gt;30,In[34] := i= NIntegrate[Log[x]&and;2/(x+ 1),{x,0,1},PrecisionGoal&minus;&gt;30,
</p>
<p>WorkingPrecision&minus;&gt;35]WorkingPrecision&minus;&gt;35]WorkingPrecision&minus;&gt;35]
Out[34] = 1.8030853547393914280996072422671750
</p>
<p>Suppose we suspect that the integral i is a linear combination of ζ (3) and 1 with
rational coefficients. FindIntegerNullVector tries to find integer coefficients such
</p>
<p>that the linear combination vanishes:
</p>
<p>In[35] := FindIntegerNullVector[{i,Zeta[3],1}]In[35] := FindIntegerNullVector[{i,Zeta[3],1}]In[35] := FindIntegerNullVector[{i,Zeta[3],1}]
Out[35] = {2,&minus;3,0}
This means that 2 i&minus; 3ζ (3) = 0, i.e., our integral is 32 ζ (3). Of course, this is not a
mathematical proof. However, if we increase precision, and the linear combination
</p>
<p>stays the same, we can be practically sure that the result is correct (this is called
</p>
<p>experimental mathematics).
</p>
<p>NSum is similar.
</p>
<p>In[36] := s= NSum[1/n&and;4,{n,1, Infinity},PrecisionGoal&minus;&gt;30,In[36] := s= NSum[1/n&and;4,{n,1, Infinity},PrecisionGoal&minus;&gt;30,In[36] := s= NSum[1/n&and;4,{n,1, Infinity},PrecisionGoal&minus;&gt;30,
WorkingPrecision&minus;&gt;35,NSumTerms&minus;&gt;30]WorkingPrecision&minus;&gt;35,NSumTerms&minus;&gt;30]WorkingPrecision&minus;&gt;35,NSumTerms&minus;&gt;30]
</p>
<p>Out[36] = 1.0823232337111381915160036965412
If we suspect that the sum s is a linear combination of π4 and 1 with rational coeffi-
cients, we can do
</p>
<p>In[37] := FindIntegerNullVector[{s,Pi&and;4,1}]In[37] := FindIntegerNullVector[{s,Pi&and;4,1}]In[37] := FindIntegerNullVector[{s,Pi&and;4,1}]
Out[37] = {90,&minus;1,0}
This means that our sum is, probably, π
</p>
<p>4
</p>
<p>90 .
</p>
<p>In[38] := Clear[i,s]In[38] := Clear[i,s]In[38] := Clear[i,s]</p>
<p/>
</div>
<div class="page"><p/>
<p>78 9 Numerical Calculations
</p>
<p>9.4 Differential Equations
</p>
<p>NDSolve solves differential equations numerically, for a finite interval of the
</p>
<p>independent variable. It returns results in terms of InterpolatingFunction; this result
</p>
<p>can be numerically evaluated for any value of the independent variable in the given
</p>
<p>interval.
</p>
<p>In[39] := a= 1/2;In[39] := a= 1/2;In[39] := a= 1/2;
In[40] := ns = NDSolve[{y&prime;&prime;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},In[40] := ns = NDSolve[{y&prime;&prime;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},In[40] := ns = NDSolve[{y&prime;&prime;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},
</p>
<p>y[t],{t,0,10}]y[t],{t,0,10}]y[t],{t,0,10}]
Out[40] = {{y[t]&rarr; InterpolatingFunction[{{0.,10.}},&lt;&gt;][t]}}
In[41] := Plot[y[t]/.ns[[1]],{t,0,10}]In[41] := Plot[y[t]/.ns[[1]],{t,0,10}]In[41] := Plot[y[t]/.ns[[1]],{t,0,10}]
</p>
<p>Out[41] =
</p>
<p>Let&rsquo;s compare with the analytical solution.
</p>
<p>In[42] := s= DSolve[{y&rdquo;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},y[t], t]In[42] := s= DSolve[{y&rdquo;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},y[t], t]In[42] := s= DSolve[{y&rdquo;[t]+ a &lowast; y&prime;[t]+ y[t] == 0,y&prime;[0] == 0,y[0] == 1},y[t], t]
</p>
<p>Out[42] =
</p>
<p>{{
</p>
<p>y[t]&rarr; 1
15
</p>
<p>e&minus;t/4
(
</p>
<p>15Cos
</p>
<p>[&radic;
15t
</p>
<p>4
</p>
<p>]
</p>
<p>+
&radic;
</p>
<p>15Sin
</p>
<p>[&radic;
15t
</p>
<p>4
</p>
<p>])}}
</p>
<p>In[43] := Plot[y[t]/.s[[1]],{t,0,10}]In[43] := Plot[y[t]/.s[[1]],{t,0,10}]In[43] := Plot[y[t]/.s[[1]],{t,0,10}]
</p>
<p>Out[43] =
</p>
<p>In[44] := Clear[a,s,ns]In[44] := Clear[a,s,ns]In[44] := Clear[a,s,ns]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 10
</p>
<p>Risch Algorithm
</p>
<p>We were taught at calculus classes that integration is an art, not a science (in contrast
</p>
<p>to differentiation&mdash;even a monkey can be trained to take derivatives). And we were
</p>
<p>taught wrong. The Risch algorithm (which is known for decades) allows one to find,
</p>
<p>in a finite number of steps, if a given indefinite integral can be taken in elementary
</p>
<p>functions, and if so, to calculate it. This algorithm has been constructed in works
</p>
<p>by an American mathematician Risch near 1970; many cases were not analyzed
</p>
<p>completely in these works and were later considered by other mathematicians. The
</p>
<p>algorithm is very complicated, and no computer algebra system implements it fully.
</p>
<p>Its implementation in Mathematica is rather complete, even with extensions to some
</p>
<p>classes of special functions, but details are not publicly known. Strictly speaking, it
</p>
<p>is not quite an algorithm, because it contains algorithmically unsolvable subprob-
</p>
<p>lems, such as finding out if a given combination of elementary functions vanishes.
</p>
<p>But in practice computer algebra systems are quite good in solving such problems.
</p>
<p>Here we shall consider, at a very elementary level, the main ideas of the Risch algo-
</p>
<p>rithm; see [16] for more details.
</p>
<p>10.1 Rational Functions
</p>
<p>We begin with a very simple case&mdash;integration of rational functions. Better methods
</p>
<p>than the partial fraction decomposition exist for this problem. And these methods
</p>
<p>can be generalized to much wider classes of integrands. Let&rsquo;s consider an integral
</p>
<p>&int;
</p>
<p>N(x)
</p>
<p>D(x)
dx ,
</p>
<p>where N(x) and D(x) are polynomials. If degN &ge; degD, we can divide with
remainder; integration of a polynomial is trivial. Therefore we&rsquo;ll assume degN &lt;
degD. The integration result consists of a rational part and a logarithmic one:
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 10, &copy; Springer International Publishing Switzerland 2014
</p>
<p>79</p>
<p/>
</div>
<div class="page"><p/>
<p>80 10 Risch Algorithm
</p>
<p>&int;
</p>
<p>N(x)
</p>
<p>D(x)
dx=
</p>
<p>P(x)
</p>
<p>D̂(x)
+&sum;ci log(x&minus; ai) ,
</p>
<p>where ai are the roots of the denominator D(x), and ci are constants. If
</p>
<p>D(x) =&prod;(x&minus; ai)di ,
</p>
<p>then
</p>
<p>D̂(x) =&prod;(x&minus; ai)di&minus;1 .
</p>
<p>Indeed, at x&rarr; ai the rational part has a pole of the order di&minus;1; when differentiated,
it becomes a pole of the order di, as needed. The numerator P(x) is a polynomial of
degree degP&lt; degD̂:
</p>
<p>P(x) =&sum; pnxn .
</p>
<p>Substituting all these parts and differentiating, we can find the unknown coefficients
</p>
<p>ci and pn by solving a linear system.
</p>
<p>For example, let&rsquo;s calculate
</p>
<p>&int;
</p>
<p>dx
</p>
<p>x2(x&minus; 1) =
p0
</p>
<p>x
+ c1 log(x)+ c2 log(x&minus; 1) .
</p>
<p>In[1] := Res = p[0]/x+ c[1]&lowast;Log[x]+ c[2]&lowast;Log[x&minus; 1]In[1] := Res = p[0]/x+ c[1]&lowast;Log[x]+ c[2]&lowast;Log[x&minus; 1]In[1] := Res = p[0]/x+ c[1]&lowast;Log[x]+ c[2]&lowast;Log[x&minus; 1]
Out[1] = c[2]Log[&minus;1+ x]+ c[1]Log[x]+ p[0]
</p>
<p>x
In[2] := Eq = Together[x&and;2 &lowast; (x&minus; 1)&lowast;D[Res,x]&minus; 1]In[2] := Eq = Together[x&and;2 &lowast; (x&minus; 1)&lowast;D[Res,x]&minus; 1]In[2] := Eq = Together[x&and;2 &lowast; (x&minus; 1)&lowast;D[Res,x]&minus; 1]
Out[2] =&minus;1&minus; xc[1]+ x2c[1]+ x2c[2]+ p[0]&minus; xp[0]
In[3] := Eqs = Table[Coefficient[Eq,x,n] == 0,{n,0,2}]In[3] := Eqs = Table[Coefficient[Eq,x,n] == 0,{n,0,2}]In[3] := Eqs = Table[Coefficient[Eq,x,n] == 0,{n,0,2}]
Out[3] = {&minus;1+ p[0] == 0,&minus;c[1]&minus; p[0] == 0,c[1]+ c[2] == 0}
In[4] := Sol = Solve[Eqs,{p[0],c[1],c[2]}][[1]]In[4] := Sol = Solve[Eqs,{p[0],c[1],c[2]}][[1]]In[4] := Sol = Solve[Eqs,{p[0],c[1],c[2]}][[1]]
Out[4] = {p[0]&rarr; 1,c[1]&rarr;&minus;1,c[2]&rarr; 1}
In[5] := Res/.SolIn[5] := Res/.SolIn[5] := Res/.Sol
</p>
<p>Out[5] =
1
</p>
<p>x
+Log[&minus;1+ x]&minus;Log[x]
</p>
<p>In[6] := Clear[Res,Eq,Eqs,Sol]In[6] := Clear[Res,Eq,Eqs,Sol]In[6] := Clear[Res,Eq,Eqs,Sol]
</p>
<p>10.2 Logarithmic Extension
</p>
<p>Now we begin to extend the class of integrands and consider
</p>
<p>&int;
</p>
<p>N(x,y)
</p>
<p>D(x,y)
dx ,</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2 Logarithmic Extension 81
</p>
<p>where y depends on x (in a nonrational way). The extension is called algebraic if y
</p>
<p>is a root of a polynomial equation p(x,y) = 0. For example, y = n
&radic;
</p>
<p>p(x)/q(x) is a
root of the equation q(x)yn&minus; p(x) = 0. An algorithm for integration of expressions
belonging to algebraic extensions has been constructed, but it requires an advanced
</p>
<p>mathematical apparatus [17], and we shall not discuss it here.
</p>
<p>Extensions which are not algebraic are called transcendental. There are two
</p>
<p>important classes of such extensions. A logarithmic extension y = logr(x) (where
r(x) is a rational function) is characterized by the property y&prime; = r&prime;/r. An exponential
extension y= expr(x)&mdash;by y&prime; = r&prime;y.
</p>
<p>If an integral of an expression from a logarithmic extension with some y =
logr(x) can be taken in elementary functions, it has the form
</p>
<p>&int;
</p>
<p>N(x,y)
</p>
<p>D(x,y)
dx=
</p>
<p>P(x,y)
</p>
<p>D̂(x,y)
+&sum;ci logqi ,
</p>
<p>where
</p>
<p>D=&prod;Ddii &rArr; D̂=&prod;Ddi&minus;1i ,
</p>
<p>qi are the irreducible factors of all Di, ci are constants,
</p>
<p>P(x,y) =&sum; pn(x)yn =&sum; pmnxmyn
</p>
<p>is a polynomial with unknown (so far) coefficients. Differentiating this general
</p>
<p>form of the result, putting everything over a common denominator, and equating
</p>
<p>coefficients of xmyn, we obtain a linear system for finding all unknown coefficients.
</p>
<p>If this system is incompatible, this means that the integral cannot be taken in ele-
</p>
<p>mentary functions.
</p>
<p>Example 1
</p>
<p>We shall consider several examples. Let y = logx so that y&prime; = 1/x. Let&rsquo;s calculate
the integral
</p>
<p>&int;
</p>
<p>ydx= p2(x)y
2 + p1(x)y+ p0(x) .
</p>
<p>When differentiated, the degree in y reduces by 1, so that the result is quadratic in y
</p>
<p>(there is no denominator, and hence no qi).
</p>
<p>In[7] := y&prime;[x ] := 1/xIn[7] := y&prime;[x ] := 1/xIn[7] := y&prime;[x ] := 1/x
In[8] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]In[8] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]In[8] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]
Out[8] = p[0][x]+ y[x]p[1][x]+ y[x]2p[2][x]
In[9] := Eq = D[Res,x]&minus; y[x]In[9] := Eq = D[Res,x]&minus; y[x]In[9] := Eq = D[Res,x]&minus; y[x]
Out[9] =&minus;y[x]+ p[1][x]
</p>
<p>x
+
</p>
<p>2y[x]p[2][x]
</p>
<p>x
+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]+ y[x]2p[2]&prime;[x]</p>
<p/>
</div>
<div class="page"><p/>
<p>82 10 Risch Algorithm
</p>
<p>In[10] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[10] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[10] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]
Out[10] =
</p>
<p>{
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1+ 2p[2][x]
</p>
<p>x
+ p[1]&prime;[x] == 0, p[2]&prime;[x] == 0
</p>
<p>}
</p>
<p>We see that p2(x) is a constant:
In[11] := p[2][x ] := p[2,0]; EqsIn[11] := p[2][x ] := p[2,0]; EqsIn[11] := p[2][x ] := p[2,0]; Eqs
</p>
<p>Out[11] =
</p>
<p>{
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1+ 2p[2,0]
</p>
<p>x
+ p[1]&prime;[x] == 0,True
</p>
<p>}
</p>
<p>Since p1(x) is a polynomial, the second equation can be satisfied only if p20 = 0:
In[12] := p[2,0] = 0; EqsIn[12] := p[2,0] = 0; EqsIn[12] := p[2,0] = 0; Eqs
</p>
<p>Out[12] =
</p>
<p>{
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1+ p[1]&prime;[x] == 0,True
</p>
<p>}
</p>
<p>The second equation gives
</p>
<p>In[13] := p[1][x ] := x+ p[1,0]In[13] := p[1][x ] := x+ p[1,0]In[13] := p[1][x ] := x+ p[1,0]
Now the first equation
</p>
<p>In[14] := Eq1 = ExpandAll[Eqs[[1]]]In[14] := Eq1 = ExpandAll[Eqs[[1]]]In[14] := Eq1 = ExpandAll[Eqs[[1]]]
</p>
<p>Out[14] = 1+
p[1,0]
</p>
<p>x
+ p[0]&prime;[x] == 0
</p>
<p>gives p10 = 0:
In[15] := p[1,0] = 0; Eq1In[15] := p[1,0] = 0; Eq1In[15] := p[1,0] = 0; Eq1
Out[15] = 1+ p[0]&prime;[x] == 0
Therefore p0(x) =&minus;x (omitting the integration constant):
In[16] := p[0][x ] :=&minus;x; Eq1In[16] := p[0][x ] :=&minus;x; Eq1In[16] := p[0][x ] :=&minus;x; Eq1
Out[16] = True
In[17] := ResIn[17] := ResIn[17] := Res
Out[17] =&minus;x+ xy[x]
In[18] := Clear[Res,Eq,Eqs,Eq1, p]In[18] := Clear[Res,Eq,Eqs,Eq1, p]In[18] := Clear[Res,Eq,Eqs,Eq1, p]
</p>
<p>We have derived the well-known result
&int;
</p>
<p>log(x)dx= x log(x)&minus; x .
</p>
<p>Consider the integrals
</p>
<p>&int;
</p>
<p>x log(x)dx ,
&int;
</p>
<p>log2(x)dx
</p>
<p>in a similar way.
</p>
<p>Example 2
</p>
<p>Let&rsquo;s calculate the integral
</p>
<p>&int;
</p>
<p>y
</p>
<p>x
dx= p2(x)y
</p>
<p>2 + p1(x)y+ p0(x) .</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2 Logarithmic Extension 83
</p>
<p>Here D̂ = 1; it seems that there is a single q, namely x, but log(x) = y, so that the
logarithmic part contributes nothing new.
</p>
<p>In[19] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}];In[19] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}];In[19] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}];
In[20] := Eq = D[Res,x]&minus; y[x]/xIn[20] := Eq = D[Res,x]&minus; y[x]/xIn[20] := Eq = D[Res,x]&minus; y[x]/x
Out[20] =&minus;y[x]
</p>
<p>x
+
</p>
<p>p[1][x]
</p>
<p>x
+
</p>
<p>2y[x]p[2][x]
</p>
<p>x
+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]+ y[x]2p[2]&prime;[x]
</p>
<p>In[21] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[21] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[21] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]
Out[21] =
</p>
<p>{
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1
</p>
<p>x
+
</p>
<p>2p[2][x]
</p>
<p>x
+ p[1]&prime;[x] == 0, p[2]&prime;[x] == 0
</p>
<p>}
</p>
<p>In[22] := p[2][x ] := p[2,0]; EqsIn[22] := p[2][x ] := p[2,0]; EqsIn[22] := p[2][x ] := p[2,0]; Eqs
</p>
<p>Out[22] =
</p>
<p>{
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1
</p>
<p>x
+
</p>
<p>2p[2,0]
</p>
<p>x
+ p[1]&prime;[x] == 0,True
</p>
<p>}
</p>
<p>From the second equation, p20 = 1/2; then p1 is a constant:
In[23] := p[2,0] = 1/2; Eqs[[2]]In[23] := p[2,0] = 1/2; Eqs[[2]]In[23] := p[2,0] = 1/2; Eqs[[2]]
Out[23] = p[1]&prime;[x] == 0
In[24] := p[1][x ] = p[1,0]; EqsIn[24] := p[1][x ] = p[1,0]; EqsIn[24] := p[1][x ] = p[1,0]; Eqs
</p>
<p>Out[24] =
</p>
<p>{
</p>
<p>p[1,0]
</p>
<p>x
+ p[0]&prime;[x] == 0,True,True
</p>
<p>}
</p>
<p>From the first equation, p10 = 0; then p0 is a constant (which may be omitted):
In[25] := p[1,0] = 0; Eqs[[1]]In[25] := p[1,0] = 0; Eqs[[1]]In[25] := p[1,0] = 0; Eqs[[1]]
Out[25] = p[0]&prime;[x] == 0
In[26] := p[0][x ] := 0; ResIn[26] := p[0][x ] := 0; ResIn[26] := p[0][x ] := 0; Res
</p>
<p>Out[26] =
y[x]2
</p>
<p>2
In[27] := Clear[Res,Eq,Eqs, p]In[27] := Clear[Res,Eq,Eqs, p]In[27] := Clear[Res,Eq,Eqs, p]
We have derived the well-known result
</p>
<p>&int;
</p>
<p>log(x)
</p>
<p>x
dx=
</p>
<p>1
</p>
<p>2
log2(x) .
</p>
<p>Example 3
</p>
<p>Let&rsquo;s change the previous integral a little:
</p>
<p>&int;
</p>
<p>y
</p>
<p>x+ 1
dx= p2(x)y
</p>
<p>2 + p1(x)y+ p0(x)+ c log(x+ 1) .
</p>
<p>In[28] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]+ c&lowast;Log[x+ 1]In[28] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]+ c&lowast;Log[x+ 1]In[28] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,2}]+ c&lowast;Log[x+ 1]
Out[28] = c, Log[1+ x]+ p[0][x]+ y[x]p[1][x]+ y[x]2p[2][x]
In[29] := Eq = D[Res,x]&minus; y[x]/(x+ 1)In[29] := Eq = D[Res,x]&minus; y[x]/(x+ 1)In[29] := Eq = D[Res,x]&minus; y[x]/(x+ 1)
Out[29] =
</p>
<p>c
</p>
<p>1+ x
&minus; y[x]
</p>
<p>1+ x
+
</p>
<p>p[1][x]
</p>
<p>x
+
</p>
<p>2y[x]p[2][x]
</p>
<p>x
+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]+
</p>
<p>y[x]2p[2]&prime;[x]</p>
<p/>
</div>
<div class="page"><p/>
<p>84 10 Risch Algorithm
</p>
<p>In[30] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[30] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[30] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]
Out[30] =
</p>
<p>{
</p>
<p>c
</p>
<p>1+ x
+
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus; 1
</p>
<p>1+ x
+
</p>
<p>2p[2][x]
</p>
<p>x
+ p[1]&prime;[x] == 0,
</p>
<p>p[2]&prime;[x] == 0
</p>
<p>}
</p>
<p>As in the previous examples, p2(x) is a constant:
In[31] := p[2][x ] := p[2,0]; EqsIn[31] := p[2][x ] := p[2,0]; EqsIn[31] := p[2][x ] := p[2,0]; Eqs
</p>
<p>Out[31] =
</p>
<p>{
</p>
<p>c
</p>
<p>1+ x
+
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus; 1
</p>
<p>1+ x
+
</p>
<p>2p[2,0]
</p>
<p>x
+ p[1]&prime;[x] == 0,
</p>
<p>True
</p>
<p>}
</p>
<p>A polynomial p1(x) satisfying the second equation does not exist. Therefore, this
integral cannot be taken in elementary functions.
</p>
<p>In[32] := Clear[Res,Eq,Eqs, p]In[32] := Clear[Res,Eq,Eqs, p]In[32] := Clear[Res,Eq,Eqs, p]
</p>
<p>Example 4
</p>
<p>Let&rsquo;s consider
&int;
</p>
<p>dx
</p>
<p>y
= p1(x)y+ p0(x)+ c log(y)
</p>
<p>(it is not quite clear what the degree of the right-hand side in y should be; we shall
</p>
<p>see in a moment that this is irrelevant).
</p>
<p>In[33] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]]In[33] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]]In[33] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]]
Out[33] = c, Log[y[x]]+ p[0][x]+ y[x]p[1][x]
In[34] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]In[34] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]In[34] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]
Out[34] =&minus;1+ c
</p>
<p>x
+
</p>
<p>y[x]p[1][x]
</p>
<p>x
+ y[x]p[0]&prime;[x]+ y[x]2p[1]&prime;[x]
</p>
<p>In[35] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[35] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[35] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]
Out[35] =
</p>
<p>{
</p>
<p>&minus;1+ c
x
== 0,
</p>
<p>p[1][x]
</p>
<p>x
+ p[0]&prime;[x] == 0, p[1]&prime;[x] == 0
</p>
<p>}
</p>
<p>From the last equation, p1(x) is a constant. The previous equation shows that it is
0, and p0(x) is a constant (it may be set to 0). It is clear that if we started from
some other degree in y, we would all the same find that all pn(x) = 0. And the first
equation cannot be solved for c.
</p>
<p>In[36] := Clear[Res,Eq,Eqs]In[36] := Clear[Res,Eq,Eqs]In[36] := Clear[Res,Eq,Eqs]
Consider the integrals
</p>
<p>&int;
</p>
<p>dx
</p>
<p>xy
,
</p>
<p>&int;
</p>
<p>dx
</p>
<p>y+ 1
</p>
<p>in a similar way.</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 Exponential Extension 85
</p>
<p>10.3 Exponential Extension
</p>
<p>Now we shall consider an exponential extension with some y = expr(x). If an
integral of an expression from this extension can be taken in elementary functions,
</p>
<p>it has the form
</p>
<p>&int;
</p>
<p>N(x,y)
</p>
<p>D(x,y)
dx=
</p>
<p>P(x,y)
</p>
<p>D̂(x,y)
+&sum;ci logqi ,
</p>
<p>D=&prod;Ddii &rArr; D̂=&prod;Dd̂ii ,
</p>
<p>where d̂i = di&minus; 1 always except the case Di = y in which d̂i = di. This is because
the derivative of 1/y is proportional to 1/y, the degree of y in the denominator
does not increase. We exclude y from the list of the factors qi (if it was present, of
</p>
<p>course) because logy= r(x) is a rational function, and such a contribution is already
accounted for. As usual, we differentiate the result and equate to the integrand to
</p>
<p>obtain a linear system. If it cannot be solved, then the integral does not exist in
</p>
<p>elementary functions.
</p>
<p>Example 1
</p>
<p>Let y= ex:
In[37] := y&prime;[x ] := y[x]In[37] := y&prime;[x ] := y[x]In[37] := y&prime;[x ] := y[x]
Let&rsquo;s calculate
</p>
<p>&int;
</p>
<p>ydx= p1(x)y+ p0(x)
</p>
<p>(the degree in y does not change when differentiating; therefore the polynomial in y
</p>
<p>in the right-hand side should have the same degree as the integrand).
</p>
<p>In[38] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]In[38] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]In[38] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]
Out[38] = p[0][x]+ y[x]p[1][x]
In[39] := Eq = D[Res,x]&minus; y[x]In[39] := Eq = D[Res,x]&minus; y[x]In[39] := Eq = D[Res,x]&minus; y[x]
Out[39] =&minus;y[x]+ y[x]p[1][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]
In[40] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[40] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[40] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[40] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,&minus;1+ p[1][x]+ p[1]&prime;[x] == 0
}
</p>
<p>In[41] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]In[41] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]In[41] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]
Out[41] =&minus;1+ p[1,0]+ p[1,1]+ xp[1,1]== 0
From this equation:
</p>
<p>In[42] := p[1,1] = 0; p[1,0] = 1; EqsIn[42] := p[1,1] = 0; p[1,0] = 1; EqsIn[42] := p[1,1] = 0; p[1,0] = 1; Eqs
Out[42] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,True
}
</p>
<p>Therefore p0(x) is a constant (which may be omitted):
In[43] := p[0][x ] := 0; ResIn[43] := p[0][x ] := 0; ResIn[43] := p[0][x ] := 0; Res
Out[43] = y[x]</p>
<p/>
</div>
<div class="page"><p/>
<p>86 10 Risch Algorithm
</p>
<p>We&rsquo;ve got the expected result.
</p>
<p>In[44] := Clear[Res,Eq,Eqs, p]In[44] := Clear[Res,Eq,Eqs, p]In[44] := Clear[Res,Eq,Eqs, p]
</p>
<p>Example 2
</p>
<p>Now let&rsquo;s calculate
&int;
</p>
<p>xydx= p1(x)y+ p0(x) .
</p>
<p>In[45] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]In[45] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]In[45] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]
Out[45] = p[0][x]+ y[x]p[1][x]
In[46] := Eq = D[Res,x]&minus; x&lowast; y[x]In[46] := Eq = D[Res,x]&minus; x&lowast; y[x]In[46] := Eq = D[Res,x]&minus; x&lowast; y[x]
Out[46] =&minus;xy[x]+ y[x]p[1][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]
In[47] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[47] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[47] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[47] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,&minus;x+ p[1][x]+ p[1]&prime;[x] == 0
}
</p>
<p>In[48] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]In[48] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]In[48] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[2]]
Out[48] =&minus;x+ p[1,0]+ p[1,1]+ xp[1,1]== 0
From this equation:
</p>
<p>In[49] := p[1,1] = 1; p[1,0] =&minus;1; EqsIn[49] := p[1,1] = 1; p[1,0] =&minus;1; EqsIn[49] := p[1,1] = 1; p[1,0] =&minus;1; Eqs
Out[49] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,True
}
</p>
<p>In[50] := p[0][x ] := 0; ResIn[50] := p[0][x ] := 0; ResIn[50] := p[0][x ] := 0; Res
Out[50] = (&minus;1+ x)y[x]
And without integration by parts!
</p>
<p>In[51] := Clear[Res,Eq,Eqs, p]In[51] := Clear[Res,Eq,Eqs, p]In[51] := Clear[Res,Eq,Eqs, p]
Consider
</p>
<p>&int;
</p>
<p>x2ydx
</p>
<p>in a similar way.
</p>
<p>Example 3
</p>
<p>Now let&rsquo;s try to calculate
</p>
<p>&int;
</p>
<p>y
</p>
<p>x
dx= p1(x)y+ p0(x)+ c logx .
</p>
<p>In[52] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[x]In[52] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[x]In[52] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[x]
Out[52] = c, Log[x]+ p[0][x]+ y[x]p[1][x]
In[53] := Eq = D[Res,x]&minus; y[x]/xIn[53] := Eq = D[Res,x]&minus; y[x]/xIn[53] := Eq = D[Res,x]&minus; y[x]/x
Out[53] =
</p>
<p>c
</p>
<p>x
&minus; y[x]
</p>
<p>x
+ y[x]p[1][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 Exponential Extension 87
</p>
<p>In[54] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[54] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[54] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[54] =
</p>
<p>{
</p>
<p>c
</p>
<p>x
+ p[0]&prime;[x] == 0,&minus;1
</p>
<p>x
+ p[1][x]+ p[1]&prime;[x] == 0
</p>
<p>}
</p>
<p>A polynomial p1(x) satisfying the second equation does not exist. Therefore this
integral cannot be taken in elementary functions.
</p>
<p>In[55] := Clear[Res,Eq,Eqs]In[55] := Clear[Res,Eq,Eqs]In[55] := Clear[Res,Eq,Eqs]
</p>
<p>Example 4
</p>
<p>Let&rsquo;s calculate
&int;
</p>
<p>dx
</p>
<p>y
=
</p>
<p>p1(x)y+ p0(x)
</p>
<p>y
</p>
<p>(here D̂ = y, and there are no qi). Of course, we could denote e
&minus;x as y, and the
</p>
<p>problem would reduce to the Example 1 with trivial modifications; but we want to
</p>
<p>observe how the algorithm works in this new case.
</p>
<p>In[56] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]/y[x]In[56] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]/y[x]In[56] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]/y[x]
Out[56] =
</p>
<p>p[0][x]+ y[x]p[1][x]
</p>
<p>y[x]
In[57] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]In[57] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]In[57] := Eq = Expand[y[x]&lowast;D[Res,x]&minus; 1]
Out[57] =&minus;1&minus; p[0][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]
In[58] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[58] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[58] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[58] =
</p>
<p>{
</p>
<p>&minus;1&minus; p[0][x]+ p[0]&prime;[x] == 0, p[1]&prime;[x] == 0
}
</p>
<p>From the second equation, p1(x) is a constant, which may be omitted&mdash;this is the
integration constant.
</p>
<p>In[59] := p[1][x ] := 0In[59] := p[1][x ] := 0In[59] := p[1][x ] := 0
In[60] := p[0][x ] := Sum[p[0,m]&lowast; x&and;m,{m,0,1}]; Eqs[[1]]In[60] := p[0][x ] := Sum[p[0,m]&lowast; x&and;m,{m,0,1}]; Eqs[[1]]In[60] := p[0][x ] := Sum[p[0,m]&lowast; x&and;m,{m,0,1}]; Eqs[[1]]
Out[60] =&minus;1&minus; p[0,0]+ p[0,1]&minus; xp[0,1]== 0
Therefore
</p>
<p>In[61] := p[0,1] = 0; p[0,0] =&minus;1; ResIn[61] := p[0,1] = 0; p[0,0] =&minus;1; ResIn[61] := p[0,1] = 0; p[0,0] =&minus;1; Res
Out[61] =&minus; 1
</p>
<p>y[x]
In[62] := Clear[Res,Eq,Eqs, p]In[62] := Clear[Res,Eq,Eqs, p]In[62] := Clear[Res,Eq,Eqs, p]
</p>
<p>Example 5
</p>
<p>Let&rsquo;s consider
&int;
</p>
<p>dx
</p>
<p>y&minus; 1 = p1(x)y+ p0(x)+ c log(y&minus; 1)
</p>
<p>(now D̂= 1, and there is a single q, namely y&minus; 1).</p>
<p/>
</div>
<div class="page"><p/>
<p>88 10 Risch Algorithm
</p>
<p>In[63] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]&minus; 1]In[63] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]&minus; 1]In[63] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}]+ c&lowast;Log[y[x]&minus; 1]
Out[63] = c, Log[&minus;1+ y[x]]+ p[0][x]+ y[x]p[1][x]
In[64] := Eq = Cancel[(y[x]&minus; 1)&lowast;D[Res,x]]&minus; 1In[64] := Eq = Cancel[(y[x]&minus; 1)&lowast;D[Res,x]]&minus; 1In[64] := Eq = Cancel[(y[x]&minus; 1)&lowast;D[Res,x]]&minus; 1
Out[64] =&minus;1+ cy[x]&minus; y[x]p[1][x]+ y[x]2p[1][x]&minus; p[0]&prime;[x]+ y[x]p[0]&prime;[x]&minus;
</p>
<p>y[x]p[1]&prime;[x]+ y[x]2p[1]&prime;[x]
In[65] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[65] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]In[65] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,2}]
Out[65] =
</p>
<p>{
</p>
<p>&minus;1&minus; p[0]&prime;[x] == 0,c&minus; p[1][x]+ p[0]&prime;[x]&minus; p[1]&prime;[x] == 0,
p[1][x]+ p[1]&prime;[x] == 0
</p>
<p>}
</p>
<p>In[66] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[3]]In[66] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[3]]In[66] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; Eqs[[3]]
Out[66] = p[1,0]+ p[1,1]+ xp[1,1]== 0
Therefore
</p>
<p>In[67] := p[1,1] = 0; p[1,0] = 0; EqsIn[67] := p[1,1] = 0; p[1,0] = 0; EqsIn[67] := p[1,1] = 0; p[1,0] = 0; Eqs
Out[67] =
</p>
<p>{
</p>
<p>&minus;1&minus; p[0]&prime;[x] == 0,c+ p[0]&prime;[x] == 0,True
}
</p>
<p>From the first equation, p0(x) =&minus;x (omitting the integration constant).
In[68] := p[0][x ] :=&minus;x; EqsIn[68] := p[0][x ] :=&minus;x; EqsIn[68] := p[0][x ] :=&minus;x; Eqs
Out[68] = {True,&minus;1+ c== 0,True}
In[69] := c= 1; ResIn[69] := c= 1; ResIn[69] := c= 1; Res
Out[69] =&minus;x+Log[&minus;1+ y[x]]
In[70] := Clear[Res,Eq,Eqs, p,c]In[70] := Clear[Res,Eq,Eqs, p,c]In[70] := Clear[Res,Eq,Eqs, p,c]
</p>
<p>Consider
&int;
</p>
<p>x
</p>
<p>y&minus; 1 dx
</p>
<p>in a similar way and demonstrate that this integral does not exist in elementary
</p>
<p>functions.
</p>
<p>Example 6
</p>
<p>Of course, the method can be also used for other exponential extensions. For exam-
</p>
<p>ple, let y= expx2:
In[71] := y&prime;[x ] := 2 &lowast; x&lowast; y[x]In[71] := y&prime;[x ] := 2 &lowast; x&lowast; y[x]In[71] := y&prime;[x ] := 2 &lowast; x&lowast; y[x]
Let&rsquo;s consider
</p>
<p>&int;
</p>
<p>ydx= p1(x)y+ p0(x) .
</p>
<p>In[72] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];In[72] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];In[72] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];
In[73] := Eq = D[Res,x]&minus; y[x]In[73] := Eq = D[Res,x]&minus; y[x]In[73] := Eq = D[Res,x]&minus; y[x]
Out[73] =&minus;y[x]+ 2xy[x]p[1][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]
In[74] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[74] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[74] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[74] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,&minus;1+ 2xp[1][x]+ p[1]&prime;[x] == 0
}
</p>
<p>In[75] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]In[75] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]In[75] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]
Out[75] =&minus;1+ 2xp[1,0]+ p[1,1]+2x2p[1,1] == 0
This equation cannot be solved. A larger degree of p1(x) does not help. Therefore
this integral cannot be taken in elementary functions.
</p>
<p>In[76] := Clear[Res,Eq,Eqs, p]In[76] := Clear[Res,Eq,Eqs, p]In[76] := Clear[Res,Eq,Eqs, p]</p>
<p/>
</div>
<div class="page"><p/>
<p>10.4 Elementary Functions 89
</p>
<p>Example 7
</p>
<p>And what about
&int;
</p>
<p>xydx= p1(x)y+ p0(x) ?
</p>
<p>In[77] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];In[77] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];In[77] := Res = Sum[p[n][x]&lowast; y[x]&and;n,{n,0,1}];
In[78] := Eq = D[Res,x]&minus; x&lowast; y[x]In[78] := Eq = D[Res,x]&minus; x&lowast; y[x]In[78] := Eq = D[Res,x]&minus; x&lowast; y[x]
Out[78] =&minus;xy[x]+ 2xy[x]p[1][x]+ p[0]&prime;[x]+ y[x]p[1]&prime;[x]
In[79] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[79] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]In[79] := Eqs = Table[Coefficient[Eq,y[x],n] == 0,{n,0,1}]
Out[79] =
</p>
<p>{
</p>
<p>p[0]&prime;[x] == 0,&minus;x+ 2xp[1][x]+ p[1]&prime;[x] == 0
}
</p>
<p>In[80] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]In[80] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]In[80] := p[1][x ] := Sum[p[1,m]&lowast; x&and;m,{m,0,1}]; ExpandAll[Eqs[[2]]]
Out[80] =&minus;x+ 2xp[1,0]+ p[1,1]+2x2p[1,1] == 0
From this equation, p11 = 0, p10 = 1/2. The first equation says that p0(x) is a con-
stant (it may be omitted).
</p>
<p>In[81] := p[1,1] = 0; p[1,0] = 1/2; p[0][x ] := 0; ResIn[81] := p[1,1] = 0; p[1,0] = 1/2; p[0][x ] := 0; ResIn[81] := p[1,1] = 0; p[1,0] = 1/2; p[0][x ] := 0; Res
</p>
<p>Out[81] =
y[x]
</p>
<p>2
In[82] := Clear[Res,Eq,Eqs, p]In[82] := Clear[Res,Eq,Eqs, p]In[82] := Clear[Res,Eq,Eqs, p]
</p>
<p>Consider
&int;
</p>
<p>x2ydx ,
&int;
</p>
<p>y
</p>
<p>x
dx
</p>
<p>in a similar way.
</p>
<p>10.4 Elementary Functions
</p>
<p>A tower of extensions can be constructed. We start from the set of rational functions
</p>
<p>N(x)/D(x). Then we introduce y1, which is either a root of a polynomial equation
p(x,y1) = 0, or logarithm or exponent of some rational function of x, and we obtain
a first extension&mdash;the set of functions N (x,y1)/D(x,y1). Then we introduce y2,
which is either a root of a polynomial equation p(x,y1,y2) = 0, or logarithm or ex-
ponent of some function from the previous extension, and we get a next extension&mdash;
</p>
<p>the set of rational functions of x, y1, y2. And so on. We should take care that an
</p>
<p>extension which seems transcendental is not in fact algebraic; if we neglect this,
</p>
<p>the methods designed for transcendental extensions may break down, e.g., produce
</p>
<p>divisions by 0. For example, if y1 = e
x, then it would not be a good idea to introduce
</p>
<p>the exponential extension with y2 = e
2x, because y2 is not algebraically independent:
</p>
<p>y2 = y
2
1. Similarly, if y1 = logx, then it&rsquo;s not reasonable to introduce the logarithmic
</p>
<p>extension with y2 = log2x, because y2 = y1+ log2 (in this case the field of constants
needs to be extended by the transcendental number log2). In simple cases such re-
</p>
<p>strictions are obvious, but in complicated ones it is necessary to decide if some
</p>
<p>function from some extension is identical 0, and this problem is algorithmically
</p>
<p>unsolvable in general.</p>
<p/>
</div>
<div class="page"><p/>
<p>90 10 Risch Algorithm
</p>
<p>Such towers of algebraic, logarithmic, and exponential extensions include all
</p>
<p>functions called elementary. And even some extra ones: an algebraic extension can
</p>
<p>be defined, e.g., by a root of a fifth degree polynomial unsolvable in radicals. Indeed,
</p>
<p>trigonometric functions reduce to exponentials, and inverse trigonometric ones&mdash;to
</p>
<p>logarithms. For each elementary function there exists a tower of extensions to which
</p>
<p>it belongs (it is not unique).
</p>
<p>Suppose we want to integrate an elementary function. We construct a tower of
</p>
<p>extensions to which it belongs. If the indefinite integral exists in elementary func-
</p>
<p>tions, it belongs to some further extension of our tower by some extra logarithms
</p>
<p>(their number may be zero). The Risch algorithm allows one to decide in a finite
</p>
<p>number of steps if the result exists in this further extension, and if so, to find it; if it
</p>
<p>does not exist, the algorithm proves this fact. In its classical form, the algorithm is re-
</p>
<p>cursive in extensions&mdash;it calls itself for solving integration subproblems in previous
</p>
<p>(smaller) extensions, until rational functions. There is a simpler and more efficient
</p>
<p>version of the Risch algorithm&mdash;to write down the general form of the result with
</p>
<p>unknown coefficients, differentiate it and equate to the integrand. Then the problem
</p>
<p>reduces to solving a linear system. This approach is guaranteed to be correct if we
</p>
<p>know upper bounds on the degrees of the polynomialP(x,y1,y2, . . .) in its variables.
But such upper bounds are not always known (as we have seen in the examples, they
</p>
<p>are known if there is no denominator). Therefore some heuristic rules to bound the
</p>
<p>degrees of P are used. This can give a situation when no result is found, though it
</p>
<p>really exists (but has a larger degree in some variables).
</p>
<p>The Risch algorithm is an outstanding achievement of mathematics in the
</p>
<p>twentieth century. But it does not solve all problems with indefinite integration. The
</p>
<p>answer that no result exists in elementary functions is not very useful. It would
</p>
<p>be much better to get the result with some special functions. There were attempts
</p>
<p>to generalize the Risch algorithm to some special functions (the error function,
</p>
<p>polylogarithms). Some of them are implemented in Mathematica.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 11
</p>
<p>Linear Algebra
</p>
<p>11.1 Constructing Matrices
</p>
<p>A matrix in Mathematica is a list of lists; all the lists&mdash;rows of the matrix&mdash;must
</p>
<p>have the same length.
</p>
<p>In[1] :=M = {{a,b},{c,d}}In[1] :=M = {{a,b},{c,d}}In[1] :=M = {{a,b},{c,d}}
Out[1] = {{a,b},{c,d}}
MatrixForm is used to print a matrix nicely.
</p>
<p>In[2] := MatrixForm[M]In[2] := MatrixForm[M]In[2] := MatrixForm[M]
Out[2]//MatrixForm =
</p>
<p>(
</p>
<p>a b
</p>
<p>c d
</p>
<p>)
</p>
<p>If the (i, j)th element of a matrix is given by an expression depending on i and j,
this matrix can be constructed by the function Table.
</p>
<p>In[3] := A= Table[a[i, j],{i,1,2},{ j,1,2}]In[3] := A= Table[a[i, j],{i,1,2},{ j,1,2}]In[3] := A= Table[a[i, j],{i,1,2},{ j,1,2}]
Out[3] = {{a[1,1],a[1,2]},{a[2,1],a[2,2]}}
In[4] := B= Table[1/(i+ j+ 1),{i,1,2},{ j,1,2}]In[4] := B= Table[1/(i+ j+ 1),{i,1,2},{ j,1,2}]In[4] := B= Table[1/(i+ j+ 1),{i,1,2},{ j,1,2}]
Out[4] =
</p>
<p>{{
</p>
<p>1
</p>
<p>3
,
</p>
<p>1
</p>
<p>4
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>1
</p>
<p>4
,
</p>
<p>1
</p>
<p>5
</p>
<p>}}
</p>
<p>In[5] := MatrixForm[A]In[5] := MatrixForm[A]In[5] := MatrixForm[A]
Out[5]//MatrixForm =
</p>
<p>(
</p>
<p>a[1,1] a[1,2]
a[2,1] a[2,2]
</p>
<p>)
</p>
<p>In[6] := MatrixForm[B]In[6] := MatrixForm[B]In[6] := MatrixForm[B]
Out[6]//MatrixForm =
</p>
<p>(
</p>
<p>1
3
</p>
<p>1
4
</p>
<p>1
4
</p>
<p>1
5
</p>
<p>)
</p>
<p>The function Array is similar, but its first argument is a function of two parameters,
</p>
<p>not an expression. It may be just a symbol or an anonymous function (Function).
In[7] := A= Array[a,{2,2}]In[7] := A= Array[a,{2,2}]In[7] := A= Array[a,{2,2}]
Out[7] = {{a[1,1],a[1,2]},{a[2,1],a[2,2]}}
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 11, &copy; Springer International Publishing Switzerland 2014
</p>
<p>91</p>
<p/>
</div>
<div class="page"><p/>
<p>92 11 Linear Algebra
</p>
<p>In[8] := B= Array[Function[{i, j},1/(i+ j+ 1)],{2,2}]In[8] := B= Array[Function[{i, j},1/(i+ j+ 1)],{2,2}]In[8] := B= Array[Function[{i, j},1/(i+ j+ 1)],{2,2}]
Out[8] =
</p>
<p>{{
</p>
<p>1
</p>
<p>3
,
</p>
<p>1
</p>
<p>4
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>1
</p>
<p>4
,
</p>
<p>1
</p>
<p>5
</p>
<p>}}
</p>
<p>Mathematica does not distinguish column vectors and row vectors; both are
</p>
<p>just lists.
</p>
<p>In[9] :=V = Table[v[i],{i,1,2}]In[9] :=V = Table[v[i],{i,1,2}]In[9] :=V = Table[v[i],{i,1,2}]
Out[9] = {v[1],v[2]}
In[10] :=V = Array[v,2]In[10] :=V = Array[v,2]In[10] :=V = Array[v,2]
Out[10] = {v[1],v[2]}
In[11] :=U = Array[u,2]In[11] :=U = Array[u,2]In[11] :=U = Array[u,2]
Out[11] = {u[1],u[2]}
</p>
<p>11.2 Parts of a Matrix
</p>
<p>A matrix element.
</p>
<p>In[12] := A[[1,2]]In[12] := A[[1,2]]In[12] := A[[1,2]]
Out[12] = a[1,2]
A row.
</p>
<p>In[13] := A[[1]]In[13] := A[[1]]In[13] := A[[1]]
Out[13] = {a[1,1],a[1,2]}
A column.
</p>
<p>In[14] := A[[All,2]]In[14] := A[[All,2]]In[14] := A[[All,2]]
Out[14] = {a[1,2],a[2,2]}
A new value can be assigned to a matrix element.
</p>
<p>In[15] :=M[[1,2]] = 0In[15] :=M[[1,2]] = 0In[15] :=M[[1,2]] = 0
Out[15] = 0
In[16] := MatrixForm[M]In[16] := MatrixForm[M]In[16] := MatrixForm[M]
Out[16]//MatrixForm=
</p>
<p>(
</p>
<p>a 0
</p>
<p>c d
</p>
<p>)
</p>
<p>Add 1 to the first row.
</p>
<p>In[17] :=M[[1]]++In[17] :=M[[1]]++In[17] :=M[[1]]++
Out[17] = {a,0}
In[18] := MatrixForm[M]In[18] := MatrixForm[M]In[18] := MatrixForm[M]
Out[18]//MatrixForm=
</p>
<p>(
</p>
<p>1+ a 1
c d
</p>
<p>)
</p>
<p>Add the second column to the first one.
</p>
<p>In[19] :=M[[All,1]]+ =M[[All,2]]In[19] :=M[[All,1]]+ =M[[All,2]]In[19] :=M[[All,1]]+ =M[[All,2]]
Out[19] = {2+ a,c+ d}
In[20] := MatrixForm[M]In[20] := MatrixForm[M]In[20] := MatrixForm[M]
Out[20]//MatrixForm=
</p>
<p>(
</p>
<p>2+ a 1
c+ d d
</p>
<p>)</p>
<p/>
</div>
<div class="page"><p/>
<p>11.4 Operations with Matrices and Vectors 93
</p>
<p>11.3 Queries
</p>
<p>The function VectorQ checks if its argument is a vector, i.e., a list whose elements
</p>
<p>are not lists.
</p>
<p>In[21] := {VectorQ[V ],VectorQ[M]}In[21] := {VectorQ[V ],VectorQ[M]}In[21] := {VectorQ[V ],VectorQ[M]}
Out[21] = {True,False}
The function MatrixQ checks if its argument is a matrix, i.e., a list of same-length
</p>
<p>lists.
</p>
<p>In[22] := {MatrixQ[V ],MatrixQ[M],MatrixQ[{{a,b},{x,y,z}}]}In[22] := {MatrixQ[V ],MatrixQ[M],MatrixQ[{{a,b},{x,y,z}}]}In[22] := {MatrixQ[V ],MatrixQ[M],MatrixQ[{{a,b},{x,y,z}}]}
Out[22] = {False,True,False}
</p>
<p>The argument of the function Dimensions must be a matrix. This function returns
</p>
<p>a two-element list&mdash;the numbers of rows and columns of the matrix.
</p>
<p>In[23] := Dimensions[M]In[23] := Dimensions[M]In[23] := Dimensions[M]
Out[23] = {2,2}
It can be conveniently used for simultaneous assignment to two variables.
</p>
<p>In[24] := {n1,n2}= Dimensions[{{a,b,c},{x,y,z}}]In[24] := {n1,n2}= Dimensions[{{a,b,c},{x,y,z}}]In[24] := {n1,n2}= Dimensions[{{a,b,c},{x,y,z}}]
Out[24] = {2,3}
In[25] := n1In[25] := n1In[25] := n1
Out[25] = 2
In[26] := n2In[26] := n2In[26] := n2
Out[26] = 3
In[27] := Clear[M,n1,n2]In[27] := Clear[M,n1,n2]In[27] := Clear[M,n1,n2]
</p>
<p>11.4 Operations with Matrices and Vectors
</p>
<p>Vectors can be added and multiplied by scalar expressions.
</p>
<p>In[28] := 2 &lowast;V +UIn[28] := 2 &lowast;V +UIn[28] := 2 &lowast;V +U
Out[28] = {u[1]+ 2v[1],u[2]+ 2v[2]}
Matrices can be added and multiplied by scalar expressions.
</p>
<p>In[29] := MatrixForm[A+ 2 &lowast;B]In[29] := MatrixForm[A+ 2 &lowast;B]In[29] := MatrixForm[A+ 2 &lowast;B]
Out[29]//MatrixForm=
</p>
<p>(
</p>
<p>2
3 + a[1,1]
</p>
<p>1
2 + a[1,2]
</p>
<p>1
2 + a[2,1]
</p>
<p>2
5 + a[2,2]
</p>
<p>)
</p>
<p>The scalar product of two vectors.
</p>
<p>In[30] :=V.UIn[30] :=V.UIn[30] :=V.U
Out[30] = u[1]v[1]+ u[2]v[2]
The product of a matrix and a column vector.
</p>
<p>In[31] := A.VIn[31] := A.VIn[31] := A.V
Out[31] = {a[1,1]v[1]+ a[1,2]v[2],a[2,1]v[1]+a[2,2]v[2]}
The product of a row vector and a matrix.
</p>
<p>In[32] :=V.AIn[32] :=V.AIn[32] :=V.A
Out[32] = {a[1,1]v[1]+ a[2,1]v[2],a[1,2]v[1]+a[2,2]v[2]}
The product of two matrices.</p>
<p/>
</div>
<div class="page"><p/>
<p>94 11 Linear Algebra
</p>
<p>In[33] := MatrixForm[A.B]In[33] := MatrixForm[A.B]In[33] := MatrixForm[A.B]
Out[33]//MatrixForm=
</p>
<p>(
</p>
<p>1
3a[1,1]+
</p>
<p>1
4a[1,2]
</p>
<p>1
4a[1,1]+
</p>
<p>1
5a[1,2]
</p>
<p>1
3a[2,1]+
</p>
<p>1
4a[2,2]
</p>
<p>1
4a[2,1]+
</p>
<p>1
5a[2,2]
</p>
<p>)
</p>
<p>It is not commutative.
</p>
<p>In[34] := MatrixForm[A.B&minus;B.A]In[34] := MatrixForm[A.B&minus;B.A]In[34] := MatrixForm[A.B&minus;B.A]
Out[34]//MatrixForm=
</p>
<p>(
</p>
<p>1
4a[1,2]&minus; 14a[2,1] 14a[1,1]&minus; 215a[1,2]&minus; 14a[2,2]
</p>
<p>&minus; 14a[1,1]+ 215a[2,1]+ 14a[2,2] &minus; 14a[1,2]+ 14a[2,1]
</p>
<p>)
</p>
<p>Determinant (the matrix must be square).
</p>
<p>In[35] := Det[A]In[35] := Det[A]In[35] := Det[A]
Out[35] =&minus;a[1,2]a[2,1]+ a[1,1]a[2,2]
Trace (the matrix must be square).
</p>
<p>In[36] := Tr[A]In[36] := Tr[A]In[36] := Tr[A]
Out[36] = a[1,1]+ a[2,2]
Transposing.
</p>
<p>In[37] := MatrixForm[Transpose[A]]In[37] := MatrixForm[Transpose[A]]In[37] := MatrixForm[Transpose[A]]
Out[37]//MatrixForm=
</p>
<p>(
</p>
<p>a[1,1] a[2,1]
a[1,2] a[2,2]
</p>
<p>)
</p>
<p>The inverse matrix.
</p>
<p>In[38] := MatrixForm[Inverse[A]]In[38] := MatrixForm[Inverse[A]]In[38] := MatrixForm[Inverse[A]]
Out[38]//MatrixForm=
</p>
<p>(
</p>
<p>a[2,2]
&minus;a[1,2]a[2,1]+a[1,1]a[2,2] &minus;
</p>
<p>a[1,2]
&minus;a[1,2]a[2,1]+a[1,1]a[2,2]
</p>
<p>&minus; a[2,1]&minus;a[1,2]a[2,1]+a[1,1]a[2,2]
a[1,1]
</p>
<p>&minus;a[1,2]a[2,1]+a[1,1]a[2,2]
</p>
<p>)
</p>
<p>A square matrix can be raised to an integer power.
</p>
<p>In[39] := MatrixForm[MatrixPower[B,3]]In[39] := MatrixForm[MatrixPower[B,3]]In[39] := MatrixForm[MatrixPower[B,3]]
Out[39]//MatrixForm=
</p>
<p>(
</p>
<p>197
2160
</p>
<p>1009
14400
</p>
<p>1009
14400
</p>
<p>323
6000
</p>
<p>)
</p>
<p>The power &minus;1 is the inverse matrix.
In[40] := MatrixForm[MatrixPower[B,&minus;1]]In[40] := MatrixForm[MatrixPower[B,&minus;1]]In[40] := MatrixForm[MatrixPower[B,&minus;1]]
Out[40]//MatrixForm=
</p>
<p>(
</p>
<p>48 &minus;60
&minus;60 80
</p>
<p>)
</p>
<p>This is the solution of the linear system A.X =V .
In[41] := Together[Inverse[A].V ]In[41] := Together[Inverse[A].V ]In[41] := Together[Inverse[A].V ]
</p>
<p>Out[41] =
</p>
<p>{
</p>
<p>a[2,2]v[1]&minus; a[1,2]v[2]
&minus;a[1,2]a[2,1]+ a[1,1]a[2,2],
</p>
<p>a[2,1]v[1]&minus; a[1,1]v[2]
a[1,2]a[2,1]&minus; a[1,1]a[2,2]
</p>
<p>}
</p>
<p>The same can be done using LinearSolve.
</p>
<p>In[42] := LinearSolve[A,V ]In[42] := LinearSolve[A,V ]In[42] := LinearSolve[A,V ]
</p>
<p>Out[42] =
</p>
<p>{
</p>
<p>a[2,2]v[1]&minus; a[1,2]v[2]
&minus;a[1,2]a[2,1]+ a[1,1]a[2,2],
</p>
<p>a[2,1]v[1]&minus; a[1,1]v[2]
a[1,2]a[2,1]&minus; a[1,1]a[2,2]
</p>
<p>}
</p>
<p>In[43] := Clear[A,B,U,V ]In[43] := Clear[A,B,U,V ]In[43] := Clear[A,B,U,V ]</p>
<p/>
</div>
<div class="page"><p/>
<p>11.5 Eigenvalues and Eigenvectors 95
</p>
<p>11.5 Eigenvalues and Eigenvectors
</p>
<p>Here is some symbolic matrix.
</p>
<p>In[44] := MatrixForm[M =In[44] := MatrixForm[M =In[44] := MatrixForm[M =
{{(1&minus; x)&and;3 &lowast; (3+ x),4 &lowast; x&lowast; (1&minus; x&and;2),&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x)},{{(1&minus; x)&and;3 &lowast; (3+ x),4 &lowast; x&lowast; (1&minus; x&and;2),&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x)},{{(1&minus; x)&and;3 &lowast; (3+ x),4 &lowast; x&lowast; (1&minus; x&and;2),&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x)},
{4 &lowast; x&lowast; (1&minus; x&and;2),&minus;(1+ x)&and;3 &lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x)},{4 &lowast; x&lowast; (1&minus; x&and;2),&minus;(1+ x)&and;3 &lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x)},{4 &lowast; x&lowast; (1&minus; x&and;2),&minus;(1+ x)&and;3 &lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x)},
{&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x),16 &lowast; x}}]{&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x),16 &lowast; x}}]{&minus;2 &lowast; (1&minus; x&and;2)&lowast; (3&minus; x),2 &lowast; (1&minus; x&and;2)&lowast; (3+ x),16 &lowast; x}}]
</p>
<p>Out[44]//MatrixForm=
⎛
</p>
<p>⎝
</p>
<p>(1&minus; x)3(3+ x) 4x
(
</p>
<p>1&minus; x2
)
</p>
<p>&minus;2(3&minus; x)
(
</p>
<p>1&minus; x2
)
</p>
<p>4x
(
</p>
<p>1&minus; x2
)
</p>
<p>&minus;(3&minus; x)(1+ x)3 2(3+ x)
(
</p>
<p>1&minus; x2
)
</p>
<p>&minus;2(3&minus; x)
(
</p>
<p>1&minus; x2
)
</p>
<p>2(3+ x)
(
</p>
<p>1&minus; x2
)
</p>
<p>16x
</p>
<p>⎞
</p>
<p>⎠
</p>
<p>It is singular.
</p>
<p>In[45] := Det[M]In[45] := Det[M]In[45] := Det[M]
Out[45] = 0
Its rank.
</p>
<p>In[46] := MatrixRank[M]In[46] := MatrixRank[M]In[46] := MatrixRank[M]
Out[46] = 2
The function NullSpace returns a list of vectors forming a basis of the null space of
</p>
<p>the matrix, i.e., the subspace of vectors nullified by the matrix.
</p>
<p>In[47] := s= NullSpace[M]In[47] := s= NullSpace[M]In[47] := s= NullSpace[M]
</p>
<p>Out[47] =
</p>
<p>{{
</p>
<p>&minus; 2&minus;1+ x ,
2
</p>
<p>1+ x
,1
</p>
<p>}}
</p>
<p>In this case, the null space is one-dimensional&mdash;it has a single basis vector. Let&rsquo;s
</p>
<p>check it.
</p>
<p>In[48] := Together[M.s[[1]]]In[48] := Together[M.s[[1]]]In[48] := Together[M.s[[1]]]
Out[48] = {0,0,0}
</p>
<p>The function Eigenvalues returns a list of eigenvalues of a matrix.
</p>
<p>In[49] := Simplify[Eigenvalues[M],Element[x,Reals]]In[49] := Simplify[Eigenvalues[M],Element[x,Reals]]In[49] := Simplify[Eigenvalues[M],Element[x,Reals]]
</p>
<p>Out[49] =
{
</p>
<p>0,
(
</p>
<p>3+ x2
)2
,&minus;
</p>
<p>(
</p>
<p>3+ x2
)2
}
</p>
<p>We have added the second argument to Simplify which informs Mathematica that
</p>
<p>the variable x is real. The function Eigenvectors returns the list of the corresponding
</p>
<p>eigenvectors (in the same order).
</p>
<p>In[50] := Simplify[Eigenvectors[M],Element[x,Reals]]In[50] := Simplify[Eigenvectors[M],Element[x,Reals]]In[50] := Simplify[Eigenvectors[M],Element[x,Reals]]
</p>
<p>Out[50] =
</p>
<p>{{
</p>
<p>&minus; 2&minus;1+ x ,
2
</p>
<p>1+ x
,1
</p>
<p>}
</p>
<p>,
</p>
<p>{&minus;1+ x
1+ x
</p>
<p>,
1&minus; x
</p>
<p>2
,1
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>1+ x
</p>
<p>2
,
</p>
<p>1+ x
</p>
<p>&minus;1+ x ,1
}}
</p>
<p>The function Eigensystem returns both. It is convenient for simultaneous assignment
</p>
<p>to two variables.
</p>
<p>In[51] := {val,vec}= Simplify[Eigensystem[M],Element[x,Reals]];In[51] := {val,vec}= Simplify[Eigensystem[M],Element[x,Reals]];In[51] := {val,vec}= Simplify[Eigensystem[M],Element[x,Reals]];
Let&rsquo;s check.
</p>
<p>In[52] := Do[Print[Simplify[M.vec[[i]]&minus; val[[i]]&lowast; vec[[i]]]],{i,1,3}]In[52] := Do[Print[Simplify[M.vec[[i]]&minus; val[[i]]&lowast; vec[[i]]]],{i,1,3}]In[52] := Do[Print[Simplify[M.vec[[i]]&minus; val[[i]]&lowast; vec[[i]]]],{i,1,3}]
{0,0,0}
{0,0,0}
{0,0,0}
In[53] := Clear[M,s,val,vec]In[53] := Clear[M,s,val,vec]In[53] := Clear[M,s,val,vec]</p>
<p/>
</div>
<div class="page"><p/>
<p>96 11 Linear Algebra
</p>
<p>11.6 Jordan Form
</p>
<p>Here is a matrix of rational numbers.
</p>
<p>In[54] := MatrixForm[M =In[54] := MatrixForm[M =In[54] := MatrixForm[M =
{{13/9,&minus;2/9,1/3,4/9,2/3},{{13/9,&minus;2/9,1/3,4/9,2/3},{{13/9,&minus;2/9,1/3,4/9,2/3},
{&minus;2/9,10/9,2/15,&minus;2/9,&minus;11/15},{&minus;2/9,10/9,2/15,&minus;2/9,&minus;11/15},{&minus;2/9,10/9,2/15,&minus;2/9,&minus;11/15},
{1/5,&minus;2/5,41/25,&minus;2/5,12/25},{1/5,&minus;2/5,41/25,&minus;2/5,12/25},{1/5,&minus;2/5,41/25,&minus;2/5,12/25},
{4/9,&minus;2/9,14/15,13/9,&minus;2/15},{4/9,&minus;2/9,14/15,13/9,&minus;2/15},{4/9,&minus;2/9,14/15,13/9,&minus;2/15},
{&minus;4/15,8/15,12/25,8/15,34/25}}]{&minus;4/15,8/15,12/25,8/15,34/25}}]{&minus;4/15,8/15,12/25,8/15,34/25}}]
</p>
<p>Out[54]//MatrixForm=
⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>13
9 &minus; 29 13 49 23
</p>
<p>&minus; 29 109 215 &minus; 29 &minus; 1115
1
5 &minus; 25 4125 &minus; 25 1225
4
9 &minus; 29 1415 139 &minus; 215
</p>
<p>&minus; 415 815 1225 815 3425
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>The function JordanDecomposition returns a pair of matrices&mdash;the Jordan form J
</p>
<p>and the transformation matrix P which reduces our matrix to its Jordan form.
</p>
<p>In[55] := {P,J}= JordanDecomposition[M];In[55] := {P,J}= JordanDecomposition[M];In[55] := {P,J}= JordanDecomposition[M];
In[56] := MatrixForm[J]In[56] := MatrixForm[J]In[56] := MatrixForm[J]
Out[56]//MatrixForm=
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>1 0 0 0 0
</p>
<p>0 2 1 0 0
</p>
<p>0 0 2 0 0
</p>
<p>0 0 0 1&minus; i 0
0 0 0 0 1+ i
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>In[57] := MatrixForm[P]In[57] := MatrixForm[P]In[57] := MatrixForm[P]
Out[57]//MatrixForm=
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>&minus;2 1 0 5i12 &minus; 5i12
&minus;2 &minus; 12 0 &minus; 5i6 5i6
0 0 65 &minus; 34 &minus; 34
1 1 0 &minus; 5i6 5i6
0 0 910 1 1
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>Let&rsquo;s check.
</p>
<p>In[58] := MatrixForm[P.J.Inverse[P]&minus;M]In[58] := MatrixForm[P.J.Inverse[P]&minus;M]In[58] := MatrixForm[P.J.Inverse[P]&minus;M]
Out[58]//MatrixForm=
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>0 0 0 0 0
</p>
<p>0 0 0 0 0
</p>
<p>0 0 0 0 0
</p>
<p>0 0 0 0 0
</p>
<p>0 0 0 0 0
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>Here are the eigenvalues and the eigenvectors of our matrix. Note that only
</p>
<p>one eigenvector corresponds to the eigenvalue 2, because the corresponding Jordan
</p>
<p>block has the size 2&times; 2. The eigenvectors are the columns of the transformation
matrix P.</p>
<p/>
</div>
<div class="page"><p/>
<p>11.7 Symbolic Vectors, Matrices, and Tensors 97
</p>
<p>In[59] := {val,vec}= Eigensystem[M];In[59] := {val,vec}= Eigensystem[M];In[59] := {val,vec}= Eigensystem[M];
In[60] := valIn[60] := valIn[60] := val
Out[60] = {2,2,1+ i,1&minus; i,1}
In[61] := vecIn[61] := vecIn[61] := vec
</p>
<p>Out[61] =
</p>
<p>{{
</p>
<p>1,&minus;1
2
,0,1,0
</p>
<p>}
</p>
<p>,{0,0,0,0,0},
{
</p>
<p>&minus; 5i
12
</p>
<p>,
5i
</p>
<p>6
,&minus;3
</p>
<p>4
,
</p>
<p>5i
</p>
<p>6
,1
</p>
<p>}
</p>
<p>,
{
</p>
<p>5i
</p>
<p>12
,&minus;5i
</p>
<p>6
,&minus;3
</p>
<p>4
,&minus;5i
</p>
<p>6
,1
</p>
<p>}
</p>
<p>,{&minus;2,&minus;2,0,1,0}
}
</p>
<p>In[62] := Clear[M,J,P,val,vec]In[62] := Clear[M,J,P,val,vec]In[62] := Clear[M,J,P,val,vec]
</p>
<p>11.7 Symbolic Vectors, Matrices, and Tensors
</p>
<p>Let&rsquo;s inform Mathematica that u, v, and w are symbolic three-dimensional vectors
</p>
<p>with real components. The scalar product is u.v, and the vector product is Cross[u,v].
The function TensorReduce simplifies expressions with vectors.
</p>
<p>In[63] := $Assumptions = Element[u|v|w,Vectors[3,Reals]]In[63] := $Assumptions = Element[u|v|w,Vectors[3,Reals]]In[63] := $Assumptions = Element[u|v|w,Vectors[3,Reals]]
Out[63] = (u|v|w) &isin; Vectors[3,Reals]
In[64] := TensorReduce[u.v&minus; v.u]In[64] := TensorReduce[u.v&minus; v.u]In[64] := TensorReduce[u.v&minus; v.u]
Out[64] = 0
In[65] := TensorReduce[Cross[u,v]+Cross[v,u]]In[65] := TensorReduce[Cross[u,v]+Cross[v,u]]In[65] := TensorReduce[Cross[u,v]+Cross[v,u]]
Out[65] = 0
In[66] := TensorReduce[u.Cross[v,w]+ v.Cross[w,u]+w.Cross[u,v]]In[66] := TensorReduce[u.Cross[v,w]+ v.Cross[w,u]+w.Cross[u,v]]In[66] := TensorReduce[u.Cross[v,w]+ v.Cross[w,u]+w.Cross[u,v]]
Out[66] = 3u&times; v.w
In[67] := TensorReduce[Cross[u,Cross[v,w]]]In[67] := TensorReduce[Cross[u,Cross[v,w]]]In[67] := TensorReduce[Cross[u,Cross[v,w]]]
Out[67] =&minus;wu.v+ vu.w
In[68] := TensorReduce[u.(2 &lowast; v+ 3 &lowast;w)]In[68] := TensorReduce[u.(2 &lowast; v+ 3 &lowast;w)]In[68] := TensorReduce[u.(2 &lowast; v+ 3 &lowast;w)]
Out[68] = 2u.v+ 3u.w
</p>
<p>Now let&rsquo;s say that u and v are d-dimensional vectors, and S and A are d &times; d
matrices, S symmetric and A antisymmetric.
</p>
<p>In[69] := $Assumptions = {Element[u|v,Vectors[d,Reals]],In[69] := $Assumptions = {Element[u|v,Vectors[d,Reals]],In[69] := $Assumptions = {Element[u|v,Vectors[d,Reals]],
Element[S,Matrices[{d,d},Reals,Symmetric[{1,2}]]],Element[S,Matrices[{d,d},Reals,Symmetric[{1,2}]]],Element[S,Matrices[{d,d},Reals,Symmetric[{1,2}]]],
Element[A,Matrices[{d,d},Reals,Antisymmetric[{1,2}]]]};Element[A,Matrices[{d,d},Reals,Antisymmetric[{1,2}]]]};Element[A,Matrices[{d,d},Reals,Antisymmetric[{1,2}]]]};
</p>
<p>In[70] := TensorReduce[v.A.(u+ v)]In[70] := TensorReduce[v.A.(u+ v)]In[70] := TensorReduce[v.A.(u+ v)]
Out[70] =&minus;u.A.v
In[71] := TensorReduce[u.S.v+ v.S.u]In[71] := TensorReduce[u.S.v+ v.S.u]In[71] := TensorReduce[u.S.v+ v.S.u]
Out[71] = 2u.S.v
The tensor product Si jAk l is contracted in j and k and in i and l.
</p>
<p>In[72] := TensorReduce[TensorContract[TensorProduct[S,A],{{2,3},{1,4}}]]In[72] := TensorReduce[TensorContract[TensorProduct[S,A],{{2,3},{1,4}}]]In[72] := TensorReduce[TensorContract[TensorProduct[S,A],{{2,3},{1,4}}]]
Out[72] = 0
</p>
<p>The Riemann curvature tensor has the properties Ri j k l = &minus;R j i k l and Ri j k l =
Rk l i j.</p>
<p/>
</div>
<div class="page"><p/>
<p>98 11 Linear Algebra
</p>
<p>In[73] := $Assumptions = Element[R,Arrays[{4,4,4,4},Reals,In[73] := $Assumptions = Element[R,Arrays[{4,4,4,4},Reals,In[73] := $Assumptions = Element[R,Arrays[{4,4,4,4},Reals,
{{{2,1,3,4},&minus;1},{{3,4,1,2},1}}]]{{{2,1,3,4},&minus;1},{{3,4,1,2},1}}]]{{{2,1,3,4},&minus;1},{{3,4,1,2},1}}]]
</p>
<p>Out[73] = R &isin; Arrays[{4,4,4,4},Reals,{{Cycles[{{1,2}}],&minus;1},
{Cycles[{{1,3},{2,4}}],1},{Cycles[{{3,4}}],&minus;1}}]
</p>
<p>In[74] := TensorReduce[TensorContract[R,{{1,2}}]]In[74] := TensorReduce[TensorContract[R,{{1,2}}]]In[74] := TensorReduce[TensorContract[R,{{1,2}}]]
Out[74] = 0
The Ricci tensor.
</p>
<p>In[75] := R2 = TensorContract[R,{{1,3}}]In[75] := R2 = TensorContract[R,{{1,3}}]In[75] := R2 = TensorContract[R,{{1,3}}]
Out[75] = TensorContract[R,{{1,3}}]
In[76] := {TensorRank[R2],TensorDimensions[R2],TensorSymmetry[R2]}In[76] := {TensorRank[R2],TensorDimensions[R2],TensorSymmetry[R2]}In[76] := {TensorRank[R2],TensorDimensions[R2],TensorSymmetry[R2]}
Out[76] = {2,{4,4},Symmetric[{1,2}]}
Ri j k l Ri j k l +Ri j k l Rk l j i+Ri j k l Ri k j l .
In[77] := TensorReduce[In[77] := TensorReduce[In[77] := TensorReduce[
</p>
<p>TensorContract[TensorProduct[R,R],{{1,5},{2,6},{3,7},{4,8}}]+TensorContract[TensorProduct[R,R],{{1,5},{2,6},{3,7},{4,8}}]+TensorContract[TensorProduct[R,R],{{1,5},{2,6},{3,7},{4,8}}]+
TensorContract[TensorProduct[R,R],{{1,7},{2,8},{3,6},{4,5}}]+TensorContract[TensorProduct[R,R],{{1,7},{2,8},{3,6},{4,5}}]+TensorContract[TensorProduct[R,R],{{1,7},{2,8},{3,6},{4,5}}]+
TensorContract[TensorProduct[R,R],{{1,5},{2,7},{3,6},{4,8}}]]TensorContract[TensorProduct[R,R],{{1,5},{2,7},{3,6},{4,8}}]]TensorContract[TensorProduct[R,R],{{1,5},{2,7},{3,6},{4,8}}]]
</p>
<p>Out[77] = TensorContract[R&otimes;R,{{1,5},{2,7},{3,6},{4,8}}]
Unfortunately, Mathematica cannot take Ri j k l +Ri k l j+Ri l j k = 0 into account.
In[78] := $Assumptions = True;In[78] := $Assumptions = True;In[78] := $Assumptions = True;</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 12
</p>
<p>Input&ndash;Output and Strings
</p>
<p>12.1 Reading and Writing .m Files
</p>
<p>When developing any nontrivial Mathematica program, it is better to write it in a
</p>
<p>text file, using a text editor, and then to read it into a fresh Mathematica session.
</p>
<p>In this way, your actions will be reproducible. You can fix a bug and see what has
</p>
<p>changed. Suppose we have a text file called wrong.m. It contains the text
</p>
<p>In[1] := FilePrint[&rdquo;wrong.m&rdquo;]In[1] := FilePrint[&rdquo;wrong.m&rdquo;]In[1] := FilePrint[&rdquo;wrong.m&rdquo;]
a=x&and;2+2*x*y+y&and;2;
b=x&and;3+3*x&and;2*y
+3*x*y&and;2+y&and;3;
We can read it. Now the variables a and b have values:
</p>
<p>In[2] :=&lt;&lt;wrong.mIn[2] :=&lt;&lt;wrong.mIn[2] :=&lt;&lt;wrong.m
In[3] := {a,b}In[3] := {a,b}In[3] := {a,b}
Out[3] =
</p>
<p>{
</p>
<p>x2 + 2xy+ y2,x3 + 3x2y
}
</p>
<p>The value of b is not what we expected. Why? When Mathematica sees an end of a
</p>
<p>line, it checks if the text read so far forms a syntactically correct expression. If so, the
</p>
<p>expression is considered complete; the next line starts a new expression. Otherwise,
</p>
<p>the next line is considered a continuation of the current expression. Thus our file
</p>
<p>wrong.m contains not two but three expressions: two assignments (to a and b) and
</p>
<p>a separate polynomial consisting of two terms. One way to prevent such unintended
</p>
<p>splitting of multiline expressions is to place a binary operator (e.g., + or &minus;) at the
end of each line. Mathematica always writes its result in such a way. But it is easy
</p>
<p>to forget about it when writing a long expression in a text editor. Also, if we paste
</p>
<p>results from some other system into a Mathematica program, it would be tedious
</p>
<p>and error-prone to bring long expressions to such a form by hand. It is better to
</p>
<p>enclose each multiline expression in extra parentheses, then any incomplete subset
</p>
<p>of lines is not syntactically correct. Therefore we edit our wrong.m and obtain a file
</p>
<p>right.m:
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 12, &copy; Springer International Publishing Switzerland 2014
</p>
<p>99</p>
<p/>
</div>
<div class="page"><p/>
<p>100 12 Input&ndash;Output and Strings
</p>
<p>In[4] := FilePrint[&rdquo;right.m&rdquo;]In[4] := FilePrint[&rdquo;right.m&rdquo;]In[4] := FilePrint[&rdquo;right.m&rdquo;]
a=x&and;2+2*x*y+y&and;2;
b=(x&and;3+3*x&and;2*y
+3*x*y&and;2+y&and;3);
Now everything&rsquo;s all right:
</p>
<p>In[5] :=&lt;&lt;right.mIn[5] :=&lt;&lt;right.mIn[5] :=&lt;&lt;right.m
In[6] := {a,b}In[6] := {a,b}In[6] := {a,b}
Out[6] =
</p>
<p>{
</p>
<p>x2 + 2xy+ y2,x3 + 3x2y+ 3xy2 + y3
}
</p>
<p>In[7] := Clear[a,b]In[7] := Clear[a,b]In[7] := Clear[a,b]
Let us modify the file:
</p>
<p>In[8] := FilePrint[&rdquo;right2.m&rdquo;]In[8] := FilePrint[&rdquo;right2.m&rdquo;]In[8] := FilePrint[&rdquo;right2.m&rdquo;]
a=x&and;2+2*x*y+y&and;2;
(x&and;3+3*x&and;2*y
+3*x*y&and;2+y&and;3)
Now the last expression is not an assignment, but just a polynomial. What happens
</p>
<p>if we read it?
</p>
<p>In[9] :=&lt;&lt;right2.mIn[9] :=&lt;&lt;right2.mIn[9] :=&lt;&lt;right2.m
Out[9] = x3 + 3x2y+ 3xy2 + y3
</p>
<p>In[10] := aIn[10] := aIn[10] := a
Out[10] = x2 + 2xy+ y2
</p>
<p>The operator &lt;&lt; (its full name is Get) returns the value of the last expression.
Therefore, we can use it in an assignment (or as an argument of any other function):
</p>
<p>In[11] := b= &lt;&lt;right2.mIn[11] := b= &lt;&lt;right2.mIn[11] := b= &lt;&lt;right2.m
Out[11] = x3 + 3x2y+ 3xy2+ y3
</p>
<p>In[12] := {a,b}In[12] := {a,b}In[12] := {a,b}
Out[12] =
</p>
<p>{
</p>
<p>x2 + 2xy+ y2,x3 + 3x2y+ 3xy2+ y3
}
</p>
<p>In[13] := Clear[b]In[13] := Clear[b]In[13] := Clear[b]
The function Get tries to find the file in all directories in the list $Path. Its default
</p>
<p>value contains, in particular, the current directory &ldquo;.&rdquo;. You can add more directories
</p>
<p>to it using list operations, such as Append, Prepend, or Join.
</p>
<p>And this operator (its full name is Put) writes the value of an expression into a file.
</p>
<p>The value is written in the input form, and hence can be later read by Mathematica.
</p>
<p>In[14] := a&gt;&gt;result.mIn[14] := a&gt;&gt;result.mIn[14] := a&gt;&gt;result.m
In[15] := FilePrint[&rdquo;result.m&rdquo;]In[15] := FilePrint[&rdquo;result.m&rdquo;]In[15] := FilePrint[&rdquo;result.m&rdquo;]
x&and;2 + 2*x*y + y&and;2
In[16] := Clear[a]In[16] := Clear[a]In[16] := Clear[a]
In[17] := a= &lt;&lt;result.mIn[17] := a= &lt;&lt;result.mIn[17] := a= &lt;&lt;result.m
Out[17] = x2 + 2xy+ y2
</p>
<p>In[18] := aIn[18] := aIn[18] := a
Out[18] = x2 + 2xy+ y2
</p>
<p>The function &gt;&gt; writes just an expression, not an assignment to some variable.
Often it is more useful to write an assignment (or several of them) which defines
</p>
<p>some variable (or function). Suppose we have
</p>
<p>In[19] := f [0] = 1; f [n ] := n &lowast; f [n&minus; 1]In[19] := f [0] = 1; f [n ] := n &lowast; f [n&minus; 1]In[19] := f [0] = 1; f [n ] := n &lowast; f [n&minus; 1]</p>
<p/>
</div>
<div class="page"><p/>
<p>12.2 Output 101
</p>
<p>We can save the definition of the function f into a file:
</p>
<p>In[20] := Save[&rdquo;f.m&rdquo;, f ]In[20] := Save[&rdquo;f.m&rdquo;, f ]In[20] := Save[&rdquo;f.m&rdquo;, f ]
In[21] := FilePrint[&rdquo;f.m&rdquo;]In[21] := FilePrint[&rdquo;f.m&rdquo;]In[21] := FilePrint[&rdquo;f.m&rdquo;]
f[0] = 1
</p>
<p>f [n ] := n &lowast; f [n&minus; 1]
In[22] := Clear[ f ]In[22] := Clear[ f ]In[22] := Clear[ f ]
In[23] :=&lt;&lt;f.mIn[23] :=&lt;&lt;f.mIn[23] :=&lt;&lt;f.m
In[24] := f [10]In[24] := f [10]In[24] := f [10]
Out[24] = 3628800
In[25] := Clear[ f ]In[25] := Clear[ f ]In[25] := Clear[ f ]
</p>
<p>12.2 Output
</p>
<p>The function Print prints expressions (including strings, plots, etc.). It does not sep-
</p>
<p>arate them by spaces, so that it is usually a good idea to insert &rdquo; &rdquo; between expres-
</p>
<p>sions. It adds a newline at the end.
</p>
<p>In[26] := s= &rdquo;A strings\nwith a newline&rdquo;;In[26] := s= &rdquo;A strings\nwith a newline&rdquo;;In[26] := s= &rdquo;A strings\nwith a newline&rdquo;;
In[27] := p = Plot3D[a,{x,&minus;1,1},{y,&minus;1,1}];In[27] := p = Plot3D[a,{x,&minus;1,1},{y,&minus;1,1}];In[27] := p = Plot3D[a,{x,&minus;1,1},{y,&minus;1,1}];
In[28] := Print[s,&rdquo; &rdquo;,a,&rdquo; &rdquo;, p]In[28] := Print[s,&rdquo; &rdquo;,a,&rdquo; &rdquo;, p]In[28] := Print[s,&rdquo; &rdquo;,a,&rdquo; &rdquo;, p]
Out[28] = A strings
</p>
<p>with a newline x2 + 2xy+ y2
</p>
<p>&minus;1.0
</p>
<p>&minus;0.5
</p>
<p>0.0
</p>
<p>0.5
</p>
<p>1.0
&minus;1.0
</p>
<p>&minus;0.5
</p>
<p>0.0
</p>
<p>0.5
</p>
<p>1.0
</p>
<p>0
</p>
<p>1
</p>
<p>2
</p>
<p>3
</p>
<p>4
</p>
<p>In[29] := Clear[p]In[29] := Clear[p]In[29] := Clear[p]
The function Print is most useful when you want to know what happens at some
</p>
<p>point deep inside your own function when it is called. If you want to write expres-
</p>
<p>sions to a file instead, use Write:
</p>
<p>In[30] := f = OpenWrite[&rdquo;res.m&rdquo;]In[30] := f = OpenWrite[&rdquo;res.m&rdquo;]In[30] := f = OpenWrite[&rdquo;res.m&rdquo;]
Out[30] = OutputStream[res.m,19]
In[31] := Write[ f ,s]; Write[ f ,a]In[31] := Write[ f ,s]; Write[ f ,a]In[31] := Write[ f ,s]; Write[ f ,a]
In[32] := Close[ f ]In[32] := Close[ f ]In[32] := Close[ f ]
Out[32] = res.m
In[33] := FilePrint[&rdquo;res.m&rdquo;]In[33] := FilePrint[&rdquo;res.m&rdquo;]In[33] := FilePrint[&rdquo;res.m&rdquo;]</p>
<p/>
</div>
<div class="page"><p/>
<p>102 12 Input&ndash;Output and Strings
</p>
<p>A strings\nwith a newline
x&and;2 + 2*x*y + y&and;2
Expressions are written in the input form and can be read later.
</p>
<p>In[34] := Clear[s,a]In[34] := Clear[s,a]In[34] := Clear[s,a]
</p>
<p>12.3 C, Fortran, and TEX Forms
</p>
<p>Suppose you have derived analytically a valuable expression a:
</p>
<p>In[35] := a= Sin[x]&and;2/x&and;2&minus; 1In[35] := a= Sin[x]&and;2/x&and;2&minus; 1In[35] := a= Sin[x]&and;2/x&and;2&minus; 1
</p>
<p>Out[35] =&minus;1+ Sin[x]
2
</p>
<p>x2
Now you want to do some large-scale numerical calculations with it. In order to
</p>
<p>avoid possible errors when translating this expression into a form suitable to inclu-
</p>
<p>sion into a numerical program, it is a good idea to do this step automatically. The
</p>
<p>function CForm converts an expression into a form which can be inserted into a C
</p>
<p>(or C++) program.
</p>
<p>In[36] := CForm[a]In[36] := CForm[a]In[36] := CForm[a]
Out[36] = -1 + Power(Sin(x),2)/Power(x,2)
The macros Power, Sin, and friends are defined in the file mdefs.h which is supplied
</p>
<p>with Mathematica. If the expression contains special functions, you will need some
</p>
<p>extra C libraries which can calculate them numerically. Of course, it is better to
</p>
<p>write the C form of an expression into a file and then insert it into your program. For
</p>
<p>those old-fashioned enough to do numerical computations in Fortran, there is also
</p>
<p>FortranForm.
</p>
<p>In[37] := FortranForm[a]In[37] := FortranForm[a]In[37] := FortranForm[a]
Out[37] = -1 + Sin(x)**2/x**2
</p>
<p>At last, all computations are done, and you are writing an article to be submitted
</p>
<p>to a scientific journal. You want to include your valuable expression a and to avoid
</p>
<p>errors in process of doing so. Scientific articles are written in LATEX (in most cases).
</p>
<p>The function TeXForm converts an expression into a form which can be inserted
</p>
<p>into a LATEX file.
</p>
<p>In[38] := TeXForm[a]In[38] := TeXForm[a]In[38] := TeXForm[a]
Out[38] = \frac{\sin &and;2(x)}{x&and;2}-1
In[39] := Clear[a]In[39] := Clear[a]In[39] := Clear[a]
</p>
<p>12.4 Strings
</p>
<p>The simplest string operation is concatenation:
</p>
<p>In[40] := s1 = &rdquo;This&rdquo;; s2 = &rdquo;is&rdquo; ; s3 = &rdquo;a string&rdquo;;In[40] := s1 = &rdquo;This&rdquo;; s2 = &rdquo;is&rdquo; ; s3 = &rdquo;a string&rdquo;;In[40] := s1 = &rdquo;This&rdquo;; s2 = &rdquo;is&rdquo; ; s3 = &rdquo;a string&rdquo;;
In[41] := s= s1 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s2 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s3In[41] := s= s1 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s2 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s3In[41] := s= s1 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s2 &lt;&gt; &rdquo; &rdquo; &lt;&gt; s3
Out[41] = This is a string</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4 Strings 103
</p>
<p>In[42] := FullForm[s]In[42] := FullForm[s]In[42] := FullForm[s]
Out[42]//FullForm=
</p>
<p>&rdquo;This is a string&rdquo;
</p>
<p>In[43] := StringLength[s]In[43] := StringLength[s]In[43] := StringLength[s]
Out[43] = 16
In[44] := Clear[s,s1,s2,s3]In[44] := Clear[s,s1,s2,s3]In[44] := Clear[s,s1,s2,s3]
</p>
<p>Mathematica has string patterns and substitutions.
</p>
<p>In[45] := StringReplace[&rdquo;abcabd&rdquo;,&rdquo;ab&rdquo; &rarr; &rdquo;AB&rdquo;]In[45] := StringReplace[&rdquo;abcabd&rdquo;,&rdquo;ab&rdquo; &rarr; &rdquo;AB&rdquo;]In[45] := StringReplace[&rdquo;abcabd&rdquo;,&rdquo;ab&rdquo; &rarr; &rdquo;AB&rdquo;]
Out[45] = ABcABd
x means an arbitrary (single) character.
</p>
<p>In[46] := StringReplace[&rdquo;a1b a2b a3c&rdquo;,a &sim;&sim; x &sim;&sim; b &rarr; A &sim;&sim; x&sim;&sim; B]In[46] := StringReplace[&rdquo;a1b a2b a3c&rdquo;,a &sim;&sim; x &sim;&sim; b &rarr; A &sim;&sim; x&sim;&sim; B]In[46] := StringReplace[&rdquo;a1b a2b a3c&rdquo;,a &sim;&sim; x &sim;&sim; b &rarr; A &sim;&sim; x&sim;&sim; B]
Out[46] = A1B A2B a3c
In[47] := StringReplace[&rdquo;a1b2 a12b&rdquo;,In[47] := StringReplace[&rdquo;a1b2 a12b&rdquo;,In[47] := StringReplace[&rdquo;a1b2 a12b&rdquo;,
</p>
<p>a &sim;&sim; x &sim;&sim; b &sim;&sim; y &rarr; A &sim;&sim; y&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; y &rarr; A &sim;&sim; y&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; y &rarr; A &sim;&sim; y&sim;&sim; B &sim;&sim; x]
Out[47] = A2B1 a12b
Internally, these patterns are the function StringExpression.
</p>
<p>In[48] := FullForm[a &sim;&sim; x ]In[48] := FullForm[a &sim;&sim; x ]In[48] := FullForm[a &sim;&sim; x ]
Out[48]//FullForm=
</p>
<p>StringExpression[a,Pattern[x,Blank[]]]
A pattern with two identical arbitrary characters.
</p>
<p>In[49] := StringReplace[&rdquo;a1b1 a1b2 a2b2&rdquo;,In[49] := StringReplace[&rdquo;a1b1 a1b2 a2b2&rdquo;,In[49] := StringReplace[&rdquo;a1b1 a1b2 a2b2&rdquo;,
a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; x&sim;&sim; B]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; x&sim;&sim; B]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; x&sim;&sim; B]
</p>
<p>Out[49] = A11B a1b2 A22B
b|c means b or c.
</p>
<p>In[50] := StringReplace[&rdquo;abcd abcd&rdquo;,b|c &rarr; X]In[50] := StringReplace[&rdquo;abcd abcd&rdquo;,b|c &rarr; X]In[50] := StringReplace[&rdquo;abcd abcd&rdquo;,b|c &rarr; X]
Out[50] = aXXd aXXd
</p>
<p>x means any nonempty sequence of characters.
</p>
<p>In[51] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]In[51] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]In[51] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]
Out[51] = ab
In[52] := StringReplace[&rdquo;a12b12&rdquo;,In[52] := StringReplace[&rdquo;a12b12&rdquo;,In[52] := StringReplace[&rdquo;a12b12&rdquo;,
</p>
<p>a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]
Out[52] = A12B12
x means any sequence of characters (including empty).
</p>
<p>In[53] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]In[53] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]In[53] := StringReplace[&rdquo;ab&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]
Out[53] = AB
In[54] := StringReplace[&rdquo;a12b12&rdquo;,In[54] := StringReplace[&rdquo;a12b12&rdquo;,In[54] := StringReplace[&rdquo;a12b12&rdquo;,
</p>
<p>a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]a &sim;&sim; x &sim;&sim; b &sim;&sim; x &rarr; A &sim;&sim; x&sim;&sim; B &sim;&sim; x]
Out[54] = A12B12
As in the case of general patterns, /; means a condition (such that).
</p>
<p>In[55] := StringReplace[&rdquo;a1b1 a1b2&rdquo;,In[55] := StringReplace[&rdquo;a1b1 a1b2&rdquo;,In[55] := StringReplace[&rdquo;a1b1 a1b2&rdquo;,
a &sim;&sim; x &sim;&sim; b &sim;&sim; y /;x!=y&rarr; A &sim;&sim; x&sim;&sim; y&sim;&sim; B]a &sim;&sim; x &sim;&sim; b &sim;&sim; y /;x!=y&rarr; A &sim;&sim; x&sim;&sim; y&sim;&sim; B]a &sim;&sim; x &sim;&sim; b &sim;&sim; y /;x!=y&rarr; A &sim;&sim; x&sim;&sim; y&sim;&sim; B]
</p>
<p>Out[55] = a1b1 A12B
The function StringMatchQ tests if a string matches a pattern.</p>
<p/>
</div>
<div class="page"><p/>
<p>104 12 Input&ndash;Output and Strings
</p>
<p>In[56] := {StringMatchQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],In[56] := {StringMatchQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],In[56] := {StringMatchQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],
StringMatchQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],StringMatchQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],StringMatchQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],
StringMatchQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}StringMatchQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}StringMatchQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}
</p>
<p>Out[56] = {True,False,False}
The function StringFreeQ tests if there are no substrings matching a pattern.
</p>
<p>In[57] := {StringFreeQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],In[57] := {StringFreeQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],In[57] := {StringFreeQ[&rdquo;a1b1&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],
StringFreeQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],StringFreeQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],StringFreeQ[&rdquo;a1b2&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ],
StringFreeQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}StringFreeQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}StringFreeQ[&rdquo;a1b1c&rdquo;,a &sim;&sim; x &sim;&sim; b &sim;&sim; x ]}
</p>
<p>Out[57] = {False,True,False}
The function StringSplit splits a string at each occurrence of a pattern; if the
</p>
<p>second argument is not given, then at each white space.
</p>
<p>In[58] := StringSplit[&rdquo;xxa1byya2bzz&rdquo;,a &sim;&sim; x &sim;&sim; b]In[58] := StringSplit[&rdquo;xxa1byya2bzz&rdquo;,a &sim;&sim; x &sim;&sim; b]In[58] := StringSplit[&rdquo;xxa1byya2bzz&rdquo;,a &sim;&sim; x &sim;&sim; b]
Out[58] = {xx,yy,zz}
In[59] := StringSplit[&rdquo;xx yy zz\nuu\tvv\t\t ww&rdquo;]In[59] := StringSplit[&rdquo;xx yy zz\nuu\tvv\t\t ww&rdquo;]In[59] := StringSplit[&rdquo;xx yy zz\nuu\tvv\t\t ww&rdquo;]
Out[59] = {xx,yy,zz,uu,vv,ww}
</p>
<p>Mathematica contains many more string manipulation functions and additional
</p>
<p>powerful features of string patterns and can be used for text processing instead of
</p>
<p>Perl. For more details, see the online help.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 13
</p>
<p>Packages
</p>
<p>13.1 Contexts
</p>
<p>When writing a large program, it is easy to accidentally use one symbol for two
</p>
<p>different quantities in different parts of the program. This leads to difficult-to-find
</p>
<p>bugs. This is especially true if parts of the program are written by different per-
</p>
<p>sons (in particular, when some packages from the standard library, or third-party
</p>
<p>packages, are used). To avoid such problems, contexts are used.
</p>
<p>In Mathematica, a full symbol name consists of two parts: the context and the
</p>
<p>short name. Two symbols in different contexts may have the same short name. For
</p>
<p>example, the global symbol x and the symbol x in the contexts a and b are unrelated.
</p>
<p>In[1] := x= 1; a`x= 2; {x,a`x,b`x}In[1] := x= 1; a`x= 2; {x,a`x,b`x}In[1] := x= 1; a`x= 2; {x,a`x,b`x}
Out[1] = {1,2,b x̀}
Contexts may be nested. Here the variable x lives in the context b which lives in the
</p>
<p>context a (and thus is unrelated to the global context b used above).
</p>
<p>In[2] := a`b`xIn[2] := a`b`xIn[2] := a`b`x
Out[2] = a`b`x
</p>
<p>The current default context is held in the variable $Context. It is used when a
</p>
<p>new symbol is created without specifying its context.
</p>
<p>In[3] := $ContextIn[3] := $ContextIn[3] := $Context
Out[3] = Global̀
When a symbol without an explicit context is used, it is being searched in contexts
</p>
<p>specified in $ContextPath.
</p>
<p>In[4] := $ContextPathIn[4] := $ContextPathIn[4] := $ContextPath
Out[4] = {PacletManager̀ ,QuantityUnits̀ ,WebServices̀ ,System ,̀Global̀ }
Built-in symbols live in the context System .̀
</p>
<p>In[5] := {Context[x],Context[a`x],Context[b`x],Context[a`b`x],Context[Pi]}In[5] := {Context[x],Context[a`x],Context[b`x],Context[a`b`x],Context[Pi]}In[5] := {Context[x],Context[a`x],Context[b`x],Context[a`b`x],Context[Pi]}
Out[5] = {Global̀ ,a ,̀b ,̀a`b ,̀System`}
You can change $ContextPath using standard list functions. The function Remove
</p>
<p>removes symbols from the system.
</p>
<p>In[6] := Clear[x,a`x]; Remove[a`x,b`x,a`b`x]In[6] := Clear[x,a`x]; Remove[a`x,b`x,a`b`x]In[6] := Clear[x,a`x]; Remove[a`x,b`x,a`b`x]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 13, &copy; Springer International Publishing Switzerland 2014
</p>
<p>105</p>
<p/>
</div>
<div class="page"><p/>
<p>106 13 Packages
</p>
<p>13.2 Packages
</p>
<p>Mathematica comes with a library of packages extending its built-in functionality.
</p>
<p>A package can be loaded by
</p>
<p>In[7] :=&lt;&lt;Quaternions̀In[7] :=&lt;&lt;Quaternions̀In[7] :=&lt;&lt;Quaternions̀
Now this context is prepended to $ContextPath.
</p>
<p>In[8] := $ContextPathIn[8] := $ContextPathIn[8] := $ContextPath
Out[8] = {Quaternions̀ ,PacletManager̀ ,QuantityUnits̀ ,WebServices̀ ,
</p>
<p>System ,̀Global̀ }
Short names will be searched in this context first, possibly shadowing variables and
</p>
<p>functions from Global̀ .
</p>
<p>In[9] := Context[Quaternion]In[9] := Context[Quaternion]In[9] := Context[Quaternion]
Out[9] = Quaternions̀
The package Quaternions lives in the directory Quaternions, which lives in the stan-
</p>
<p>dard library directory.
</p>
<p>Many additional packages are available at
</p>
<p>http://library.wolfram.com/infocenter/MathSource/.You can download them and in-
</p>
<p>stall somewhere in your $Path.
</p>
<p>You can instruct Mathematica to load a package whenever any function defined
</p>
<p>in it is used.
</p>
<p>In[10] := DeclarePackage[&rdquo;NumericalCalculus̀ &rdquo;,In[10] := DeclarePackage[&rdquo;NumericalCalculus̀ &rdquo;,In[10] := DeclarePackage[&rdquo;NumericalCalculus̀ &rdquo;,
{&rdquo;EulerSum&rdquo;,&rdquo;NLimit&rdquo;,&rdquo;ND&rdquo;,&rdquo;NSeries&rdquo;,&rdquo;NResidue&rdquo;}]{&rdquo;EulerSum&rdquo;,&rdquo;NLimit&rdquo;,&rdquo;ND&rdquo;,&rdquo;NSeries&rdquo;,&rdquo;NResidue&rdquo;}]{&rdquo;EulerSum&rdquo;,&rdquo;NLimit&rdquo;,&rdquo;ND&rdquo;,&rdquo;NSeries&rdquo;,&rdquo;NResidue&rdquo;}]
</p>
<p>Out[10] = NumericalCalculus̀
In[11] := ND[x&and;2,x,1.0]In[11] := ND[x&and;2,x,1.0]In[11] := ND[x&and;2,x,1.0]
Out[11] = 2.
</p>
<p>13.3 Writing Your Own Package
</p>
<p>Begin, End
</p>
<p>Begin[&rdquo;a`&rdquo;] changes the default $Context; all symbols defined after this will live in
this context.
</p>
<p>In[12] := Begin[&rdquo;a`&rdquo;]In[12] := Begin[&rdquo;a`&rdquo;]In[12] := Begin[&rdquo;a`&rdquo;]
Out[12] = a`
In[13] := $ContextIn[13] := $ContextIn[13] := $Context
Out[13] = a`
In[14] := z= 0; Context[z]In[14] := z= 0; Context[z]In[14] := z= 0; Context[z]
Out[14] = a`
End[] restores the previous $Context.
In[15] := End[]In[15] := End[]In[15] := End[]
Out[15] = a`</p>
<p/>
<div class="annotation"><a href="http://library.wolfram.com/infocenter/MathSource/">http://library.wolfram.com/infocenter/MathSource/</a></div>
</div>
<div class="page"><p/>
<p>13.3 Writing Your Own Package 107
</p>
<p>In[16] := $ContextIn[16] := $ContextIn[16] := $Context
Out[16] = Global̀
In[17] := a`zIn[17] := a`zIn[17] := a`z
Out[17] = 0
</p>
<p>BeginPackage, EndPackage
</p>
<p>BeginPackage[&rdquo;a`&rdquo;] sets $Context and changes $ContextPath in such a way that only
the contexts a` and System` are available.
</p>
<p>In[18] := BeginPackage[&rdquo;a`&rdquo;]In[18] := BeginPackage[&rdquo;a`&rdquo;]In[18] := BeginPackage[&rdquo;a`&rdquo;]
Out[18] = a`
In[19] := $ContextIn[19] := $ContextIn[19] := $Context
Out[19] = a`
In[20] := $ContextPathIn[20] := $ContextPathIn[20] := $ContextPath
Out[20] = {a ,̀System`}
In[21] := u= 1;In[21] := u= 1;In[21] := u= 1;
</p>
<p>EndPackage[] restores the previous $Context; ContextPath gets its old value
prepended by a ,̀ so that symbols defined after BeginPackage[a ]̀ remain available.
In[22] := EndPackage[]In[22] := EndPackage[]In[22] := EndPackage[]
In[23] := $ContextIn[23] := $ContextIn[23] := $Context
Out[23] = Global̀
In[24] := $ContextPathIn[24] := $ContextPathIn[24] := $ContextPath
Out[24] = {a ,̀NumericalCalculus̀ ,Quaternions̀ ,PacletManager̀ ,
</p>
<p>QuantityUnits̀ ,WebServices̀ ,System ,̀Global̀ }
In[25] := uIn[25] := uIn[25] := u
Out[25] = 1
In[26] := Clear[z,u]In[26] := Clear[z,u]In[26] := Clear[z,u]
</p>
<p>A Typical Package
</p>
<p>A simple package looks like this.
</p>
<p>In[27] := FilePrint[&rdquo;APackage.m&rdquo;]In[27] := FilePrint[&rdquo;APackage.m&rdquo;]In[27] := FilePrint[&rdquo;APackage.m&rdquo;]
BeginPackage[&rdquo;APackagè &rdquo;]
f::usage = &rdquo;f squares its argument&rdquo;
Begin[&rdquo;`Private`&rdquo;]
g[x ] := x&and;2
f [x ] := Expand[g[x]]
End[]
EndPackage[]
After BeginPackage[&rdquo;APackagè &rdquo;], publicly available functions and variables of
the package are introduced, usually by assignments to their usage messages.</p>
<p/>
</div>
<div class="page"><p/>
<p>108 13 Packages
</p>
<p>Implementation of the package is done in the context APackagè Private ,̀ which
</p>
<p>may contain additional functions and variables (not seen by users of the package).
</p>
<p>In[28] :=&lt;&lt;APackagèIn[28] :=&lt;&lt;APackagèIn[28] :=&lt;&lt;APackagè
In[29] :=? fIn[29] :=? fIn[29] :=? f
Out[29] = f squares its argument
In[30] := f [a+ b]In[30] := f [a+ b]In[30] := f [a+ b]
Out[30] = a2 + 2ab+ b2</p>
<p/>
</div>
<div class="page"><p/>
<p>Part II
</p>
<p>Computer Classes
</p>
<p>Before spending your time and effort on catching a lion, check: maybe, somebody
</p>
<p>has already caught it, and it is available for download at http:// library.wolfram.
</p>
<p>com/ infocenter/MathSource/</p>
<p/>
<div class="annotation"><a href="http://library.wolfram.com/infocenter/MathSource/">http://library.wolfram.com/infocenter/MathSource/</a></div>
<div class="annotation"><a href="http://library.wolfram.com/infocenter/MathSource/">http://library.wolfram.com/infocenter/MathSource/</a></div>
</div>
<div class="page"><p/>
<p>Chapter 14
</p>
<p>Plots
</p>
<p>After typing a Mathematica command in its notebook interface, you can send it to
</p>
<p>the kernel (which performs calculations) by pressing Shift-Enter. The result appears
</p>
<p>in the output cell which follows your input cell. Both are nested in an outer cell
</p>
<p>representing a calculation step. Later you can return to this input cell, edit the com-
</p>
<p>mand, and execute it again. The old output will be replaced by the new result. It is
</p>
<p>allowed to type several commands in a single input cell, but this is not convenient&mdash;
</p>
<p>don&rsquo;t do so unless you have good reasons.
</p>
<p>Mathematica Help contains all the necessary information. The Help menu con-
</p>
<p>tains Documentation Center, Function Navigator, and Virtual Book (among other
</p>
<p>things). You can quickly get help for a specific function if you select it with the
</p>
<p>mouse and press F1.
</p>
<p>14.1 2D Plots
</p>
<p>Function Plot
</p>
<p>See Help &rarr; Virtual Book &rarr; Visualization and Graphics &rarr; Graphics and Sound &rarr;
Basic Plotting, and Help &rarr; Function Navigator &rarr; Visualization and Graphics &rarr;
Function Visualization &rarr; Plot for more details.
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 14, &copy; Springer International Publishing Switzerland 2014
</p>
<p>111</p>
<p/>
</div>
<div class="page"><p/>
<p>112 14 Plots
</p>
<p>In[1] := Plot[Sin[x],{x,&minus;10,10}]In[1] := Plot[Sin[x],{x,&minus;10,10}]In[1] := Plot[Sin[x],{x,&minus;10,10}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[1] =
</p>
<p>Several Functions
</p>
<p>In[2] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10}]In[2] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10}]In[2] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[2] =
</p>
<p>You can set colors and styles of the curves (Virtual Book &rarr; Visualization and
Graphics &rarr; Graphics and Sound &rarr; Options for Graphics; Function Navigator &rarr;
Visualization and Graphics &rarr; Options and Styling &rarr; Plotting Options &rarr; Plot-
Style).</p>
<p/>
</div>
<div class="page"><p/>
<p>14.1 2D Plots 113
</p>
<p>In[3] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10},PlotStyle&minus;&gt;{Red,{Blue,Dashed}}]In[3] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10},PlotStyle&minus;&gt;{Red,{Blue,Dashed}}]In[3] := Plot[{Sin[x],Cos[x]},{x,&minus;10,10},PlotStyle&minus;&gt;{Red,{Blue,Dashed}}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[3] =
</p>
<p>Unbounded Function
</p>
<p>In[4] := Plot[Tan[x],{x,&minus;10,10}]In[4] := Plot[Tan[x],{x,&minus;10,10}]In[4] := Plot[Tan[x],{x,&minus;10,10}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[4] =
</p>
<p>Mathematica has chosen some y scale. How to set it? Find in the Help.</p>
<p/>
</div>
<div class="page"><p/>
<p>114 14 Plots
</p>
<p>In[5] := Plot[Tan[x],{x,&minus;10,10},PlotRange&minus;&gt;{&minus;3,3}]In[5] := Plot[Tan[x],{x,&minus;10,10},PlotRange&minus;&gt;{&minus;3,3}]In[5] := Plot[Tan[x],{x,&minus;10,10},PlotRange&minus;&gt;{&minus;3,3}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[5] =
</p>
<p>Logarithmic Scale
</p>
<p>If our function is positive and varies by orders of magnitude in our region, it is
</p>
<p>convenient to use logarithmic scale in y. If the independent variable also varies by
</p>
<p>orders of magnitude, the x-axis scale also should be logarithmic (Function Navigator
</p>
<p>&rarr; Visualization and Graphics &rarr; Function Visualization &rarr; LogPlot, LogLogPlot).
In[6] := LogPlot[Exp[x]+ 1,{x,&minus;10,10}]In[6] := LogPlot[Exp[x]+ 1,{x,&minus;10,10}]In[6] := LogPlot[Exp[x]+ 1,{x,&minus;10,10}]
</p>
<p>&minus;
</p>
<p>Out[6] =</p>
<p/>
</div>
<div class="page"><p/>
<p>14.1 2D Plots 115
</p>
<p>In[7] := LogLogPlot[x&and;3+ 2 &lowast; x,{x,10&and;&minus; 2,10&and;2}]In[7] := LogLogPlot[x&and;3+ 2 &lowast; x,{x,10&and;&minus; 2,10&and;2}]In[7] := LogLogPlot[x&and;3+ 2 &lowast; x,{x,10&and;&minus; 2,10&and;2}]
</p>
<p>Out[7] =
</p>
<p>Parametric Curve
</p>
<p>Lissajous figures.
</p>
<p>In[8] := Manipulate[ParametricPlot[{Sin[a &lowast; t+ c],Sin[b &lowast; t]},{t,0,2 &lowast;Pi}],In[8] := Manipulate[ParametricPlot[{Sin[a &lowast; t+ c],Sin[b &lowast; t]},{t,0,2 &lowast;Pi}],In[8] := Manipulate[ParametricPlot[{Sin[a &lowast; t+ c],Sin[b &lowast; t]},{t,0,2 &lowast;Pi}],
{a,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},{a,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},{a,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},
{b,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},{{c,Pi/2},0,Pi/2}]{b,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},{{c,Pi/2},0,Pi/2}]{b,1,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;},{{c,Pi/2},0,Pi/2}]
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>a
</p>
<p>b
</p>
<p>c
</p>
<p>2
</p>
<p>3
</p>
<p>Out[8] =</p>
<p/>
</div>
<div class="page"><p/>
<p>116 14 Plots
</p>
<p>Implicit Plots
</p>
<p>In[9] := ContourPlot[x&and;2+ y&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1}]In[9] := ContourPlot[x&and;2+ y&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1}]In[9] := ContourPlot[x&and;2+ y&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>Out[9] =
</p>
<p>In[10] := ContourPlot[x&lowast; y,{x,&minus;4,4},{y,&minus;4,4},Contours&minus;&gt;{1,2,3,4}]In[10] := ContourPlot[x&lowast; y,{x,&minus;4,4},{y,&minus;4,4},Contours&minus;&gt;{1,2,3,4}]In[10] := ContourPlot[x&lowast; y,{x,&minus;4,4},{y,&minus;4,4},Contours&minus;&gt;{1,2,3,4}]
</p>
<p>&minus;&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[10] =</p>
<p/>
</div>
<div class="page"><p/>
<p>14.1 2D Plots 117
</p>
<p>Experimental Points
</p>
<p>In real life they are being read from a file. We don&rsquo;t have such a file at hand, and
</p>
<p>therefore we&rsquo;ll generate a list of &ldquo;experimental&rdquo; points according to some formulas.
</p>
<p>In[11] := l = Table[N[Sin[Pi&lowast; n/20]],{n,0,20}]In[11] := l = Table[N[Sin[Pi&lowast; n/20]],{n,0,20}]In[11] := l = Table[N[Sin[Pi&lowast; n/20]],{n,0,20}]
Out[11] = {0.,0.156434,0.309017,0.45399,0.587785,0.707107,0.809017,
</p>
<p>0.891007,0.951057,0.987688,1.,0.987688,0.951057,0.891007,0.809017,
0.707107,0.587785,0.45399,0.309017,0.156434,0.}
</p>
<p>Function Navigator &rarr; Visualization and Graphics &rarr; Data Visualization &rarr; List-
Plot.
</p>
<p>In[12] := p1 = ListPlot[l]In[12] := p1 = ListPlot[l]In[12] := p1 = ListPlot[l]
</p>
<p>Out[12] =
</p>
<p>Let&rsquo;s try to fit these points by a quadratic polynomial.
</p>
<p>In[13] := f = Fit[l,{1,x,x&and;2},x]In[13] := f = Fit[l,{1,x,x&and;2},x]In[13] := f = Fit[l,{1,x,x&and;2},x]
Out[13] =&minus;0.24953+ 0.222936x&minus;0.0101334x2
In[14] := p2 = Plot[ f ,{x,1,21}]In[14] := p2 = Plot[ f ,{x,1,21}]In[14] := p2 = Plot[ f ,{x,1,21}]
</p>
<p>Out[14] =
</p>
<p>And now the curve and the points on a single plot (Function Navigator &rarr; Visualiza-
tion and Graphics &rarr; Data Visualization &rarr; Annotation &amp; Combination &rarr; Show).</p>
<p/>
</div>
<div class="page"><p/>
<p>118 14 Plots
</p>
<p>In[15] := Show[p1,p2]In[15] := Show[p1,p2]In[15] := Show[p1,p2]
</p>
<p>Out[15] =
</p>
<p>In[16] := Clear[l, f ,p1,p2]In[16] := Clear[l, f ,p1,p2]In[16] := Clear[l, f ,p1,p2]
</p>
<p>Inequalities
</p>
<p>Function Navigator &rarr; Visualization and Graphics &rarr; Function Visualization &rarr;
RegionPlot.
</p>
<p>In[17] := RegionPlot[x&and;2+ y&and;2 &lt; 1&amp;&amp;x+ y&gt; 0,{x,&minus;1,1},{y,&minus;1,1}]In[17] := RegionPlot[x&and;2+ y&and;2 &lt; 1&amp;&amp;x+ y&gt; 0,{x,&minus;1,1},{y,&minus;1,1}]In[17] := RegionPlot[x&and;2+ y&and;2 &lt; 1&amp;&amp;x+ y&gt; 0,{x,&minus;1,1},{y,&minus;1,1}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>Out[17] =</p>
<p/>
</div>
<div class="page"><p/>
<p>14.1 2D Plots 119
</p>
<p>Vector Fields
</p>
<p>In[18] := VectorPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5&lowast; y},{x,&minus;1,1},{y,&minus;1,1}]In[18] := VectorPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5 &lowast; y},{x,&minus;1,1},{y,&minus;1,1}]In[18] := VectorPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5&lowast; y},{x,&minus;1,1},{y,&minus;1,1}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>Out[18] =
</p>
<p>In[19] := StreamPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5&lowast; y},{x,&minus;1,1},{y,&minus;1,1}]In[19] := StreamPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5&lowast; y},{x,&minus;1,1},{y,&minus;1,1}]In[19] := StreamPlot[{y+ 0.5 &lowast; x,&minus;x+ 0.5&lowast; y},{x,&minus;1,1},{y,&minus;1,1}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>Out[19] =</p>
<p/>
</div>
<div class="page"><p/>
<p>120 14 Plots
</p>
<p>14.2 3D Plots
</p>
<p>Hat
</p>
<p>Let&rsquo;s draw a hat with a wavy pent. First define a function.
</p>
<p>In[20] := f [x ,y ] := With[{r = Sqrt[x&and;2+ y&and;2]},Sin[r]/r]In[20] := f [x ,y ] := With[{r = Sqrt[x&and;2+ y&and;2]},Sin[r]/r]In[20] := f [x ,y ] := With[{r = Sqrt[x&and;2+ y&and;2]},Sin[r]/r]
Virtual Book &rarr; Visualization and Graphics &rarr; Three-Dimensional Surface Plots;
Function Navigator &rarr; Visualization and Graphics &rarr; Function Visualization &rarr;
Plot3D.
</p>
<p>In[21] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10}]In[21] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10}]In[21] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10}]
</p>
<p>Out[21] =
</p>
<p>And why is the top of the hat cut off?
</p>
<p>In[22] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10},PlotRange&minus;&gt;All]In[22] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10},PlotRange&minus;&gt;All]In[22] := Plot3D[ f [x,y],{x,&minus;10,10},{y,&minus;10,10},PlotRange&minus;&gt;All]
</p>
<p>Out[22] =</p>
<p/>
</div>
<div class="page"><p/>
<p>14.2 3D Plots 121
</p>
<p>All 3D plots can be rotated by the mouse. If you press Shift, the mouse will move
</p>
<p>the plot; and if you press Ctrl, then it will resize it.
</p>
<p>In[23] := Clear[ f ]In[23] := Clear[ f ]In[23] := Clear[ f ]
</p>
<p>Sphere
</p>
<p>In[24] := ParametricPlot3D[{Sin[θ ]&lowast;Cos[φ ],Sin[θ ]&lowast;Sin[φ ],Cos[θ ]},In[24] := ParametricPlot3D[{Sin[θ ]&lowast;Cos[φ ],Sin[θ ]&lowast;Sin[φ ],Cos[θ ]},In[24] := ParametricPlot3D[{Sin[θ ]&lowast;Cos[φ ],Sin[θ ]&lowast;Sin[φ ],Cos[θ ]},
{θ ,0,Pi},{φ ,0,2 &lowast;Pi}]{θ ,0,Pi},{φ ,0,2 &lowast;Pi}]{θ ,0,Pi},{φ ,0,2 &lowast;Pi}]
</p>
<p>Out[24] =
</p>
<p>Donut
</p>
<p>Take a point on the x-axis at a distance R from the origin; draw a circle of a radius r
</p>
<p>around it in the x, z plane; and rotate it around the z axis. You will get a donut (torus).
</p>
<p>Let R be 1; r can be tuned by the mouse from 0 to 1, with the initial value 0.3.
</p>
<p>In[25] := R= 1;In[25] := R= 1;In[25] := R= 1;
In[26] := Manipulate[In[26] := Manipulate[In[26] := Manipulate[
</p>
<p>ParametricPlot3D[ParametricPlot3D[ParametricPlot3D[
{(R+ r &lowast;Cos[θ ])&lowast;Cos[φ ],(R+ r &lowast;Cos[θ ])&lowast;Sin[φ ],r &lowast;Sin[θ ]},{(R+ r &lowast;Cos[θ ])&lowast;Cos[φ ],(R+ r &lowast;Cos[θ ])&lowast;Sin[φ ],r &lowast;Sin[θ ]},{(R+ r &lowast;Cos[θ ])&lowast;Cos[φ ],(R+ r &lowast;Cos[θ ])&lowast;Sin[φ ],r &lowast;Sin[θ ]},
{θ ,0,2 &lowast;Pi},{φ ,0,2 &lowast;Pi}],{θ ,0,2 &lowast;Pi},{φ ,0,2 &lowast;Pi}],{θ ,0,2 &lowast;Pi},{φ ,0,2 &lowast;Pi}],
</p>
<p>{{r,0.3},0,1}]{{r,0.3},0,1}]{{r,0.3},0,1}]</p>
<p/>
</div>
<div class="page"><p/>
<p>122 14 Plots
</p>
<p>Out[26] =
</p>
<p>In[27] := Clear[R]In[27] := Clear[R]In[27] := Clear[R]
</p>
<p>Spiral
</p>
<p>ParametricPlot3D can draw curves, too.
</p>
<p>In[28] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},In[28] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},In[28] := Manipulate[ParametricPlot3D[{Cos[t],Sin[t],a &lowast; t},{t,0,20},
PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],PlotRange&minus;&gt;{{&minus;1,1},{&minus;1,1},{0,2}}],
</p>
<p>{{a,0.1},0,0.2}]{{a,0.1},0,0.2}]{{a,0.1},0,0.2}]
</p>
<p>Out[28] =</p>
<p/>
</div>
<div class="page"><p/>
<p>14.2 3D Plots 123
</p>
<p>Implicit Surface
</p>
<p>In[29] := ContourPlot3D[x&and;2+ y&and;2+ z&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1}]In[29] := ContourPlot3D[x&and;2+ y&and;2+ z&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1}]In[29] := ContourPlot3D[x&and;2+ y&and;2+ z&and;2 == 1,{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1}]
</p>
<p>Out[29] =
</p>
<p>Inequalities
</p>
<p>In[30] := RegionPlot3D[x&and;2+ y&and;2+ z&and;2 &lt; 1&amp;&amp;x+ y+ z&gt; 0,In[30] := RegionPlot3D[x&and;2+ y&and;2+ z&and;2 &lt; 1&amp;&amp;x+ y+ z&gt; 0,In[30] := RegionPlot3D[x&and;2+ y&and;2+ z&and;2 &lt; 1&amp;&amp;x+ y+ z&gt; 0,
{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1},{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1},{x,&minus;1,1},{y,&minus;1,1},{z,&minus;1,1},
ViewPoint&minus;&gt;{&minus;2,&minus;10,2},PlotPoints&minus;&gt;100]ViewPoint&minus;&gt;{&minus;2,&minus;10,2},PlotPoints&minus;&gt;100]ViewPoint&minus;&gt;{&minus;2,&minus;10,2},PlotPoints&minus;&gt;100]
</p>
<p>Out[30] =</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 15
</p>
<p>Trigonometric Functions
</p>
<p>Statement of the Problem
</p>
<p>Mathematica can calculate Cos and Sin for many arguments equal to π times ratio-
nal numbers. For example,
</p>
<p>In[1] := Table[Cos[Pi/n],{n,1,12}]In[1] := Table[Cos[Pi/n],{n,1,12}]In[1] := Table[Cos[Pi/n],{n,1,12}]
</p>
<p>Out[1] =
</p>
<p>{
</p>
<p>&minus;1,0, 1
2
,
</p>
<p>1&radic;
2
,
</p>
<p>1
</p>
<p>4
</p>
<p>(
</p>
<p>1+
&radic;
</p>
<p>5
)
</p>
<p>,
</p>
<p>&radic;
3
</p>
<p>2
,Cos
</p>
<p>[π
7
</p>
<p>]
</p>
<p>,Cos
[π
</p>
<p>8
</p>
<p>]
</p>
<p>,Cos
[π
</p>
<p>9
</p>
<p>]
</p>
<p>,
&radic;
</p>
<p>5
</p>
<p>8
+
</p>
<p>&radic;
5
</p>
<p>8
,Cos
</p>
<p>[ π
11
</p>
<p>]
</p>
<p>,
1+
</p>
<p>&radic;
3
</p>
<p>2
&radic;
</p>
<p>2
</p>
<p>}
</p>
<p>But it does not apply the half-angle formulas in all possible cases. We&rsquo;ll write
</p>
<p>our own cos function which does this; then
</p>
<p>In[2] := sin[x ] := cos[x&minus;Pi/2]In[2] := sin[x ] := cos[x&minus;Pi/2]In[2] := sin[x ] := cos[x&minus;Pi/2]
</p>
<p>Simple Cases
</p>
<p>These cases should be considered separately because Mathematica does not treat
</p>
<p>them as rational numbers times π .
In[3] := cos[0] = 1; cos[Pi] =&minus;1;In[3] := cos[0] = 1; cos[Pi] =&minus;1;In[3] := cos[0] = 1; cos[Pi] =&minus;1;
In[4] := cos[n Integer&lowast;Pi] := (&minus;1)&and;nIn[4] := cos[n Integer&lowast;Pi] := (&minus;1)&and;nIn[4] := cos[n Integer&lowast;Pi] := (&minus;1)&and;n
</p>
<p>General Case
</p>
<p>In[5] := cos[r Rational&lowast;Pi] := Which[r &lt; 0,cos[&minus;r &lowast;Pi],In[5] := cos[r Rational&lowast;Pi] := Which[r &lt; 0,cos[&minus;r &lowast;Pi],In[5] := cos[r Rational&lowast;Pi] := Which[r &lt; 0,cos[&minus;r &lowast;Pi],
r &gt; 2,cos[FractionalPart[r/2]&lowast; 2 &lowast;Pi],r &gt; 1,cos[(2&minus; r)&lowast;Pi],r &gt; 2,cos[FractionalPart[r/2]&lowast; 2 &lowast;Pi],r &gt; 1,cos[(2&minus; r)&lowast;Pi],r &gt; 2,cos[FractionalPart[r/2]&lowast; 2 &lowast;Pi],r &gt; 1,cos[(2&minus; r)&lowast;Pi],
r &gt; 1/2,&minus;cos[(1&minus; r)&lowast;Pi],r &gt; 1/2,&minus;cos[(1&minus; r)&lowast;Pi],r &gt; 1/2,&minus;cos[(1&minus; r)&lowast;Pi],
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 15, &copy; Springer International Publishing Switzerland 2014
</p>
<p>125</p>
<p/>
</div>
<div class="page"><p/>
<p>126 15 Trigonometric Functions
</p>
<p>EvenQ[Denominator[r]],Simplify[Sqrt[(1+ cos[2 &lowast; r &lowast;Pi])/2]],EvenQ[Denominator[r]],Simplify[Sqrt[(1+ cos[2 &lowast; r &lowast;Pi])/2]],EvenQ[Denominator[r]],Simplify[Sqrt[(1+ cos[2 &lowast; r &lowast;Pi])/2]],
True,Cos[r &lowast;Pi]]True,Cos[r &lowast;Pi]]True,Cos[r &lowast;Pi]]
</p>
<p>For example,
</p>
<p>In[6] := {cos[Pi/32],cos[&minus;65 &lowast;Pi/32],cos[3 &lowast;Pi/32],cos[33 &lowast;Pi/32]}In[6] := {cos[Pi/32],cos[&minus;65 &lowast;Pi/32],cos[3 &lowast;Pi/32],cos[33 &lowast;Pi/32]}In[6] := {cos[Pi/32],cos[&minus;65 &lowast;Pi/32],cos[3 &lowast;Pi/32],cos[33 &lowast;Pi/32]}
</p>
<p>Out[6] =
</p>
<p>⎧
</p>
<p>⎪
</p>
<p>⎨
</p>
<p>⎪
</p>
<p>⎩
</p>
<p>1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
&radic;
</p>
<p>2,
1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
&radic;
</p>
<p>2,
</p>
<p>1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2&minus;
&radic;
</p>
<p>2,&minus;1
2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
&radic;
</p>
<p>2
</p>
<p>⎫
</p>
<p>⎪
</p>
<p>⎬
</p>
<p>⎪
</p>
<p>⎭
</p>
<p>In[7] := {cos[Pi/48],cos[5 &lowast;Pi/48],cos[7 &lowast;Pi/48]}In[7] := {cos[Pi/48],cos[5 &lowast;Pi/48],cos[7 &lowast;Pi/48]}In[7] := {cos[Pi/48],cos[5 &lowast;Pi/48],cos[7 &lowast;Pi/48]}
</p>
<p>Out[7] =
</p>
<p>⎧
</p>
<p>⎪
</p>
<p>⎨
</p>
<p>⎪
</p>
<p>⎩
</p>
<p>1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
&radic;
</p>
<p>3,
1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2&minus;
&radic;
</p>
<p>3,
</p>
<p>1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2&minus;
&radic;
</p>
<p>2&minus;
&radic;
</p>
<p>3
</p>
<p>⎫
</p>
<p>⎪
</p>
<p>⎬
</p>
<p>⎪
</p>
<p>⎭
</p>
<p>In[8] := {cos[Pi/40],cos[3 &lowast;Pi/40]}In[8] := {cos[Pi/40],cos[3 &lowast;Pi/40]}In[8] := {cos[Pi/40],cos[3 &lowast;Pi/40]}
</p>
<p>Out[8] =
</p>
<p>⎧
</p>
<p>⎪
</p>
<p>⎨
</p>
<p>⎪
</p>
<p>⎩
</p>
<p>1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>1
</p>
<p>2
</p>
<p>(
</p>
<p>5+
&radic;
</p>
<p>5
)
</p>
<p>,
1
</p>
<p>2
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>2+
</p>
<p>&radic;
</p>
<p>1
</p>
<p>2
</p>
<p>(
</p>
<p>5&minus;
&radic;
</p>
<p>5
)
</p>
<p>⎫
</p>
<p>⎪
</p>
<p>⎬
</p>
<p>⎪
</p>
<p>⎭
</p>
<p>Check
</p>
<p>In[9] := check[d ,n ] := Module[{e= 0,x,ex},In[9] := check[d ,n ] := Module[{e= 0,x,ex},In[9] := check[d ,n ] := Module[{e= 0,x,ex},
Do[x= i/d &lowast;Pi; ex = Abs[N[cos[x]&minus;Cos[x]]]; If[ex &gt; e,e= ex],Do[x= i/d &lowast;Pi; ex = Abs[N[cos[x]&minus;Cos[x]]]; If[ex &gt; e,e= ex],Do[x= i/d &lowast;Pi; ex = Abs[N[cos[x]&minus;Cos[x]]]; If[ex &gt; e,e= ex],
</p>
<p>{i,&minus;d &lowast; n,d &lowast; n}];{i,&minus;d &lowast; n,d &lowast; n}];{i,&minus;d &lowast; n,d &lowast; n}];
e]e]e]
</p>
<p>In[10] := {check[128,5],check[192,5],check[320,5]}In[10] := {check[128,5],check[192,5],check[320,5]}In[10] := {check[128,5],check[192,5],check[320,5]}
Out[10] =
</p>
<p>{
</p>
<p>2.220446049250313&times;10&minus;16,6.106226635438361&times;10&minus;16,
</p>
<p>1.861358289723114&times;10&minus;15
}</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 16
</p>
<p>Quantum Oscillator
</p>
<p>Catching a lion, the Schrödinger&rsquo;s method: At any moment,
</p>
<p>there is a nonzero probability that a lion is inside the cage. Sit
</p>
<p>and wait.
</p>
<p>16.1 Lowering and Raising Operators
</p>
<p>The Hamiltonian of the harmonic oscillator is [18]
</p>
<p>Ĥ =
p̂2
</p>
<p>2m
+
</p>
<p>mω2 x̂2
</p>
<p>2
.
</p>
<p>There is a dimensionful constant h̄ in quantum mechanics; therefore, two quanti-
</p>
<p>ties m and ω define a scale of length
&radic;
</p>
<p>h̄/(mω), momentum
&radic;
h̄mω , energy h̄ω ,
</p>
<p>and any other quantity of any dimensionality. They have the meaning of the charac-
</p>
<p>teristic amplitude, momentum, and energy of zero oscillations. We shall put h̄ = 1,
m= 1, and ω = 1, thus choosing these characteristic scales as units for measurement
of corresponding quantities. Then
</p>
<p>Ĥ =
p̂2 + x̂2
</p>
<p>2
.
</p>
<p>Let&rsquo;s introduce the operator
</p>
<p>â=
x̂+ ip̂&radic;
</p>
<p>2
</p>
<p>and its Hermitian conjugate
</p>
<p>â+ =
x̂&minus; ip̂&radic;
</p>
<p>2
.
</p>
<p>The commutation relation [p̂, x̂] =&minus;i implies for them
[
</p>
<p>â, â+
]
</p>
<p>= 1 .
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 16, &copy; Springer International Publishing Switzerland 2014
</p>
<p>127</p>
<p/>
</div>
<div class="page"><p/>
<p>128 16 Quantum Oscillator
</p>
<p>The Hamiltonian is expressed via these operators as
</p>
<p>Ĥ = â+ â+
1
</p>
<p>2
,
</p>
<p>from where we obtain
[
</p>
<p>Ĥ, â
]
</p>
<p>= &minus;â,
[
</p>
<p>Ĥ, â+
]
</p>
<p>= â+. Therefore, if |ψ&gt; is an eigen-
state of Ĥ with the energy E: Ĥ |ψ&gt; = E |ψ&gt;, then â |ψ&gt; and â+ |ψ&gt; are also
eigenstates of Ĥ with the energies E&minus; 1 and E+ 1:
</p>
<p>Ĥ â |ψ&gt;=
(
</p>
<p>âĤ&minus; â
)
</p>
<p>|ψ&gt;= (E&minus; 1)â |ψ&gt;, Ĥ â+ |ψ&gt;= (E+ 1)â+ |ψ&gt;
</p>
<p>(if only these states don&rsquo;t vanish). Hence the eigenvalues of Ĥ form an arithmetic
</p>
<p>progression with step equal to 1. It is bounded from below because Ĥ is a positive
</p>
<p>definite operator. Therefore, there exists a state |0&gt; with the lowest energy that
cannot be lowered any more:
</p>
<p>â |0&gt;= 0 .
Its energy is equal to 12 :
</p>
<p>Ĥ |0&gt;=
(
</p>
<p>â+â+
1
</p>
<p>2
</p>
<p>)
</p>
<p>|0&gt;= 1
2
|0&gt;
</p>
<p>(this is the zero oscillations energy). Acting on |0&gt; by the raising operator â+ n
times, we obtain a state |n&gt; with the energy
</p>
<p>En = n+
1
</p>
<p>2
.
</p>
<p>Hence, Ĥ |n&gt;=
(
</p>
<p>â+a+ 12
)
</p>
<p>|n&gt;=
(
</p>
<p>n+ 12
)
</p>
<p>|n&gt; or
</p>
<p>â+â |n&gt;= n |n&gt;,
</p>
<p>i.e., â+â acts as an operator of the level number.
</p>
<p>We have â |n&gt;= cn |n&minus; 1&gt;; it is possible to make cn real and positive by tuning
the phases of the states |n&gt;. These coefficients can be found from the normaliza-
tion condition: |cn|2 =&lt;n|â+â|n&gt;= n. The action of the operator â+ follows from
Hermitian conjugation:
</p>
<p>â |n&gt;=
&radic;
n |n&minus; 1&gt;, â+ |n&gt;=
</p>
<p>&radic;
n+ 1 |n+ 1&gt;.
</p>
<p>From this we again have â+â |n&gt;= n |n&gt;.
In the coordinate representation
</p>
<p>x̂= x , p̂=&minus;i d
dx
</p>
<p>.
</p>
<p>Let&rsquo;s implement the operators â and â+ in Mathematica.
</p>
<p>In[1] := a[ f ] := Together[(x&lowast; f +D[ f ,x])/Sqrt[2]]In[1] := a[ f ] := Together[(x&lowast; f +D[ f ,x])/Sqrt[2]]In[1] := a[ f ] := Together[(x&lowast; f +D[ f ,x])/Sqrt[2]]
In[2] := ac[ f ] := Together[(x&lowast; f &minus;D[ f ,x])/Sqrt[2]]In[2] := ac[ f ] := Together[(x&lowast; f &minus;D[ f ,x])/Sqrt[2]]In[2] := ac[ f ] := Together[(x&lowast; f &minus;D[ f ,x])/Sqrt[2]]</p>
<p/>
</div>
<div class="page"><p/>
<p>16.3 Excited States 129
</p>
<p>16.2 Ground State
</p>
<p>This is the state which cannot be lowered by â.
</p>
<p>In[3] := Eq = a [ψ0[x]] == 0In[3] := Eq = a [ψ0[x]] == 0In[3] := Eq = a [ψ0[x]] == 0
</p>
<p>Out[3] =
xψ0[x]+ψ &prime;0[x]&radic;
</p>
<p>2
== 0
</p>
<p>In[4] := s= DSolve [Eq,ψ0[x],x]In[4] := s= DSolve [Eq,ψ0[x],x]In[4] := s= DSolve [Eq,ψ0[x],x]
</p>
<p>Out[4] =
</p>
<p>{{
</p>
<p>ψ0[x]&rarr; e&minus;
x2
</p>
<p>2 C[1]
</p>
<p>}}
</p>
<p>In[5] := ψ0 = ψ0[x]/.s[[1]]In[5] := ψ0 = ψ0[x]/.s[[1]]In[5] := ψ0 = ψ0[x]/.s[[1]]
</p>
<p>Out[5] = e&minus;
x2
</p>
<p>2 C[1]
In[6] := Clear[Eq]In[6] := Clear[Eq]In[6] := Clear[Eq]
The normalization integral.
</p>
<p>In[7] := NI = Integrate [ψ0&and;2,{x,&minus;Infinity, Infinity}]In[7] := NI = Integrate [ψ0&and;2,{x,&minus;Infinity, Infinity}]In[7] := NI = Integrate [ψ0&and;2,{x,&minus;Infinity, Infinity}]
Out[7] =
</p>
<p>&radic;
πC[1]2
</p>
<p>In[8] := s= Solve[NI == 1,C[1]]In[8] := s= Solve[NI == 1,C[1]]In[8] := s= Solve[NI == 1,C[1]]
</p>
<p>Out[8] =
</p>
<p>{{
</p>
<p>C[1]&rarr;&minus; 1
π1/4
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>C[1]&rarr; 1
π1/4
</p>
<p>}}
</p>
<p>In[9] := ψ0 = ψ0/.s[[2]]In[9] := ψ0 = ψ0/.s[[2]]In[9] := ψ0 = ψ0/.s[[2]]
</p>
<p>Out[9] =
e&minus;
</p>
<p>x2
</p>
<p>2
</p>
<p>π1/4
In[10] := Clear[NI,s]In[10] := Clear[NI,s]In[10] := Clear[NI,s]
</p>
<p>16.3 Excited States
</p>
<p>In[11] := ψ [0] = ψ0;In[11] := ψ [0] = ψ0;In[11] := ψ [0] = ψ0;
In[12] := ψ [n ] := ψ [n] = ac[ψ [n&minus; 1]]/Sqrt[n]In[12] := ψ [n ] := ψ [n] = ac[ψ [n&minus; 1]]/Sqrt[n]In[12] := ψ [n ] := ψ [n] = ac[ψ [n&minus; 1]]/Sqrt[n]
The wave functions of a few first states.
</p>
<p>In[13] := Table[ψ [n],{n,0,10}]In[13] := Table[ψ [n],{n,0,10}]In[13] := Table[ψ [n],{n,0,10}]
</p>
<p>Out[13] =
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>e&minus;
x2
</p>
<p>2
</p>
<p>π1/4
,
</p>
<p>&radic;
2e&minus;
</p>
<p>x2
</p>
<p>2 x
</p>
<p>π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2
(
</p>
<p>&minus;1+ 2x2
)
</p>
<p>&radic;
2π1/4
</p>
<p>,
e&minus;
</p>
<p>x2
</p>
<p>2 x
(
</p>
<p>&minus;3+ 2x2
)
</p>
<p>&radic;
3π1/4
</p>
<p>,
</p>
<p>e&minus;
x2
</p>
<p>2
</p>
<p>(
</p>
<p>3&minus; 12x2+ 4x4
)
</p>
<p>2
&radic;
</p>
<p>6π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2 x
(
</p>
<p>15&minus; 20x2+ 4x4
)
</p>
<p>2
&radic;
</p>
<p>15π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2
</p>
<p>(
</p>
<p>&minus;15+ 90x2&minus; 60x4+ 8x6
)
</p>
<p>12
&radic;
</p>
<p>5π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2 x
(
</p>
<p>&minus;105+ 210x2&minus; 84x4 + 8x6
)
</p>
<p>6
&radic;
</p>
<p>70π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2
</p>
<p>(
</p>
<p>105&minus; 840x2+ 840x4&minus; 224x6+ 16x8
)
</p>
<p>24
&radic;
</p>
<p>70π1/4
,</p>
<p/>
</div>
<div class="page"><p/>
<p>130 16 Quantum Oscillator
</p>
<p>e&minus;
x2
</p>
<p>2 x
(
</p>
<p>945&minus; 2520x2+ 1512x4&minus; 288x6 + 16x8
)
</p>
<p>72
&radic;
</p>
<p>35π1/4
,
</p>
<p>e&minus;
x2
</p>
<p>2
(
</p>
<p>&minus;945+ 9450x2&minus; 12600x4+ 5040x6&minus; 720x8+ 32x10
)
</p>
<p>720
&radic;
</p>
<p>7π1/4
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>And here the level number can be set by the mouse.
</p>
<p>In[14] := Manipulate[ψ [n],{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]In[14] := Manipulate[ψ [n],{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]In[14] := Manipulate[ψ [n],{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]
</p>
<p>n 3
</p>
<p>e&minus;x2 x (&minus;3+2x2)
2
</p>
<p>&radic;3p1/4
Out[14] =
</p>
<p>The wave functions of a few first states.
</p>
<p>In[15] := Plot[Evaluate[Table[ψ [n],{n,0,3}]],{x,&minus;5,5}]In[15] := Plot[Evaluate[Table[ψ [n],{n,0,3}]],{x,&minus;5,5}]In[15] := Plot[Evaluate[Table[ψ [n],{n,0,3}]],{x,&minus;5,5}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;&minus;
</p>
<p>Out[15] =
</p>
<p>And this is a live plot: the level number can be set by the mouse.
</p>
<p>In[16] := Manipulate[Plot[ψ [n],{x,&minus;5,5},PlotRange &rarr;{&minus;0.8,0.8}],In[16] := Manipulate[Plot[ψ [n],{x,&minus;5,5},PlotRange &rarr;{&minus;0.8,0.8}],In[16] := Manipulate[Plot[ψ [n],{x,&minus;5,5},PlotRange &rarr;{&minus;0.8,0.8}],
{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{n,0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]</p>
<p/>
</div>
<div class="page"><p/>
<p>16.4 Some Properties 131
</p>
<p>&minus;
</p>
<p>&minus;&minus;
</p>
<p>n 3
</p>
<p>Out[16] =
</p>
<p>16.4 Some Properties
</p>
<p>Orthogonality and normalization.
</p>
<p>In[17] := Distribute[ψ ]In[17] := Distribute[ψ ]In[17] := Distribute[ψ ]
Out[17] = ψ
In[18] := Parallelize[Table[Table[Integrate[ψ [n]&lowast;ψ [m],{x,&minus;Infinity, Infinity}],In[18] := Parallelize[Table[Table[Integrate[ψ [n]&lowast;ψ [m],{x,&minus;Infinity, Infinity}],In[18] := Parallelize[Table[Table[Integrate[ψ [n]&lowast;ψ [m],{x,&minus;Infinity, Infinity}],
</p>
<p>{n,0,10}],{m,0,10}]]{n,0,10}],{m,0,10}]]{n,0,10}],{m,0,10}]]
Out[18] = {{1,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0},
</p>
<p>{0,0,1,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0},{0,0,0,0,0,1,0,0,0,0,0},
{0,0,0,0,0,0,1,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,0,1,0},
{0,0,0,0,0,0,0,0,0,0,1}}
</p>
<p>Wave functions in the momentum representation (Fourier transforms) are the same
</p>
<p>as in the coordinate one, up to phase factors.
</p>
<p>In[19] := Parallelize[Table[In[19] := Parallelize[Table[In[19] := Parallelize[Table[
Cancel[Integrate[ψ [n]&lowast;Exp[&minus;I &lowast; p &lowast; x],{x,&minus;Infinity, Infinity}]/Cancel[Integrate[ψ [n]&lowast;Exp[&minus;I &lowast; p &lowast; x],{x,&minus;Infinity, Infinity}]/Cancel[Integrate[ψ [n]&lowast;Exp[&minus;I &lowast; p &lowast; x],{x,&minus;Infinity, Infinity}]/
</p>
<p>Sqrt[2 &lowast;Pi]/(ψ [n]/.x&rarr; p)],Sqrt[2 &lowast;Pi]/(ψ [n]/.x&rarr; p)],Sqrt[2 &lowast;Pi]/(ψ [n]/.x&rarr; p)],
{n,0,10}]]{n,0,10}]]{n,0,10}]]
</p>
<p>Out[19] = {1,&minus;i,&minus;1, i,1,&minus;i,&minus;1, i,1,&minus;i,&minus;1}
The probability density.
</p>
<p>In[20] := Manipulate[Plot[ψ [n]&and;2,{x,&minus;6,6},PlotRange&rarr; {0,0.6}],In[20] := Manipulate[Plot[ψ [n]&and;2,{x,&minus;6,6},PlotRange&rarr; {0,0.6}],In[20] := Manipulate[Plot[ψ [n]&and;2,{x,&minus;6,6},PlotRange&rarr; {0,0.6}],
{{n,10},0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{{n,10},0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{{n,10},0,10,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]</p>
<p/>
</div>
<div class="page"><p/>
<p>132 16 Quantum Oscillator
</p>
<p>&minus; &minus; &minus;
</p>
<p>Out[20] =
</p>
<p>Why is it larger near the boundaries?</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 17
</p>
<p>Spherical Harmonics
</p>
<p>17.1 Angular Momentum in Quantum Mechanics
</p>
<p>The angular momentum operator ĴJJ is defined [18] in such a way that Û =
exp
</p>
<p>(
</p>
<p>&minus;iĴJJ &middot;δϕϕϕ
)
</p>
<p>is the operator of an infinitesimal rotation with the angle δϕϕϕ : if |ψ&gt;
is a state, then Û |ψ&gt; is the same state rotated by δϕϕϕ . Therefore, the average value
VVV &prime; of a vector operator V̂VV over Û |ψ&gt; is related to its average valueVVV over |ψ&gt; by
the formulaVVV &prime; =VVV + δϕϕϕ&times;VVV and hence Û+V̂VVÛ = V̂VV + i
</p>
<p>[
</p>
<p>ĴJJ &middot;δϕϕϕ,V̂VV
]
</p>
<p>= V̂VV + δϕϕϕ&times;V̂VV .
Therefore, for any vector operator V̂VV the commutation relation
</p>
<p>[
</p>
<p>V̂i, Ĵ j
]
</p>
<p>= iεi jkV̂k
holds. The average value of a scalar operator Ŝ does not change at rotations; hence
[
</p>
<p>Ŝ, Ĵi
]
</p>
<p>= 0. In particular, the angular momentum ĴJJ is a vector operator, and its square
</p>
<p>ĴJJ
2
= Ĵ2x + Ĵ
</p>
<p>2
y + Ĵ
</p>
<p>2
z is a scalar one:
</p>
<p>[
</p>
<p>Ĵi, Ĵ j
]
</p>
<p>= iεi jk Ĵk ,
[
</p>
<p>ĴJJ
2
, Ĵi
</p>
<p>]
</p>
<p>= 0 .
</p>
<p>Therefore, a system of common eigenstates of ĴJJ
2
</p>
<p>and Ĵz exists. Let&rsquo;s introduce
</p>
<p>the operators Ĵ&plusmn; = Ĵx &plusmn; iĴy, Ĵ+&plusmn; = Ĵ∓; we have
[
</p>
<p>Ĵz, Ĵ&plusmn;
]
</p>
<p>= &plusmn;Ĵ&plusmn;. This means that
if |ψ&gt; is an eigenstate of Ĵz (Ĵz |ψ&gt; = m |ψ&gt;), then Ĵ&plusmn; |ψ&gt; are also eigenstates
of Ĵz: ĴzĴ&plusmn; |ψ&gt; = (m&plusmn; 1)Ĵ&plusmn; |ψ&gt; (if they don&rsquo;t vanish). Therefore, eigenvalues m
of Ĵz form a progression with unit step, and the ladder operators Ĵ&plusmn; increase and
decrease m.
</p>
<p>Let&rsquo;s consider states with a given eigenvalue of ĴJJ
2
. For these states, eigenvalues
</p>
<p>of Ĵz are bounded from above and from below because the operator ĴJJ
2&minus; Ĵ2z = Ĵ2x + Ĵ2y
</p>
<p>is positive definite. Let |m&plusmn;&gt; be the eigenstates with the maximum and the mini-
mum eigenvalues of Ĵz equal to m&plusmn;. Then these eigenvalues cannot be further in-
creased and decreased by the operators Ĵ&plusmn; correspondingly: Ĵ&plusmn; |m&plusmn;&gt;= 0. We have
</p>
<p>Ĵ&plusmn;Ĵ∓ = ĴJJ
2 &minus; Ĵ2z &plusmn; Ĵz .
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 17, &copy; Springer International Publishing Switzerland 2014
</p>
<p>133</p>
<p/>
</div>
<div class="page"><p/>
<p>134 17 Spherical Harmonics
</p>
<p>Therefore, Ĵ∓Ĵ&plusmn; |m&plusmn;&gt; = 0 =
[
</p>
<p>ĴJJ
2 &minus;m&plusmn; (m&plusmn;&plusmn; 1)
</p>
<p>]
</p>
<p>|m&plusmn;&gt;, i.e., the eigenvalue of the
operator ĴJJ
</p>
<p>2
for these states (as well as for all the other states being considered)
</p>
<p>is m+ (m++ 1) = m&minus; (m&minus;&minus; 1). Hence (m++m&minus;) (m+&minus;m&minus;+ 1) = 0; taking into
account m+ �m&minus; we obtain m&minus; =&minus;m+ or m&plusmn; =&plusmn; j. The number j must be integer
or half-integer because m+ and m&minus; differ by an integer.
</p>
<p>Finally, we have a system of common eigenstates | j,m&gt; of the operators ĴJJ2
and Ĵz:
</p>
<p>ĴJJ
2 | j,m&gt;= j( j+ 1) | j,m&gt;, Ĵz | j,m&gt; = m | j,m&gt;,
</p>
<p>where j is integer or half-integer, and m varies from &minus; j to j by 1. The operators Ĵ&plusmn;
increase and decrease m correspondingly: Ĵ&plusmn; | j,m&gt; = a&plusmn;( j,m) | j,m&plusmn; 1&gt;. Tuning
the phases of | j,m&gt; we can make a&plusmn;( j,m) real and positive. They can be found
from the normalization: |a&plusmn;( j,m)|2 = &lt; j,m|Ĵ∓Ĵ&plusmn;| j,m&gt; = j( j+ 1)&minus;m(m&plusmn; 1).
Finally we arrive at
</p>
<p>Ĵ&plusmn; | j,m&gt; =
&radic;
</p>
<p>j( j+ 1)&minus;m(m&plusmn; 1)| j,m&plusmn; 1&gt;=
&radic;
</p>
<p>( j&plusmn;m+ 1)( j∓m)| j,m&plusmn; 1&gt;.
</p>
<p>The orbital angular momentum of a particle l̂ll = rrr&times; p̂pp (where p̂pp = &minus;i&nabla;&nabla;&nabla; in the
coordinate representation) is an example of angular momentum. In spherical coor-
</p>
<p>dinates
</p>
<p>l̂z =&minus;i
&part;
&part;ϕ
</p>
<p>, l̂&plusmn; = e
&plusmn;iϕ
</p>
<p>(
</p>
<p>&plusmn; &part;
&part;θ
</p>
<p>+ icotθ
&part;
&part;ϕ
</p>
<p>)
</p>
<p>.
</p>
<p>The eigenfunctions of l̂z are e
imϕ ; they must not change at ϕ &rarr; ϕ + 2π ; hence
</p>
<p>m must be integer. The common eigenfunctions of l̂ll
2
</p>
<p>and l̂z are called spherical
</p>
<p>harmonics:
</p>
<p>l̂ll
2
Ylm(θ ,ϕ) = l(l+ 1)Ylm(θ ,ϕ) , l̂zYlm(θ ,ϕ) =mYlm(θ ,ϕ) ,
</p>
<p>where l is integer, and m varies from &minus;l to l by 1; Ylm(θ ,ϕ) = Plm(θ )eimϕ . They are
orthonormalized:
</p>
<p>&int;
</p>
<p>Y &lowast;l&prime;m&prime;(θ ,ϕ)Ylm(θ ,ϕ)dΩ = δl&prime;lδm&prime;m .
</p>
<p>Here are the operators l̂&plusmn; in Mathematica:
In[1] := lp[ f ] := Together[Exp[I &lowast;ϕ ]&lowast; (D[ f ,θ ]+ I&lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]In[1] := lp[ f ] := Together[Exp[I &lowast;ϕ ]&lowast; (D[ f ,θ ]+ I&lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]In[1] := lp[ f ] := Together[Exp[I &lowast;ϕ ]&lowast; (D[ f ,θ ]+ I &lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]
In[2] := lm[ f ] := Together[Exp[&minus;I &lowast;ϕ ]&lowast; (&minus;D[ f ,θ ]+ I&lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]In[2] := lm[ f ] := Together[Exp[&minus;I &lowast;ϕ ]&lowast; (&minus;D[ f ,θ ]+ I&lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]In[2] := lm[ f ] := Together[Exp[&minus;I &lowast;ϕ ]&lowast; (&minus;D[ f ,θ ]+ I&lowast;Cot[θ ]&lowast;D[ f ,ϕ ])]
</p>
<p>17.2 Yll(θ ,ϕ)
</p>
<p>The angular momentum projection of this state cannot be raised by l̂+.
</p>
<p>In[3] := Eq = lp[Exp[I &lowast; l &lowast;ϕ ]&lowast;P[θ ]] == 0In[3] := Eq = lp[Exp[I &lowast; l &lowast;ϕ ]&lowast;P[θ ]] == 0In[3] := Eq = lp[Exp[I &lowast; l &lowast;ϕ ]&lowast;P[θ ]] == 0
Out[3] =&minus;eiϕ+ilϕ
</p>
<p>(
</p>
<p>l, Cot[θ ]P[θ ]&minus;P&prime;[θ ]
)
</p>
<p>== 0</p>
<p/>
</div>
<div class="page"><p/>
<p>17.3 Ylm(θ ,ϕ) 135
</p>
<p>In[4] := s= DSolve[Eq,P[θ ],θ ]In[4] := s= DSolve[Eq,P[θ ],θ ]In[4] := s= DSolve[Eq,P[θ ],θ ]
</p>
<p>Out[4] =
{{
</p>
<p>P[θ ]&rarr;C[1]Sin[θ ]l
}}
</p>
<p>In[5] := P= P[θ ]/.s[[1]]In[5] := P= P[θ ]/.s[[1]]In[5] := P= P[θ ]/.s[[1]]
Out[5] =C[1]Sin[θ ]l
</p>
<p>The normalization integral.
</p>
<p>In[6] := NI = 2 &lowast;Pi&lowast; Integrate[P&and;2 &lowast;Sin[θ ],{θ ,0,Pi},Assumptions&minus;&gt;{l &ge; 0}]/.In[6] := NI = 2 &lowast;Pi&lowast; Integrate[P&and;2 &lowast;Sin[θ ],{θ ,0,Pi},Assumptions&minus;&gt;{l &ge; 0}]/.In[6] := NI = 2 &lowast;Pi&lowast; Integrate[P&and;2 &lowast;Sin[θ ],{θ ,0,Pi},Assumptions&minus;&gt;{l &ge; 0}]/.
Gamma[&minus;l]&minus;&gt;&minus;Pi/(Sin[Pi&lowast; l]&lowast;Gamma[l+ 1])Gamma[&minus;l]&minus;&gt;&minus;Pi/(Sin[Pi&lowast; l]&lowast;Gamma[l+ 1])Gamma[&minus;l]&minus;&gt;&minus;Pi/(Sin[Pi&lowast; l]&lowast;Gamma[l+ 1])
</p>
<p>Out[6] =
2π3/2C[1]2Gamma[1+ l]
</p>
<p>Gamma
[
</p>
<p>3
2 + l
</p>
<p>]
</p>
<p>In[7] := s= Solve[NI == 1,C[1]]In[7] := s= Solve[NI == 1,C[1]]In[7] := s= Solve[NI == 1,C[1]]
</p>
<p>Out[7] =
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>C[1]&rarr;&minus;
</p>
<p>&radic;
</p>
<p>Gamma
[
</p>
<p>3
2 + l
</p>
<p>]
</p>
<p>&radic;
2π3/4
</p>
<p>&radic;
</p>
<p>Gamma[1+ l]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>,
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>C[1]&rarr;
</p>
<p>&radic;
</p>
<p>Gamma
[
</p>
<p>3
2 + l
</p>
<p>]
</p>
<p>&radic;
2π3/4
</p>
<p>&radic;
</p>
<p>Gamma[1+ l]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>In[8] := P= P/.s[[2]]In[8] := P= P/.s[[2]]In[8] := P= P/.s[[2]]
</p>
<p>Out[8] =
</p>
<p>&radic;
</p>
<p>Gamma
[
</p>
<p>3
2 + l
</p>
<p>]
</p>
<p>Sin[θ ]l
&radic;
</p>
<p>2π3/4
&radic;
</p>
<p>Gamma[1+ l]
The phase can be chosen arbitrarily. According to Landau&ndash;Lifshitz [18]:
</p>
<p>In[9] := Y [l , l ] = (&minus;I)&and;l &lowast;P&lowast;Exp[I &lowast; l &lowast;ϕ ]In[9] := Y [l , l ] = (&minus;I)&and;l &lowast;P&lowast;Exp[I &lowast; l &lowast;ϕ ]In[9] := Y [l , l ] = (&minus;I)&and;l &lowast;P&lowast;Exp[I &lowast; l &lowast;ϕ ]
</p>
<p>Out[9] =
(&minus;i)leilϕ
</p>
<p>&radic;
</p>
<p>Gamma
[
</p>
<p>3
2 + l
</p>
<p>]
</p>
<p>Sin[θ ]l
&radic;
</p>
<p>2π3/4
&radic;
</p>
<p>Gamma[1+ l]
In[10] := Clear[Eq,s,P]In[10] := Clear[Eq,s,P]In[10] := Clear[Eq,s,P]
</p>
<p>17.3 Ylm(θ ,ϕ)
</p>
<p>These states can be obtained from Yll(θ ,ϕ) by the lowering operator l̂&minus;.
In[11] := S = Cos[x ]&and;n &minus;&gt;(1&minus;Sin[x]&and;2)&and;Quotient[n,2]&lowast;Cos[x]&and;Mod[n,2];In[11] := S = Cos[x ]&and;n &minus;&gt;(1&minus;Sin[x]&and;2)&and;Quotient[n,2]&lowast;Cos[x]&and;Mod[n,2];In[11] := S = Cos[x ]&and;n &minus;&gt;(1&minus;Sin[x]&and;2)&and;Quotient[n,2]&lowast;Cos[x]&and;Mod[n,2];
In[12] := Y [l ,m ]/;m&lt; l := Y [l,m] =In[12] := Y [l ,m ]/;m&lt; l := Y [l,m] =In[12] := Y [l ,m ]/;m&lt; l := Y [l,m] =
</p>
<p>Factor[Expand[lm[Y [l,m+ 1]]/Sqrt[(l&minus;m)&lowast; (l+m+ 1)]/.S]]Factor[Expand[lm[Y [l,m+ 1]]/Sqrt[(l&minus;m)&lowast; (l+m+ 1)]/.S]]Factor[Expand[lm[Y [l,m+ 1]]/Sqrt[(l&minus;m)&lowast; (l+m+ 1)]/.S]]
In[13] := Table[Table[Y [l,m],{m, l,&minus;l,&minus;1}],{l,0,4}]In[13] := Table[Table[Y [l,m],{m, l,&minus;l,&minus;1}],{l,0,4}]In[13] := Table[Table[Y [l,m],{m, l,&minus;l,&minus;1}],{l,0,4}]
</p>
<p>Out[13] =
</p>
<p>{
</p>
<p>{
</p>
<p>1
</p>
<p>2
&radic;
π
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>&minus;1
2
</p>
<p>ieiϕ
&radic;
</p>
<p>3
</p>
<p>2π
Sin[θ ],
</p>
<p>1
</p>
<p>2
i
</p>
<p>&radic;
</p>
<p>3
</p>
<p>π
Cos[θ ],
</p>
<p>1
</p>
<p>2
ie&minus;iϕ
</p>
<p>&radic;
</p>
<p>3
</p>
<p>2π
Sin[θ ]
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>&minus;1
4
</p>
<p>e2iϕ
&radic;
</p>
<p>15
</p>
<p>2π
Sin[θ ]2,
</p>
<p>1
</p>
<p>2
eiϕ
</p>
<p>&radic;
</p>
<p>15
</p>
<p>2π
Cos[θ ]Sin[θ ],
</p>
<p>1
</p>
<p>4
</p>
<p>&radic;
</p>
<p>5
</p>
<p>π
</p>
<p>(
</p>
<p>&minus;2+ 3Sin[θ ]2
)
</p>
<p>,
</p>
<p>&minus;1
2
</p>
<p>e&minus;iϕ
&radic;
</p>
<p>15
</p>
<p>2π
Cos[θ ]Sin[θ ],&minus;1
</p>
<p>4
e&minus;2iϕ
</p>
<p>&radic;
</p>
<p>15
</p>
<p>2π
Sin[θ ]2
</p>
<p>}
</p>
<p>,</p>
<p/>
</div>
<div class="page"><p/>
<p>136 17 Spherical Harmonics
</p>
<p>{
</p>
<p>1
</p>
<p>8
ie3iϕ
</p>
<p>&radic;
</p>
<p>35
</p>
<p>π
Sin[θ ]3,&minus;1
</p>
<p>4
ie2iϕ
</p>
<p>&radic;
</p>
<p>105
</p>
<p>2π
Cos[θ ]Sin[θ ]2,
</p>
<p>&minus; 1
8
</p>
<p>ieiϕ
&radic;
</p>
<p>21
</p>
<p>π
Sin[θ ]
</p>
<p>(
</p>
<p>&minus;4+ 5Sin[θ ]2
)
</p>
<p>,
1
</p>
<p>4
i
</p>
<p>&radic;
</p>
<p>7
</p>
<p>π
Cos[θ ]
</p>
<p>(
</p>
<p>&minus;2+ 5Sin[θ ]2
)
</p>
<p>,
</p>
<p>1
</p>
<p>8
ie&minus;iϕ
</p>
<p>&radic;
</p>
<p>21
</p>
<p>π
Sin[θ ]
</p>
<p>(
</p>
<p>&minus;4+ 5Sin[θ ]2
)
</p>
<p>,&minus;1
4
</p>
<p>ie&minus;2iϕ
&radic;
</p>
<p>105
</p>
<p>2π
Cos[θ ]Sin[θ ]2,
</p>
<p>&minus;1
8
</p>
<p>ie&minus;3iϕ
&radic;
</p>
<p>35
</p>
<p>π
Sin[θ ]3
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>3
</p>
<p>16
e4iϕ
</p>
<p>&radic;
</p>
<p>35
</p>
<p>2π
Sin[θ ]4,&minus;3
</p>
<p>8
e3iϕ
</p>
<p>&radic;
</p>
<p>35
</p>
<p>π
Cos[θ ]Sin[θ ]3,
</p>
<p>&minus; 3
8
</p>
<p>e2iϕ
&radic;
</p>
<p>5
</p>
<p>2π
Sin[θ ]2
</p>
<p>(
</p>
<p>&minus;6+ 7Sin[θ ]2
)
</p>
<p>,
</p>
<p>3
</p>
<p>8
eiϕ
</p>
<p>&radic;
</p>
<p>5
</p>
<p>π
Cos[θ ]Sin[θ ]
</p>
<p>(
</p>
<p>&minus;4+ 7Sin[θ ]2
)
</p>
<p>,
3
(
</p>
<p>8&minus; 40Sin[θ ]2 + 35Sin[θ ]4
)
</p>
<p>16
&radic;
π
</p>
<p>,
</p>
<p>&minus; 3
8
</p>
<p>e&minus;iϕ
&radic;
</p>
<p>5
</p>
<p>π
Cos[θ ]Sin[θ ]
</p>
<p>(
</p>
<p>&minus;4+ 7Sin[θ ]2
)
</p>
<p>,
</p>
<p>&minus; 3
8
</p>
<p>e&minus;2iϕ
&radic;
</p>
<p>5
</p>
<p>2π
Sin[θ ]2
</p>
<p>(
</p>
<p>&minus;6+ 7Sin[θ ]2
)
</p>
<p>,
3
</p>
<p>8
e&minus;3iϕ
</p>
<p>&radic;
</p>
<p>35
</p>
<p>π
Cos[θ ]Sin[θ ]3,
</p>
<p>3
</p>
<p>16
e&minus;4iϕ
</p>
<p>&radic;
</p>
<p>35
</p>
<p>2π
Sin[θ ]4
</p>
<p>}}
</p>
<p>In[14] := Manipulate[Manipulate[Y [l,m],In[14] := Manipulate[Manipulate[Y [l,m],In[14] := Manipulate[Manipulate[Y [l,m],
{m,&minus;l, l,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}],{l,0,4,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{m,&minus;l, l,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}],{l,0,4,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]{m,&minus;l, l,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}],{l,0,4,1,Appearance&minus;&gt;&rdquo;Labeled&rdquo;}]
</p>
<p>Out[14] =
</p>
<p>l
</p>
<p>m
</p>
<p>1
2
e&minus;iϕ 15
</p>
<p>2π
Cos[q]Sin[q]
</p>
<p>2
</p>
<p>1
</p>
<p>&minus;
</p>
<p>Orthogonality of Yl1m1 and Yl2m2 with m1 &#13;= m2 is evident; let&rsquo;s check all the rest.</p>
<p/>
</div>
<div class="page"><p/>
<p>17.3 Ylm(θ ,ϕ) 137
</p>
<p>In[15] := Table[Table[Table[In[15] := Table[Table[Table[In[15] := Table[Table[Table[
Integrate[Y [l1,m]&lowast;Conjugate[Y [l2,m]]&lowast;Sin[θ ],{ϕ ,0,2 &lowast;Pi},{θ ,0,Pi}],Integrate[Y [l1,m]&lowast;Conjugate[Y [l2,m]]&lowast;Sin[θ ],{ϕ ,0,2 &lowast;Pi},{θ ,0,Pi}],Integrate[Y [l1,m]&lowast;Conjugate[Y [l2,m]]&lowast;Sin[θ ],{ϕ ,0,2 &lowast;Pi},{θ ,0,Pi}],
{m, l2,&minus;l2,&minus;1}],{l2,0, l1}],{l1,0,4}]{m, l2,&minus;l2,&minus;1}],{l2,0, l1}],{l1,0,4}]{m, l2,&minus;l2,&minus;1}],{l2,0, l1}],{l1,0,4}]
</p>
<p>Out[15] = {{{1}},{{0},{1,1,1}},{{0},{0,0,0},{1,1,1,1,1}},
{{0},{0,0,0},{0,0,0,0,0},{1,1,1,1,1,1,1}},
{{0},{0,0,0},{0,0,0,0,0},{0,0,0,0,0,0,0},{1,1,1,1,1,1,1,1,1}}}</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 18
</p>
<p>Adding Angular Momenta in Quantum
</p>
<p>Mechanics
</p>
<p>Let ĴJJ1 and ĴJJ2 be two angular momentum operators commuting with each other.
</p>
<p>Then the basis | j1,m1; j2,m2&gt; of common eigenstates of the operators ĴJJ
2
1, Ĵ1z, ĴJJ
</p>
<p>2
2,
</p>
<p>Ĵ2z exists. On the other hand, the total angular momentum ĴJJ = ĴJJ1 + ĴJJ2 is also an
angular momentum operator. Therefore, linear combinations | j,m&gt; of the states
| j1,m1; j2,m2&gt; at given j1, j2 can be constructed in such a way that they are eigen-
states of ĴJJ
</p>
<p>2
and Ĵz. This problem [18] is called addition of the angular momenta j1
</p>
<p>and j2.
</p>
<p>We always have m= m1 +m2 because Ĵz = Ĵ1z+ Ĵ2z. The following figure illus-
trates addition of j1 and j2 (it assumes j1 � j2).
</p>
<p>In[1] := Fig[j1 , j2 ] := If[j1 &lt; j2,Fig[j2, j1],In[1] := Fig[j1 , j2 ] := If[j1 &lt; j2,Fig[j2, j1],In[1] := Fig[j1 , j2 ] := If[j1 &lt; j2,Fig[j2, j1],
With[{d = 0.75 &lowast; j2,d2 = 0.1 &lowast; j2,d3 = 0.15 &lowast; j2,r = 0.05 &lowast; j2},With[{d = 0.75 &lowast; j2,d2 = 0.1 &lowast; j2,d3 = 0.15 &lowast; j2,r = 0.05 &lowast; j2},With[{d = 0.75 &lowast; j2,d2 = 0.1 &lowast; j2,d3 = 0.15 &lowast; j2,r = 0.05 &lowast; j2},
</p>
<p>Graphics[Join[{Line[{{j2, j1+ j2},{j2, j2&minus; j1},{&minus;j2,&minus;j1&minus; j2},Graphics[Join[{Line[{{j2, j1+ j2},{j2, j2&minus; j1},{&minus;j2,&minus;j1&minus; j2},Graphics[Join[{Line[{{j2, j1+ j2},{j2, j2&minus; j1},{&minus;j2,&minus;j1&minus; j2},
{&minus;j2, j1&minus; j2},{j2, j1+ j2}}],{&minus;j2, j1&minus; j2},{j2, j1+ j2}}],{&minus;j2, j1&minus; j2},{j2, j1+ j2}}],
</p>
<p>Line[{{0,&minus;j1&minus; j2&minus; d},{0, j1+ j2+ d}}],Line[{{0,&minus;j1&minus; j2&minus; d},{0, j1+ j2+ d}}],Line[{{0,&minus;j1&minus; j2&minus; d},{0, j1+ j2+ d}}],
Line[{{&minus;j2&minus; d,0},{j2+ d,0}}],Line[{{&minus;j2&minus; d,0},{j2+ d,0}}],Line[{{&minus;j2&minus; d,0},{j2+ d,0}}],
Line[{{&minus;d2, j1+ j2},{d2, j1+ j2}}],Line[{{&minus;d2, j1+ j2},{d2, j1+ j2}}],Line[{{&minus;d2, j1+ j2},{d2, j1+ j2}}],
Text [ j1 + j2,{&minus;d3, j1+ j2},{1,0}] ,Text [ j1 + j2,{&minus;d3, j1+ j2},{1,0}] ,Text [ j1 + j2,{&minus;d3, j1+ j2},{1,0}] ,
Line[{{&minus;d2,&minus;j1&minus; j2},{d2,&minus;j1&minus; j2}}],Line[{{&minus;d2,&minus;j1&minus; j2},{d2,&minus;j1&minus; j2}}],Line[{{&minus;d2,&minus;j1&minus; j2},{d2,&minus;j1&minus; j2}}],
Text [&minus;( j1 + j2) ,{d3,&minus;j1&minus; j2},{&minus;1,0}] ,Text [&minus;( j1 + j2) ,{d3,&minus;j1&minus; j2},{&minus;1,0}] ,Text [&minus;( j1 + j2) ,{d3,&minus;j1&minus; j2},{&minus;1,0}] ,
Line[{{&minus;d2, j1&minus; j2},{d2, j1&minus; j2}}],Line[{{&minus;d2, j1&minus; j2},{d2, j1&minus; j2}}],Line[{{&minus;d2, j1&minus; j2},{d2, j1&minus; j2}}],
Text [ j1 &minus; j2,{d3, j1&minus; j2},{&minus;1,1}] ,Text [ j1 &minus; j2,{d3, j1&minus; j2},{&minus;1,1}] ,Text [ j1 &minus; j2,{d3, j1&minus; j2},{&minus;1,1}] ,
Line[{{&minus;d2, j2&minus; j1},{d2, j2&minus; j1}}],Line[{{&minus;d2, j2&minus; j1},{d2, j2&minus; j1}}],Line[{{&minus;d2, j2&minus; j1},{d2, j2&minus; j1}}],
Text [&minus;( j1 &minus; j2) ,{&minus;d3, j2&minus; j1},{1,&minus;1}] ,Text [&minus;( j1 &minus; j2) ,{&minus;d3, j2&minus; j1},{1,&minus;1}] ,Text [&minus;( j1 &minus; j2) ,{&minus;d3, j2&minus; j1},{1,&minus;1}] ,
Text [&minus; j2,{&minus;j2&minus; d2,&minus;d2},{1,1}] ,Text [ j2,{j2+ d2,&minus;d2},{&minus;1,1}] ,Text [&minus; j2,{&minus;j2&minus; d2,&minus;d2},{1,1}] ,Text [ j2,{j2+ d2,&minus;d2},{&minus;1,1}] ,Text [&minus; j2,{&minus;j2&minus; d2,&minus;d2},{1,1}] ,Text [ j2,{j2+ d2,&minus;d2},{&minus;1,1}] ,
Text [m ,{&minus;d2, j1+ j2+ d},{1,0}],Text [m2,{j2+ d,&minus;d2},{0,1}]},Text [m ,{&minus;d2, j1+ j2+ d},{1,0}],Text [m2,{j2+ d,&minus;d2},{0,1}]},Text [m ,{&minus;d2, j1+ j2+ d},{1,0}],Text [m2,{j2+ d,&minus;d2},{0,1}]},
</p>
<p>Join[Table[{Disk[{m2,m},r]},{m, j1&minus; j2+ 1, j1+ j2},{m2,m&minus; j1, j2}]],Join[Table[{Disk[{m2,m},r]},{m, j1&minus; j2+ 1, j1+ j2},{m2,m&minus; j1, j2}]],Join[Table[{Disk[{m2,m},r]},{m, j1&minus; j2+ 1, j1+ j2},{m2,m&minus; j1, j2}]],
Join[Table[Disk[{m2,m},r],{m,&minus;j1&minus; j2, j2&minus; j1&minus; 1},{m2,&minus;j2,m+ j1}]],Join[Table[Disk[{m2,m},r],{m,&minus;j1&minus; j2, j2&minus; j1&minus; 1},{m2,&minus;j2,m+ j1}]],Join[Table[Disk[{m2,m},r],{m,&minus;j1&minus; j2, j2&minus; j1&minus; 1},{m2,&minus;j2,m+ j1}]],
Join[Table[Disk[{m2,m},r],{m, j2&minus; j1, j1&minus; j2},{m2,&minus;j2, j2}]]]]]]Join[Table[Disk[{m2,m},r],{m, j2&minus; j1, j1&minus; j2},{m2,&minus;j2, j2}]]]]]]Join[Table[Disk[{m2,m},r],{m, j2&minus; j1, j1&minus; j2},{m2,&minus;j2, j2}]]]]]]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 18, &copy; Springer International Publishing Switzerland 2014
</p>
<p>139</p>
<p/>
</div>
<div class="page"><p/>
<p>140 18 Adding Angular Momenta in Quantum Mechanics
</p>
<p>In[2] := Show[Fig[4,2]]In[2] := Show[Fig[4,2]]In[2] := Show[Fig[4,2]]
</p>
<p>Out[2] =
</p>
<p>In[3] := Clear[Fig]In[3] := Clear[Fig]In[3] := Clear[Fig]
There is one state with m = j1 + j2, two states with m = j1 + j2 &minus; 1, etc. Such an
increase of the number of states occurs up to m = j1 &minus; j2; further on it is constant
up to m = &minus;( j1 &minus; j2) and then decreases to one at m = &minus;( j1 + j2). Therefore, the
maximum angular momentum resulting from adding j1 and j2 is j = j1 + j2. One
state in the two-dimensional space of states with m= j1 + j2 &minus; 1 refers to the same
angular momentum, and the other one is the state with the maximum projection for
</p>
<p>the angular momentum j = j1 + j2 &minus; 1. Continuing such reasoning, we see that all
angular momenta up to j1 &minus; j2 appear. In general, adding angular momenta j1 and
j2 results in the angular momenta j from | j1 &minus; j2| to j1 + j2 in steps of 1.</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Adding Angular Momenta in Quantum Mechanics 141
</p>
<p>This description naturally leads to the algorithm implemented below. We start
</p>
<p>from the only state with m = j1 + j2, namely the state | j1, j1; j2, j2&gt;. It has j =
j1 + j2, i.e., it is | j1 + j2, j1 + j2&gt;. Repeatedly acting by the ladder operator Ĵ&minus; =
Ĵ1&minus; + Ĵ2&minus; (and dividing by the appropriate normalization factor) we construct all
the states with the total angular momentum j = j1 + j2: | j1 + j2, j1 + j2 &minus; 1&gt;, . . . ,
| j1 + j2,&minus;( j1 + j2)&gt;. Then we turn to the projection m = j1 + j2 &minus; 1 and choose
the state orthogonal to the already constructed one | j1 + j2, j1 + j2 &minus; 1&gt;. It has
j = j1 + j2 &minus; 1, i.e., it is | j1 + j2 &minus; 1, j1 + j2 &minus; 1&gt;. Using the ladder operator we
construct all the states with j = j1 + j2 &minus; 1.
</p>
<p>Then we proceed in a similar way. At the beginning of each step, when consider-
</p>
<p>ing a new value of the projection m, we need to construct the state orthogonal to all
</p>
<p>the states with the same m already constructed. This is achieved as follows: we start
</p>
<p>from an arbitrary state, say, | j1, j1; j2,m&minus; j1&gt;, subtract its components along the
already constructed states, and finally normalize the result. Then we construct all
</p>
<p>the states with the same total angular momentum from this state repeatedly acting
</p>
<p>by Ĵ&minus;.
The function AddJ constructs the states | j,m&gt; (denoted Ket[ j,m]) as linear com-
</p>
<p>binations of the states | j1,m1; j2,m2&gt; (denoted ket[m1,m2]). It uses two local func-
tions: Jm is the lowering operator Ĵ&minus; and ScaP is the scalar product. The procedure
returns its local Ket, so that later the user will be able to inquire about Ket[ j,m] for
specific values of j, m; in addition to this, the procedure prints all its results.
</p>
<p>In[4] := AddJ = Function[{j1, j2}, If[j2 &gt; j1,AddJ[j2, j1],In[4] := AddJ = Function[{j1, j2}, If[j2 &gt; j1,AddJ[j2, j1],In[4] := AddJ = Function[{j1, j2}, If[j2 &gt; j1,AddJ[j2, j1],
Module[{Ket, j,J,m,Module[{Ket, j,J,m,Module[{Ket, j,J,m,
</p>
<p>Jm = Function[{k},Jm = Function[{k},Jm = Function[{k},
Expand[k/.ket[m1 ,m2 ]&minus;&gt;Expand[k/.ket[m1 ,m2 ]&minus;&gt;Expand[k/.ket[m1 ,m2 ]&minus;&gt;
</p>
<p>Sqrt[(j1&minus;m1+ 1)&lowast; (j1+m1)]&lowast; ket[m1&minus; 1,m2]+Sqrt[(j1&minus;m1+ 1)&lowast; (j1+m1)]&lowast; ket[m1&minus; 1,m2]+Sqrt[(j1&minus;m1+ 1)&lowast; (j1+m1)]&lowast; ket[m1&minus; 1,m2]+
Sqrt[(j2&minus;m2+ 1)&lowast; (j2+m2)]&lowast; ket[m1,m2&minus; 1]]],Sqrt[(j2&minus;m2+ 1)&lowast; (j2+m2)]&lowast; ket[m1,m2&minus; 1]]],Sqrt[(j2&minus;m2+ 1)&lowast; (j2+m2)]&lowast; ket[m1,m2&minus; 1]]],
</p>
<p>ScaP = Function[{k1,k2},ScaP = Function[{k1,k2},ScaP = Function[{k1,k2},
Expand[k1&lowast; k2]/.Expand[k1&lowast; k2]/.Expand[k1&lowast; k2]/.
{ket[m1 ,m2 ]&and;2&minus;&gt;1,ket[m1 ,m2 ]&lowast; ket[M1 ,M2 ]&minus;&gt;0}]},{ket[m1 ,m2 ]&and;2&minus;&gt;1,ket[m1 ,m2 ]&lowast; ket[M1 ,M2 ]&minus;&gt;0}]},{ket[m1 ,m2 ]&and;2&minus;&gt;1,ket[m1 ,m2 ]&lowast; ket[M1 ,M2 ]&minus;&gt;0}]},
</p>
<p>Do[Ket[ j, j] = ket[ j&minus; j2, j2];Do[Ket[ j, j] = ket[ j&minus; j2, j2];Do[Ket[ j, j] = ket[ j&minus; j2, j2];
Do[Ket[ j, j]&minus; = Expand[ScaP[Ket[ j, j],Ket[J, j]]&lowast;Ket[J, j]],Do[Ket[ j, j]&minus; = Expand[ScaP[Ket[ j, j],Ket[J, j]]&lowast;Ket[J, j]],Do[Ket[ j, j]&minus; = Expand[ScaP[Ket[ j, j],Ket[J, j]]&lowast;Ket[J, j]],
{J, j1+ j2, j+ 1,&minus;1}];{J, j1+ j2, j+ 1,&minus;1}];{J, j1+ j2, j+ 1,&minus;1}];
</p>
<p>Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;, j,&rdquo;] = &rdquo;,Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;, j,&rdquo;] = &rdquo;,Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;, j,&rdquo;] = &rdquo;,
Ket[ j, j] = Expand[Ket[ j, j]/Sqrt[ScaP[Ket[ j, j],Ket[ j, j]]]]];Ket[ j, j] = Expand[Ket[ j, j]/Sqrt[ScaP[Ket[ j, j],Ket[ j, j]]]]];Ket[ j, j] = Expand[Ket[ j, j]/Sqrt[ScaP[Ket[ j, j],Ket[ j, j]]]]];
</p>
<p>Do[Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;,m,&rdquo;] = &rdquo;,Do[Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;,m,&rdquo;] = &rdquo;,Do[Print[&rdquo;Ket[&rdquo;, j,&rdquo;,&rdquo;,m,&rdquo;] = &rdquo;,
Ket[ j,m] = Expand[Jm[Ket[ j,m+ 1]]/Sqrt[( j&minus;m)&lowast; ( j+m+ 1)]]],Ket[ j,m] = Expand[Jm[Ket[ j,m+ 1]]/Sqrt[( j&minus;m)&lowast; ( j+m+ 1)]]],Ket[ j,m] = Expand[Jm[Ket[ j,m+ 1]]/Sqrt[( j&minus;m)&lowast; ( j+m+ 1)]]],
</p>
<p>{m, j&minus; 1,&minus; j,&minus;1}],{m, j&minus; 1,&minus; j,&minus;1}],{m, j&minus; 1,&minus; j,&minus;1}],
{ j, j1+ j2, j1&minus; j2,&minus;1}];{ j, j1+ j2, j1&minus; j2,&minus;1}];{ j, j1+ j2, j1&minus; j2,&minus;1}];
</p>
<p>Ket]]];Ket]]];Ket]]];
In[5] := AddJ[1/2,1/2]In[5] := AddJ[1/2,1/2]In[5] := AddJ[1/2,1/2]
</p>
<p>Ket[1,1] = ket
</p>
<p>[
</p>
<p>1
</p>
<p>2
,
</p>
<p>1
</p>
<p>2
</p>
<p>]
</p>
<p>Ket[1,0] =
ket
</p>
<p>[
</p>
<p>&minus; 12 , 12
]
</p>
<p>&radic;
2
</p>
<p>+
ket
</p>
<p>[
</p>
<p>1
2 ,&minus; 12
</p>
<p>]
</p>
<p>&radic;
2</p>
<p/>
</div>
<div class="page"><p/>
<p>142 18 Adding Angular Momenta in Quantum Mechanics
</p>
<p>Ket[1,&minus;1] = ket
[
</p>
<p>&minus;1
2
,&minus;1
</p>
<p>2
</p>
<p>]
</p>
<p>Ket[0,0] =
ket
</p>
<p>[
</p>
<p>&minus; 12 , 12
]
</p>
<p>&radic;
2
</p>
<p>&minus; ket
[
</p>
<p>1
2 ,&minus; 12
</p>
<p>]
</p>
<p>&radic;
2
</p>
<p>Out[5] = Ket$668
In[6] := AddJ[1,1/2]In[6] := AddJ[1,1/2]In[6] := AddJ[1,1/2]
</p>
<p>Ket
</p>
<p>[
</p>
<p>3
</p>
<p>2
,
</p>
<p>3
</p>
<p>2
</p>
<p>]
</p>
<p>= ket
</p>
<p>[
</p>
<p>1,
1
</p>
<p>2
</p>
<p>]
</p>
<p>Ket
</p>
<p>[
</p>
<p>3
</p>
<p>2
,
</p>
<p>1
</p>
<p>2
</p>
<p>]
</p>
<p>=
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket
</p>
<p>[
</p>
<p>0,
1
</p>
<p>2
</p>
<p>]
</p>
<p>+
ket
</p>
<p>[
</p>
<p>1,&minus; 12
]
</p>
<p>&radic;
3
</p>
<p>Ket
</p>
<p>[
</p>
<p>3
</p>
<p>2
,&minus;1
</p>
<p>2
</p>
<p>]
</p>
<p>=
ket
</p>
<p>[
</p>
<p>&minus;1, 12
]
</p>
<p>&radic;
3
</p>
<p>+
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket
</p>
<p>[
</p>
<p>0,&minus;1
2
</p>
<p>]
</p>
<p>Ket
</p>
<p>[
</p>
<p>3
</p>
<p>2
,&minus;3
</p>
<p>2
</p>
<p>]
</p>
<p>= ket
</p>
<p>[
</p>
<p>&minus;1,&minus;1
2
</p>
<p>]
</p>
<p>Ket
</p>
<p>[
</p>
<p>1
</p>
<p>2
,
</p>
<p>1
</p>
<p>2
</p>
<p>]
</p>
<p>=
ket
</p>
<p>[
</p>
<p>0, 12
]
</p>
<p>&radic;
3
</p>
<p>&minus;
&radic;
</p>
<p>2
</p>
<p>3
ket
</p>
<p>[
</p>
<p>1,&minus;1
2
</p>
<p>]
</p>
<p>Ket
</p>
<p>[
</p>
<p>1
</p>
<p>2
,&minus;1
</p>
<p>2
</p>
<p>]
</p>
<p>=
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket
</p>
<p>[
</p>
<p>&minus;1, 1
2
</p>
<p>]
</p>
<p>&minus; ket
[
</p>
<p>0,&minus; 12
]
</p>
<p>&radic;
3
</p>
<p>Out[6] = Ket$669
In[7] := AddJ[1,1]In[7] := AddJ[1,1]In[7] := AddJ[1,1]
Ket[2,2] = ket[1,1]
</p>
<p>Ket[2,1] =
ket[0,1]&radic;
</p>
<p>2
+
</p>
<p>ket[1,0]&radic;
2
</p>
<p>Ket[2,0] =
ket[&minus;1,1]&radic;
</p>
<p>6
+
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket[0,0]+
</p>
<p>ket[1,&minus;1]&radic;
6
</p>
<p>Ket[2,&minus;1] = ket[&minus;1,0]&radic;
2
</p>
<p>+
ket[0,&minus;1]&radic;
</p>
<p>2
Ket[2,&minus;2] = ket[&minus;1,&minus;1]
Ket[1,1] =
</p>
<p>ket[0,1]&radic;
2
</p>
<p>&minus; ket[1,0]&radic;
2
</p>
<p>Ket[1,0] =
ket[&minus;1,1]&radic;
</p>
<p>2
&minus; ket[1,&minus;1]&radic;
</p>
<p>2
</p>
<p>Ket[1,&minus;1] = ket[&minus;1,0]&radic;
2
</p>
<p>&minus; ket[0,&minus;1]&radic;
2
</p>
<p>Ket[0,0] =
ket[&minus;1,1]&radic;
</p>
<p>3
&minus; ket[0,0]&radic;
</p>
<p>3
+
</p>
<p>ket[1,&minus;1]&radic;
3
</p>
<p>Out[7] = Ket$670
In[8] := AddJ[2,1]In[8] := AddJ[2,1]In[8] := AddJ[2,1]
Ket[3,3] = ket[2,1]
</p>
<p>Ket[3,2] =
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket[1,1]+
</p>
<p>ket[2,0]&radic;
3
</p>
<p>Ket[3,1] =
</p>
<p>&radic;
</p>
<p>2
</p>
<p>5
ket[0,1]+ 2
</p>
<p>&radic;
</p>
<p>2
</p>
<p>15
ket[1,0]+
</p>
<p>ket[2,&minus;1]&radic;
15</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Adding Angular Momenta in Quantum Mechanics 143
</p>
<p>Ket[3,0] =
ket[&minus;1,1]&radic;
</p>
<p>5
+
</p>
<p>&radic;
</p>
<p>3
</p>
<p>5
ket[0,0]+
</p>
<p>ket[1,&minus;1]&radic;
5
</p>
<p>Ket[3,&minus;1] = ket[&minus;2,1]&radic;
15
</p>
<p>+ 2
</p>
<p>&radic;
</p>
<p>2
</p>
<p>15
ket[&minus;1,0]+
</p>
<p>&radic;
</p>
<p>2
</p>
<p>5
ket[0,&minus;1]
</p>
<p>Ket[3,&minus;2] = ket[&minus;2,0]&radic;
3
</p>
<p>+
</p>
<p>&radic;
</p>
<p>2
</p>
<p>3
ket[&minus;1,&minus;1]
</p>
<p>Ket[3,&minus;3] = ket[&minus;2,&minus;1]
</p>
<p>Ket[2,2] =
ket[1,1]&radic;
</p>
<p>3
&minus;
&radic;
</p>
<p>2
</p>
<p>3
ket[2,0]
</p>
<p>Ket[2,1] =
ket[0,1]&radic;
</p>
<p>2
&minus; ket[1,0]&radic;
</p>
<p>6
&minus; ket[2,&minus;1]&radic;
</p>
<p>3
</p>
<p>Ket[2,0] =
ket[&minus;1,1]&radic;
</p>
<p>2
&minus; ket[1,&minus;1]&radic;
</p>
<p>2
</p>
<p>Ket[2,&minus;1] = ket[&minus;2,1]&radic;
3
</p>
<p>+
ket[&minus;1,0]&radic;
</p>
<p>6
&minus; ket[0,&minus;1]&radic;
</p>
<p>2
</p>
<p>Ket[2,&minus;2] =
&radic;
</p>
<p>2
</p>
<p>3
ket[&minus;2,0]&minus; ket[&minus;1,&minus;1]&radic;
</p>
<p>3
</p>
<p>Ket[1,1] =
ket[0,1]&radic;
</p>
<p>10
&minus;
&radic;
</p>
<p>3
</p>
<p>10
ket[1,0]+
</p>
<p>&radic;
</p>
<p>3
</p>
<p>5
ket[2,&minus;1]
</p>
<p>Ket[1,0] =
</p>
<p>&radic;
</p>
<p>3
</p>
<p>10
ket[&minus;1,1]&minus;
</p>
<p>&radic;
</p>
<p>2
</p>
<p>5
ket[0,0]+
</p>
<p>&radic;
</p>
<p>3
</p>
<p>10
ket[1,&minus;1]
</p>
<p>Ket[1,&minus;1] =
&radic;
</p>
<p>3
</p>
<p>5
ket[&minus;2,1]&minus;
</p>
<p>&radic;
</p>
<p>3
</p>
<p>10
ket[&minus;1,0]+ ket[0,&minus;1]&radic;
</p>
<p>10
Out[8] = Ket$671</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 19
</p>
<p>Classical Nonlinear Oscillator
</p>
<p>19.1 Statement of the Problem
</p>
<p>Let&rsquo;s consider one-dimensional motion of a particle with mass m near a minimum
</p>
<p>of an arbitrary smooth potential [19]
</p>
<p>U(x) =
kx2
</p>
<p>2
+V(x) , V (x) = O
</p>
<p>(
</p>
<p>x3
)
</p>
<p>(we have chosen the origin of x and the zero energy level to be at the minimum).
</p>
<p>If we neglect V (x), then the equation of motion
</p>
<p>m
d2x
</p>
<p>dt2
=&minus;dU
</p>
<p>dx
</p>
<p>becomes
d2x
</p>
<p>dt2
+ω20x= 0 , ω
</p>
<p>2
0 =
</p>
<p>k
</p>
<p>m
,
</p>
<p>and has the solution
</p>
<p>x(t) = a cosω0t+ b sinω0t .
</p>
<p>Now we consider the effect of
</p>
<p>V (x) =
&infin;
</p>
<p>&sum;
n=1
</p>
<p>cnx
n+2 .
</p>
<p>Choosing units of measurement in such a way that m = 1 and k = 1, we have the
equation of motion
</p>
<p>d2x
</p>
<p>dt2
+ x= R(x)&equiv;&minus;dV
</p>
<p>dx
.
</p>
<p>Its solution x(t) is a periodic function of t. If we choose the time origin at a
maximum of x(t), then x(t) is an even function, due to reversibility. In the zeroth
approximation x(t) = a cost.
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 19, &copy; Springer International Publishing Switzerland 2014
</p>
<p>145</p>
<p/>
</div>
<div class="page"><p/>
<p>146 19 Classical Nonlinear Oscillator
</p>
<p>In[1] :=V = Series[c[1]&lowast; x&and;3,{x,0,3}]In[1] :=V = Series[c[1]&lowast; x&and;3,{x,0,3}]In[1] :=V = Series[c[1]&lowast; x&and;3,{x,0,3}]
Out[1] = c[1]x3 +O[x]4
</p>
<p>In[2] := R=&minus;D[V,x]In[2] := R=&minus;D[V,x]In[2] := R=&minus;D[V,x]
Out[2] =&minus;3c[1]x2 +O[x]3
In[3] := x[t] = Series[a &lowast;Cos[t],{a,0,1}]In[3] := x[t] = Series[a &lowast;Cos[t],{a,0,1}]In[3] := x[t] = Series[a &lowast;Cos[t],{a,0,1}]
Out[3] = Cos[t]a+O[a]2
</p>
<p>The equation of motion is satisfied at O(a).
In[4] := D[x[t],{t,2}]+ x[t]In[4] := D[x[t],{t,2}]+ x[t]In[4] := D[x[t],{t,2}]+ x[t]
Out[4] = O[a]2
</p>
<p>19.2 The First Correction
</p>
<p>Now we want to take terms of order a2 into account. The right-hand side is
</p>
<p>In[5] := R1 = R/.x&minus;&gt;x[t]In[5] := R1 = R/.x&minus;&gt;x[t]In[5] := R1 = R/.x&minus;&gt;x[t]
Out[5] =&minus;3
</p>
<p>(
</p>
<p>c[1]Cos[t]2
)
</p>
<p>a2 +O[a]3
</p>
<p>Let&rsquo;s expand it in harmonics.
</p>
<p>In[6] := R1 = Map[TrigReduce,R1]In[6] := R1 = Map[TrigReduce,R1]In[6] := R1 = Map[TrigReduce,R1]
</p>
<p>Out[6] =&minus;3
2
(c[1]+ c[1]Cos[2t])a2 +O[a]3
</p>
<p>That is, the &rdquo;driving force&rdquo; contains zeroth and second harmonics. This means that
</p>
<p>we should add such harmonics to x(t). We&rsquo;ll not add the solution of the homoge-
neous equation&mdash;the first harmonic: by definition of the amplitude a, it is completely
</p>
<p>given by the leading term a cost.
</p>
<p>In[7] := x[t] = Series[a &lowast;Cos[t]+In[7] := x[t] = Series[a &lowast;Cos[t]+In[7] := x[t] = Series[a &lowast;Cos[t]+
a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,2}]a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,2}]a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,2}]
</p>
<p>Out[7] = Cos[t]a+(b[2,0]+ b[2,2]Cos[2t])a2 +O[a]3
</p>
<p>Now we substitute this form of the solution into the equation of motion.
</p>
<p>In[8] := Eq = D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])In[8] := Eq = D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])In[8] := Eq = D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])
Out[8] =
</p>
<p>(
</p>
<p>b[2,0]+ 3c[1]Cos[t]2 &minus; 3b[2,2]Cos[2t]
)
</p>
<p>a2 +O[a]3
</p>
<p>In[9] := Eq = Map[TrigReduce,Eq]In[9] := Eq = Map[TrigReduce,Eq]In[9] := Eq = Map[TrigReduce,Eq]
</p>
<p>Out[9] =
1
</p>
<p>2
(2b[2,0]+ 3c[1]&minus; 6b[2,2]Cos[2t]+ 3c[1]Cos[2t])a2 +O[a]3
</p>
<p>In[10] := Eq2 = SeriesCoefficient[Eq,2]In[10] := Eq2 = SeriesCoefficient[Eq,2]In[10] := Eq2 = SeriesCoefficient[Eq,2]
</p>
<p>Out[10] =
1
</p>
<p>2
(2b[2,0]+ 3c[1]&minus; 6b[2,2]Cos[2t]+ 3c[1]Cos[2t])
</p>
<p>This expression should vanish. How can we separate harmonics? Let&rsquo;s help Mathe-
</p>
<p>matica a little.
</p>
<p>In[11] := Eq2 = Eq2/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[11] := Eq2 = Eq2/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[11] := Eq2 = Eq2/.Cos[ j .&lowast; t]&minus;&gt;z&and; j
Out[11] =
</p>
<p>1
</p>
<p>2
</p>
<p>(
</p>
<p>2b[2,0]&minus; 6z2b[2,2]+ 3c[1]+ 3z2c[1]
)
</p>
<p>The coefficients of z0 and z2 should vanish.
</p>
<p>In[12] := Eq20 = Coefficient[Eq2,z,0]In[12] := Eq20 = Coefficient[Eq2,z,0]In[12] := Eq20 = Coefficient[Eq2,z,0]
</p>
<p>Out[12] =
1
</p>
<p>2
(2b[2,0]+ 3c[1])</p>
<p/>
</div>
<div class="page"><p/>
<p>19.3 The Second Correction 147
</p>
<p>In[13] := Eq22 = Coefficient[Eq2,z,2]In[13] := Eq22 = Coefficient[Eq2,z,2]In[13] := Eq22 = Coefficient[Eq2,z,2]
</p>
<p>Out[13] =
1
</p>
<p>2
(&minus;6b[2,2]+ 3c[1])
</p>
<p>We can find b[2,0] from the first equation and b[2,2] from the second one.
In[14] := b[2,0] = b[2,0]/.Solve[Eq20 == 0,b[2,0]][[1]]In[14] := b[2,0] = b[2,0]/.Solve[Eq20 == 0,b[2,0]][[1]]In[14] := b[2,0] = b[2,0]/.Solve[Eq20 == 0,b[2,0]][[1]]
</p>
<p>Out[14] =&minus;3c[1]
2
</p>
<p>In[15] := b[2,2] = b[2,2]/.Solve[Eq22 == 0,b[2,2]][[1]]In[15] := b[2,2] = b[2,2]/.Solve[Eq22 == 0,b[2,2]][[1]]In[15] := b[2,2] = b[2,2]/.Solve[Eq22 == 0,b[2,2]][[1]]
</p>
<p>Out[15] =
c[1]
</p>
<p>2
Now we know the solution.
</p>
<p>In[16] := x[t] = x[t]In[16] := x[t] = x[t]In[16] := x[t] = x[t]
</p>
<p>Out[16] = Cos[t]a+
</p>
<p>(
</p>
<p>&minus;3c[1]
2
</p>
<p>+
1
</p>
<p>2
c[1]Cos[2t]
</p>
<p>)
</p>
<p>a2 +O[a]3
</p>
<p>Let&rsquo;s check energy conservation.
</p>
<p>In[17] := Et = D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t]);In[17] := Et = D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t]);In[17] := Et = D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t]);
In[18] := Map[TrigReduce,Et]In[18] := Map[TrigReduce,Et]In[18] := Map[TrigReduce,Et]
</p>
<p>Out[18] =
a2
</p>
<p>2
+O[a]4
</p>
<p>In[19] := Clear[b]In[19] := Clear[b]In[19] := Clear[b]
</p>
<p>19.3 The Second Correction
</p>
<p>Now we want to find two corrections.
</p>
<p>In[20] := n= 2;In[20] := n= 2;In[20] := n= 2;
In[21] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]In[21] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]In[21] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]
Out[21] = c[1]x3 + c[2]x4 +O[x]5
</p>
<p>In[22] := R=&minus;D[V,x]In[22] := R=&minus;D[V,x]In[22] := R=&minus;D[V,x]
Out[22] =&minus;3c[1]x2 &minus; 4c[2]x3+O[x]4
This is x[t] up to a2.
In[23] := x[t] = Series[a &lowast;Cos[t]+In[23] := x[t] = Series[a &lowast;Cos[t]+In[23] := x[t] = Series[a &lowast;Cos[t]+
</p>
<p>a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,n}]a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,n}]a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}],{a,0,n}]
Out[23] = Cos[t]a+(b[2,0]+ b[2,2]Cos[2t])a2 +O[a]3
</p>
<p>The right-hand side of the equation of motion.
</p>
<p>In[24] := R1 = Map[TrigReduce,ExpandAll[R/.x&minus;&gt;x[t]]]In[24] := R1 = Map[TrigReduce,ExpandAll[R/.x&minus;&gt;x[t]]]In[24] := R1 = Map[TrigReduce,ExpandAll[R/.x&minus;&gt;x[t]]]
Out[24] =&minus;3
</p>
<p>2
(c[1]+ c[1]Cos[2t])a2+
</p>
<p>(&minus;6b[2,0]c[1]Cos[t]&minus; 3b[2,2]c[1]Cos[t]&minus; 3c[2]Cos[t]&minus;
3b[2,2]c[1]Cos[3t]&minus; c[2]Cos[3t])a3+
</p>
<p>O[a]4
</p>
<p>There are the first and the third harmonics at the order a3, that is, there is a
</p>
<p>resonant term in the &rdquo;driving force&rdquo; which would lead to an unbounded growth of
</p>
<p>the solution. This means we have forgotten something. Namely, we have forgotten
</p>
<p>that the oscillation period depends on the amplitude (unless the potential is strictly</p>
<p/>
</div>
<div class="page"><p/>
<p>148 19 Classical Nonlinear Oscillator
</p>
<p>parabolic). And our solution should contain cos( jωt). If we denote τ =ωt, then the
equation of motion is
</p>
<p>ω2
d2x
</p>
<p>dτ2
+ x= R .
</p>
<p>Let&rsquo;s suppose that the variable t in the program really means τ and denote ω2 = w.
It is a series in a2 beginning with 1.
</p>
<p>In[25] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]In[25] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]In[25] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]
Out[25] = 1+ u[2]a2+O[a]4
</p>
<p>Now we are able to cancel the first harmonic in the a3 term of the equation of motion.
</p>
<p>And the third one should be added to the general form of the solution.
</p>
<p>In[26] := x[t] = Series[a &lowast;Cos[t]+ a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}]+In[26] := x[t] = Series[a &lowast;Cos[t]+ a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}]+In[26] := x[t] = Series[a &lowast;Cos[t]+ a&and;2 &lowast;Sum[b[2, j]&lowast;Cos[ j &lowast; t],{ j,0,2,2}]+
a&and;3 &lowast;Sum[b[3, j]&lowast;Cos[ j &lowast; t],{ j,3,3,2}],{a,0,n+ 1}]a&and;3 &lowast;Sum[b[3, j]&lowast;Cos[ j &lowast; t],{ j,3,3,2}],{a,0,n+ 1}]a&and;3 &lowast;Sum[b[3, j]&lowast;Cos[ j &lowast; t],{ j,3,3,2}],{a,0,n+ 1}]
</p>
<p>Out[26] = Cos[t]a+(b[2,0]+ b[2,2]Cos[2t])a2 + b[3,3]Cos[3t]a3 +O[a]4
</p>
<p>The equation of motion is
</p>
<p>In[27] := Eq = Map[TrigReduce,In[27] := Eq = Map[TrigReduce,In[27] := Eq = Map[TrigReduce,
ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]
</p>
<p>Out[27] =
1
</p>
<p>2
(2b[2,0]+ 3c[1]&minus; 6b[2,2]Cos[2t]+ 3c[1]Cos[2t])a2+
</p>
<p>(6b[2,0]c[1]Cos[t]+ 3b[2,2]c[1]Cos[t]+ 3c[2]Cos[t]&minus;
8b[3,3]Cos[3t]+ 3b[2,2]c[1]Cos[3t]+ c[2]Cos[3t]&minus;Cos[t]u[2])a3+
</p>
<p>O[a]4
</p>
<p>We already know how to solve it at the order a2.
</p>
<p>In[28] := Eq2 = SeriesCoefficient[Eq,2]/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[28] := Eq2 = SeriesCoefficient[Eq,2]/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[28] := Eq2 = SeriesCoefficient[Eq,2]/.Cos[ j .&lowast; t]&minus;&gt;z&and; j
Out[28] =
</p>
<p>1
</p>
<p>2
</p>
<p>(
</p>
<p>2b[2,0]&minus; 6z2b[2,2]+ 3c[1]+ 3z2c[1]
)
</p>
<p>In[29] := Do[Print[b[2, j] = b[2, j]/.Solve[Coefficient[Eq2,z, j] == 0,b[2, j]][[1]]],In[29] := Do[Print[b[2, j] = b[2, j]/.Solve[Coefficient[Eq2,z, j] == 0,b[2, j]][[1]]],In[29] := Do[Print[b[2, j] = b[2, j]/.Solve[Coefficient[Eq2,z, j] == 0,b[2, j]][[1]]],
{ j,0,2,2}]{ j,0,2,2}]{ j,0,2,2}]
</p>
<p>&minus;3c[1]
2
</p>
<p>c[1]
</p>
<p>2
At the order a3:
</p>
<p>In[30] := Eq3 = SeriesCoefficient[Eq,3]/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[30] := Eq3 = SeriesCoefficient[Eq,3]/.Cos[ j .&lowast; t]&minus;&gt;z&and; jIn[30] := Eq3 = SeriesCoefficient[Eq,3]/.Cos[ j .&lowast; t]&minus;&gt;z&and; j
Out[30] =&minus;8z3b[3,3]&minus; 15
</p>
<p>2
zc[1]2 +
</p>
<p>3
</p>
<p>2
z3c[1]2 + 3zc[2]+ z3c[2]&minus; zu[2]
</p>
<p>This is the coefficient of the first harmonic, i.e., of z1:
</p>
<p>In[31] := Eq31 = Coefficient[Eq3,z,1]In[31] := Eq31 = Coefficient[Eq3,z,1]In[31] := Eq31 = Coefficient[Eq3,z,1]
</p>
<p>Out[31] =&minus;15
2
c[1]2 + 3c[2]&minus; u[2]
</p>
<p>It can be nullified by choosing u[2].
In[32] := u[2] = u[2]/.Solve[Eq31 == 0,u[2]][[1]]In[32] := u[2] = u[2]/.Solve[Eq31 == 0,u[2]][[1]]In[32] := u[2] = u[2]/.Solve[Eq31 == 0,u[2]][[1]]
</p>
<p>Out[32] =&minus;3
2
</p>
<p>(
</p>
<p>5c[1]2 &minus; 2c[2]
)
</p>
<p>And this is the coefficient of the third harmonic, i.e., of z3:</p>
<p/>
</div>
<div class="page"><p/>
<p>19.4 The nth Correction 149
</p>
<p>In[33] := Eq33 = Coefficient[Eq3,z,3]In[33] := Eq33 = Coefficient[Eq3,z,3]In[33] := Eq33 = Coefficient[Eq3,z,3]
</p>
<p>Out[33] =&minus;8b[3,3]+ 3c[1]
2
</p>
<p>2
+ c[2]
</p>
<p>It can be nullified by choosing b[3,3].
In[34] := b[3,3] = b[3,3]/.Solve[Eq33 == 0,b[3,3]][[1]]In[34] := b[3,3] = b[3,3]/.Solve[Eq33 == 0,b[3,3]][[1]]In[34] := b[3,3] = b[3,3]/.Solve[Eq33 == 0,b[3,3]][[1]]
</p>
<p>Out[34] =
1
</p>
<p>16
</p>
<p>(
</p>
<p>3c[1]2 + 2c[2]
)
</p>
<p>Now we know the oscillation frequency
</p>
<p>In[35] := w= wIn[35] := w= wIn[35] := w= w
</p>
<p>Out[35] = 1&minus; 3
2
</p>
<p>(
</p>
<p>5c[1]2 &minus; 2c[2]
)
</p>
<p>a2 +O[a]4
</p>
<p>and x[t]:
In[36] := x[t] = x[t]In[36] := x[t] = x[t]In[36] := x[t] = x[t]
</p>
<p>Out[36] = Cos[t]a+
</p>
<p>(
</p>
<p>&minus;3c[1]
2
</p>
<p>+
1
</p>
<p>2
c[1]Cos[2t]
</p>
<p>)
</p>
<p>a2+
</p>
<p>1
</p>
<p>16
</p>
<p>(
</p>
<p>3c[1]2 + 2c[2]
)
</p>
<p>Cos[3t]a3 +O[a]4
</p>
<p>Let&rsquo;s check energy conservation.
</p>
<p>In[37] := Et = Map[TrigReduce,In[37] := Et = Map[TrigReduce,In[37] := Et = Map[TrigReduce,
ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]
</p>
<p>Out[37] =
a2
</p>
<p>2
+
</p>
<p>1
</p>
<p>16
</p>
<p>(
</p>
<p>&minus;37c[1]2+ 18c[2]
)
</p>
<p>a4 +O[a]5
</p>
<p>In[38] := Clear[b,u]In[38] := Clear[b,u]In[38] := Clear[b,u]
</p>
<p>19.4 The nth Correction
</p>
<p>Now we&rsquo;ll write a program which can find n corrections in a to the particle mo-
</p>
<p>tion for any n. Just a single line should be changed for the calculation with a new
</p>
<p>value of n.
</p>
<p>In[39] := n= 4;In[39] := n= 4;In[39] := n= 4;
The correction to the potential and the &ldquo;driving force.&rdquo;
</p>
<p>In[40] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]In[40] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]In[40] :=V = Series[Sum[c[i]&lowast; x&and;(i+ 2),{i,1,n}],{x,0,n+ 2}]
Out[40] = c[1]x3 + c[2]x4 + c[3]x5+ c[4]x6 +O[x]7
</p>
<p>In[41] := R=&minus;D[V,x]In[41] := R=&minus;D[V,x]In[41] := R=&minus;D[V,x]
Out[41] =&minus;3c[1]x2 &minus; 4c[2]x3&minus; 5c[3]x4 &minus; 6c[4]x5+O[x]6
The frequency squared is a series in a2.
</p>
<p>In[42] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]In[42] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]In[42] := w= Series[1+Sum[u[i]&lowast; a&and;i,{i,2,n+ 1,2}],{a,0,n+ 1}]
Out[42] = 1+ u[2]a2+ u[4]a4+O[a]6
</p>
<p>The general form of the solution. The order ai contains harmonics up to the ith one.
</p>
<p>They are all even at even values of i and odd at odd values. The first harmonic never
</p>
<p>appears&mdash;by definition, it is entirely contained in the leading term a cost.</p>
<p/>
</div>
<div class="page"><p/>
<p>150 19 Classical Nonlinear Oscillator
</p>
<p>In[43] := x[t] = Series[a &lowast;Cos[t]+In[43] := x[t] = Series[a &lowast;Cos[t]+In[43] := x[t] = Series[a &lowast;Cos[t]+
Sum[a&and;i&lowast;Sum[b[i, j]&lowast;Cos[ j &lowast; t],{ j, If[EvenQ[i],0,3], i,2}],{i,2,n+ 1}],Sum[a&and;i&lowast;Sum[b[i, j]&lowast;Cos[ j &lowast; t],{ j, If[EvenQ[i],0,3], i,2}],{i,2,n+ 1}],Sum[a&and;i&lowast;Sum[b[i, j]&lowast;Cos[ j &lowast; t],{ j, If[EvenQ[i],0,3], i,2}],{i,2,n+ 1}],
</p>
<p>{a,0,n+ 1}]{a,0,n+ 1}]{a,0,n+ 1}]
Out[43] = Cos[t]a+(b[2,0]+ b[2,2]Cos[2t])a2 + b[3,3]Cos[3t]a3+
</p>
<p>(b[4,0]+ b[4,2]Cos[2t]+ b[4,4]Cos[4t])a4+
(b[5,3]Cos[3t]+ b[5,5]Cos[5t])a5 +O[a]6
</p>
<p>The equation of motion.
</p>
<p>In[44] := Eq = Map[TrigReduce,In[44] := Eq = Map[TrigReduce,In[44] := Eq = Map[TrigReduce,
ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t],{t,2}]+ x[t]&minus; (R/.x&minus;&gt;x[t])]]
</p>
<p>Out[44] =
1
</p>
<p>2
(2b[2,0]+ 3c[1]&minus; 6b[2,2]Cos[2t]+ 3c[1]Cos[2t])a2+
</p>
<p>(6b[2,0]c[1]Cos[t]+ 3b[2,2]c[1]Cos[t]+ 3c[2]Cos[t]&minus;
8b[3,3]Cos[3t]+ 3b[2,2]c[1]Cos[3t]+ c[2]Cos[3t]&minus;Cos[t]u[2])a3+
</p>
<p>1
</p>
<p>8
</p>
<p>(
</p>
<p>8b[4,0]+ 24b[2,0]2c[1]+ 12b[2,2]2c[1]+ 48b[2,0]c[2]+24b[2,2]c[2]+
</p>
<p>15c[3]&minus; 24b[4,2]Cos[2t]+ 48b[2,0]b[2,2]c[1]Cos[2t]+
24b[3,3]c[1]Cos[2t]+ 48b[2,0]c[2]Cos[2t]+ 48b[2,2]c[2]Cos[2t]+
20c[3]Cos[2t]&minus; 120b[4,4]Cos[4t]+ 12b[2,2]2c[1]Cos[4t]+
24b[3,3]c[1]Cos[4t]+ 24b[2,2]c[2]Cos[4t]+ 5c[3]Cos[4t]&minus;
32b[2,2]Cos[2t]u[2])a4+
</p>
<p>(
</p>
<p>3b[2,2]b[3,3]c[1]Cos[t]+ 6b[4,0]c[1]Cos[t]+ 3b[4,2]c[1]Cos[t]+
</p>
<p>12b[2,0]2c[2]Cos[t]+ 12b[2,0]b[2,2]c[2]Cos[t]+ 6b[2,2]2c[2]Cos[t]+
3b[3,3]c[2]Cos[t]+ 15b[2,0]c[3]Cos[t]+ 10b[2,2]c[3]Cos[t]+
15
</p>
<p>4
c[4]Cos[t]&minus; 8b[5,3]Cos[3t]+ 6b[2,0]b[3,3]c[1]Cos[3t]+
</p>
<p>3b[4,2]c[1]Cos[3t]+ 3b[4,4]c[1]Cos[3t]+ 12b[2,0]b[2,2]c[2]Cos[3t]+
3b[2,2]2c[2]Cos[3t]+ 6b[3,3]c[2]Cos[3t]+ 5b[2,0]c[3]Cos[3t]+
15
</p>
<p>2
b[2,2]c[3]Cos[3t]+
</p>
<p>15
</p>
<p>8
c[4]Cos[3t]&minus; 24b[5,5]Cos[5t]+
</p>
<p>3b[2,2]b[3,3]c[1]Cos[5t]+ 3b[4,4]c[1]Cos[5t]+ 3b[2,2]2c[2]Cos[5t]+
</p>
<p>3b[3,3]c[2]Cos[5t]+
5
</p>
<p>2
b[2,2]c[3]Cos[5t]+
</p>
<p>3
</p>
<p>8
c[4]Cos[5t]&minus;
</p>
<p>9b[3,3]Cos[3t]u[2]&minus;Cos[t]u[4]
)
</p>
<p>a5+
</p>
<p>O[a]6
</p>
<p>All terms of the orders ai for i from 2 to n+ 1 must vanish. If i is odd, the first har-
monic is present; a correction to the frequency squared is found from the condition
</p>
<p>that this harmonic vanishes. All other harmonics give us coefficients in x(t).
In[45] := Do[Eqi = SeriesCoefficient[Eq, i]/.Cos[ j .&lowast; t]&minus;&gt;z&and; j;In[45] := Do[Eqi = SeriesCoefficient[Eq, i]/.Cos[ j .&lowast; t]&minus;&gt;z&and; j;In[45] := Do[Eqi = SeriesCoefficient[Eq, i]/.Cos[ j .&lowast; t]&minus;&gt;z&and; j;
</p>
<p>If[OddQ[i],If[OddQ[i],If[OddQ[i],
u[i&minus; 1] = u[i&minus; 1]/.Solve[Coefficient[Eqi,z,1] == 0,u[i&minus; 1]][[1]]];u[i&minus; 1] = u[i&minus; 1]/.Solve[Coefficient[Eqi,z,1] == 0,u[i&minus; 1]][[1]]];u[i&minus; 1] = u[i&minus; 1]/.Solve[Coefficient[Eqi,z,1] == 0,u[i&minus; 1]][[1]]];
</p>
<p>Do[b[i, j] = b[i, j]/.Solve[Coefficient[Eqi,z, j] == 0,b[i, j]][[1]],Do[b[i, j] = b[i, j]/.Solve[Coefficient[Eqi,z, j] == 0,b[i, j]][[1]],Do[b[i, j] = b[i, j]/.Solve[Coefficient[Eqi,z, j] == 0,b[i, j]][[1]],
{ j, If[EvenQ[i],0,3], i,2}],{ j, If[EvenQ[i],0,3], i,2}],{ j, If[EvenQ[i],0,3], i,2}],
</p>
<p>{i,2,n+ 1}]{i,2,n+ 1}]{i,2,n+ 1}]
Now we know the frequency squared.</p>
<p/>
</div>
<div class="page"><p/>
<p>19.4 The nth Correction 151
</p>
<p>In[46] := w= wIn[46] := w= wIn[46] := w= w
</p>
<p>Out[46] = 1&minus; 3
2
</p>
<p>(
</p>
<p>5c[1]2 &minus; 2c[2]
)
</p>
<p>a2&minus;
3
</p>
<p>32
</p>
<p>(
</p>
<p>335c[1]4&minus; 572c[1]2c[2]&minus; 4c[2]2+ 280c[1]c[3]&minus; 40c[4]
)
</p>
<p>a4 +O[a]6
</p>
<p>and x(t)
In[47] := x[t] = x[t]In[47] := x[t] = x[t]In[47] := x[t] = x[t]
</p>
<p>Out[47] =Cos[t]a+
</p>
<p>(
</p>
<p>&minus;3c[1]
2
</p>
<p>+
1
</p>
<p>2
c[1]Cos[2t]
</p>
<p>)
</p>
<p>a2+
1
</p>
<p>16
</p>
<p>(
</p>
<p>3c[1]2 + 2c[2]
)
</p>
<p>Cos[3t]a3+
(
</p>
<p>&minus;3
8
</p>
<p>(
</p>
<p>19c[1]3 &minus; 20c[1]c[2]+ 5c[3]
)
</p>
<p>+
</p>
<p>1
</p>
<p>48
</p>
<p>(
</p>
<p>177c[1]3&minus; 186c[1]c[2]+ 40c[3]
)
</p>
<p>Cos[2t]+
</p>
<p>1
</p>
<p>48
</p>
<p>(
</p>
<p>3c[1]3 + 6c[1]c[2]+ 2c[3]
)
</p>
<p>Cos[4t]
</p>
<p>)
</p>
<p>a4+
(
</p>
<p>3
</p>
<p>256
</p>
<p>(
</p>
<p>237c[1]4&minus; 172c[1]2c[2]&minus; 28c[2]2&minus; 12c[1]c[3]+ 20c[4]
)
</p>
<p>Cos[3t]+
</p>
<p>1
</p>
<p>768
</p>
<p>(
</p>
<p>15c[1]4 + 60c[1]2c[2]+ 12c[2]2+ 44c[1]c[3]+ 12c[4]
)
</p>
<p>Cos[5t]
</p>
<p>)
</p>
<p>a5+
</p>
<p>O[a]6
</p>
<p>Let&rsquo;s check energy conservation.
</p>
<p>In[48] := Et = Map[TrigReduce,In[48] := Et = Map[TrigReduce,In[48] := Et = Map[TrigReduce,
ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]ExpandAll[w&lowast;D[x[t], t]&and;2/2+ x[t]&and;2/2+(V/.x&minus;&gt;x[t])]]
</p>
<p>Out[48] =
a2
</p>
<p>2
+
</p>
<p>1
</p>
<p>16
</p>
<p>(
</p>
<p>&minus;37c[1]2+ 18c[2]
)
</p>
<p>a4+
</p>
<p>1
</p>
<p>1536
</p>
<p>(
</p>
<p>&minus;9309c[1]4+ 17796c[1]2c[2]+ 300c[2]2&minus; 10880c[1]c[3]+
1920c[4])a6+
</p>
<p>O[a]7
</p>
<p>It is easy to write a function with the parameter n which can be used as a black box.
</p>
<p>It should use only local variables.
</p>
<p>Now we save the results for the energy Et and the frequency squared w to a file;
</p>
<p>later we&rsquo;ll compare them to the similar results in quantum mechanics.
</p>
<p>In[49] := Ec = Normal[Et]/.a&minus;&gt;Sqrt[2 &lowast;A];In[49] := Ec = Normal[Et]/.a&minus;&gt;Sqrt[2 &lowast;A];In[49] := Ec = Normal[Et]/.a&minus;&gt;Sqrt[2 &lowast;A];
Wc = Normal[Simplify[Sqrt[w]]]/.a&minus;&gt;Sqrt[2 &lowast;A];Wc = Normal[Simplify[Sqrt[w]]]/.a&minus;&gt;Sqrt[2 &lowast;A];Wc = Normal[Simplify[Sqrt[w]]]/.a&minus;&gt;Sqrt[2 &lowast;A];
Save[&rdquo;class.m&rdquo;,{Ec,Wc}]Save[&rdquo;class.m&rdquo;,{Ec,Wc}]Save[&rdquo;class.m&rdquo;,{Ec,Wc}]</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 20
</p>
<p>Quantum Nonlinear Oscillator
</p>
<p>20.1 Perturbation Theory
</p>
<p>Suppose we know eigenvalues and eigenstates of a Hamiltonian Ĥ0 and want to find
</p>
<p>them for a Hamiltonian Ĥ = Ĥ0+V̂ in the form of series in V̂ [18]. Let&rsquo;s concentrate
on a non-degenerate eigenstate of the unperturbed Hamiltonian
</p>
<p>Ĥ0 |ψ0&gt;= E0 |ψ0&gt;.
</p>
<p>After switching the perturbation on it transforms to a similar eigenstate of the full
</p>
<p>Hamiltonian
</p>
<p>Ĥ |ψ&gt;= E |ψ&gt;, E = E0 + δE .
Let&rsquo;s normalize |ψ&gt; in such a way that &lt;ψ0|ψ&gt; = 1, then |ψ&gt; = |ψ0&gt;+ |δψ&gt;,
&lt;ψ0|δψ&gt;= 0. We need to solve the equation
</p>
<p>Ĥ0 |ψ&gt;+ V̂ |ψ&gt;= E |ψ&gt;.
</p>
<p>Let&rsquo;s separate its components parallel and orthogonal to |ψ0&gt;. The parallel part is
singled out by multiplying by &lt;ψ0|:
</p>
<p>δE =&lt;ψ0|V̂ |ψ&gt;.
</p>
<p>The orthogonal part is singled out by the projector P̂= 1&minus;|ψ0&gt;&lt;ψ0|:
</p>
<p>Ĥ0 |δψ&gt;+ P̂V̂ |ψ&gt;= E |δψ&gt;,
</p>
<p>or
</p>
<p>|δψ&gt;= D̂V̂ |ψ&gt;, D̂= P̂
E&minus; Ĥ0
</p>
<p>.
</p>
<p>Solving this equation by iterations, we obtain
</p>
<p>|δψ&gt;= D̂V̂ |ψ0&gt;+ D̂V̂ D̂V̂ |ψ0&gt;+ &middot; &middot; &middot; ,
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 20, &copy; Springer International Publishing Switzerland 2014
</p>
<p>153</p>
<p/>
</div>
<div class="page"><p/>
<p>154 20 Quantum Nonlinear Oscillator
</p>
<p>and
</p>
<p>δE =&lt;ψ0|V̂ |ψ0&gt;+&lt; ψ0|V̂ D̂V̂ |ψ0&gt;+&lt;ψ0|V̂ D̂V̂ D̂V̂ |ψ0&gt;+ &middot; &middot; &middot; .
</p>
<p>Note that D̂ contains E = E0 + δE and should be expanded in δE:
</p>
<p>D̂= Ĝ&minus; ĜδEĜ+ ĜδEĜδEĜ&minus;&middot;&middot; &middot; , Ĝ= P̂
E0 &minus; Ĥ0
</p>
<p>.
</p>
<p>20.2 Nonlinear Oscillator
</p>
<p>We are going to apply the perturbation theory to the nonlinear oscillator
</p>
<p>Ĥ0 =
p̂2 + x̂2
</p>
<p>2
, V̂ =
</p>
<p>&infin;
</p>
<p>&sum;
k=1
</p>
<p>ckx̂
k+2 .
</p>
<p>The oscillation amplitude is &sim; 1 if n &sim; 1; therefore, ck &sim; ak, where a &sim; 1/L≪ 1,
L is the characteristic length of the potential in the oscillator units. If n ≫ 1, the
amplitude is
</p>
<p>&radic;
n times larger, and the real expansion parameter is a
</p>
<p>&radic;
n.
</p>
<p>We concentrate on the eigenstate |n&gt; of Ĥ0 having the energy E0 = n+ 12 . In
order to calculate δE up to the Mth order of the perturbation theory, we need to sum
all expressions of the form
</p>
<p>(
</p>
<p>V̂kN
</p>
<p>)
</p>
<p>n,n+ jN&minus;1
Ĝn+ jN&minus;1
</p>
<p>(
</p>
<p>Δ̂kN&minus;1
)
</p>
<p>n+ jN&minus;1,n+ jN&minus;2
Ĝn+ jN&minus;2 &middot; &middot; &middot;
</p>
<p>Ĝn+ j2
(
</p>
<p>Δ̂k2
)
</p>
<p>n+ j2,n+ j1
Ĝn+ j1
</p>
<p>(
</p>
<p>V̂k1
</p>
<p>)
</p>
<p>n+ j1,n
,
</p>
<p>where Δ̂ is V̂ or &minus;δE and the sum of the orders of smallness k1 + k2 + &middot; &middot; &middot;+ kN �
M; the sum over all nonzero j1, j2, . . . jN&minus;1 is assumed. The following procedure
prepares the values V [k, j] of
</p>
<p>(
</p>
<p>V̂k
)
</p>
<p>n+ j,n
(x[k, j] means
</p>
<p>(
</p>
<p>x̂k
)
</p>
<p>n+ j,n
):
</p>
<p>In[1] := Prepare[m ] := (M = m; x[1,1] = Sqrt[(n+ 1)/2]; x[1,&minus;1] = Sqrt[n/2];In[1] := Prepare[m ] := (M = m; x[1,1] = Sqrt[(n+ 1)/2]; x[1,&minus;1] = Sqrt[n/2];In[1] := Prepare[m ] := (M = m; x[1,1] = Sqrt[(n+ 1)/2]; x[1,&minus;1] = Sqrt[n/2];
x[1,0] = 0;x[1,0] = 0;x[1,0] = 0;
Do[x[k, j] = If[ j &lt; k&minus; 1,(x[1,1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j+ 1],0]+Do[x[k, j] = If[ j &lt; k&minus; 1,(x[1,1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j+ 1],0]+Do[x[k, j] = If[ j &lt; k&minus; 1,(x[1,1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j+ 1],0]+
</p>
<p>If[ j &gt; 1&minus; k,(x[1,&minus;1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j&minus; 1],0],If[ j &gt; 1&minus; k,(x[1,&minus;1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j&minus; 1],0],If[ j &gt; 1&minus; k,(x[1,&minus;1]/.n&rarr; n+ j)&lowast; x[k&minus; 1, j&minus; 1],0],
{k,2,m+ 2},{ j,&minus;k,k}];{k,2,m+ 2},{ j,&minus;k,k}];{k,2,m+ 2},{ j,&minus;k,k}];
</p>
<p>Do[V [k, j] = Simplify[c[k]&lowast; x[k+ 2, j]],{k,1,m},{ j,&minus;k&minus; 2,k+ 2,2}])Do[V [k, j] = Simplify[c[k]&lowast; x[k+ 2, j]],{k,1,m},{ j,&minus;k&minus; 2,k+ 2,2}])Do[V [k, j] = Simplify[c[k]&lowast; x[k+ 2, j]],{k,1,m},{ j,&minus;k&minus; 2,k+ 2,2}])
</p>
<p>20.3 Energy Levels
</p>
<p>The expressions we want to generate and calculate can be visualized as paths in the
</p>
<p>following graph:</p>
<p/>
</div>
<div class="page"><p/>
<p>20.3 Energy Levels 155
</p>
<p>In[2] := ParametricPlot[{{t,3&minus; 3 &lowast; t},{t,&minus;3+3&lowast; t},In[2] := ParametricPlot[{{t,3&minus; 3 &lowast; t},{t,&minus;3+ 3&lowast; t},In[2] := ParametricPlot[{{t,3&minus; 3 &lowast; t},{t,&minus;3+3&lowast; t},
{t/2,3/2 &lowast; t},{t/2,&minus;3/2&lowast; t}},{t,0,1},{t/2,3/2 &lowast; t},{t/2,&minus;3/2&lowast; t}},{t,0,1},{t/2,3/2 &lowast; t},{t/2,&minus;3/2&lowast; t}},{t,0,1},
PlotRange &rarr; {{0,1},{&minus;3,3}},AxesLabel&rarr; {l, j},PlotRange &rarr; {{0,1},{&minus;3,3}},AxesLabel&rarr; {l, j},PlotRange &rarr; {{0,1},{&minus;3,3}},AxesLabel&rarr; {l, j},
Ticks &rarr;{{0,{1/2,M/2},{1,M}},Ticks &rarr;{{0,{1/2,M/2},{1,M}},Ticks &rarr; {{0,{1/2,M/2},{1,M}},
</p>
<p>{{&minus;3,&minus;3 &lowast;M},{&minus;3/2,&minus;3/2&lowast;M},0,{3/2,3/2&lowast;M},{3,3&lowast;M}}}]{{&minus;3,&minus;3 &lowast;M},{&minus;3/2,&minus;3/2&lowast;M},0,{3/2,3/2&lowast;M},{3,3&lowast;M}}}]{{&minus;3,&minus;3 &lowast;M},{&minus;3/2,&minus;3/2&lowast;M},0,{3/2,3/2&lowast;M},{3,3&lowast;M}}}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[2] =</p>
<p/>
</div>
<div class="page"><p/>
<p>156 20 Quantum Nonlinear Oscillator
</p>
<p>Here l is the number of orders of smallness we need to distribute. We start at
</p>
<p>the point l = M, j = 0. At each step we consider all possible Δ̂k. If we choose
(
</p>
<p>V̂k
)
</p>
<p>n+ j+i,n+ j
, we move k steps to the left and i steps vertically. If we choose &minus;δ Ek,
</p>
<p>we move k steps to the left horizontally (this choice is not allowed as the first or
</p>
<p>the last step). Whenever we hit the j = 0 axis, we have a complete expression for
a contribution to δE . The fastest movement along j at varying l occurs when V̂1 is
used, and its velocity is 3. Hence, in order to have enough time to return to j = 0,
we should not leave the rhombus in the figure.
</p>
<p>Suppose we have already generated a right-hand part a of the expression up to
</p>
<p>some Ĝn+ j inclusively, and there remain l orders of smallness to distribute. The
</p>
<p>procedure considers all possible
(
</p>
<p>Δ̂k
)
</p>
<p>n+ j+i,n+ j
which can be inserted to the left of
</p>
<p>a. It may be &minus;δEk with all possible values of k (if we are not at the very first step
l =M), the maximum k is obtained from the rhombus. Or it may be
</p>
<p>(
</p>
<p>V̂k
)
</p>
<p>n+ j+i,n+ j
</p>
<p>with all possible values of k and i. V̂k = ckx̂
k+2 has nonzero matrix elements for i
</p>
<p>from&minus;k&minus;2 to k+2 in steps of 2. The limits of the i loop follow from the intersection
of this range with the rhombus, and the k loop terminates when this intersection
</p>
<p>disappears. If we happen to return to the initial state ( j+ i = 0), this means that
the generation of an expression is complete, and it should be added to the element
</p>
<p>of the list d which accumulates contributions to δE (this contribution may contain
lower-order δEk = de[k]). In all other cases, the procedure is called recursively, with
l replaced by l&minus; k, j by j+ i, and a multiplied by
</p>
<p>(
</p>
<p>Δ̂k
)
</p>
<p>n+ j+i,n+ j
and Ĝn+ j+i.
</p>
<p>In[3] := v[l , j ,a ] := (If[l ==M,d = Table[0,{M}],In[3] := v[l , j ,a ] := (If[l ==M,d = Table[0,{M}],In[3] := v[l , j ,a ] := (If[l ==M,d = Table[0,{M}],
Do[v[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus;Abs[ j]/3,2}]];Do[v[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus;Abs[ j]/3,2}]];Do[v[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus;Abs[ j]/3,2}]];
</p>
<p>Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),
v[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],v[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],v[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],
</p>
<p>{k,Min[l,1+(3 &lowast; l&minus;Abs[ j])/2]},{k,Min[l,1+(3 &lowast; l&minus;Abs[ j])/2]},{k,Min[l,1+(3 &lowast; l&minus;Abs[ j])/2]},
{i,Max[&minus;k&minus; 2,&minus;3 &lowast; (l&minus; k)&minus; j],Min[k+ 2,3 &lowast; (l&minus; k)&minus; j],2}]){i,Max[&minus;k&minus; 2,&minus;3 &lowast; (l&minus; k)&minus; j],Min[k+ 2,3 &lowast; (l&minus; k)&minus; j],2}]){i,Max[&minus;k&minus; 2,&minus;3 &lowast; (l&minus; k)&minus; j],Min[k+ 2,3 &lowast; (l&minus; k)&minus; j],2}])
</p>
<p>In[4] := Prepare[6]; v[M,0,1];In[4] := Prepare[6]; v[M,0,1];In[4] := Prepare[6]; v[M,0,1];
Now we substitute lower-order δ E into expressions for higher-order ones, to get
explicit formulas.
</p>
<p>In[5] := Do[de[k] = Simplify[d[[k]]]; Print[Collect[de[k],c[ ],Factor]],{k,2,M,2}]In[5] := Do[de[k] = Simplify[d[[k]]]; Print[Collect[de[k],c[ ],Factor]],{k,2,M,2}]In[5] := Do[de[k] = Simplify[d[[k]]]; Print[Collect[de[k],c[ ],Factor]],{k,2,M,2}]
1
</p>
<p>8
</p>
<p>(
</p>
<p>&minus;11&minus; 30n&minus; 30n2
)
</p>
<p>c[1]2 +
3
</p>
<p>4
</p>
<p>(
</p>
<p>1+ 2n+ 2n2
)
</p>
<p>c[2]
</p>
<p>&minus;15
32
</p>
<p>(1+ 2n)
(
</p>
<p>31+ 47n+ 47n2
)
</p>
<p>c[1]4 +
9
</p>
<p>8
(1+ 2n)
</p>
<p>(
</p>
<p>19+ 25n+ 25n2
)
</p>
<p>c[1]2c[2]&minus;
1
</p>
<p>8
(1+ 2n)
</p>
<p>(
</p>
<p>21+ 17n+ 17n2
)
</p>
<p>c[2]2 &minus; 5
8
(1+ 2n)
</p>
<p>(
</p>
<p>13+ 14n+ 14n2
)
</p>
<p>c[1]c[3]+
</p>
<p>5
</p>
<p>8
(1+ 2n)
</p>
<p>(
</p>
<p>3+ 2n+ 2n2
)
</p>
<p>c[4]
</p>
<p>1
</p>
<p>128
</p>
<p>(
</p>
<p>&minus;39709&minus; 162405n&minus;278160n2&minus; 231510n3&minus; 115755n4
)
</p>
<p>c[1]6+
</p>
<p>3
</p>
<p>64
</p>
<p>(
</p>
<p>15169+ 59385n+98160n2+ 77550n3+ 38775n4
)
</p>
<p>c[1]4c[2]+
</p>
<p>3
</p>
<p>16
</p>
<p>(
</p>
<p>111+ 347n+ 472n2+ 250n3+ 125n4
)
</p>
<p>c[2]3+</p>
<p/>
</div>
<div class="page"><p/>
<p>20.4 Correspondence Principle 157
</p>
<p>1
</p>
<p>16
</p>
<p>(
</p>
<p>&minus;4517&minus; 16815n&minus;26580n2&minus; 19530n3&minus; 9765n4
)
</p>
<p>c[1]3c[3]+
</p>
<p>1
</p>
<p>32
</p>
<p>(
</p>
<p>&minus;449&minus; 1400n&minus;2030n2&minus; 1260n3&minus; 630n4
)
</p>
<p>c[3]2&minus;
15
</p>
<p>8
</p>
<p>(
</p>
<p>12+ 35n+ 46n2+ 22n3+ 11n4
)
</p>
<p>c[2]c[4]+
</p>
<p>c[1]2
(
</p>
<p>1
</p>
<p>32
</p>
<p>(
</p>
<p>&minus;11827&minus; 43479n&minus;68424n2&minus; 49890n3&minus; 24945n4
)
</p>
<p>c[2]2+
</p>
<p>5
</p>
<p>16
</p>
<p>(
</p>
<p>323+ 1125n+1668n2+ 1086n3+ 543n4
)
</p>
<p>c[4]
</p>
<p>)
</p>
<p>+
</p>
<p>c[1]
</p>
<p>(
</p>
<p>3
</p>
<p>8
</p>
<p>(
</p>
<p>474+ 1625n+2430n2+ 1610n3+ 805n4
)
</p>
<p>c[2]c[3]&minus;
105
</p>
<p>16
</p>
<p>(
</p>
<p>5+ 16n+ 22n2+ 12n3+ 6n4
)
</p>
<p>c[5]
</p>
<p>)
</p>
<p>+
</p>
<p>35
</p>
<p>16
</p>
<p>(
</p>
<p>3+ 8n+ 10n2+ 4n3+ 2n4
)
</p>
<p>c[6]
</p>
<p>20.4 Correspondence Principle
</p>
<p>At n≫ 1 the expansion parameter of the perturbation series is a&radic;n where ck &sim; ak.
Keeping only the highest powers of n in each order, we have
</p>
<p>In[6] := Eq = Series[n+In[6] := Eq = Series[n+In[6] := Eq = Series[n+
Sum[(Expand[(de[2 &lowast; ( j&minus; 1)]/.n&rarr; 1/a)&lowast; a&and; j]/.a&rarr; 0)&lowast; n&and; j,Sum[(Expand[(de[2 &lowast; ( j&minus; 1)]/.n&rarr; 1/a)&lowast; a&and; j]/.a&rarr; 0)&lowast; n&and; j,Sum[(Expand[(de[2 &lowast; ( j&minus; 1)]/.n&rarr; 1/a)&lowast; a&and; j]/.a&rarr; 0)&lowast; n&and; j,
</p>
<p>{ j,2,M/2+ 1}],{ j,2,M/2+ 1}],{ j,2,M/2+ 1}],
{n,0,M/2+ 1}]{n,0,M/2+ 1}]{n,0,M/2+ 1}]
</p>
<p>Out[6] = n+
</p>
<p>(
</p>
<p>&minus;15
4
c[1]2 +
</p>
<p>3c[2]
</p>
<p>2
</p>
<p>)
</p>
<p>n2+
</p>
<p>1
</p>
<p>16
</p>
<p>(
</p>
<p>&minus;705c[1]4+ 900c[1]2c[2]&minus; 68c[2]2&minus; 280c[1]c[3]+ 40c[4]
)
</p>
<p>n3&minus;
5
</p>
<p>128
</p>
<p>(
</p>
<p>23151c[1]6&minus; 46530c[1]4c[2]+ 19956c[1]2c[2]2 &minus; 600c[2]3+
15624c[1]3c[3]&minus; 7728c[1]c[2]c[3]+504c[3]2&minus; 4344c[1]2c[4]+
528c[2]c[4]+ 1008c[1]c[5]&minus;112c[6]
</p>
<p>)
</p>
<p>n4+
</p>
<p>O[n]5
</p>
<p>Bohr&rsquo;s correspondence principle must hold. From the quantum point of view, the
</p>
<p>particle at the nth energy level can radiate a photon, jumping to the (n&minus;1)th one, or
more generally to the (n&minus; k)th one. The frequency of this photon is En&minus;En&minus;k, or
approximately dEndn k. From the classical point of view, the frequencies of the emit-
</p>
<p>ted light are equal to the oscillation frequency ω and its harmonics. Therefore, the
oscillation frequency is
</p>
<p>ω =
dEn
</p>
<p>dn
.</p>
<p/>
</div>
<div class="page"><p/>
<p>158 20 Quantum Nonlinear Oscillator
</p>
<p>In[7] := Wq = D[Eq,n]In[7] := Wq = D[Eq,n]In[7] := Wq = D[Eq,n]
</p>
<p>Out[7] = 1+ 2
</p>
<p>(
</p>
<p>&minus;15
4
c[1]2 +
</p>
<p>3c[2]
</p>
<p>2
</p>
<p>)
</p>
<p>n+
</p>
<p>3
</p>
<p>16
</p>
<p>(
</p>
<p>&minus;705c[1]4+ 900c[1]2c[2]&minus; 68c[2]2&minus; 280c[1]c[3]+ 40c[4]
)
</p>
<p>n2&minus;
5
</p>
<p>32
</p>
<p>(
</p>
<p>23151c[1]6&minus; 46530c[1]4c[2]+ 19956c[1]2c[2]2 &minus; 600c[2]3+
15624c[1]3c[3]&minus; 7728c[1]c[2]c[3]+504c[3]2&minus; 4344c[1]2c[4]+
528c[2]c[4]+ 1008c[1]c[5]&minus;112c[6]
</p>
<p>)
</p>
<p>n3+
</p>
<p>O[n]4
</p>
<p>We want to compare it with the result of the calculation in classical mechanics. But
</p>
<p>the quantum expression for ω is in terms of n and the classical one in terms of the
oscillation amplitude a. We need to re-express both of them via the same quantity,
</p>
<p>the energy E .
</p>
<p>In[8] := ne = InverseSeries[Eq,e]In[8] := ne = InverseSeries[Eq,e]In[8] := ne = InverseSeries[Eq,e]
</p>
<p>Out[8] = e+
3
</p>
<p>4
</p>
<p>(
</p>
<p>5c[1]2 &minus; 2c[2]
)
</p>
<p>e2+
</p>
<p>5
</p>
<p>16
</p>
<p>(
</p>
<p>231c[1]4&minus; 252c[1]2c[2]+ 28c[2]2+ 56c[1]c[3]&minus; 8c[4]
)
</p>
<p>e3+
</p>
<p>35
</p>
<p>128
</p>
<p>(
</p>
<p>7293c[1]6&minus; 12870c[1]4c[2]+ 5148c[1]2c[2]2 &minus; 264c[2]3+
3432c[1]3c[3]&minus; 1584c[1]c[2]c[3]+72c[3]2&minus; 792c[1]2c[4]+
144c[2]c[4]+ 144c[1]c[5]&minus;16c[6]
</p>
<p>)
</p>
<p>e4+
</p>
<p>O[e]5
</p>
<p>In[9] := Wqe = Simplify[Wq/.n&rarr; ne]In[9] := Wqe = Simplify[Wq/.n&rarr; ne]In[9] := Wqe = Simplify[Wq/.n&rarr; ne]
Out[9] = 1+
</p>
<p>(
</p>
<p>&minus;15
2
c[1]2 + 3c[2]
</p>
<p>)
</p>
<p>e&minus;
3
</p>
<p>16
</p>
<p>(
</p>
<p>855c[1]4&minus; 1020c[1]2c[2]+ 92c[2]2+ 280c[1]c[3]&minus; 40c[4]
)
</p>
<p>e2+
</p>
<p>1
</p>
<p>32
</p>
<p>(
</p>
<p>&minus;164805c[1]6+ 311670c[1]4c[2]&minus; 94920c[1]3c[3]&minus;
180c[1]2
</p>
<p>(
</p>
<p>715c[2]2&minus; 134c[4]
)
</p>
<p>+ 5040c[1](9c[2]c[3]&minus; c[5])+
8
(
</p>
<p>633c[2]3&minus; 315c[3]2&minus; 450c[2]c[4]+ 70c[6]
))
</p>
<p>e3+
</p>
<p>O[e]4
</p>
<p>Now we read the classical results for the energy Ec and the frequency Wc (written
</p>
<p>in terms of A= a2
/
</p>
<p>2, where the amplitude a is defined as the coefficient of the first
</p>
<p>harmonic cosωt).
In[10] :=&lt;&lt;class.m;In[10] :=&lt;&lt;class.m;In[10] :=&lt;&lt;class.m;
In[11] := Ec = Series[Ec,{A,0,3}]In[11] := Ec = Series[Ec,{A,0,3}]In[11] := Ec = Series[Ec,{A,0,3}]
Out[11] = A+
</p>
<p>(
</p>
<p>&minus;37
4
c[1]2 +
</p>
<p>9c[2]
</p>
<p>2
</p>
<p>)
</p>
<p>A2+
</p>
<p>1
</p>
<p>192
</p>
<p>(
</p>
<p>&minus;9309c[1]4+ 17796c[1]2c[2]+ 300c[2]2&minus; 10880c[1]c[3]+ 1920c[4]
)
</p>
<p>A3+
</p>
<p>O[A]4</p>
<p/>
</div>
<div class="page"><p/>
<p>20.5 States 159
</p>
<p>In[12] := Wc = Series[Wc,{A,0,2}]In[12] := Wc = Series[Wc,{A,0,2}]In[12] := Wc = Series[Wc,{A,0,2}]
Out[12] = 1+
</p>
<p>(
</p>
<p>&minus;15
2
c[1]2 + 3c[2]
</p>
<p>)
</p>
<p>A&minus;
3
</p>
<p>16
</p>
<p>(
</p>
<p>485c[1]4&minus; 692c[1]2c[2]+ 20c[2]2+ 280c[1]c[3]&minus; 40c[4]
)
</p>
<p>A2+
</p>
<p>O[A]3
</p>
<p>In[13] := Ae = Simplify[InverseSeries[Ec,e]]In[13] := Ae = Simplify[InverseSeries[Ec,e]]In[13] := Ae = Simplify[InverseSeries[Ec,e]]
</p>
<p>Out[13] = e+
</p>
<p>(
</p>
<p>37c[1]2
</p>
<p>4
&minus; 9c[2]
</p>
<p>2
</p>
<p>)
</p>
<p>e2+
(
</p>
<p>14055c[1]4
</p>
<p>64
&minus; 4147
</p>
<p>16
c[1]2c[2]+
</p>
<p>623c[2]2
</p>
<p>16
+
</p>
<p>170
</p>
<p>3
c[1]c[3]&minus; 10c[4]
</p>
<p>)
</p>
<p>e3+
</p>
<p>O[e]4
</p>
<p>In[14] := Wce = Simplify[Wc/.A&rarr; Ae]In[14] := Wce = Simplify[Wc/.A&rarr; Ae]In[14] := Wce = Simplify[Wc/.A&rarr; Ae]
Out[14] = 1+
</p>
<p>(
</p>
<p>&minus;15
2
c[1]2 + 3c[2]
</p>
<p>)
</p>
<p>e&minus;
3
</p>
<p>16
</p>
<p>(
</p>
<p>855c[1]4&minus; 1020c[1]2c[2]+ 92c[2]2+ 280c[1]c[3]&minus; 40c[4]
)
</p>
<p>e2+
</p>
<p>O[e]3
</p>
<p>In[15] := Wqe&minus;WceIn[15] := Wqe&minus;WceIn[15] := Wqe&minus;Wce
Out[15] = O[e]3
</p>
<p>20.5 States
</p>
<p>The following procedure accumulates contributions to δE in elements of the list d
and to |δψ&gt; in the list dp. Now we have to consider the large triangle in the figure,
not just the rhombus.
</p>
<p>In[16] := v2[l , j ,a ] := (dp[[M&minus; l]]+ = a &lowast; ket[n+ j];In[16] := v2[l , j ,a ] := (dp[[M&minus; l]]+ = a &lowast; ket[n+ j];In[16] := v2[l , j ,a ] := (dp[[M&minus; l]]+ = a &lowast; ket[n+ j];
If[l &lt;M,Do[v2[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus; 1,2}]];If[l &lt;M,Do[v2[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus; 1,2}]];If[l &lt;M,Do[v2[l&minus; k, j,a &lowast; de[k]/ j],{k,2, l&minus; 1,2}]];
Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),Do[If[ j+ i== 0,d[[M&minus; l+ k]]+ = a &lowast; (V [k, i]/.n&rarr; n+ j),
</p>
<p>v2[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],v2[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],v2[l&minus; k, j+ i,&minus;a &lowast; (V [k, i]/.n&rarr; n+ j)/( j+ i)]],
{k, l},{i,&minus;k&minus; 2,k+ 2,2}]){k, l},{i,&minus;k&minus; 2,k+ 2,2}]){k, l},{i,&minus;k&minus; 2,k+ 2,2}])
</p>
<p>In[17] := Prepare[2]; d = Table[0,{M}]; dp = Table[0,{M}];In[17] := Prepare[2]; d = Table[0,{M}]; dp = Table[0,{M}];In[17] := Prepare[2]; d = Table[0,{M}]; dp = Table[0,{M}];
Clear[de]; v2[M,0,1];Clear[de]; v2[M,0,1];Clear[de]; v2[M,0,1];
</p>
<p>In[18] := Do[de[k] = Simplify[d[[k]]];In[18] := Do[de[k] = Simplify[d[[k]]];In[18] := Do[de[k] = Simplify[d[[k]]];
Print[Collect[dp[[k]],ket[ ],Simplify]],{k,M}]Print[Collect[dp[[k]],ket[ ],Simplify]],{k,M}]Print[Collect[dp[[k]],ket[ ],Simplify]],{k,M}]&radic;
</p>
<p>&minus;2+ n
&radic;
&minus;1+ n&radic;nc[1]ket[&minus;3+ n]
</p>
<p>6
&radic;
</p>
<p>2
+
</p>
<p>3n3/2c[1]ket[&minus;1+ n]
2
&radic;
</p>
<p>2
&minus;
</p>
<p>3(1+ n)3/2c[1]ket[1+ n]
</p>
<p>2
&radic;
</p>
<p>2
&minus;
</p>
<p>&radic;
1+ n
</p>
<p>&radic;
2+ n
</p>
<p>&radic;
3+ nc[1]ket[3+ n]
</p>
<p>6
&radic;
</p>
<p>2
1
</p>
<p>144
</p>
<p>&radic;
&minus;5+ n
</p>
<p>&radic;
&minus;4+ n
</p>
<p>&radic;
&minus;3+ n
</p>
<p>&radic;
&minus;2+ n
</p>
<p>&radic;
&minus;1+ n
</p>
<p>&radic;
nc[1]2ket[&minus;6+ n]+
</p>
<p>1
</p>
<p>32
</p>
<p>&radic;
&minus;3+ n
</p>
<p>&radic;
&minus;2+ n
</p>
<p>&radic;
&minus;1+ n
</p>
<p>&radic;
n
(
</p>
<p>(&minus;3+ 4n)c[1]2+ 2c[2]
)
</p>
<p>ket[&minus;4+ n]+</p>
<p/>
</div>
<div class="page"><p/>
<p>160 20 Quantum Nonlinear Oscillator
</p>
<p>1
</p>
<p>16
</p>
<p>&radic;
&minus;1+ n
</p>
<p>&radic;
n
((
</p>
<p>1&minus; 19n+ 7n2
)
</p>
<p>c[1]2 + 4(&minus;1+ 2n)c[2]
)
</p>
<p>ket[&minus;2+ n]+
1
</p>
<p>16
</p>
<p>&radic;
1+ n
</p>
<p>&radic;
2+ n
</p>
<p>((
</p>
<p>27+ 33n+ 7n2
)
</p>
<p>c[1]2 &minus; 4(3+ 2n)c[2]
)
</p>
<p>ket[2+ n]+
</p>
<p>1
</p>
<p>32
</p>
<p>&radic;
1+ n
</p>
<p>&radic;
2+ n
</p>
<p>&radic;
3+ n
</p>
<p>&radic;
4+ n
</p>
<p>(
</p>
<p>(7+ 4n)c[1]2&minus; 2c[2]
)
</p>
<p>ket[4+ n]+
</p>
<p>1
</p>
<p>144
</p>
<p>&radic;
1+ n
</p>
<p>&radic;
2+ n
</p>
<p>&radic;
3+ n
</p>
<p>&radic;
4+ n
</p>
<p>&radic;
5+ n
</p>
<p>&radic;
6+ nc[1]2ket[6+ n]
</p>
<p>As an additional problem, calculate the average values of x̂k over the states just
</p>
<p>obtained, for several k. At n ≫ 1 compare them to the classical averages obtained
from the particle&rsquo;s motion x(t).</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 21
</p>
<p>Riemann Curvature Tensor
</p>
<p>Catching a lion, the Einstein&rsquo;s method: Enter the cage and lock
</p>
<p>it from inside. Then the Universe will be subdivided into two
</p>
<p>disjoint regions in such a way that you are in one of them and
</p>
<p>the lion is in the other one. It depends on one&rsquo;s point of view
</p>
<p>whom to consider caught; for convenience, let&rsquo;s say it&rsquo;s the
</p>
<p>lion.
</p>
<p>Suppose we have a coordinate system x&micro; in a region of an n-dimensional Rie-
</p>
<p>mann (or pseudo-Riemann) manifold [20]. Components of the metric tensor g&micro;ν are
</p>
<p>given as functions of x&micro; . We want to calculate the Riemann curvature tensor R&micro;ναβ
and related quantities (the Ricci tensor R&micro;ν , the scalar curvature R).
</p>
<p>The metric tensor is symmetric; therefore, it is reasonable to ask the user to pro-
</p>
<p>vide only the components with &micro; &ge; ν . If the user gives an argument having a wrong
shape, we print an error message and abort the calculation. We shall also need the
</p>
<p>contravariant metric tensor g&micro;ν defined by g&micro;λgλν = δ
&micro;
ν .
</p>
<p>In[1] := Metric[g0 ] := Module[{n= Length[g0],g,gu},In[1] := Metric[g0 ] := Module[{n= Length[g0],g,gu},In[1] := Metric[g0 ] := Module[{n= Length[g0],g,gu},
Do[If[Length[g0[[&micro; ]]]=!=&micro; ,Message[Metric :: shape];Abort[]],{&micro; ,n}];Do[If[Length[g0[[&micro; ]]]=!=&micro; ,Message[Metric :: shape];Abort[]],{&micro; ,n}];Do[If[Length[g0[[&micro; ]]]=!=&micro; ,Message[Metric :: shape];Abort[]],{&micro; ,n}];
g= Table[If[&micro; &ge; ν,g0[[&micro; ,ν]],g0[[ν,&micro; ]]],{&micro; ,n},{ν,n}];g= Table[If[&micro; &ge; ν,g0[[&micro; ,ν]],g0[[ν,&micro; ]]],{&micro; ,n},{ν,n}];g= Table[If[&micro; &ge; ν,g0[[&micro; ,ν]],g0[[ν,&micro; ]]],{&micro; ,n},{ν,n}];
gu = Simplify[Inverse[g]]; {n,g,gu}]gu = Simplify[Inverse[g]]; {n,g,gu}]gu = Simplify[Inverse[g]]; {n,g,gu}]
</p>
<p>In[2] := Metric :: shape = &rdquo;Wrong shape of the argument&rdquo;;In[2] := Metric :: shape = &rdquo;Wrong shape of the argument&rdquo;;In[2] := Metric :: shape = &rdquo;Wrong shape of the argument&rdquo;;
Next we calculate the Christoffel symbols
</p>
<p>Γλ&micro;ν =
1
</p>
<p>2
</p>
<p>(
</p>
<p>&part;&micro;gλν + &part;νgλ&micro; &minus; &part;λg&micro;ν
)
</p>
<p>and Γ λ &micro;ν = gλρΓρ&micro;ν . They are symmetric in &micro; and ν; therefore, we calculate them
only at ν � &micro; and reuse the calculated values at ν &gt; &micro; . If the optional parameter
PrintNonZero is True, nonzero components are printed (following the tradition, in
</p>
<p>the printed results all indices vary from 0 to n&minus; 1).
In[3] := Christoffel[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u},In[3] := Christoffel[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u},In[3] := Christoffel[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u},
</p>
<p>Γ = Γ u = Table[0,{λ ,n},{&micro; ,n},{ν,n}];Γ = Γ u = Table[0,{λ ,n},{&micro; ,n},{ν,n}];Γ = Γ u = Table[0,{λ ,n},{&micro; ,n},{ν,n}];
Do[Γ [[λ ,&micro; ,ν]] = Simplify[(D[g[[λ ,ν]],x[&micro; ]]+D[g[[λ ,&micro; ]],x[ν]]&minus;Do[Γ [[λ ,&micro; ,ν]] = Simplify[(D[g[[λ ,ν]],x[&micro; ]]+D[g[[λ ,&micro; ]],x[ν]]&minus;Do[Γ [[λ ,&micro; ,ν]] = Simplify[(D[g[[λ ,ν]],x[&micro; ]]+D[g[[λ ,&micro; ]],x[ν]]&minus;
</p>
<p>D[g[[&micro; ,ν]],x[λ ]])/2];D[g[[&micro; ,ν]],x[λ ]])/2];D[g[[&micro; ,ν]],x[λ ]])/2];
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 21, &copy; Springer International Publishing Switzerland 2014
</p>
<p>161</p>
<p/>
</div>
<div class="page"><p/>
<p>162 21 Riemann Curvature Tensor
</p>
<p>If[&micro; &#13;= ν,Γ [[λ ,ν,&micro; ]] = Γ [[λ ,&micro; ,ν]]],If[&micro; &#13;= ν,Γ [[λ ,ν,&micro; ]] = Γ [[λ ,&micro; ,ν]]],If[&micro; &#13;= ν,Γ [[λ ,ν,&micro; ]] = Γ [[λ ,&micro; ,ν]]],
{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];
</p>
<p>Do[Γ u[[λ ,&micro; ,ν]] = Simplify[Sum[gu[[λ ,ρ ]]&lowast;Γ [[ρ ,&micro; ,ν]],{ρ ,n}]];Do[Γ u[[λ ,&micro; ,ν]] = Simplify[Sum[gu[[λ ,ρ ]]&lowast;Γ [[ρ ,&micro; ,ν]],{ρ ,n}]];Do[Γ u[[λ ,&micro; ,ν]] = Simplify[Sum[gu[[λ ,ρ ]]&lowast;Γ [[ρ ,&micro; ,ν]],{ρ ,n}]];
If[&micro; &#13;= ν,Γ u[[λ ,ν,&micro; ]] = Γ u[[λ ,&micro; ,ν]]],If[&micro; &#13;= ν,Γ u[[λ ,ν,&micro; ]] = Γ u[[λ ,&micro; ,ν]]],If[&micro; &#13;= ν,Γ u[[λ ,ν,&micro; ]] = Γ u[[λ ,&micro; ,ν]]],
</p>
<p>{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];
If[OptionValue[PrintNonZero],If[OptionValue[PrintNonZero],If[OptionValue[PrintNonZero],
</p>
<p>Do[If[Γ [[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ &rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ [[λ ,&micro; ,ν]]]],Do[If[Γ [[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ &rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ [[λ ,&micro; ,ν]]]],Do[If[Γ [[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ &rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ [[λ ,&micro; ,ν]]]],
{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];{λ ,n},{&micro; ,n},{ν,&micro;}];
</p>
<p>Do[If[Γ u[[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ u&rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ u[[λ ,&micro; ,ν]]]],Do[If[Γ u[[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ u&rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ u[[λ ,&micro; ,ν]]]],Do[If[Γ u[[λ ,&micro; ,ν]]=!=0,Print[&rdquo;Γ u&rdquo;,λ &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,Γ u[[λ ,&micro; ,ν]]]],
{λ ,n},{&micro; ,n},{ν,&micro;}]];{λ ,n},{&micro; ,n},{ν,&micro;}]];{λ ,n},{&micro; ,n},{ν,&micro;}]];
</p>
<p>{Γ ,Γ u}]{Γ ,Γ u}]{Γ ,Γ u}]
In[4] := Options[Christoffel] = {PrintNonZero&rarr; True};In[4] := Options[Christoffel] = {PrintNonZero&rarr; True};In[4] := Options[Christoffel] = {PrintNonZero&rarr; True};
</p>
<p>Finally, we calculate the Riemann tensor
</p>
<p>Rαβ&micro;ν = gαλ
</p>
<p>(
</p>
<p>&part;&micro;Γ λ βν &minus; &part;νΓ λ β&micro;
)
</p>
<p>+Γαλ&micro;Γ
λ
βν &minus;ΓαλνΓ λ β&micro; ,
</p>
<p>the Ricci tensor R&micro;ν = g
αβRα&micro;βν , and the scalar curvature R = g
</p>
<p>&micro;νR&micro;ν . The Rie-
</p>
<p>mann tensor has the properties
</p>
<p>Rαβ&micro;ν =&minus;Rβα&micro;ν =&minus;Rαβν&micro; = R&micro;ναβ ,
and we use them to avoid unnecessary calculations.
</p>
<p>In[5] := Riemann[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u,In[5] := Riemann[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u,In[5] := Riemann[{n ,g ,gu },OptionsPattern[]] := Module[{Γ ,Γ u,
R= Table[0,{α,n},{β ,n},{&micro; ,n},{ν,n}],R2= Table[0,{&micro; ,n},{ν,n}],R0},R= Table[0,{α,n},{β ,n},{&micro; ,n},{ν,n}],R2= Table[0,{&micro; ,n},{ν,n}],R0},R= Table[0,{α,n},{β ,n},{&micro; ,n},{ν,n}],R2= Table[0,{&micro; ,n},{ν,n}],R0},
</p>
<p>{Γ ,Γ u}= Christoffel[{n,g,gu}];{Γ ,Γ u}= Christoffel[{n,g,gu}];{Γ ,Γ u}= Christoffel[{n,g,gu}];
Do[R[[α,β ,&micro; ,ν]] = R[[β ,α,ν,&micro; ]] = Simplify[Sum[Do[R[[α,β ,&micro; ,ν]] = R[[β ,α,ν,&micro; ]] = Simplify[Sum[Do[R[[α,β ,&micro; ,ν]] = R[[β ,α,ν,&micro; ]] = Simplify[Sum[
</p>
<p>g[[α,λ ]]&lowast; (D[Γu[[λ ,β ,ν]],x[&micro; ]]&minus;D[Γ u[[λ ,β ,&micro; ]],x[ν]])g[[α,λ ]]&lowast; (D[Γu[[λ ,β ,ν]],x[&micro; ]]&minus;D[Γ u[[λ ,β ,&micro; ]],x[ν]])g[[α,λ ]]&lowast; (D[Γu[[λ ,β ,ν]],x[&micro; ]]&minus;D[Γu[[λ ,β ,&micro; ]],x[ν]])
+Γ [[α,λ ,&micro; ]]&lowast;Γu[[λ ,β ,ν]]&minus;Γ [[α,λ ,ν]]&lowast;Γ u[[λ ,β ,&micro; ]],{λ ,n}]];+Γ [[α,λ ,&micro; ]]&lowast;Γu[[λ ,β ,ν]]&minus;Γ [[α,λ ,ν]]&lowast;Γ u[[λ ,β ,&micro; ]],{λ ,n}]];+Γ [[α,λ ,&micro; ]]&lowast;Γu[[λ ,β ,ν]]&minus;Γ [[α,λ ,ν]]&lowast;Γ u[[λ ,β ,&micro; ]],{λ ,n}]];
</p>
<p>R[[β ,α,&micro; ,ν]] = R[[α,β ,ν,&micro; ]] =&minus;R[[α,β ,&micro; ,ν]];R[[β ,α,&micro; ,ν]] = R[[α,β ,ν,&micro; ]] =&minus;R[[α,β ,&micro; ,ν]];R[[β ,α,&micro; ,ν]] = R[[α,β ,ν,&micro; ]] =&minus;R[[α,β ,&micro; ,ν]];
If[&micro; &#13;= α,R[[&micro; ,ν,α,β ]] = R[[ν,&micro; ,β ,α]] = R[[α,β ,&micro; ,ν]];If[&micro; &#13;= α,R[[&micro; ,ν,α,β ]] = R[[ν,&micro; ,β ,α]] = R[[α,β ,&micro; ,ν]];If[&micro; &#13;= α,R[[&micro; ,ν,α,β ]] = R[[ν,&micro; ,β ,α]] = R[[α,β ,&micro; ,ν]];
R[[ν,&micro; ,α,β ]] = R[[&micro; ,ν,β ,α]] =&minus;R[[α,β ,&micro; ,ν]]],R[[ν,&micro; ,α,β ]] = R[[&micro; ,ν,β ,α]] =&minus;R[[α,β ,&micro; ,ν]]],R[[ν,&micro; ,α,β ]] = R[[&micro; ,ν,β ,α]] =&minus;R[[α,β ,&micro; ,ν]]],
</p>
<p>{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];
Do[R2[[&micro; ,ν]] = Simplify[Sum[gu[[α,β ]]&lowast;R[[α,&micro; ,β ,ν]],{α,n},{β ,n}]];Do[R2[[&micro; ,ν]] = Simplify[Sum[gu[[α,β ]]&lowast;R[[α,&micro; ,β ,ν]],{α,n},{β ,n}]];Do[R2[[&micro; ,ν]] = Simplify[Sum[gu[[α,β ]]&lowast;R[[α,&micro; ,β ,ν]],{α,n},{β ,n}]];
</p>
<p>If[&micro; &#13;= ν,R2[[ν,&micro; ]] = R2[[&micro; ,ν]]],If[&micro; &#13;= ν,R2[[ν,&micro; ]] = R2[[&micro; ,ν]]],If[&micro; &#13;= ν,R2[[ν,&micro; ]] = R2[[&micro; ,ν]]],
{&micro; ,n},{ν,&micro;}];{&micro; ,n},{ν,&micro;}];{&micro; ,n},{ν,&micro;}];
</p>
<p>R0 = Simplify[Sum[gu[[&micro; ,ν]]&lowast;R2[[&micro; ,ν]]&lowast; If[&micro; &#13;= ν,2,1],{&micro; ,n},{ν,&micro;}]];R0 = Simplify[Sum[gu[[&micro; ,ν]]&lowast;R2[[&micro; ,ν]]&lowast; If[&micro; &#13;= ν,2,1],{&micro; ,n},{ν,&micro;}]];R0 = Simplify[Sum[gu[[&micro; ,ν]]&lowast;R2[[&micro; ,ν]]&lowast; If[&micro; &#13;= ν,2,1],{&micro; ,n},{ν,&micro;}]];
If[OptionValue[PrintNonZero],If[OptionValue[PrintNonZero],If[OptionValue[PrintNonZero],
</p>
<p>Do[If[R[[α,β ,&micro; ,ν]]=!=0,Do[If[R[[α,β ,&micro; ,ν]]=!=0,Do[If[R[[α,β ,&micro; ,ν]]=!=0,
Print[R,α&minus; 1,β &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R[[α,β ,&micro; ,ν]]]],Print[R,α&minus; 1,β &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R[[α,β ,&micro; ,ν]]]],Print[R,α&minus; 1,β &minus; 1,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R[[α,β ,&micro; ,ν]]]],
</p>
<p>{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];{α,2,n},{β ,α&minus; 1},{&micro; ,2,α},{ν, If[&micro; === α,β ,&micro;&minus; 1]}];
Do[If[R2[[&micro; ,ν]]=!=0,Print[&rdquo;R&rdquo;,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R2[[&micro; ,ν]]]],{&micro; ,n},{ν,&micro;}];Do[If[R2[[&micro; ,ν]]=!=0,Print[&rdquo;R&rdquo;,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R2[[&micro; ,ν]]]],{&micro; ,n},{ν,&micro;}];Do[If[R2[[&micro; ,ν]]=!=0,Print[&rdquo;R&rdquo;,&micro;&minus; 1,ν&minus; 1,&rdquo; &rdquo;,R2[[&micro; ,ν]]]],{&micro; ,n},{ν,&micro;}];
If[R0=!=0,Print[&rdquo;R &rdquo;,R0]]];If[R0=!=0,Print[&rdquo;R &rdquo;,R0]]];If[R0=!=0,Print[&rdquo;R &rdquo;,R0]]];
</p>
<p>{R,R2,R0}]{R,R2,R0}]{R,R2,R0}]
In[6] := Options[Riemann] = {PrintNonZero&rarr; True};In[6] := Options[Riemann] = {PrintNonZero&rarr; True};In[6] := Options[Riemann] = {PrintNonZero&rarr; True};
</p>
<p>Let&rsquo;s consider an example: the Schwarzschild metric
</p>
<p>ds2 =
(
</p>
<p>1&minus; r0
r
</p>
<p>)
</p>
<p>dt2 &minus; dr
2
</p>
<p>1&minus; r0
r
</p>
<p>&minus; r2
(
</p>
<p>dθ 2 + sin2 θdϕ2
)
</p>
<p>.</p>
<p/>
</div>
<div class="page"><p/>
<p>21 Riemann Curvature Tensor 163
</p>
<p>First we give names to the coordinates.
</p>
<p>In[7] := Evaluate[Table[x[&micro; ],{&micro; ,4}]] = {t,r,θ ,ϕ};In[7] := Evaluate[Table[x[&micro; ],{&micro; ,4}]] = {t,r,θ ,ϕ};In[7] := Evaluate[Table[x[&micro; ],{&micro; ,4}]] = {t,r,θ ,ϕ};
Setting the Schwarzschild radius r0 = 1, we obtain
In[8] := Riemann[Metric[{{1&minus; 1/r},{0,&minus;1/(1&minus;1/r)},{0,0,&minus;r&and;2},In[8] := Riemann[Metric[{{1&minus; 1/r},{0,&minus;1/(1&minus;1/r)},{0,0,&minus;r&and;2},In[8] := Riemann[Metric[{{1&minus; 1/r},{0,&minus;1/(1&minus;1/r)},{0,0,&minus;r&and;2},
</p>
<p>{0,0,0,&minus;r&and;2 &lowast;Sin[θ ]&and;2}}]];{0,0,0,&minus;r&and;2 &lowast;Sin[θ ]&and;2}}]];{0,0,0,&minus;r&and;2 &lowast;Sin[θ ]&and;2}}]];
Γ 010
</p>
<p>1
</p>
<p>2r2
</p>
<p>Γ 100 &minus; 1
2r2
</p>
<p>Γ 111
1
</p>
<p>2(&minus;1+ r)2
Γ 122 r
Γ 133 rSin[θ ]2
</p>
<p>Γ 221 &minus; r
Γ 233 r2Cos[θ ]Sin[θ ]
Γ 331 &minus; rSin[θ ]2
Γ 332 &minus; r2Cos[θ ]Sin[θ ]
Γ u010
</p>
<p>1
</p>
<p>2(&minus;1+ r)r
Γ u100
</p>
<p>&minus;1+ r
2r3
</p>
<p>Γ u111
1
</p>
<p>2r&minus; 2r2
Γ u122 1&minus; r
Γ u133 &minus; (&minus;1+ r)Sin[θ ]2
</p>
<p>Γ u221
1
</p>
<p>r
Γ u233 &minus;Cos[θ ]Sin[θ ]
Γ u331
</p>
<p>1
</p>
<p>r
Γ u332 Cot[θ ]
</p>
<p>R1010
1
</p>
<p>r3
</p>
<p>R2020 &minus; &minus;1+ r
2r2
</p>
<p>R2121
1
</p>
<p>2(&minus;1+ r)
</p>
<p>R3030 &minus; (&minus;1+ r)Sin[θ ]
2
</p>
<p>2r2
</p>
<p>R3131
Sin[θ ]2
</p>
<p>&minus;2+ 2r
R3232 &minus; rSin[θ ]2
The Ricci tensor (and hence the scalar curvature) vanishes. Therefore, the
</p>
<p>Schwarzschild metric satisfies the vacuum Einstein equation.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 22
</p>
<p>Multi-ζ Functions
</p>
<p>22.1 Definition
</p>
<p>The Riemann ζ -function is defined by
</p>
<p>ζs = &sum;
n&gt;0
</p>
<p>1
</p>
<p>ns
.
</p>
<p>Mathematica knows this function; it can be expressed via powers of π for even
integer values of s.
</p>
<p>In[1] := Table[Zeta[s],{s,2,6}]In[1] := Table[Zeta[s],{s,2,6}]In[1] := Table[Zeta[s],{s,2,6}]
</p>
<p>Out[1] =
</p>
<p>{
</p>
<p>π2
</p>
<p>6
,Zeta[3],
</p>
<p>π4
</p>
<p>90
,Zeta[5],
</p>
<p>π6
</p>
<p>945
</p>
<p>}
</p>
<p>Let&rsquo;s define
</p>
<p>ζs1s2 = &sum;
n1&gt;n2&gt;0
</p>
<p>1
</p>
<p>n
s1
1 n
</p>
<p>s2
2
</p>
<p>, ζs1s2s3 = &sum;
n1&gt;n2&gt;n3&gt;0
</p>
<p>1
</p>
<p>n
s1
1 n
</p>
<p>s2
2 n
</p>
<p>s3
3
</p>
<p>,
</p>
<p>and so on. These series converge at s1 &gt; 1. Mathematica does not know these multi-
ζ functions. The sum s1 + s2 + &middot; &middot; &middot;+ sk is called the weight. All relations we shall
discuss contain terms of the same weight (the weight of a product is the sum of the
</p>
<p>weights of its factors).
</p>
<p>22.2 Stuffling Relations
</p>
<p>Suppose we want to multiply ζsζs1s2 :
</p>
<p>ζsζs1s2 = &sum;
n&gt;0
</p>
<p>n1&gt;n2&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>.
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 22, &copy; Springer International Publishing Switzerland 2014
</p>
<p>165</p>
<p/>
</div>
<div class="page"><p/>
<p>166 22 Multi-ζ Functions
</p>
<p>Here n can be anywhere with respect to n1, n2. There are five contributions:
</p>
<p>&sum;
n&gt;n1&gt;n2&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>= ζss1s2 ,
</p>
<p>&sum;
n=n1&gt;n2&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>= ζs+s1,s2 ,
</p>
<p>&sum;
n1&gt;n&gt;n2&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>= ζs1ss2 ,
</p>
<p>&sum;
n1&gt;n=n2&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>= ζs1,s+s2 ,
</p>
<p>&sum;
n1&gt;n2&gt;n&gt;0
</p>
<p>1
</p>
<p>nsn
s1
1 n
</p>
<p>s2
2
</p>
<p>= ζs1s2s .
</p>
<p>This process reminds shuffling cards. The order of cards in the upper deck, as well
</p>
<p>as in the lower one, is kept fixed. We sum over all possible shufflings. Unlike real
</p>
<p>playing cards, however, two cards may be exactly on top of each other. In this case
</p>
<p>they are stuffed together: a single card (which is their sum) appears in the result-
</p>
<p>ing deck. A mathematical jargon term for such shuffling with (possible) stuffing is
</p>
<p>stuffling.
</p>
<p>In[2] := Show[Import[&rdquo;c1.jpg&rdquo;]]In[2] := Show[Import[&rdquo;c1.jpg&rdquo;]]In[2] := Show[Import[&rdquo;c1.jpg&rdquo;]]</p>
<p/>
</div>
<div class="page"><p/>
<p>22.3 Integral Representation 167
</p>
<p>Let&rsquo;s implement this in Mathematica. The multi-ζ function will be called ζ ; it
can have any number of arguments. The function Stuffling first of all transforms
</p>
<p>products of ζ functions (including squares) to a local function z with three list pa-
rameters: the first two contain the arguments of the initial ζ functions, and the third
one is empty. These are our two decks for shuffling and the resulting deck, initially
</p>
<p>empty. All the work is done by the following repeated substitution. Let the two un-
</p>
<p>processed decks be nonempty: the first one contains some front &ldquo;card&rdquo; a and the
</p>
<p>remainder A ; the second one&mdash;the front &ldquo;card&rdquo; b and the remainder B . Then
</p>
<p>there are three possibilities: either we move the front &ldquo;card&rdquo; from the first deck (a)
</p>
<p>to the resulting deck, or we move the front &ldquo;card&rdquo; from the second deck (b) to the
</p>
<p>resulting deck, or we take the front &ldquo;cards&rdquo; from both decks and put their sum to
</p>
<p>the resulting deck (stuffing). We need to use a delayed substitution :&gt; here to ensure
that the command Expand in its right-hand side is executed when the substitution
</p>
<p>is applied. In addition to this, we should take care of the situations when one of the
</p>
<p>source decks becomes empty. In this case we can just append the other source deck
</p>
<p>to the resulting one and yield the result.
</p>
<p>This process can also be described as the following. The final result is a sum
</p>
<p>of many ζ functions with various argument lists. During intermediate steps, the
function z[deck1,deck2, res] represents the sum of a subset of terms of the result
whose argument lists begin with res. At each step we subdivide this sum into three
</p>
<p>parts, according to three possible values of the next argument.
</p>
<p>In[3] := Stuffling[x ] := Module[{y,z},y= x/.In[3] := Stuffling[x ] := Module[{y,z},y= x/.In[3] := Stuffling[x ] := Module[{y,z},y= x/.
{ζ [A ]&and;2&minus;&gt;z[{A},{A},{}],ζ [A ]&lowast; ζ [B ]&minus;&gt;z[{A},{B},{}]};{ζ [A ]&and;2&minus;&gt;z[{A},{A},{}],ζ [A ]&lowast; ζ [B ]&minus;&gt;z[{A},{B},{}]};{ζ [A ]&and;2&minus;&gt;z[{A},{A},{}],ζ [A ]&lowast; ζ [B ]&minus;&gt;z[{A},{B},{}]};
</p>
<p>y//.{z[{},{B },{C }]&minus;&gt;ζ [C,B],z[{A },{},{C }]&minus;&gt;ζ [C,A],y//.{z[{},{B },{C }]&minus;&gt;ζ [C,B],z[{A },{},{C }]&minus;&gt;ζ [C,A],y//.{z[{},{B },{C }]&minus;&gt;ζ [C,B],z[{A },{},{C }]&minus;&gt;ζ [C,A],
z[{a ,A },{b ,B },{C }] : &gt;z[{a ,A },{b ,B },{C }] : &gt;z[{a ,A },{b ,B },{C }] : &gt;
</p>
<p>Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]+Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]+Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]+
z[{A},{B},{C,a+ b}]]}]z[{A},{B},{C,a+ b}]]}]z[{A},{B},{C,a+ b}]]}]
</p>
<p>In[4] := Map[Stuffling,{ζ [x]&and;2,ζ [x]&lowast; ζ [y],ζ [x]&lowast; ζ [y,z]}]In[4] := Map[Stuffling,{ζ [x]&and;2,ζ [x]&lowast; ζ [y],ζ [x]&lowast; ζ [y,z]}]In[4] := Map[Stuffling,{ζ [x]&and;2,ζ [x]&lowast; ζ [y],ζ [x]&lowast; ζ [y,z]}]
Out[4] = {ζ [2x]+ 2ζ [x,x],ζ [x+ y]+ ζ [x,y]+ ζ [y,x],
</p>
<p>ζ [y,x+ z]+ ζ [x+ y,z]+ ζ [x,y,z]+ ζ [y,x,z]+ ζ [y,z,x]}
</p>
<p>22.3 Integral Representation
</p>
<p>It is easy to check the integral representation of the ζ -function of an integer
argument
</p>
<p>ζs =
&int;
</p>
<p>1&gt;x1&gt;&middot;&middot;&middot;&gt;xs&gt;0
</p>
<p>dx1
</p>
<p>x1
&middot; &middot; &middot; dxs&minus;1
</p>
<p>xs&minus;1
</p>
<p>dxs
</p>
<p>1&minus; xs
.
</p>
<p>Let&rsquo;s denote
</p>
<p>ω0 =
dx
</p>
<p>x
, ω1 =
</p>
<p>dx
</p>
<p>1&minus; x .</p>
<p/>
</div>
<div class="page"><p/>
<p>168 22 Multi-ζ Functions
</p>
<p>All integrals will always have the integration region 1 &gt; x1 &gt; &middot; &middot; &middot;&gt; xs &gt; 0. Then
</p>
<p>ζs =
&int;
</p>
<p>ωs&minus;10 ω1 .
</p>
<p>This representation can be generalized to multi-ζ functions:
</p>
<p>ζs1s2 =
&int;
</p>
<p>ωs1&minus;10 ω1ω
s2&minus;1
0 ω1 , ζs1s2s3 =
</p>
<p>&int;
</p>
<p>ωs1&minus;10 ω1ω
s2&minus;1
0 ω1ω
</p>
<p>s3&minus;1
0 ω1 ,
</p>
<p>and so on. Let&rsquo;s write functions for transforming ζ with integer arguments to such
integral representation and back. The integral representation ζ i takes an arbitrary
number of arguments equal to 0 or 1 corresponding to ω0, ω1.
In[5] := s2i[x ] := Module[{y,z},y= x/.ζ [A ]&minus;&gt;z[{A},{}];In[5] := s2i[x ] := Module[{y,z},y= x/.ζ [A ]&minus;&gt;z[{A},{}];In[5] := s2i[x ] := Module[{y,z},y= x/.ζ [A ]&minus;&gt;z[{A},{}];
</p>
<p>y//.{z[{},{B }]&minus;&gt;ζ i[B],y//.{z[{},{B }]&minus;&gt;ζ i[B],y//.{z[{},{B }]&minus;&gt;ζ i[B],
z[{a ,A },{B }] : &gt;z[{a ,A },{B }] : &gt;z[{a ,A },{B }] : &gt;
</p>
<p>z[{A},Append[Join[{B},Table[0,{a&minus; 1}]],1]]}]z[{A},Append[Join[{B},Table[0,{a&minus; 1}]],1]]}]z[{A},Append[Join[{B},Table[0,{a&minus; 1}]],1]]}]
In[6] := l = Map[s2i,{ζ [2],ζ [2,3]}]In[6] := l = Map[s2i,{ζ [2],ζ [2,3]}]In[6] := l = Map[s2i,{ζ [2],ζ [2,3]}]
Out[6] = {ζ i[0,1],ζ i[0,1,0,0,1]}
In[7] := i2s[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{1}];In[7] := i2s[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{1}];In[7] := i2s[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{1}];
</p>
<p>y//.{z[{1},{B }]&minus;&gt;ζ [B],y//.{z[{1},{B }]&minus;&gt;ζ [B],y//.{z[{1},{B }]&minus;&gt;ζ [B],
z[{a ,A },{B ,b }] : &gt;z[{a ,A },{B ,b }] : &gt;z[{a ,A },{B ,b }] : &gt;
</p>
<p>If[a== 0,z[{A},{B,b+ 1}],z[{A},{B,b,1}]]}]If[a== 0,z[{A},{B,b+ 1}],z[{A},{B,b,1}]]}]If[a== 0,z[{A},{B,b+ 1}],z[{A},{B,b,1}]]}]
In[8] := Map[i2s, l]In[8] := Map[i2s, l]In[8] := Map[i2s, l]
Out[8] = {ζ [2],ζ [2,3]}
In[9] := Clear[l]In[9] := Clear[l]In[9] := Clear[l]
</p>
<p>22.4 Shuffling Relations
</p>
<p>Suppose we want to multiply ζ2 &middot;ζ2:
</p>
<p>ζ 22 =
&int;
</p>
<p>1&gt;x1&gt;x2&gt;0
</p>
<p>ω0ω1 &middot;
&int;
</p>
<p>1&gt;x&prime;1&gt;x
&prime;
2&gt;0
</p>
<p>ω0ω1 .
</p>
<p>The order of primed and non-primed integration variables is not fixed. There are six
</p>
<p>contributions:
</p>
<p>1 &gt; x1 &gt; x2 &gt; x
&prime;
1 &gt; x
</p>
<p>&prime;
2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω1ω0ω1 = ζ22 ;
</p>
<p>1 &gt; x1 &gt; x
&prime;
1 &gt; x2 &gt; x
</p>
<p>&prime;
2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω0ω1ω1 = ζ31 ;
</p>
<p>1 &gt; x1 &gt; x
&prime;
1 &gt; x
</p>
<p>&prime;
2 &gt; x2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω0ω1ω1 = ζ31 ;</p>
<p/>
</div>
<div class="page"><p/>
<p>22.4 Shuffling Relations 169
</p>
<p>1 &gt; x&prime;1 &gt; x1 &gt; x2 &gt; x
&prime;
2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω0ω1ω1 = ζ31 ;
</p>
<p>1 &gt; x&prime;1 &gt; x1 &gt; x
&prime;
2 &gt; x2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω0ω1ω1 = ζ31 ;
</p>
<p>1 &gt; x&prime;1 &gt; x
&prime;
2 &gt; x1 &gt; x2 &gt; 0 :
</p>
<p>&int;
</p>
<p>ω0ω1ω0ω1 = ζ22 .
</p>
<p>Now we are multiplying integrals, not sums. Therefore our &ldquo;cards&rdquo; are now in-
</p>
<p>finitely thin and cannot be exactly on top of each other. There are just two kinds of
</p>
<p>&ldquo;cards&rdquo;: ω0 and ω1, and we sum over all possible shufflings of two decks.
</p>
<p>In[10] := Show[Import[&rdquo;c2.jpg&rdquo;]]In[10] := Show[Import[&rdquo;c2.jpg&rdquo;]]In[10] := Show[Import[&rdquo;c2.jpg&rdquo;]]
</p>
<p>In[11] := shuffling[x ] := Module[{y,z},y= x/.In[11] := shuffling[x ] := Module[{y,z},y= x/.In[11] := shuffling[x ] := Module[{y,z},y= x/.
{ζ i[A ]&and;2&minus;&gt;z[{A},{A},{}],{ζ i[A ]&and;2&minus;&gt;z[{A},{A},{}],{ζ i[A ]&and;2&minus;&gt;z[{A},{A},{}],
ζ i[A ]&lowast; ζ i[B ]&minus;&gt;z[{A},{B},{}]};ζ i[A ]&lowast; ζ i[B ]&minus;&gt;z[{A},{B},{}]};ζ i[A ]&lowast; ζ i[B ]&minus;&gt;z[{A},{B},{}]};
</p>
<p>y//.{z[{},{B },{C }]&minus;&gt;ζ i[C,B],z[{A },{},{C }]&minus;&gt;ζ i[C,A],y//.{z[{},{B },{C }]&minus;&gt;ζ i[C,B],z[{A },{},{C }]&minus;&gt;ζ i[C,A],y//.{z[{},{B },{C }]&minus;&gt;ζ i[C,B],z[{A },{},{C }]&minus;&gt;ζ i[C,A],
z[{a ,A },{b ,B },{C }] : &gt;z[{a ,A },{b ,B },{C }] : &gt;z[{a ,A },{b ,B },{C }] : &gt;
</p>
<p>Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]]}]Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]]}]Expand[z[{A},{b,B},{C,a}]+ z[{a,A},{B},{C,b}]]}]
In[12] := Shuffling[x ] := i2s[Expand[shuffling[s2i[x]]]]In[12] := Shuffling[x ] := i2s[Expand[shuffling[s2i[x]]]]In[12] := Shuffling[x ] := i2s[Expand[shuffling[s2i[x]]]]
In[13] := Map[Shuffling,{ζ [2]&and;2,ζ [2]&lowast; ζ [3],ζ [2]&lowast; ζ [2,1]}]In[13] := Map[Shuffling,{ζ [2]&and;2,ζ [2]&lowast; ζ [3],ζ [2]&lowast; ζ [2,1]}]In[13] := Map[Shuffling,{ζ [2]&and;2,ζ [2]&lowast; ζ [3],ζ [2]&lowast; ζ [2,1]}]
Out[13] = {2ζ [2,2]+ 4ζ [3,1],ζ [2,3]+ 3ζ [3,2]+6ζ [4,1],
</p>
<p>ζ [2,1,2]+ 3ζ [2,2,1]+ 6ζ [3,1,1]}</p>
<p/>
</div>
<div class="page"><p/>
<p>170 22 Multi-ζ Functions
</p>
<p>22.5 Duality Relations
</p>
<p>The integral representation allows us to derive another set of useful relations, even
</p>
<p>simpler than shuffling&mdash;duality relations. Let&rsquo;s make the substitution xi &rarr; 1&minus; xi.
Then ω0 &larr;&rarr; ω1; to preserve the order 1 &gt; x1 &gt; &middot; &middot; &middot; &gt; xs &gt; 0, we have to arrange
all the ω factors in the opposite order. In other words, after writing down an integral
representation for a multi-ζ value, we may read it in the Arabic fashion, right to left,
simultaneously replacing ω0 &larr;&rarr;ω1. Duality relations are the only known relations
which say that two multi-ζ values with distinct arguments are just equal to each
other.
</p>
<p>In[14] := duality[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{}];In[14] := duality[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{}];In[14] := duality[x ] := Module[{y,z},y= x/.ζ i[A ]&minus;&gt;z[{A},{}];
y//.{z[{},{B }]&minus;&gt;ζ i[B],z[{a ,A },{B }]&minus;&gt;z[{A},{1&minus; a,B}]}]y//.{z[{},{B }]&minus;&gt;ζ i[B],z[{a ,A },{B }]&minus;&gt;z[{A},{1&minus; a,B}]}]y//.{z[{},{B }]&minus;&gt;ζ i[B],z[{a ,A },{B }]&minus;&gt;z[{A},{1&minus; a,B}]}]
</p>
<p>In[15] := Duality[x ] := i2s[duality[s2i[x]]]In[15] := Duality[x ] := i2s[duality[s2i[x]]]In[15] := Duality[x ] := i2s[duality[s2i[x]]]
In[16] := Map[Duality,{ζ [3],ζ [4],ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]In[16] := Map[Duality,{ζ [3],ζ [4],ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]In[16] := Map[Duality,{ζ [3],ζ [4],ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]
Out[16] = {ζ [2,1],ζ [2,1,1],ζ [2,1,1,1],ζ [3,1,1],ζ [2,2,1],ζ [2,1,2]}
</p>
<p>22.6 Weight 4
</p>
<p>There are four converging multi-ζ series of weight 4: ζ4, ζ31, ζ22, and ζ211. Due to
duality, two of them are equal to each other.
</p>
<p>In[17] := Duality[ζ [4]]In[17] := Duality[ζ [4]]In[17] := Duality[ζ [4]]
Out[17] = ζ [2,1,1]
We can express ζ4 via ζ 22 using their explicit values:
In[18] := S = ζ [4]&minus;&gt;Zeta[4]/Zeta[2]&and;2 &lowast; ζ [2]&and;2In[18] := S = ζ [4]&minus;&gt;Zeta[4]/Zeta[2]&and;2 &lowast; ζ [2]&and;2In[18] := S = ζ [4]&minus;&gt;Zeta[4]/Zeta[2]&and;2 &lowast; ζ [2]&and;2
</p>
<p>Out[18] = ζ [4]&rarr; 2ζ [2]
2
</p>
<p>5
Two equations for ζ 22 follow from stuffling
In[19] := eq1 = ζ [2]&and;2 == Stuffling[ζ [2]&and;2]In[19] := eq1 = ζ [2]&and;2 == Stuffling[ζ [2]&and;2]In[19] := eq1 = ζ [2]&and;2 == Stuffling[ζ [2]&and;2]
Out[19] = ζ [2]2 == ζ [4]+ 2ζ [2,2]
and shuffling
</p>
<p>In[20] := eq2 = ζ [2]&and;2 == Shuffling[ζ [2]&and;2]In[20] := eq2 = ζ [2]&and;2 == Shuffling[ζ [2]&and;2]In[20] := eq2 = ζ [2]&and;2 == Shuffling[ζ [2]&and;2]
Out[20] = ζ [2]2 == 2ζ [2,2]+ 4ζ [3,1]
They can be solved for ζ22 and ζ31 (taking the expression for ζ4 into account).
In[21] := s= Solve[{eq1/.S,eq2},{ζ [2,2],ζ [3,1]}][[1]]In[21] := s= Solve[{eq1/.S,eq2},{ζ [2,2],ζ [3,1]}][[1]]In[21] := s= Solve[{eq1/.S,eq2},{ζ [2,2],ζ [3,1]}][[1]]
</p>
<p>Out[21] =
</p>
<p>{
</p>
<p>ζ [2,2]&rarr; 3ζ [2]
2
</p>
<p>10
,ζ [3,1]&rarr; ζ [2]
</p>
<p>2
</p>
<p>10
</p>
<p>}
</p>
<p>Thus we have demonstrated that all multi-ζ values of weight 4 can be expressed
via ζ 22 .
In[22] := Clear[S]In[22] := Clear[S]In[22] := Clear[S]</p>
<p/>
</div>
<div class="page"><p/>
<p>22.7 Weight 5 171
</p>
<p>22.7 Weight 5
</p>
<p>There are four distinct multi-ζ values of weight 5,
In[23] := Map[Duality,{ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]In[23] := Map[Duality,{ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]In[23] := Map[Duality,{ζ [5],ζ [4,1],ζ [3,2],ζ [2,3]}]
Out[23] = {ζ [2,1,1,1],ζ [3,1,1],ζ [2,2,1],ζ [2,1,2]}
due to duality. The stuffling relation for ζ2ζ3:
In[24] := eq1 = ζ [2]&lowast; ζ [3] == Stuffling[ζ [2]&lowast; ζ [3]]In[24] := eq1 = ζ [2]&lowast; ζ [3] == Stuffling[ζ [2]&lowast; ζ [3]]In[24] := eq1 = ζ [2]&lowast; ζ [3] == Stuffling[ζ [2]&lowast; ζ [3]]
Out[24] = ζ [2]ζ [3] == ζ [5]+ ζ [2,3]+ ζ [3,2]
A similar equation where ζ3 is written in the dual form.
In[25] := eq2 = Stuffling[ζ [2]&lowast;Duality[ζ [3]]]In[25] := eq2 = Stuffling[ζ [2]&lowast;Duality[ζ [3]]]In[25] := eq2 = Stuffling[ζ [2]&lowast;Duality[ζ [3]]]
Out[25] = ζ [2,3]+ ζ [4,1]+ ζ [2,1,2]+ 2ζ [2,2,1]
In[26] := eq2 = eq2/.{ζ [2,1,2] : &gt;Duality[ζ [2,1,2]],In[26] := eq2 = eq2/.{ζ [2,1,2] : &gt;Duality[ζ [2,1,2]],In[26] := eq2 = eq2/.{ζ [2,1,2] : &gt;Duality[ζ [2,1,2]],
</p>
<p>ζ [2,2,1] : &gt;Duality[ζ [2,2,1]]}ζ [2,2,1] : &gt;Duality[ζ [2,2,1]]}ζ [2,2,1] : &gt;Duality[ζ [2,2,1]]}
Out[26] = 2ζ [2,3]+ 2ζ [3,2]+ ζ [4,1]
In[27] := eq2 = ζ [2]&lowast; ζ [3] == eq2In[27] := eq2 = ζ [2]&lowast; ζ [3] == eq2In[27] := eq2 = ζ [2]&lowast; ζ [3] == eq2
Out[27] = ζ [2]ζ [3] == 2ζ [2,3]+ 2ζ [3,2]+ ζ [4,1]
The shuffling relation for ζ2ζ3:
In[28] := eq3 = ζ [2]&lowast; ζ [3] == Shuffling[ζ [2]&lowast; ζ [3]]In[28] := eq3 = ζ [2]&lowast; ζ [3] == Shuffling[ζ [2]&lowast; ζ [3]]In[28] := eq3 = ζ [2]&lowast; ζ [3] == Shuffling[ζ [2]&lowast; ζ [3]]
Out[28] = ζ [2]ζ [3] == ζ [2,3]+ 3ζ [3,2]+ 6ζ [4,1]
This system can be solved for ζ41, ζ32, and ζ23.
In[29] := s= Solve[{eq1,eq2,eq3},{ζ [4,1],ζ [3,2],ζ [2,3]}][[1]]In[29] := s= Solve[{eq1,eq2,eq3},{ζ [4,1],ζ [3,2],ζ [2,3]}][[1]]In[29] := s= Solve[{eq1,eq2,eq3},{ζ [4,1],ζ [3,2],ζ [2,3]}][[1]]
Out[29] =
</p>
<p>{
</p>
<p>ζ [4,1]&rarr;&minus;ζ [2]ζ [3]+ 2ζ [5],ζ [3,2]&rarr; 3ζ [2]ζ [3]&minus; 11ζ [5]
2
</p>
<p>,
</p>
<p>ζ [2,3]&rarr;&minus;2ζ [2]ζ [3]+ 9ζ [5]
2
</p>
<p>}
</p>
<p>Thus we have demonstrated that all multi-ζ values of weight 5 can be expressed via
ζ2ζ3 and ζ5.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 23
</p>
<p>Rainbow
</p>
<p>23.1 Statement of the Problem
</p>
<p>We consider scattering of light by a spherical water drop in geometrical optics. For
</p>
<p>small drops, diffraction becomes significant; our analysis is only valid for drops
</p>
<p>which are not too small. Let the drop radius be 1. The ray with the impact parameter
</p>
<p>ρ splits into the reflected ray and the refracted one. Their directions are given by the
Snell law
</p>
<p>In[1] := Snell = {α&minus;&gt;ArcSin[ρ ],β&minus;&gt;ArcSin[ρ/n]};In[1] := Snell = {α&minus;&gt;ArcSin[ρ ],β&minus;&gt;ArcSin[ρ/n]};In[1] := Snell = {α&minus;&gt;ArcSin[ρ ],β&minus;&gt;ArcSin[ρ/n]};
where the refraction index of water is
</p>
<p>In[2] := Water = n&minus;&gt;1.333;In[2] := Water = n&minus;&gt;1.333;In[2] := Water = n&minus;&gt;1.333;
In[3] := col = {RGBColor[1,0,0],RGBColor[0,0,1],RGBColor[0,1,0],In[3] := col = {RGBColor[1,0,0],RGBColor[0,0,1],RGBColor[0,1,0],In[3] := col = {RGBColor[1,0,0],RGBColor[0,0,1],RGBColor[0,1,0],
</p>
<p>RGBColor[1,0,1],RGBColor[0,1,1],RGBColor[1,1,0]};RGBColor[1,0,1],RGBColor[0,1,1],RGBColor[1,1,0]};RGBColor[1,0,1],RGBColor[0,1,1],RGBColor[1,1,0]};
In[4] := With[{y= 0.6},In[4] := With[{y= 0.6},In[4] := With[{y= 0.6},
</p>
<p>With[{α = α/.Snell/.ρ&minus;&gt;y,β = β/.Snell/.ρ&minus;&gt;y/.Water,With[{α = α/.Snell/.ρ&minus;&gt;y,β = β/.Snell/.ρ&minus;&gt;y/.Water,With[{α = α/.Snell/.ρ&minus;&gt;y,β = β/.Snell/.ρ&minus;&gt;y/.Water,
x=&minus;Sqrt[1&minus; y&and;2]},x=&minus;Sqrt[1&minus; y&and;2]},x=&minus;Sqrt[1&minus; y&and;2]},
</p>
<p>With[{ϕ = π&minus;α,ϑ = π&minus; 2 &lowast;α},With[{ψ = ϕ+ 2 &lowast;β &minus;π},With[{ϕ = π&minus;α,ϑ = π&minus; 2 &lowast;α},With[{ψ = ϕ+ 2 &lowast;β &minus;π},With[{ϕ = π&minus;α,ϑ = π&minus; 2 &lowast;α},With[{ψ = ϕ+ 2 &lowast;β &minus;π},
Graphics[{Black,Circle[],Line[{{&minus;2,0},{1.2,0}}],Graphics[{Black,Circle[],Line[{{&minus;2,0},{1.2,0}}],Graphics[{Black,Circle[],Line[{{&minus;2,0},{1.2,0}}],
</p>
<p>Line[{{0,0},{2 &lowast;Cos[ϕ ],2 &lowast;Sin[ϕ ]}}],Line[{{0,0},{2 &lowast;Cos[ϕ ],2 &lowast;Sin[ϕ ]}}],Line[{{0,0},{2 &lowast;Cos[ϕ ],2 &lowast;Sin[ϕ ]}}],
Line[{{0,0},{Cos[ψ ],Sin[ψ ]}}],Line[{{0,0},{Cos[ψ ],Sin[ψ ]}}],Line[{{0,0},{Cos[ψ ],Sin[ψ ]}}],
Line[{{x,y},{x,0}}],col[[1]],Line[{{&minus;2,y},{x,y}}],Line[{{x,y},{x,0}}],col[[1]],Line[{{&minus;2,y},{x,y}}],Line[{{x,y},{x,0}}],col[[1]],Line[{{&minus;2,y},{x,y}}],
col[[2]],Line[{{x,y},{x+ 1.5 &lowast;Cos[ϑ ],y+ 1.5 &lowast;Sin[ϑ ]}}],col[[2]],Line[{{x,y},{x+ 1.5 &lowast;Cos[ϑ ],y+ 1.5 &lowast;Sin[ϑ ]}}],col[[2]],Line[{{x,y},{x+ 1.5 &lowast;Cos[ϑ ],y+ 1.5 &lowast;Sin[ϑ ]}}],
col[[3]],Line[{{x,y},{Cos[ψ ],Sin[ψ ]}}],col[[3]],Line[{{x,y},{Cos[ψ ],Sin[ψ ]}}],col[[3]],Line[{{x,y},{Cos[ψ ],Sin[ψ ]}}],
Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.25,0.1}],Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.25,0.1}],Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.25,0.1}],
Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.25,y+ 0.1}],Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.25,y+ 0.1}],Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.25,y+ 0.1}],
Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.15,y+ 0.25}],Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.15,y+ 0.25}],Inset[Style[&rdquo;α&rdquo;,24],{x&minus; 0.15,y+ 0.25}],
Inset[Style[&rdquo;β&rdquo;,24],{x+ 0.35,y&minus; 0.15}],Inset[Style[&rdquo;β&rdquo;,24],{x+ 0.35,y&minus; 0.15}],Inset[Style[&rdquo;β&rdquo;,24],{x+ 0.35,y&minus; 0.15}],
Inset[Style[&rdquo;ρ&rdquo;,24],{x+ 0.1,0.5 &lowast; y}]}]]]]]Inset[Style[&rdquo;ρ&rdquo;,24],{x+ 0.1,0.5 &lowast; y}]}]]]]]Inset[Style[&rdquo;ρ&rdquo;,24],{x+ 0.1,0.5 &lowast; y}]}]]]]]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 23, &copy; Springer International Publishing Switzerland 2014
</p>
<p>173</p>
<p/>
</div>
<div class="page"><p/>
<p>174 23 Rainbow
</p>
<p>a
</p>
<p>a
</p>
<p>r
</p>
<p>a
</p>
<p>b
Out[4] =
</p>
<p>The incident ray hits the drop at the point {Cos[ϕ ],Sin[ϕ ]}, where ϕ = π &minus;α .
The reflected ray has the direction ϑ = π &minus; 2α . The refracted ray hits the drop
surface again at {Cos[ψ ],Sin[ψ ]}, where ψ = ϕ+ 2β &minus;π .
</p>
<p>The incident light has two polarizations, with the electric field orthogonal to the
</p>
<p>scattering plane or lying in this plane. The reflection coefficients for these polariza-
</p>
<p>tions are given by the Fresnel formulas [21] (they don&rsquo;t depend on the direction, i.e.,
</p>
<p>are the same for a ray entering water and a ray leaving it).
</p>
<p>In[5] := Rs = (Sin[α&minus;β ]/Sin[α+β ])&and;2; Rp = (Tan[α&minus;β ]/Tan[α+β ])&and;2;In[5] := Rs = (Sin[α&minus;β ]/Sin[α+β ])&and;2; Rp = (Tan[α&minus;β ]/Tan[α+β ])&and;2;In[5] := Rs = (Sin[α&minus;β ]/Sin[α+β ])&and;2; Rp = (Tan[α&minus;β ]/Tan[α+β ])&and;2;
</p>
<p>23.2 0 Ray Segments Inside the Drop
</p>
<p>First let&rsquo;s consider rays reflected by the drop immediately after they hit its surface.
</p>
<p>In[6] := Ray0[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[6] := Ray0[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[6] := Ray0[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,
β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},
</p>
<p>With[{ϑ = π&minus; 2 &lowast;α},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],With[{ϑ = π&minus; 2 &lowast;α},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],With[{ϑ = π&minus; 2 &lowast;α},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],
col[[2]],Line[{{x,y},{x+ a &lowast;Cos[ϑ ],y+ a &lowast;Sin[ϑ ]}}]}]]col[[2]],Line[{{x,y},{x+ a &lowast;Cos[ϑ ],y+ a &lowast;Sin[ϑ ]}}]}]]col[[2]],Line[{{x,y},{x+ a &lowast;Cos[ϑ ],y+ a &lowast;Sin[ϑ ]}}]}]]
</p>
<p>In[7] := Manipulate[Graphics[Join[{Black,Circle[]},Ray0[y,a]],In[7] := Manipulate[Graphics[Join[{Black,Circle[]},Ray0[y,a]],In[7] := Manipulate[Graphics[Join[{Black,Circle[]},Ray0[y,a]],
PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],
</p>
<p>{{y,0.6},0,1},{{a,2},1,10}]{{y,0.6},0,1},{{a,2},1,10}]{{y,0.6},0,1},{{a,2},1,10}]</p>
<p/>
</div>
<div class="page"><p/>
<p>23.2 0 Ray Segments Inside the Drop 175
</p>
<p>y
</p>
<p>a
</p>
<p>Out[7] =
</p>
<p>In[8] := Manipulate[In[8] := Manipulate[In[8] := Manipulate[
Graphics[Graphics[Graphics[
</p>
<p>Join[{Black,Circle[]},Join[{Black,Circle[]},Join[{Black,Circle[]},
With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},
</p>
<p>If[δ &gt; 0,Apply[Join,Table[Ray0[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray0[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray0[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],
PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1.1,a+0.7}}],
</p>
<p>{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},
{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]</p>
<p/>
</div>
<div class="page"><p/>
<p>176 23 Rainbow
</p>
<p>10M
</p>
<p>rmin
</p>
<p>rmax
</p>
<p>a
</p>
<p>Out[8] =
</p>
<p>The scattering angle is
</p>
<p>In[9] := ϑ0 = π&minus; 2 &lowast;α;In[9] := ϑ0 = π&minus; 2 &lowast;α;In[9] := ϑ0 = π&minus; 2 &lowast;α;
In[10] := Plot[Evaluate[ϑ0/.Snell],{ρ ,0,1}]In[10] := Plot[Evaluate[ϑ0/.Snell],{ρ ,0,1}]In[10] := Plot[Evaluate[ϑ0/.Snell],{ρ ,0,1}]
</p>
<p>Out[10] =
</p>
<p>In order to calculate the differential cross section, we need to express ρ via the
scattering angle ϑ :</p>
<p/>
</div>
<div class="page"><p/>
<p>23.2 0 Ray Segments Inside the Drop 177
</p>
<p>In[11] := sol0 = Simplify[Solve[(ϑ0/.Snell) == ϑ ,ρ ],0 &lt; ϑ &lt; π ]In[11] := sol0 = Simplify[Solve[(ϑ0/.Snell) == ϑ ,ρ ],0 &lt; ϑ &lt; π ]In[11] := sol0 = Simplify[Solve[(ϑ0/.Snell) == ϑ ,ρ ],0 &lt; ϑ &lt; π ]
</p>
<p>Out[11] =
</p>
<p>{{
</p>
<p>ρ &rarr; Cos
[
</p>
<p>ϑ
2
</p>
<p>]}}
</p>
<p>In[12] := ρ0 = ρ/.sol0[[1]]In[12] := ρ0 = ρ/.sol0[[1]]In[12] := ρ0 = ρ/.sol0[[1]]
</p>
<p>Out[12] = Cos
</p>
<p>[
</p>
<p>ϑ
2
</p>
<p>]
</p>
<p>In[13] := Clear[sol0]In[13] := Clear[sol0]In[13] := Clear[sol0]
The angles α and β are
In[14] := Snell0 = {α&minus;&gt;(π&minus;ϑ)/2,β&minus;&gt;ArcSin[Sin[α]/n]};In[14] := Snell0 = {α&minus;&gt;(π&minus;ϑ)/2,β&minus;&gt;ArcSin[Sin[α]/n]};In[14] := Snell0 = {α&minus;&gt;(π&minus;ϑ)/2,β&minus;&gt;ArcSin[Sin[α]/n]};
The area of the ring in the transverse plane corresponding to the scattering angles
</p>
<p>between ϑ and ϑ + dϑ , divided by dΩ = 2π Sin[ϑ ]dϑ , is
In[15] := σ0 = Simplify[&minus;D[ρ0&and;2,ϑ ]/(2 &lowast;Sin[ϑ ])]In[15] := σ0 = Simplify[&minus;D[ρ0&and;2,ϑ ]/(2 &lowast;Sin[ϑ ])]In[15] := σ0 = Simplify[&minus;D[ρ0&and;2,ϑ ]/(2 &lowast;Sin[ϑ ])]
Out[15] =
</p>
<p>1
</p>
<p>4
Therefore, the cross sections for the two polarizations are
</p>
<p>In[16] := σ0s[ϑ ] = Simplify[σ0&lowast;Rs//.Snell0/.Water];In[16] := σ0s[ϑ ] = Simplify[σ0&lowast;Rs//.Snell0/.Water];In[16] := σ0s[ϑ ] = Simplify[σ0&lowast;Rs//.Snell0/.Water];
σ0p[ϑ ] = Simplify[σ0&lowast;Rp//.Snell0/.Water];σ0p[ϑ ] = Simplify[σ0&lowast;Rp//.Snell0/.Water];σ0p[ϑ ] = Simplify[σ0&lowast;Rp//.Snell0/.Water];
</p>
<p>In[17] := Plot[{σ0s[ϑ ],σ0p[ϑ ],(σ0s[ϑ ]+σ0p[ϑ ])/2},{ϑ ,0,π},In[17] := Plot[{σ0s[ϑ ],σ0p[ϑ ],(σ0s[ϑ ]+σ0p[ϑ ])/2},{ϑ ,0,π},In[17] := Plot[{σ0s[ϑ ],σ0p[ϑ ],(σ0s[ϑ ]+σ0p[ϑ ])/2},{ϑ ,0,π},
PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]
</p>
<p>Out[17] =
</p>
<p>Note that there is a scattering angle ϑ at which the scattered light is completely
polarized: its electric field is orthogonal to the scattering plane. This happens when
</p>
<p>α is equal to the Brewster angle αB
In[18] := αB = ArcTan[n]; αB/.WaterIn[18] := αB = ArcTan[n]; αB/.WaterIn[18] := αB = ArcTan[n]; αB/.Water
Out[18] = 0.927175
In this case
</p>
<p>In[19] := βB = ArcTan[1/n];In[19] := βB = ArcTan[1/n];In[19] := βB = ArcTan[1/n];
so that αB+βB = π/2 &mdash;the refracted ray is perpendicular to the reflected one:</p>
<p/>
</div>
<div class="page"><p/>
<p>178 23 Rainbow
</p>
<p>In[20] := Graphics[{Line[{{&minus;1,0},{1,0}}],Line[{{0,&minus;1},{0,1}}],In[20] := Graphics[{Line[{{&minus;1,0},{1,0}}],Line[{{0,&minus;1},{0,1}}],In[20] := Graphics[{Line[{{&minus;1,0},{1,0}}],Line[{{0,&minus;1},{0,1}}],
col[[1]],Line[{{0,0},{&minus;1,1/n}}],col[[1]],Line[{{0,0},{&minus;1,1/n}}],col[[1]],Line[{{0,0},{&minus;1,1/n}}],
col[[2]],Line[{{0,0},{1,1/n}}],col[[2]],Line[{{0,0},{1,1/n}}],col[[2]],Line[{{0,0},{1,1/n}}],
col[[3]],Line[{{0,0},{1/n,&minus;1}}],col[[3]],Line[{{0,0},{1/n,&minus;1}}],col[[3]],Line[{{0,0},{1/n,&minus;1}}],
Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.06,0.13}], Inset[Style[&rdquo;α&rdquo;,24],{0.06,0.13}],Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.06,0.13}], Inset[Style[&rdquo;α&rdquo;,24],{0.06,0.13}],Black, Inset[Style[&rdquo;α&rdquo;,24],{&minus;0.06,0.13}], Inset[Style[&rdquo;α&rdquo;,24],{0.06,0.13}],
Inset[Style[&rdquo;β&rdquo;,24],{0.06,&minus;0.13}]}]/.WaterInset[Style[&rdquo;β&rdquo;,24],{0.06,&minus;0.13}]}]/.WaterInset[Style[&rdquo;β&rdquo;,24],{0.06,&minus;0.13}]}]/.Water
</p>
<p>a a
</p>
<p>b
</p>
<p>Out[20] =
</p>
<p>When the incoming light with the electric field in the scattering plane reaches water,
</p>
<p>electric dipoles in it oscillate along the direction perpendicular to the refracted ray;
</p>
<p>they don&rsquo;t radiate in the direction along this axis, i.e., don&rsquo;t produce the reflected
</p>
<p>ray: Rp = 0.
In[21] := Plot[σ0p[ϑ ],{ϑ ,0,π},PlotRange&minus;&gt;{0,0.01}]In[21] := Plot[σ0p[ϑ ],{ϑ ,0,π},PlotRange&minus;&gt;{0,0.01}]In[21] := Plot[σ0p[ϑ ],{ϑ ,0,π},PlotRange&minus;&gt;{0,0.01}]
</p>
<p>Out[21] =
</p>
<p>In[22] := ϑ0/.α&minus;&gt;αB/.WaterIn[22] := ϑ0/.α&minus;&gt;αB/.WaterIn[22] := ϑ0/.α&minus;&gt;αB/.Water
Out[22] = 1.28724</p>
<p/>
</div>
<div class="page"><p/>
<p>23.3 1 Ray Segment Inside the Drop 179
</p>
<p>23.3 1 Ray Segment Inside the Drop
</p>
<p>In[23] := Ray1[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[23] := Ray1[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[23] := Ray1[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,
β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},
</p>
<p>With[{ϕ = π&minus;α,ϑ = 2 &lowast; (β &minus;α)},With[{ψ = ϕ+ 2 &lowast;β&minus;π},With[{ϕ = π&minus;α,ϑ = 2 &lowast; (β &minus;α)},With[{ψ = ϕ+ 2 &lowast;β &minus;π},With[{ϕ = π&minus;α,ϑ = 2 &lowast; (β &minus;α)},With[{ψ = ϕ+ 2 &lowast;β &minus;π},
With[{x1 = Cos[ψ ],y1 = Sin[ψ ]},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],With[{x1 = Cos[ψ ],y1 = Sin[ψ ]},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],With[{x1 = Cos[ψ ],y1 = Sin[ψ ]},{col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}],
</p>
<p>col[[3]],Line[{{x,y},{x1,y1}}],col[[3]],Line[{{x,y},{x1,y1}}],col[[3]],Line[{{x,y},{x1,y1}}],
col[[2]],Line[{{x1,y1},{x1+ a &lowast;Cos[ϑ ],y1+ a &lowast;Sin[ϑ ]}}]}]]]]col[[2]],Line[{{x1,y1},{x1+ a &lowast;Cos[ϑ ],y1+ a &lowast;Sin[ϑ ]}}]}]]]]col[[2]],Line[{{x1,y1},{x1+ a &lowast;Cos[ϑ ],y1+ a &lowast;Sin[ϑ ]}}]}]]]]
</p>
<p>In[24] := Manipulate[Graphics[Join[{Black,Circle[]},Ray1[y,a]],In[24] := Manipulate[Graphics[Join[{Black,Circle[]},Ray1[y,a]],In[24] := Manipulate[Graphics[Join[{Black,Circle[]},Ray1[y,a]],
PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],{{y,0.6},0,1},PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],{{y,0.6},0,1},PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],{{y,0.6},0,1},
</p>
<p>{{a,2},1,10}]{{a,2},1,10}]{{a,2},1,10}]
</p>
<p>y
</p>
<p>a
</p>
<p>Out[24] =
</p>
<p>When entering water, the ray is deflected by α&minus;β clockwise; when leaving water,
it is deflected by the same angle again. The direction of the outgoing ray is
</p>
<p>In[25] := ϑ1 = 2 &lowast; (β &minus;α);In[25] := ϑ1 = 2 &lowast; (β &minus;α);In[25] := ϑ1 = 2 &lowast; (β &minus;α);
In[26] := Manipulate[In[26] := Manipulate[In[26] := Manipulate[
</p>
<p>Graphics[Graphics[Graphics[
Join[{Black,Circle[]},Join[{Black,Circle[]},Join[{Black,Circle[]},
</p>
<p>With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},
If[δ &gt; 0,Apply[Join,Table[Ray1[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray1[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray1[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],
</p>
<p>PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1.1,1.1}}],
{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},
{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]
</p>
<p>10M
</p>
<p>rmin
</p>
<p>rmax
</p>
<p>a
Out[26] =</p>
<p/>
</div>
<div class="page"><p/>
<p>180 23 Rainbow
</p>
<p>The scattering angle ϑ is obtained by reducing ϑ1 to the interval [&minus;π ,π ] and then
taking Abs; in the present case, it is just &minus;ϑ1.
In[27] := Plot[Evaluate[&minus;ϑ1/.Snell/.Water],{ρ ,0,1}]In[27] := Plot[Evaluate[&minus;ϑ1/.Snell/.Water],{ρ ,0,1}]In[27] := Plot[Evaluate[&minus;ϑ1/.Snell/.Water],{ρ ,0,1}]
</p>
<p>Out[27] =
</p>
<p>It varies from 0 to
</p>
<p>In[28] := ϑ1m = Simplify[&minus;ϑ1/.Snell/.ρ&minus;&gt;1]In[28] := ϑ1m = Simplify[&minus;ϑ1/.Snell/.ρ&minus;&gt;1]In[28] := ϑ1m = Simplify[&minus;ϑ1/.Snell/.ρ&minus;&gt;1]
Out[28] = π&minus; 2ArcSin
</p>
<p>[
</p>
<p>1
</p>
<p>n
</p>
<p>]
</p>
<p>In[29] := ϑ1m/.WaterIn[29] := ϑ1m/.WaterIn[29] := ϑ1m/.Water
Out[29] = 1.4449
</p>
<p>Now we have to solve the equation α&minus;β = ϑ/2 for ρ .
In[30] := eq1 = (TrigExpand[Sin[α&minus;β ]]/.{Sin[α]&minus;&gt;ρ ,Cos[α]&minus;&gt;Sqrt[1&minus;ρ&and;2],In[30] := eq1 = (TrigExpand[Sin[α&minus;β ]]/.{Sin[α]&minus;&gt;ρ ,Cos[α]&minus;&gt;Sqrt[1&minus;ρ&and;2],In[30] := eq1 = (TrigExpand[Sin[α&minus;β ]]/.{Sin[α]&minus;&gt;ρ ,Cos[α]&minus;&gt;Sqrt[1&minus;ρ&and;2],
</p>
<p>Sin[β ]&minus;&gt;ρ/n,Cos[β ]&minus;&gt;Sqrt[1&minus; (ρ/n)&and;2]}) == Sin[ϑ/2]Sin[β ]&minus;&gt;ρ/n,Cos[β ]&minus;&gt;Sqrt[1&minus; (ρ/n)&and;2]}) == Sin[ϑ/2]Sin[β ]&minus;&gt;ρ/n,Cos[β ]&minus;&gt;Sqrt[1&minus; (ρ/n)&and;2]}) == Sin[ϑ/2]
</p>
<p>Out[30] =&minus;ρ
&radic;
</p>
<p>1&minus;ρ2
n
</p>
<p>+ρ
</p>
<p>&radic;
</p>
<p>1&minus; ρ
2
</p>
<p>n2
== Sin
</p>
<p>[
</p>
<p>ϑ
2
</p>
<p>]
</p>
<p>In[31] := sol1 = Solve[eq1,ρ ]In[31] := sol1 = Solve[eq1,ρ ]In[31] := sol1 = Solve[eq1,ρ ]
</p>
<p>Out[31] =
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>ρ &rarr;&minus;
&radic;
</p>
<p>n2 &minus; n2Cos[ϑ ]
&radic;
</p>
<p>2
&radic;
</p>
<p>1+ n2&minus; 2nCos
[ϑ
</p>
<p>2
</p>
<p>]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>,
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>ρ &rarr;
&radic;
</p>
<p>n2 &minus; n2Cos[ϑ ]
&radic;
</p>
<p>2
&radic;
</p>
<p>1+ n2&minus; 2nCos
[ϑ
</p>
<p>2
</p>
<p>]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>,
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>ρ &rarr;&minus;
&radic;
</p>
<p>n2 &minus; n2Cos[ϑ ]
&radic;
</p>
<p>2
&radic;
</p>
<p>1+ n2+ 2nCos
[ϑ
</p>
<p>2
</p>
<p>]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>,
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>ρ &rarr;
&radic;
</p>
<p>n2 &minus; n2Cos[ϑ ]
&radic;
</p>
<p>2
&radic;
</p>
<p>1+ n2+ 2nCos
[ϑ
</p>
<p>2
</p>
<p>]
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭
</p>
<p>We discard the negative solutions. The positive ones evaluated at ϑ1m are
In[32] := Simplify[ρ/.sol1[[{2,4}]]/.ϑ&minus;&gt;ϑ1m,n&gt; 1]In[32] := Simplify[ρ/.sol1[[{2,4}]]/.ϑ&minus;&gt;ϑ1m,n&gt; 1]In[32] := Simplify[ρ/.sol1[[{2,4}]]/.ϑ&minus;&gt;ϑ1m,n&gt; 1]
</p>
<p>Out[32] =
</p>
<p>⎧
</p>
<p>⎨
</p>
<p>⎩
</p>
<p>1,
</p>
<p>&radic;
</p>
<p>&minus;1+ n2
3+ n2
</p>
<p>⎫
</p>
<p>⎬
</p>
<p>⎭</p>
<p/>
</div>
<div class="page"><p/>
<p>23.4 2 Ray Segments Inside the Drop 181
</p>
<p>So, the right solution is number 2:
</p>
<p>In[33] := ρ1 = Simplify[Simplify[ρ/.sol1[[2]],{n&gt; 1,0 &lt; ϑ &lt; π}]/.In[33] := ρ1 = Simplify[Simplify[ρ/.sol1[[2]],{n&gt; 1,0 &lt; ϑ &lt; π}]/.In[33] := ρ1 = Simplify[Simplify[ρ/.sol1[[2]],{n&gt; 1,0 &lt; ϑ &lt; π}]/.
Cos[ϑ ]&minus;&gt;1&minus; 2 &lowast;Sin[ϑ/2]&and;2,{n&gt; 1,ϑ &gt; 0,ϑ &lt; π}]Cos[ϑ ]&minus;&gt;1&minus; 2 &lowast;Sin[ϑ/2]&and;2,{n&gt; 1,ϑ &gt; 0,ϑ &lt; π}]Cos[ϑ ]&minus;&gt;1&minus; 2 &lowast;Sin[ϑ/2]&and;2,{n&gt; 1,ϑ &gt; 0,ϑ &lt; π}]
</p>
<p>Out[33] =
nSin
</p>
<p>[ϑ
2
</p>
<p>]
</p>
<p>&radic;
</p>
<p>1+ n2&minus; 2nCos
[ϑ
</p>
<p>2
</p>
<p>]
</p>
<p>In[34] := Clear[eq1,sol1]In[34] := Clear[eq1,sol1]In[34] := Clear[eq1,sol1]
The geometrical cross section for ϑ between ϑ and ϑ + dϑ , divided by dΩ , is
In[35] := σ1 = Simplify[D[ρ1&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.In[35] := σ1 = Simplify[D[ρ1&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.In[35] := σ1 = Simplify[D[ρ1&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.
</p>
<p>{Cos[ϑ/2]&minus;&gt;c2,Sin[ϑ/2]&minus;&gt;s2}]{Cos[ϑ/2]&minus;&gt;c2,Sin[ϑ/2]&minus;&gt;s2}]{Cos[ϑ/2]&minus;&gt;c2,Sin[ϑ/2]&minus;&gt;s2}]
</p>
<p>Out[35] =
n2
</p>
<p>(
</p>
<p>c2&minus; 2c22n+ c2n2 &minus; ns22
)
</p>
<p>4c2 (1&minus; 2c2n+ n2)2
where c2 = Cos[ϑ/2], s2 = Sin[ϑ/2]. The angles α and β are
In[36] := Snell1 = {α&minus;&gt;ArcSin[ρ1],β&minus;&gt;ArcSin[ρ1/n]};In[36] := Snell1 = {α&minus;&gt;ArcSin[ρ1],β&minus;&gt;ArcSin[ρ1/n]};In[36] := Snell1 = {α&minus;&gt;ArcSin[ρ1],β&minus;&gt;ArcSin[ρ1/n]};
The differential cross sections for the two polarizations are
</p>
<p>In[37] := cs2 = {c2&minus;&gt;Cos[ϑ/2],s2&minus;&gt;Sin[ϑ/2]};In[37] := cs2 = {c2&minus;&gt;Cos[ϑ/2],s2&minus;&gt;Sin[ϑ/2]};In[37] := cs2 = {c2&minus;&gt;Cos[ϑ/2],s2&minus;&gt;Sin[ϑ/2]};
In[38] := σ1s[ϑ ] = Simplify[σ1&lowast; (1&minus;Rs)&and;2/.Snell1/.cs2/.Water];In[38] := σ1s[ϑ ] = Simplify[σ1&lowast; (1&minus;Rs)&and;2/.Snell1/.cs2/.Water];In[38] := σ1s[ϑ ] = Simplify[σ1&lowast; (1&minus;Rs)&and;2/.Snell1/.cs2/.Water];
</p>
<p>σ1p[ϑ ] = Simplify[σ1&lowast; (1&minus;Rp)&and;2/.Snell1/.cs2/.Water];σ1p[ϑ ] = Simplify[σ1&lowast; (1&minus;Rp)&and;2/.Snell1/.cs2/.Water];σ1p[ϑ ] = Simplify[σ1&lowast; (1&minus;Rp)&and;2/.Snell1/.cs2/.Water];
(the transmission coefficient is T = 1&minus;R, and transmission happens twice).
In[39] := Plot[{σ1s[ϑ ],σ1p[ϑ ],(σ1s[ϑ ]+σ1p[ϑ ])/2},{ϑ ,0,ϑ1m/.Water},In[39] := Plot[{σ1s[ϑ ],σ1p[ϑ ],(σ1s[ϑ ]+σ1p[ϑ ])/2},{ϑ ,0,ϑ1m/.Water},In[39] := Plot[{σ1s[ϑ ],σ1p[ϑ ],(σ1s[ϑ ]+σ1p[ϑ ])/2},{ϑ ,0,ϑ1m/.Water},
</p>
<p>PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]PlotRange&minus;&gt;All,PlotStyle&minus;&gt;col]
</p>
<p>Out[39] =
</p>
<p>23.4 2 Ray Segments Inside the Drop
</p>
<p>In[40] := Ray2[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[40] := Ray2[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[40] := Ray2[y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,
β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},β = β/.Snell/.ρ&minus;&gt;y/.Water,x=&minus;Sqrt[1&minus; y&and;2]},
</p>
<p>With[{ϑ = 4 &lowast;β &minus; 2 &lowast;α&minus;π},With[{ϑ = 4 &lowast;β &minus; 2 &lowast;α&minus;π},With[{ϑ = 4 &lowast;β &minus; 2 &lowast;α&minus;π},
Module[{ϕ = π&minus;α,R= {col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}]},Module[{ϕ = π&minus;α,R= {col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}]},Module[{ϕ = π&minus;α,R= {col[[1]],Line[{{&minus;1&minus; a,y},{x,y}}]},
</p>
<p>x1 = x,y1 = y,x2,y2,ψ},x1 = x,y1 = y,x2,y2,ψ},x1 = x,y1 = y,x2,y2,ψ},</p>
<p/>
</div>
<div class="page"><p/>
<p>182 23 Rainbow
</p>
<p>ψ = ϕ+ 2 &lowast;β&minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];ψ = ϕ+ 2 &lowast;β&minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];ψ = ϕ+ 2 &lowast;β&minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];
R= Join[R,{col[[3]],Line[{{x1,y1},{x2,y2}}]}];R= Join[R,{col[[3]],Line[{{x1,y1},{x2,y2}}]}];R= Join[R,{col[[3]],Line[{{x1,y1},{x2,y2}}]}];
ϕ = ψ ; x1 = x2; y1 = y2; ψ = ϕ+ 2 &lowast;β&minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];ϕ = ψ ; x1 = x2; y1 = y2; ψ = ϕ+ 2 &lowast;β&minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];ϕ = ψ ; x1 = x2; y1 = y2; ψ = ϕ+ 2 &lowast;β &minus;π ; x2 = Cos[ψ ]; y2 = Sin[ψ ];
R= Join[R,{col[[4]],Line[{{x1,y1},{x2,y2}}]}];R= Join[R,{col[[4]],Line[{{x1,y1},{x2,y2}}]}];R= Join[R,{col[[4]],Line[{{x1,y1},{x2,y2}}]}];
Join[R,{col[[2]],Line[{{x2,y2},{x2+ a &lowast;Cos[ϑ ],y2+ a &lowast;Sin[ϑ ]}}]}]]]]Join[R,{col[[2]],Line[{{x2,y2},{x2+ a &lowast;Cos[ϑ ],y2+ a &lowast;Sin[ϑ ]}}]}]]]]Join[R,{col[[2]],Line[{{x2,y2},{x2+ a &lowast;Cos[ϑ ],y2+ a &lowast;Sin[ϑ ]}}]}]]]]
</p>
<p>In[41] := Manipulate[Graphics[Join[{Black,Circle[]},Ray2[y,a]],In[41] := Manipulate[Graphics[Join[{Black,Circle[]},Ray2[y,a]],In[41] := Manipulate[Graphics[Join[{Black,Circle[]},Ray2[y,a]],
PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],
</p>
<p>{{y,0.6},0,1},{{a,2},1,10}]{{y,0.6},0,1},{{a,2},1,10}]{{y,0.6},0,1},{{a,2},1,10}]
</p>
<p>y
</p>
<p>a
</p>
<p>Out[41] =
</p>
<p>The second segment of the ray inside the drop is obtained from the first one by
</p>
<p>rotating by the angle π&minus;2β clockwise; hence the outgoing ray is obtained from the
one in the previous section by the same rotation:
</p>
<p>In[42] := ϑ2 = 4 &lowast;β &minus; 2 &lowast;α&minus;π ;In[42] := ϑ2 = 4 &lowast;β &minus; 2 &lowast;α&minus;π ;In[42] := ϑ2 = 4 &lowast;β &minus; 2 &lowast;α&minus;π ;
In[43] := Manipulate[In[43] := Manipulate[In[43] := Manipulate[
</p>
<p>Graphics[Graphics[Graphics[
Join[{Black,Circle[]},Join[{Black,Circle[]},Join[{Black,Circle[]},
</p>
<p>With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},
If[δ &gt; 0,Apply[Join,Table[Ray2[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray2[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray2[y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],
</p>
<p>PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1.1},{&minus;1&minus;0.7&lowast;a,1.1}}],
{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},
{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]{{M,10},Table[i,{i,30}]},{{a,2},1,10}]</p>
<p/>
</div>
<div class="page"><p/>
<p>23.4 2 Ray Segments Inside the Drop 183
</p>
<p>10M
</p>
<p>rmin
</p>
<p>rmax
</p>
<p>a
</p>
<p>Out[43] =
</p>
<p>The real scattering angle is ϑ =&minus;ϑ2:
In[44] := Plot[&minus;ϑ2/.Snell/.Water,{ρ ,0,1}]In[44] := Plot[&minus;ϑ2/.Snell/.Water,{ρ ,0,1}]In[44] := Plot[&minus;ϑ2/.Snell/.Water,{ρ ,0,1}]
</p>
<p>Out[44] =
</p>
<p>It has a minimum at
</p>
<p>In[45] := s2r = Solve[D[ϑ2/.Snell,ρ ] == 0,ρ ]In[45] := s2r = Solve[D[ϑ2/.Snell,ρ ] == 0,ρ ]In[45] := s2r = Solve[D[ϑ2/.Snell,ρ ] == 0,ρ ]
</p>
<p>Out[45] =
</p>
<p>{{
</p>
<p>ρ &rarr;&minus;
&radic;
</p>
<p>4&minus; n2&radic;
3
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>ρ &rarr;
&radic;
</p>
<p>4&minus; n2&radic;
3
</p>
<p>}}</p>
<p/>
</div>
<div class="page"><p/>
<p>184 23 Rainbow
</p>
<p>In[46] := ρ2r = ρ/.s2r[[2]]In[46] := ρ2r = ρ/.s2r[[2]]In[46] := ρ2r = ρ/.s2r[[2]]
</p>
<p>Out[46] =
</p>
<p>&radic;
4&minus; n2&radic;
</p>
<p>3
equal to
</p>
<p>In[47] := ϑ2r =&minus;ϑ2/.Snell/.ρ&minus;&gt;ρ2rIn[47] := ϑ2r =&minus;ϑ2/.Snell/.ρ&minus;&gt;ρ2rIn[47] := ϑ2r =&minus;ϑ2/.Snell/.ρ&minus;&gt;ρ2r
</p>
<p>Out[47] = π+ 2ArcSin
</p>
<p>[&radic;
4&minus; n2&radic;
</p>
<p>3
</p>
<p>]
</p>
<p>&minus; 4ArcSin
[&radic;
</p>
<p>4&minus; n2&radic;
3n
</p>
<p>]
</p>
<p>In[48] := {ρ2r,ϑ2r}/.WaterIn[48] := {ρ2r,ϑ2r}/.WaterIn[48] := {ρ2r,ϑ2r}/.Water
Out[48] = {0.860835,2.40719}
</p>
<p>Rays from a relatively wide ring around ρ2r have practically the same scattering
angle ϑ2r. This contribution to the cross section tends to &infin; at this angle. When an
observer sees a cloud of water drops illuminated by the sun, especially bright light
</p>
<p>rays arrive along the cone with angle π &minus;ϑ2r. Usually, only a part of the circle is
seen (the full circle can be sometimes observed from an airplane).
</p>
<p>In[49] := With[{R=&minus;Tan[ϑ2r/.Water]},Graphics3D[In[49] := With[{R=&minus;Tan[ϑ2r/.Water]},Graphics3D[In[49] := With[{R=&minus;Tan[ϑ2r/.Water]},Graphics3D[
Join[{Opacity[0.1],Yellow,Cone[{{1,0,0},{0,0,0}},R]},Join[{Opacity[0.1],Yellow,Cone[{{1,0,0},{0,0,0}},R]},Join[{Opacity[0.1],Yellow,Cone[{{1,0,0},{0,0,0}},R]},
</p>
<p>Apply[Join,Table[Apply[Join,Table[Apply[Join,Table[
Module[{x= 0.5 &lowast; (Random[]+ 1),ϕ = 2 &lowast;π &lowast;Random[],y,z},Module[{x= 0.5 &lowast; (Random[]+ 1),ϕ = 2 &lowast;π &lowast;Random[],y,z},Module[{x= 0.5 &lowast; (Random[]+ 1),ϕ = 2 &lowast;π &lowast;Random[],y,z},
y= R&lowast; x&lowast;Cos[ϕ ]; z= R&lowast; x&lowast;Sin[ϕ ];y= R&lowast; x&lowast;Cos[ϕ ]; z= R&lowast; x&lowast;Sin[ϕ ];y= R&lowast; x&lowast;Cos[ϕ ]; z= R&lowast; x&lowast;Sin[ϕ ];
{Red,Line[{{0,y,z},{x,y,z}}],Blue,Line[{{x,y,z},{0,0,0}}]}],{Red,Line[{{0,y,z},{x,y,z}}],Blue,Line[{{x,y,z},{0,0,0}}]}],{Red,Line[{{0,y,z},{x,y,z}}],Blue,Line[{{x,y,z},{0,0,0}}]}],
</p>
<p>{n,50}]]],{n,50}]]],{n,50}]]],
Boxed&minus;&gt;False,ViewPoint&minus;&gt;{&minus;10,&minus;30,0}]]Boxed&minus;&gt;False,ViewPoint&minus;&gt;{&minus;10,&minus;30,0}]]Boxed&minus;&gt;False,ViewPoint&minus;&gt;{&minus;10,&minus;30,0}]]</p>
<p/>
</div>
<div class="page"><p/>
<p>23.4 2 Ray Segments Inside the Drop 185
</p>
<p>In[50] := Show[Import[&rdquo;rainbow.jpg&rdquo;]]In[50] := Show[Import[&rdquo;rainbow.jpg&rdquo;]]In[50] := Show[Import[&rdquo;rainbow.jpg&rdquo;]]
</p>
<p>The scattering angle at ρ = 1 is
In[51] := ϑ2m =&minus;ϑ2/.Snell/.ρ&minus;&gt;1In[51] := ϑ2m =&minus;ϑ2/.Snell/.ρ&minus;&gt;1In[51] := ϑ2m =&minus;ϑ2/.Snell/.ρ&minus;&gt;1
Out[51] = 2π&minus; 4ArcSin
</p>
<p>[
</p>
<p>1
</p>
<p>n
</p>
<p>]
</p>
<p>In[52] := {ϑ2rw,ϑ2mw}= {ϑ2r,ϑ2m}/.Water;In[52] := {ϑ2rw,ϑ2mw}= {ϑ2r,ϑ2m}/.Water;In[52] := {ϑ2rw,ϑ2mw}= {ϑ2r,ϑ2m}/.Water;
Now we have to solve the equation α&minus; 2β = (ϑ &minus;π)/2 for ρ .
In[53] := eq2 = (TrigExpand[Sin[α&minus; 2 &lowast;β ]]/.In[53] := eq2 = (TrigExpand[Sin[α&minus; 2 &lowast;β ]]/.In[53] := eq2 = (TrigExpand[Sin[α&minus; 2 &lowast;β ]]/.
</p>
<p>{Sin[α]&rarr; ρ ,Cos[α]&rarr; Sqrt[1&minus;ρ&and;2],{Sin[α]&rarr; ρ ,Cos[α]&rarr; Sqrt[1&minus;ρ&and;2],{Sin[α]&rarr; ρ ,Cos[α]&rarr; Sqrt[1&minus;ρ&and;2],
Sin[β ]&rarr; ρ/n,Cos[β ]&rarr; Sqrt[1&minus; (ρ/n)&and;2]}) ==&minus;Cos[ϑ/2]Sin[β ]&rarr; ρ/n,Cos[β ]&rarr; Sqrt[1&minus; (ρ/n)&and;2]}) ==&minus;Cos[ϑ/2]Sin[β ]&rarr; ρ/n,Cos[β ]&rarr; Sqrt[1&minus; (ρ/n)&and;2]}) ==&minus;Cos[ϑ/2]
</p>
<p>Out[53] =&minus;ρ
3
</p>
<p>n2
&minus;
</p>
<p>2ρ
&radic;
</p>
<p>1&minus;ρ2
&radic;
</p>
<p>1&minus; ρ2
n2
</p>
<p>n
+ρ
</p>
<p>(
</p>
<p>1&minus; ρ
2
</p>
<p>n2
</p>
<p>)
</p>
<p>==&minus;Cos
[
</p>
<p>ϑ
2
</p>
<p>]
</p>
<p>In[54] := sol2 = Solve[eq2,ρ ];In[54] := sol2 = Solve[eq2,ρ ];In[54] := sol2 = Solve[eq2,ρ ];
The solution number 3 is the smaller one; number 4 is the larger one (1 and 2 are
</p>
<p>negative).
</p>
<p>In[55] := ρ2a = ρ/.sol2[[3]]; ρ2b = ρ/.sol2[[4]];In[55] := ρ2a = ρ/.sol2[[3]]; ρ2b = ρ/.sol2[[4]];In[55] := ρ2a = ρ/.sol2[[3]]; ρ2b = ρ/.sol2[[4]];
In[56] := Clear[eq2,sol2]In[56] := Clear[eq2,sol2]In[56] := Clear[eq2,sol2]
In[57] := p2a = ParametricPlot[{ϑ ,ρ2a/.Water},{ϑ ,ϑ2r/.Water,π},In[57] := p2a = ParametricPlot[{ϑ ,ρ2a/.Water},{ϑ ,ϑ2r/.Water,π},In[57] := p2a = ParametricPlot[{ϑ ,ρ2a/.Water},{ϑ ,ϑ2r/.Water,π},
</p>
<p>PlotStyle &rarr; Blue];PlotStyle &rarr; Blue];PlotStyle &rarr; Blue];
p2b = ParametricPlot[{ϑ ,ρ2b/.Water},{ϑ ,ϑ2r/.Water,ϑ2m/.Water},p2b = ParametricPlot[{ϑ ,ρ2b/.Water},{ϑ ,ϑ2r/.Water,ϑ2m/.Water},p2b = ParametricPlot[{ϑ ,ρ2b/.Water},{ϑ ,ϑ2r/.Water,ϑ2m/.Water},
</p>
<p>PlotStyle &rarr; Red];PlotStyle &rarr; Red];PlotStyle &rarr; Red];
Show[p2a,p2b,PlotRange &rarr; {{ϑ2r/.Water,π},{0,1}}]Show[p2a,p2b,PlotRange &rarr; {{ϑ2r/.Water,π},{0,1}}]Show[p2a,p2b,PlotRange &rarr; {{ϑ2r/.Water,π},{0,1}}]</p>
<p/>
</div>
<div class="page"><p/>
<p>186 23 Rainbow
</p>
<p>Out[57] =
</p>
<p>In order to scatter between ϑ and ϑ + dϑ , the incident ray has to hit one of the two
rings, σ2a or (if ϑ &lt; ϑ2m) σ2b.
In[58] := σ2a =&minus;(D[ρ2a&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,In[58] := σ2a =&minus;(D[ρ2a&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,In[58] := σ2a =&minus;(D[ρ2a&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,
</p>
<p>Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2});Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2});Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2});
σ2b = D[ρ2b&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,σ2b = D[ρ2b&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,σ2b =D[ρ2b&and;2,ϑ ]/(4 &lowast; c2&lowast; s2)/.{Cos[ϑ/2]&rarr; c2,Sin[ϑ/2]&rarr; s2,
</p>
<p>Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2};Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2};Cos[ϑ ]&rarr; c2&and;2&minus; s2&and;2,Sin[ϑ ]&minus;&gt;2 &lowast; c2&lowast; s2};
The angles α and β in these two cases are
In[59] := Snell2a = {α&minus;&gt;ArcSin[ρ2a],β&minus;&gt;ArcSin[ρ2a/n]};In[59] := Snell2a = {α&minus;&gt;ArcSin[ρ2a],β&minus;&gt;ArcSin[ρ2a/n]};In[59] := Snell2a = {α&minus;&gt;ArcSin[ρ2a],β&minus;&gt;ArcSin[ρ2a/n]};
</p>
<p>Snell2b = {α&minus;&gt;ArcSin[ρ2b],β&minus;&gt;ArcSin[ρ2b/n]};Snell2b = {α&minus;&gt;ArcSin[ρ2b],β&minus;&gt;ArcSin[ρ2b/n]};Snell2b = {α&minus;&gt;ArcSin[ρ2b],β&minus;&gt;ArcSin[ρ2b/n]};
The differential cross sections for the two polarizations are
</p>
<p>In[60] := σ2as[ϑ ] = σ2a&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2a/.cs2/.Water;In[60] := σ2as[ϑ ] = σ2a&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2a/.cs2/.Water;In[60] := σ2as[ϑ ] = σ2a&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2a/.cs2/.Water;
σ2ap[ϑ ] = σ2a&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2a/.cs2/.Water;σ2ap[ϑ ] = σ2a&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2a/.cs2/.Water;σ2ap[ϑ ] = σ2a&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2a/.cs2/.Water;
σ2bs[ϑ ] = σ2b&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2b/.cs2/.Water;σ2bs[ϑ ] = σ2b&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2b/.cs2/.Water;σ2bs[ϑ ] = σ2b&lowast; (1&minus;Rs)&and;2 &lowast;Rs/.Snell2b/.cs2/.Water;
σ2bp[ϑ ] = σ2b&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2b/.cs2/.Water;σ2bp[ϑ ] = σ2b&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2b/.cs2/.Water;σ2bp[ϑ ] = σ2b&lowast; (1&minus;Rp)&and;2 &lowast;Rp/.Snell2b/.cs2/.Water;
</p>
<p>In[61] := σ2s[ϑ ] := If[ϑ &gt; ϑ2rw,σ2as[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bs[ϑ ],0],0];In[61] := σ2s[ϑ ] := If[ϑ &gt; ϑ2rw,σ2as[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bs[ϑ ],0],0];In[61] := σ2s[ϑ ] := If[ϑ &gt; ϑ2rw,σ2as[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bs[ϑ ],0],0];
σ2p[ϑ ] := If[ϑ &gt; ϑ2rw,σ2ap[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bp[ϑ ],0],0];σ2p[ϑ ] := If[ϑ &gt; ϑ2rw,σ2ap[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bp[ϑ ],0],0];σ2p[ϑ ] := If[ϑ &gt; ϑ2rw,σ2ap[ϑ ]+ If[ϑ &lt; ϑ2mw,σ2bp[ϑ ],0],0];</p>
<p/>
</div>
<div class="page"><p/>
<p>23.4 2 Ray Segments Inside the Drop 187
</p>
<p>In[62] := Plot[{σ2s[ϑ ],σ2p[ϑ ],(σ2s[ϑ ]+σ2p[ϑ ])/2},{ϑ ,ϑ2rw+ 0.001,π},In[62] := Plot[{σ2s[ϑ ],σ2p[ϑ ],(σ2s[ϑ ]+σ2p[ϑ ])/2},{ϑ ,ϑ2rw+ 0.001,π},In[62] := Plot[{σ2s[ϑ ],σ2p[ϑ ],(σ2s[ϑ ]+σ2p[ϑ ])/2},{ϑ ,ϑ2rw+ 0.001,π},
PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]
</p>
<p>Out[62] =
</p>
<p>The considered contributions (0, 1, 2 ray segments inside the drop) to the cross
</p>
<p>sections with the s, p polarizations, as well as their sums, are
</p>
<p>In[63] := {Plot[{σ0s[ϑ ],σ1s[ϑ ],σ2s[ϑ ],σ0s[ϑ ]+σ1s[ϑ ]+σ2s[ϑ ]},{ϑ ,0,π},In[63] := {Plot[{σ0s[ϑ ],σ1s[ϑ ],σ2s[ϑ ],σ0s[ϑ ]+σ1s[ϑ ]+σ2s[ϑ ]},{ϑ ,0,π},In[63] := {Plot[{σ0s[ϑ ],σ1s[ϑ ],σ2s[ϑ ],σ0s[ϑ ]+σ1s[ϑ ]+σ2s[ϑ ]},{ϑ ,0,π},
PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col],PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col],PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col],
</p>
<p>Plot[{σ0p[ϑ ],σ1p[ϑ ],σ2p[ϑ ],σ0p[ϑ ]+σ1p[ϑ ]+σ2p[ϑ ]},{ϑ ,0,π},Plot[{σ0p[ϑ ],σ1p[ϑ ],σ2p[ϑ ],σ0p[ϑ ]+σ1p[ϑ ]+σ2p[ϑ ]},{ϑ ,0,π},Plot[{σ0p[ϑ ],σ1p[ϑ ],σ2p[ϑ ],σ0p[ϑ ]+σ1p[ϑ ]+σ2p[ϑ ]},{ϑ ,0,π},
PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]}PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]}PlotRange&minus;&gt;{0,1},PlotStyle&minus;&gt;col]}
</p>
<p>Out[63] =
,
</p>
<p>Of course, there are also higher contributions, not included here. The cross section
</p>
<p>is small for scattering angles below the rainbow peak; i.e., the sky just outside the
</p>
<p>rainbow is darker.
</p>
<p>Near the rainbow peak, the last contribution (2 ray segments) is dominant; the
</p>
<p>ratio of the s and p polarizations is
</p>
<p>In[64] := Rs2 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρ2r],n&gt; 1];In[64] := Rs2 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρ2r],n&gt; 1];In[64] := Rs2 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρ2r],n &gt; 1];
Rp2 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρ2r],n&gt; 1];Rp2 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρ2r],n&gt; 1];Rp2 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρ2r],n&gt; 1];
P2 = Simplify[(1&minus;Rs2)&and;2 &lowast;Rs2/((1&minus;Rp2)&and;2 &lowast;Rp2),n&gt; 1]P2 = Simplify[(1&minus;Rs2)&and;2 &lowast;Rs2/((1&minus;Rp2)&and;2 &lowast;Rp2),n&gt; 1]P2 = Simplify[(1&minus;Rs2)&and;2 &lowast;Rs2/((1&minus;Rp2)&and;2 &lowast;Rp2),n&gt; 1]
</p>
<p>Out[64] =
</p>
<p>(
</p>
<p>2+ n2
)6
</p>
<p>729n4 (&minus;2+ n2)2
In[65] := P2/.WaterIn[65] := P2/.WaterIn[65] := P2/.Water
Out[65] = 25.3347</p>
<p/>
</div>
<div class="page"><p/>
<p>188 23 Rainbow
</p>
<p>The rainbow light is highly linearly polarized, with the electric field orthogonal to
</p>
<p>the scattering plane, i.e., along the rainbow. The reason is that the incidence angle
</p>
<p>β of the ray which is about to reflect from the inner surface of the drop
In[66] := β/.Snell/.ρ&minus;&gt;ρ2r/.WaterIn[66] := β/.Snell/.ρ&minus;&gt;ρ2r/.WaterIn[66] := β/.Snell/.ρ&minus;&gt;ρ2r/.Water
Out[66] = 0.702055
is close to the Brewster angle
</p>
<p>In[67] := βB/.WaterIn[67] := βB/.WaterIn[67] := βB/.Water
Out[67] = 0.643621
</p>
<p>23.5 L Ray Segments Inside the Drop
</p>
<p>Repeating the arguments from the previous sections, we obtain the direction of the
</p>
<p>outgoing ray ϑL = 2(β &minus;α)&minus; (L&minus; 1)(π&minus; 2β ):
In[68] := ϑL = 2 &lowast;L&lowast;β &minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π ;In[68] := ϑL = 2 &lowast;L&lowast;β &minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π ;In[68] := ϑL = 2 &lowast;L&lowast;β&minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π ;
In[69] := Ray[L ,y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[69] := Ray[L ,y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,In[69] := Ray[L ,y ,a ] := With[{α = α/.Snell/.ρ&minus;&gt;y,
</p>
<p>β = β/.Snell/.ρ&minus;&gt;y/.Water},β = β/.Snell/.ρ&minus;&gt;y/.Water},β = β/.Snell/.ρ&minus;&gt;y/.Water},
Module[{R= {col[[1]],Line[{{&minus;1&minus; a,y},{&minus;Sqrt[1&minus; y&and;2],y}}]},Module[{R= {col[[1]],Line[{{&minus;1&minus; a,y},{&minus;Sqrt[1&minus; y&and;2],y}}]},Module[{R= {col[[1]],Line[{{&minus;1&minus; a,y},{&minus;Sqrt[1&minus; y&and;2],y}}]},
</p>
<p>ϕ = π&minus;α,ϕ1,ϑ = 2 &lowast;L&lowast;β&minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π},ϕ = π&minus;α,ϕ1,ϑ = 2 &lowast;L&lowast;β&minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π},ϕ = π&minus;α,ϕ1,ϑ = 2 &lowast;L&lowast;β&minus; 2 &lowast;α&minus; (L&minus; 1)&lowast;π},
Do[ϕ1 = ϕ+ 2 &lowast;β&minus;π ;Do[ϕ1 = ϕ+ 2 &lowast;β&minus;π ;Do[ϕ1 = ϕ+ 2 &lowast;β&minus;π ;
R= Join[R,{col[[m+ 2]],Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ1],Sin[ϕ1]}}]}];R= Join[R,{col[[m+ 2]],Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ1],Sin[ϕ1]}}]}];R= Join[R,{col[[m+ 2]],Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ1],Sin[ϕ1]}}]}];
ϕ = ϕ1,{m,L}];ϕ = ϕ1,{m,L}];ϕ = ϕ1,{m,L}];
</p>
<p>Join[R,{col[[2]],Join[R,{col[[2]],Join[R,{col[[2]],
Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ ]+ a &lowast;Cos[ϑ ],Sin[ϕ ]+ a &lowast;Sin[ϑ ]}}]}]]]Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ ]+ a &lowast;Cos[ϑ ],Sin[ϕ ]+ a &lowast;Sin[ϑ ]}}]}]]]Line[{{Cos[ϕ ],Sin[ϕ ]},{Cos[ϕ ]+ a &lowast;Cos[ϑ ],Sin[ϕ ]+ a &lowast;Sin[ϑ ]}}]}]]]
</p>
<p>In[70] := ϑ [L ,ρ ] = ϑL/.Snell/.Water;In[70] := ϑ [L ,ρ ] = ϑL/.Snell/.Water;In[70] := ϑ [L ,ρ ] = ϑL/.Snell/.Water;
In[71] := Manipulate[{In[71] := Manipulate[{In[71] := Manipulate[{
</p>
<p>Manipulate[Manipulate[Manipulate[
Graphics[Join[{Black,Circle[]},Ray[L,y,a]],Graphics[Join[{Black,Circle[]},Ray[L,y,a]],Graphics[Join[{Black,Circle[]},Ray[L,y,a]],
</p>
<p>PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],
{{y,0.6},0,1},{{a,2},1,10}],{{y,0.6},0,1},{{a,2},1,10}],{{y,0.6},0,1},{{a,2},1,10}],
</p>
<p>Manipulate[Manipulate[Manipulate[
Graphics[Join[{Black,Circle[]},Graphics[Join[{Black,Circle[]},Graphics[Join[{Black,Circle[]},
</p>
<p>With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},With[{δ = (ρmax&minus;ρmin)/M},
If[δ &gt; 0,Apply[Join,Table[Ray[L,y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray[L,y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],If[δ &gt; 0,Apply[Join,Table[Ray[L,y,a],{y,ρmin+ δ/2,ρmax,δ}]],{}]]],
</p>
<p>PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],PlotRange&minus;&gt;{{&minus;1&minus; a,1+ a},{&minus;1&minus;a,1+a}}],
{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},{{ρmin,0},0,1},{{ρmax,1},0,1},
{{M,10},Table[i,{i,30}]},{{a,2},1,10}],{{M,10},Table[i,{i,30}]},{{a,2},1,10}],{{M,10},Table[i,{i,30}]},{{a,2},1,10}],
</p>
<p>Plot[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{ρ ,0,1}]},Plot[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{ρ ,0,1}]},Plot[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{ρ ,0,1}]},
{{L,3},Table[i,{i,0,4}]}]{{L,3},Table[i,{i,0,4}]}]{{L,3},Table[i,{i,0,4}]}]</p>
<p/>
</div>
<div class="page"><p/>
<p>23.5 L Ray Segments Inside the Drop 189
</p>
<p>10M
</p>
<p>rmin
rmax
</p>
<p>a
</p>
<p>a
y
</p>
<p>0 1 2 3 4
</p>
<p>Out[71] =
</p>
<p>,
</p>
<p>,
</p>
<p>Scattering angles for L= 0, 1, 2, 3, 4 as functions of ρ are
In[72] := Plot[Evaluate[Table[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{L,0,4}]],{ρ ,0,1},In[72] := Plot[Evaluate[Table[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{L,0,4}]],{ρ ,0,1},In[72] := Plot[Evaluate[Table[Abs[Mod[ϑ [L,ρ ],2 &lowast;π ,&minus;π ]],{L,0,4}]],{ρ ,0,1},
</p>
<p>PlotStyle&minus;&gt;col]PlotStyle&minus;&gt;col]PlotStyle&minus;&gt;col]
</p>
<p>Out[72] =</p>
<p/>
</div>
<div class="page"><p/>
<p>190 23 Rainbow
</p>
<p>Naturally, those with even L start from π at ρ = 0; for odd L they start from 0. For
L� 2 each one has a single extremum:
</p>
<p>In[73] := sol = Solve[D[ϑL/.Snell,ρ ] == 0,ρ ]In[73] := sol = Solve[D[ϑL/.Snell,ρ ] == 0,ρ ]In[73] := sol = Solve[D[ϑL/.Snell,ρ ] == 0,ρ ]
</p>
<p>Out[73] =
</p>
<p>{{
</p>
<p>ρ &rarr;&minus;
&radic;
L2 &minus; n2&radic;
&minus;1+L2
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>ρ &rarr;
&radic;
L2 &minus; n2&radic;
&minus;1+L2
</p>
<p>}}
</p>
<p>In[74] := ρL = ρ/.sol[[2]]In[74] := ρL = ρ/.sol[[2]]In[74] := ρL = ρ/.sol[[2]]
</p>
<p>Out[74] =
</p>
<p>&radic;
L2 &minus; n2&radic;
&minus;1+L2
</p>
<p>In[75] := ϑ r = ϑL/.Snell/.ρ-&gt;ρLIn[75] := ϑ r = ϑL/.Snell/.ρ-&gt;ρLIn[75] := ϑ r = ϑL/.Snell/.ρ-&gt;ρL
</p>
<p>Out[75] =&minus;(&minus;1+L)π&minus; 2ArcSin
[ &radic;
</p>
<p>L2 &minus; n2&radic;
&minus;1+L2
</p>
<p>]
</p>
<p>+ 2LArcSin
</p>
<p>[ &radic;
L2 &minus; n2&radic;
&minus;1+L2n
</p>
<p>]
</p>
<p>These extrema produce rainbows at the angles (in degrees)
</p>
<p>In[76] := Table[(π&minus;Abs[Mod[ϑ r/.Water,2 &lowast;π ,&minus;π ]])/Degree,{L,2,4}]In[76] := Table[(π&minus;Abs[Mod[ϑ r/.Water,2 &lowast;π ,&minus;π ]])/Degree,{L,2,4}]In[76] := Table[(π&minus;Abs[Mod[ϑ r/.Water,2 &lowast;π ,&minus;π ]])/Degree,{L,2,4}]
Out[76] = {42.0781,50.8908,138.263}
The angles at which an observer sees the first and the second rainbow are
</p>
<p>In[77] := {ϑ r2,ϑ r3}= {π+(ϑ r/.L&minus;&gt;2),&minus;π&minus; (ϑ r/.L&minus;&gt;3)}In[77] := {ϑ r2,ϑ r3}= {π+(ϑ r/.L&minus;&gt;2),&minus;π&minus; (ϑ r/.L&minus;&gt;3)}In[77] := {ϑ r2,ϑ r3}= {π+(ϑ r/.L&minus;&gt;2),&minus;π&minus; (ϑ r/.L&minus;&gt;3)}
</p>
<p>Out[77] =
</p>
<p>{
</p>
<p>&minus;2ArcSin
[&radic;
</p>
<p>4&minus; n2&radic;
3
</p>
<p>]
</p>
<p>+ 4ArcSin
</p>
<p>[&radic;
4&minus; n2&radic;
</p>
<p>3n
</p>
<p>]
</p>
<p>,
</p>
<p>π+ 2ArcSin
</p>
<p>[&radic;
9&minus; n2
2
&radic;
</p>
<p>2
</p>
<p>]
</p>
<p>&minus; 6ArcSin
[&radic;
</p>
<p>9&minus; n2
2
&radic;
</p>
<p>2n
</p>
<p>]}
</p>
<p>The sky is somewhat darker between the first rainbow and the second one, because
</p>
<p>neither rays with L= 2 nor those with L= 3 come from these directions.
Until now, we discussed monochromatic light. Then each rainbow is just a bright
</p>
<p>arc of the same color. In fact, the refraction index of water n depends on the color
</p>
<p>(wavelength) of light (dispersion). It is larger for violet light than for red one. There-
</p>
<p>fore the positions of the maxima of intensity of the scattered light also depend on
</p>
<p>the color.
</p>
<p>In[78] := Plot[{ϑ r2/Degree,ϑ r3/Degree},{n,1.325,1.335},PlotStyle&minus;&gt;col]In[78] := Plot[{ϑ r2/Degree,ϑ r3/Degree},{n,1.325,1.335},PlotStyle&minus;&gt;col]In[78] := Plot[{ϑ r2/Degree,ϑ r3/Degree},{n,1.325,1.335},PlotStyle&minus;&gt;col]
</p>
<p>Out[78] =</p>
<p/>
</div>
<div class="page"><p/>
<p>23.5 L Ray Segments Inside the Drop 191
</p>
<p>We see that the order of colors in the second rainbow is opposite to that in the first
</p>
<p>one; and the second rainbow is wider.
</p>
<p>The ratios of s and p polarizations at the rainbow peaks are
</p>
<p>In[79] := Rs0 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]In[79] := Rs0 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]In[79] := Rs0 = Simplify[TrigExpand[Rs/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]
</p>
<p>Out[79] =
(&minus;1+L)2
(1+L)2
</p>
<p>In[80] := Rp0 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]In[80] := Rp0 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]In[80] := Rp0 = Simplify[TrigExpand[Rp/.Snell/.ρ&minus;&gt;ρL],{n&gt; 1,L&gt; 1}]
</p>
<p>Out[80] =
</p>
<p>(
</p>
<p>L&minus; n2
)2
</p>
<p>(L+ n2)
2
</p>
<p>In[81] := P= Simplify[(1&minus;Rs0)&and;2 &lowast;Rs0&and;(L&minus; 1)/((1&minus;Rp0)&and;2 &lowast;Rp0&and;(L&minus; 1)),In[81] := P= Simplify[(1&minus;Rs0)&and;2 &lowast;Rs0&and;(L&minus; 1)/((1&minus;Rp0)&and;2 &lowast;Rp0&and;(L&minus; 1)),In[81] := P= Simplify[(1&minus;Rs0)&and;2 &lowast;Rs0&and;(L&minus; 1)/((1&minus;Rp0)&and;2 &lowast;Rp0&and;(L&minus; 1)),
{n&gt; 1,L&gt; 1}]{n&gt; 1,L&gt; 1}]{n&gt; 1,L&gt; 1}]
</p>
<p>Out[81] =
</p>
<p>(
</p>
<p>(&minus;1+L)2(L+n2)2
</p>
<p>(1+L)2(L&minus;n2)2
</p>
<p>)L
(
</p>
<p>L2 &minus; n4
)2
</p>
<p>(&minus;1+L2)2 n4
In[82] := Table[P/.Water,{L,2,4}]In[82] := Table[P/.Water,{L,2,4}]In[82] := Table[P/.Water,{L,2,4}]
Out[82] = {25.3347,9.36736,8.10737}
Higher rainbows are not so strongly polarized as the first one, because the incidence
</p>
<p>angle for the reflections inside the drop is not so close to the Brewster angle.</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 24
</p>
<p>Cyclohexane
</p>
<p>24.1 Statement of the Problem
</p>
<p>Cyclohexane molecule contains 6 C atoms connected cyclically by single chemical
</p>
<p>bonds; 2 H atoms are attached to each carbon one. Single bonds of a C atom have a
</p>
<p>fixed length and form fixed angles: if the C atom is put to the center of a tetrahedron,
</p>
<p>then its single bonds point to its vertices. The problem is: how many geometrical
</p>
<p>configurations (conformations, as chemists call them) of the cyclohexane molecule
</p>
<p>exist&mdash;one, several, or infinitely many (and if so, what is the dimensionality of this
</p>
<p>set).
</p>
<p>Tetrahedron
</p>
<p>What is the angle between single bonds? The unit vectors a[1], . . . a[4] (blue) are
directed from the center of the tetrahedron (red) to its vertices.
</p>
<p>In[1] := a[0] = {0,0,0}; a[1] = {0,0,1}; a[2] = {2 &lowast;Sqrt[2],0,&minus;1}/3;In[1] := a[0] = {0,0,0}; a[1] = {0,0,1}; a[2] = {2 &lowast;Sqrt[2],0,&minus;1}/3;In[1] := a[0] = {0,0,0}; a[1] = {0,0,1}; a[2] = {2 &lowast;Sqrt[2],0,&minus;1}/3;
a[3] = {&minus;Sqrt[2],Sqrt[6],&minus;1}/3; a[4] = {&minus;Sqrt[2],&minus;Sqrt[6],&minus;1}/3;a[3] = {&minus;Sqrt[2],Sqrt[6],&minus;1}/3; a[4] = {&minus;Sqrt[2],&minus;Sqrt[6],&minus;1}/3;a[3] = {&minus;Sqrt[2],Sqrt[6],&minus;1}/3; a[4] = {&minus;Sqrt[2],&minus;Sqrt[6],&minus;1}/3;
</p>
<p>In[2] := rc = 0.025; rs = 0.1;In[2] := rc = 0.025; rs = 0.1;In[2] := rc = 0.025; rs = 0.1;
In[3] := Graphics3D[{Blue,Cylinder[{a[0],a[1]}, rc],Cylinder[{a[0],a[2]}, rc],In[3] := Graphics3D[{Blue,Cylinder[{a[0],a[1]}, rc],Cylinder[{a[0],a[2]}, rc],In[3] := Graphics3D[{Blue,Cylinder[{a[0],a[1]}, rc],Cylinder[{a[0],a[2]}, rc],
</p>
<p>Cylinder[{a[0],a[3]}, rc],Cylinder[{a[0],a[4]}, rc],Cylinder[{a[0],a[3]}, rc],Cylinder[{a[0],a[4]}, rc],Cylinder[{a[0],a[3]}, rc],Cylinder[{a[0],a[4]}, rc],
Red,Cylinder[{a[1],a[2]}, rc],Cylinder[{a[1],a[3]}, rc],Red,Cylinder[{a[1],a[2]}, rc],Cylinder[{a[1],a[3]}, rc],Red,Cylinder[{a[1],a[2]}, rc],Cylinder[{a[1],a[3]}, rc],
Cylinder[{a[1],a[4]}, rc],Cylinder[{a[2],a[3]}, rc],Cylinder[{a[1],a[4]}, rc],Cylinder[{a[2],a[3]}, rc],Cylinder[{a[1],a[4]}, rc],Cylinder[{a[2],a[3]}, rc],
Cylinder[{a[2],a[4]}, rc],Cylinder[{a[3],a[4]}, rc],Cylinder[{a[2],a[4]}, rc],Cylinder[{a[3],a[4]}, rc],Cylinder[{a[2],a[4]}, rc],Cylinder[{a[3],a[4]}, rc],
Sphere[a[1], rs],Sphere[a[2], rs],Sphere[a[3], rs],Sphere[a[4], rs]},Sphere[a[1], rs],Sphere[a[2], rs],Sphere[a[3], rs],Sphere[a[4], rs]},Sphere[a[1], rs],Sphere[a[2], rs],Sphere[a[3], rs],Sphere[a[4], rs]},
</p>
<p>Boxed&minus;&gt;False,ViewPoint&minus;&gt;{10,10,4}]Boxed&minus;&gt;False,ViewPoint&minus;&gt;{10,10,4}]Boxed&minus;&gt;False,ViewPoint&minus;&gt;{10,10,4}]
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 24, &copy; Springer International Publishing Switzerland 2014
</p>
<p>193</p>
<p/>
</div>
<div class="page"><p/>
<p>194 24 Cyclohexane
</p>
<p>Let&rsquo;s check: the vectors are indeed unit and form equal angles with each other; hence
</p>
<p>all edges have equal lengths, so this is indeed a tetrahedron.
</p>
<p>In[4] := MatrixForm[Table[a[i].a[ j],{i,1,4},{ j,1,4}]]In[4] := MatrixForm[Table[a[i].a[ j],{i,1,4},{ j,1,4}]]In[4] := MatrixForm[Table[a[i].a[ j],{i,1,4},{ j,1,4}]]
Out[4]//MatrixForm =
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>1 &minus; 13 &minus; 13 &minus; 13
&minus; 13 1 &minus; 13 &minus; 13
&minus; 13 &minus; 13 1 &minus; 13
&minus; 13 &minus; 13 &minus; 13 1
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>Cosine of the angle between these vectors is &minus;1/3.
In[5] := Clear[a, rc, rs]In[5] := Clear[a, rc, rs]In[5] := Clear[a, rc, rs]
</p>
<p>24.2 First Steps
</p>
<p>Thus we have 6 vectors a[1], . . . , a[6] drawn from each C atom to the next one.
They form a closed hexagon: a[1]+ &middot; &middot; &middot;+ a[6] = 0. Let the length of a single C&ndash;C
bond be 1, then all the vectors are unit. Scalar products of neighboring vectors are
</p>
<p>1/3 (the sign has changed because now one of the vectors points in, not out). In
order not to deal with the overall orientation of the molecule, let&rsquo;s consider invariant
</p>
<p>quantities&mdash;cosines of the angles c[i, j] = a[i].a[ j].
In[6] := c[i , j ]/; i&gt; j := c[ j, i]In[6] := c[i , j ]/; i&gt; j := c[ j, i]In[6] := c[i , j ]/; i&gt; j := c[ j, i]
In[7] := Do[c[i, i] = 1,{i,1,6}]In[7] := Do[c[i, i] = 1,{i,1,6}]In[7] := Do[c[i, i] = 1,{i,1,6}]
In[8] := Do[c[i, i+ 1] = 1/3,{i,1,5}]; c[1,6] = 1/3;In[8] := Do[c[i, i+ 1] = 1/3,{i,1,5}]; c[1,6] = 1/3;In[8] := Do[c[i, i+ 1] = 1/3,{i,1,5}]; c[1,6] = 1/3;</p>
<p/>
</div>
<div class="page"><p/>
<p>24.2 First Steps 195
</p>
<p>In[9] := MatrixForm[M = Array[c,{6,6}]]In[9] := MatrixForm[M = Array[c,{6,6}]]In[9] := MatrixForm[M = Array[c,{6,6}]]
Out[9]//MatrixForm =
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>1 13 c[1,3] c[1,4] c[1,5]
1
3
</p>
<p>1
3 1
</p>
<p>1
3 c[2,4] c[2,5] c[2,6]
</p>
<p>c[1,3] 13 1
1
3 c[3,5] c[3,6]
</p>
<p>c[1,4] c[2,4] 13 1
1
3 c[4,6]
</p>
<p>c[1,5] c[2,5] c[3,5] 13 1
1
3
</p>
<p>1
3 c[2,6] c[3,6] c[4,6]
</p>
<p>1
3 1
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠
</p>
<p>Linear Equations
</p>
<p>Multiplying the vector equality a[1]+ &middot; &middot; &middot;+ a[6] = 0 by each vector a[i], we get 6
linear equations for c[i, j].
In[10] := Eq = Table[Sum[c[i, j],{ j,1,6}] == 0,{i,1,6}]In[10] := Eq = Table[Sum[c[i, j],{ j,1,6}] == 0,{i,1,6}]In[10] := Eq = Table[Sum[c[i, j],{ j,1,6}] == 0,{i,1,6}]
Out[10] =
</p>
<p>{
</p>
<p>5
</p>
<p>3
+ c[1,3]+ c[1,4]+ c[1,5]== 0,
</p>
<p>5
</p>
<p>3
+ c[2,4]+ c[2,5]+ c[2,6]== 0,
</p>
<p>5
</p>
<p>3
+ c[1,3]+ c[3,5]+ c[3,6]== 0,
</p>
<p>5
</p>
<p>3
+ c[1,4]+ c[2,4]+ c[4,6]== 0,
</p>
<p>5
</p>
<p>3
+ c[1,5]+ c[2,5]+ c[3,5]== 0,
</p>
<p>5
</p>
<p>3
+ c[2,6]+ c[3,6]+ c[4,6]== 0
</p>
<p>}
</p>
<p>Let&rsquo;s take x= c[1,3], y= c[3,5], z= c[5,1] as independent variables and express the
remaining ones via them.
</p>
<p>In[11] := c[1,3] = x; c[3,5] = y; c[1,5] = z;In[11] := c[1,3] = x; c[3,5] = y; c[1,5] = z;In[11] := c[1,3] = x; c[3,5] = y; c[1,5] = z;
In[12] := s= Solve[Eq,{c[1,4],c[2,4],c[2,5],c[2,6],c[3,6],c[4,6]}][[1]]In[12] := s= Solve[Eq,{c[1,4],c[2,4],c[2,5],c[2,6],c[3,6],c[4,6]}][[1]]In[12] := s= Solve[Eq,{c[1,4],c[2,4],c[2,5],c[2,6],c[3,6],c[4,6]}][[1]]
Out[12] =
</p>
<p>{
</p>
<p>c[1,4]&rarr;&minus;5
3
&minus; x&minus; z,c[2,4]&rarr; z,c[2,5]&rarr;&minus;5
</p>
<p>3
&minus; y&minus; z,c[2,6]&rarr; y,
</p>
<p>c[3,6]&rarr;&minus;5
3
&minus; x&minus; y,c[4,6]&rarr; x
</p>
<p>}
</p>
<p>In[13] := c[1,4] = c[1,4]/.s; c[2,4] = c[2,4]/.s; c[2,5] = c[2,5]/.s;In[13] := c[1,4] = c[1,4]/.s; c[2,4] = c[2,4]/.s; c[2,5] = c[2,5]/.s;In[13] := c[1,4] = c[1,4]/.s; c[2,4] = c[2,4]/.s; c[2,5] = c[2,5]/.s;
c[2,6] = c[2,6]/.s; c[3,6] = c[3,6]/.s; c[4,6] = c[4,6]/.s;c[2,6] = c[2,6]/.s; c[3,6] = c[3,6]/.s; c[4,6] = c[4,6]/.s;c[2,6] = c[2,6]/.s; c[3,6] = c[3,6]/.s; c[4,6] = c[4,6]/.s;
</p>
<p>In[14] := Clear[s]In[14] := Clear[s]In[14] := Clear[s]
In[15] := MatrixForm[M =M]In[15] := MatrixForm[M =M]In[15] := MatrixForm[M =M]
Out[15]//MatrixForm=
</p>
<p>⎛
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎜
</p>
<p>⎝
</p>
<p>1 13 x &minus; 53 &minus; x&minus; z z 13
1
3 1
</p>
<p>1
3 z &minus; 53 &minus; y&minus; z y
</p>
<p>x 13 1
1
3 y &minus; 53 &minus; x&minus; y
</p>
<p>&minus; 53 &minus; x&minus; z z 13 1 13 x
z &minus; 53 &minus; y&minus; z y 13 1 13
1
3 y &minus; 53 &minus; x&minus; y x 13 1
</p>
<p>⎞
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎟
</p>
<p>⎠</p>
<p/>
</div>
<div class="page"><p/>
<p>196 24 Cyclohexane
</p>
<p>24.3 Equations
</p>
<p>Generating Combinations
</p>
<p>Now let&rsquo;s recall that our vectors a[1], . . . , a[6] live in 3-dimensional space. Any
4 of them are linearly dependent. First we have to find a way to generate all 4-
</p>
<p>element lists made of the numbers from 1 to 6 in the increasing order. We shall
</p>
<p>accumulate them in the list L. The main work is done by the recursive function Gen.
</p>
<p>Its parameters: l&mdash;part of the list which has been already constructed; n&mdash;how many
</p>
<p>elements are to be added; a and b&mdash;boundaries of the interval from which numbers
</p>
<p>can be taken. If everything has been done (n= 0), the constructed list l is appended
to the list of results L. Otherwise, we add each number i from the allowed interval
</p>
<p>to l and call Gen recursively to add n&minus; 1 numbers. The upper limit of the loop is
determined by the requirement to have at least n&minus; 1 numbers in the interval from
i+ 1 to b.
In[16] := L= {};In[16] := L= {};In[16] := L= {};
In[17] := Gen[l ,n ,a ,b ] := If[n&le; 0,L= Append[L, l],In[17] := Gen[l ,n ,a ,b ] := If[n&le; 0,L= Append[L, l],In[17] := Gen[l ,n ,a ,b ] := If[n&le; 0,L= Append[L, l],
</p>
<p>Do[Gen[Append[l, i],n&minus; 1, i+ 1,b],{i,a,b&minus; n+1}]]Do[Gen[Append[l, i],n&minus; 1, i+ 1,b],{i,a,b&minus; n+1}]]Do[Gen[Append[l, i],n&minus; 1, i+ 1,b],{i,a,b&minus; n+1}]]
In[18] := Gen[{},4,1,6]; LIn[18] := Gen[{},4,1,6]; LIn[18] := Gen[{},4,1,6]; L
Out[18] = {{1,2,3,4},{1,2,3,5},{1,2,3,6},{1,2,4,5},{1,2,4,6},{1,2,5,6},
</p>
<p>{1,3,4,5},{1,3,4,6},{1,3,5,6},{1,4,5,6},{2,3,4,5},{2,3,4,6},
{2,3,5,6},{2,4,5,6},{3,4,5,6}}
</p>
<p>It works. There are 15 4-combinations of 6 numbers.
</p>
<p>Nonlinear Equations
</p>
<p>For each set of 4 vectors, the determinant of the corresponding 4&times; 4 submatrix of
the matrix M (it is the square of the 4-dimensional volume spanned by these vectors)
</p>
<p>should be equal to 0.
</p>
<p>In[19] := Eq = Table[Det[M[[l, l]]],{l,L}]In[19] := Eq = Table[Det[M[[l, l]]],{l,L}]In[19] := Eq = Table[Det[M[[l, l]]],{l,L}]
</p>
<p>Out[19] =
</p>
<p>{
</p>
<p>&minus;5
3
&minus; 34x
</p>
<p>9
&minus; 23x
</p>
<p>2
</p>
<p>9
&minus; 34z
</p>
<p>9
&minus; 20xz
</p>
<p>9
+
</p>
<p>2x2z
</p>
<p>3
&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xz2
</p>
<p>3
+ x2z2,
</p>
<p>&minus; 2+ 2x
9
+
</p>
<p>16x2
</p>
<p>9
&minus; 40y
</p>
<p>9
+
</p>
<p>10xy
</p>
<p>9
+
</p>
<p>10x2y
</p>
<p>3
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xy2
</p>
<p>3
+ x2y2 &minus; 40z
</p>
<p>9
+
</p>
<p>10xz
</p>
<p>9
+
</p>
<p>10x2z
</p>
<p>3
&minus; 32yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+ 2x2yz&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xz2
</p>
<p>3
+ x2z2,
</p>
<p>&minus; 5
3
&minus; 34x
</p>
<p>9
&minus; 23x
</p>
<p>2
</p>
<p>9
&minus; 34y
</p>
<p>9
&minus; 20xy
</p>
<p>9
+
</p>
<p>2x2y
</p>
<p>3
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xy2
</p>
<p>3
+ x2y2,
</p>
<p>7
</p>
<p>3
+
</p>
<p>50x
</p>
<p>9
+
</p>
<p>16x2
</p>
<p>9
+
</p>
<p>50y
</p>
<p>9
+
</p>
<p>98xy
</p>
<p>9
+
</p>
<p>10x2y
</p>
<p>3
+
</p>
<p>16y2
</p>
<p>9
+
</p>
<p>10xy2
</p>
<p>3
+ x2y2 +
</p>
<p>20z
</p>
<p>3
+
</p>
<p>118xz
</p>
<p>9
+
</p>
<p>10x2z
</p>
<p>3
+
</p>
<p>118yz
</p>
<p>9
+
</p>
<p>40xyz
</p>
<p>3
+ 2x2yz+
</p>
<p>10y2z
</p>
<p>3
+ 2xy2z+ 4z2+</p>
<p/>
</div>
<div class="page"><p/>
<p>24.3 Equations 197
</p>
<p>20xz2
</p>
<p>3
+ x2z2 +
</p>
<p>20yz2
</p>
<p>3
+ 2xyz2 + y2z2,
</p>
<p>&minus; 2&minus; 40x
9
</p>
<p>&minus; 23x
2
</p>
<p>9
+
</p>
<p>2y
</p>
<p>9
+
</p>
<p>10xy
</p>
<p>9
+
</p>
<p>2x2y
</p>
<p>3
+
</p>
<p>16y2
</p>
<p>9
+
</p>
<p>10xy2
</p>
<p>3
+ x2y2 &minus; 40z
</p>
<p>9
&minus;
</p>
<p>32xz
</p>
<p>9
+
</p>
<p>10yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+
</p>
<p>10y2z
</p>
<p>3
+ 2xy2z&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2yz2
</p>
<p>3
+ y2z2,
</p>
<p>&minus; 5
3
&minus; 34y
</p>
<p>9
&minus; 23y
</p>
<p>2
</p>
<p>9
&minus; 34z
</p>
<p>9
&minus; 20yz
</p>
<p>9
+
</p>
<p>2y2z
</p>
<p>3
&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2yz2
</p>
<p>3
+ y2z2,
</p>
<p>&minus; 2&minus; 40x
9
</p>
<p>&minus; 23x
2
</p>
<p>9
+
</p>
<p>2y
</p>
<p>9
+
</p>
<p>10xy
</p>
<p>9
+
</p>
<p>2x2y
</p>
<p>3
+
</p>
<p>16y2
</p>
<p>9
+
</p>
<p>10xy2
</p>
<p>3
+ x2y2 &minus; 40z
</p>
<p>9
&minus;
</p>
<p>32xz
</p>
<p>9
+
</p>
<p>10yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+
</p>
<p>10y2z
</p>
<p>3
+ 2xy2z&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2yz2
</p>
<p>3
+ y2z2,
</p>
<p>7
</p>
<p>3
+
</p>
<p>20x
</p>
<p>3
+ 4x2 +
</p>
<p>50y
</p>
<p>9
+
</p>
<p>118xy
</p>
<p>9
+
</p>
<p>20x2y
</p>
<p>3
+
</p>
<p>16y2
</p>
<p>9
+
</p>
<p>10xy2
</p>
<p>3
+ x2y2 +
</p>
<p>50z
</p>
<p>9
+
</p>
<p>118xz
</p>
<p>9
+
</p>
<p>20x2z
</p>
<p>3
+
</p>
<p>98yz
</p>
<p>9
+
</p>
<p>40xyz
</p>
<p>3
+ 2x2yz+
</p>
<p>10y2z
</p>
<p>3
+ 2xy2z+
</p>
<p>16z2
</p>
<p>9
+
</p>
<p>10xz2
</p>
<p>3
+ x2z2 +
</p>
<p>10yz2
</p>
<p>3
+ 2xyz2 + y2z2,
</p>
<p>&minus; 2&minus; 40x
9
</p>
<p>&minus; 23x
2
</p>
<p>9
&minus; 40y
</p>
<p>9
&minus; 32xy
</p>
<p>9
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2z
</p>
<p>9
+
</p>
<p>10xz
</p>
<p>9
+
</p>
<p>2x2z
</p>
<p>3
+
</p>
<p>10yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+
</p>
<p>2y2z
</p>
<p>3
+
</p>
<p>16z2
</p>
<p>9
+
</p>
<p>10xz2
</p>
<p>3
+ x2z2 +
</p>
<p>10yz2
</p>
<p>3
+ 2xyz2 + y2z2,
</p>
<p>&minus; 5
3
&minus; 34x
</p>
<p>9
&minus; 23x
</p>
<p>2
</p>
<p>9
&minus; 34z
</p>
<p>9
&minus; 20xz
</p>
<p>9
+
</p>
<p>2x2z
</p>
<p>3
&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xz2
</p>
<p>3
+ x2z2,
</p>
<p>&minus; 5
3
&minus; 34y
</p>
<p>9
&minus; 23y
</p>
<p>2
</p>
<p>9
&minus; 34z
</p>
<p>9
&minus; 20yz
</p>
<p>9
+
</p>
<p>2y2z
</p>
<p>3
&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2yz2
</p>
<p>3
+ y2z2,
</p>
<p>&minus; 2&minus; 40x
9
</p>
<p>&minus; 23x
2
</p>
<p>9
&minus; 40y
</p>
<p>9
&minus; 32xy
</p>
<p>9
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2z
</p>
<p>9
+
</p>
<p>10xz
</p>
<p>9
+
</p>
<p>2x2z
</p>
<p>3
+
</p>
<p>10yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+
</p>
<p>2y2z
</p>
<p>3
+
</p>
<p>16z2
</p>
<p>9
+
</p>
<p>10xz2
</p>
<p>3
+ x2z2 +
</p>
<p>10yz2
</p>
<p>3
+ 2xyz2 + y2z2,
</p>
<p>7
</p>
<p>3
+
</p>
<p>50x
</p>
<p>9
+
</p>
<p>16x2
</p>
<p>9
+
</p>
<p>20y
</p>
<p>3
+
</p>
<p>118xy
</p>
<p>9
+
</p>
<p>10x2y
</p>
<p>3
+ 4y2+
</p>
<p>20xy2
</p>
<p>3
+ x2y2 +
</p>
<p>50z
</p>
<p>9
+
</p>
<p>98xz
</p>
<p>9
+
</p>
<p>10x2z
</p>
<p>3
+
</p>
<p>118yz
</p>
<p>9
+
</p>
<p>40xyz
</p>
<p>3
+ 2x2yz+
</p>
<p>20y2z
</p>
<p>3
+ 2xy2z+
</p>
<p>16z2
</p>
<p>9
+
</p>
<p>10xz2
</p>
<p>3
+ x2z2 +
</p>
<p>10yz2
</p>
<p>3
+ 2xyz2 + y2z2,
</p>
<p>&minus; 2+ 2x
9
+
</p>
<p>16x2
</p>
<p>9
&minus; 40y
</p>
<p>9
+
</p>
<p>10xy
</p>
<p>9
+
</p>
<p>10x2y
</p>
<p>3
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xy2
</p>
<p>3
+ x2y2 &minus; 40z
</p>
<p>9
+
</p>
<p>10xz
</p>
<p>9
+
</p>
<p>10x2z
</p>
<p>3
&minus; 32yz
</p>
<p>9
+
</p>
<p>10xyz
</p>
<p>3
+ 2x2yz&minus; 23z
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xz2
</p>
<p>3
+ x2z2,
</p>
<p>&minus; 5
3
&minus; 34x
</p>
<p>9
&minus; 23x
</p>
<p>2
</p>
<p>9
&minus; 34y
</p>
<p>9
&minus; 20xy
</p>
<p>9
+
</p>
<p>2x2y
</p>
<p>3
&minus; 23y
</p>
<p>2
</p>
<p>9
+
</p>
<p>2xy2
</p>
<p>3
+ x2y2
</p>
<p>}
</p>
<p>These 15 polynomials of 3 variables must be equal to 0.
</p>
<p>In[20] := Clear[L]In[20] := Clear[L]In[20] := Clear[L]</p>
<p/>
</div>
<div class="page"><p/>
<p>198 24 Cyclohexane
</p>
<p>Gröbner Basis
</p>
<p>Let&rsquo;s find a simpler set of polynomials having the same solution set&mdash;the Gröbner
</p>
<p>basis.
</p>
<p>In[21] := GB = GroebnerBasis[Eq,{z,y,x}]In[21] := GB = GroebnerBasis[Eq,{z,y,x}]In[21] := GB = GroebnerBasis[Eq,{z,y,x}]
Out[21] =
</p>
<p>{
</p>
<p>&minus;15&minus; 34x&minus; 23x2&minus; 34y&minus; 20xy+ 6x2y&minus; 23y2+ 6xy2 + 9x2y2,
&minus; 102&minus; 400x&minus; 284x2+ 18x4&minus; 69y&minus; 212xy+ 18x2y+ 108x3y+ 27x4y&minus;
</p>
<p>69z&minus; 212xz+ 18x2z+ 108x3z+ 27x4z,
18+ 54x+ 18x2&minus; 6x3 + 21y+ 41xy&minus; 9x2y&minus; 9x3y+ 21z+ 41xz&minus;
</p>
<p>9x2z&minus; 9x3z+ 20yz,
&minus; 15&minus; 34x&minus; 23x2&minus; 34z&minus; 20xz+ 6x2z&minus; 23z2+ 6xz2 + 9x2z2
</p>
<p>}
</p>
<p>Do they factorize?
</p>
<p>In[22] := GB = Map[Factor,GB]In[22] := GB = Map[Factor,GB]In[22] := GB = Map[Factor,GB]
Out[22] =
</p>
<p>{
</p>
<p>&minus;15&minus; 34x&minus; 23x2&minus; 34y&minus; 20xy+ 6x2y&minus; 23y2+ 6xy2 + 9x2y2,
(3+ x)(1+ 3x)
</p>
<p>(
</p>
<p>&minus;34&minus; 20x+ 6x2&minus; 23y+ 6xy+ 9x2y&minus; 23z+ 6xz+ 9x2z
)
</p>
<p>,
</p>
<p>18+ 54x+ 18x2&minus; 6x3 + 21y+ 41xy&minus; 9x2y&minus; 9x3y+ 21z+ 41xz&minus; 9x2z&minus;
9x3z+ 20yz,
</p>
<p>&minus; 15&minus; 34x&minus; 23x2&minus; 34z&minus; 20xz+ 6x2z&minus; 23z2+ 6xz2 + 9x2z2
}
</p>
<p>In[23] := p1 = GB[[1]]; p2 = GB[[2]]/(3+ x)/(1+ 3 &lowast; x);In[23] := p1 = GB[[1]]; p2 = GB[[2]]/(3+ x)/(1+ 3 &lowast; x);In[23] := p1 = GB[[1]]; p2 = GB[[2]]/(3+ x)/(1+ 3 &lowast; x);
p3 = GB[[3]]; p4 = GB[[4]];p3 = GB[[3]]; p4 = GB[[4]];p3 = GB[[3]]; p4 = GB[[4]];
</p>
<p>24.4 Projection onto the x, y Plane
</p>
<p>Allowed Region
</p>
<p>First let&rsquo;s find the projection of the solution set onto the x, y plane. What part of this
</p>
<p>plane are we interested in? First, x and y should lie between &minus;1 and 1; second,
In[24] := c[3,6]In[24] := c[3,6]In[24] := c[3,6]
</p>
<p>Out[24] =&minus;5
3
&minus; x&minus; y
</p>
<p>should also lie between &minus;1 and 1.
In[25] := RegionPlot[&minus;1 &le; x&le; 1&amp;&amp;&minus; 1&le; y&le; 1&amp;&amp;&minus; 1&le; c[3,6]&le; 1,In[25] := RegionPlot[&minus;1 &le; x&le; 1&amp;&amp;&minus; 1&le; y&le; 1&amp;&amp;&minus; 1&le; c[3,6]&le; 1,In[25] := RegionPlot[&minus;1 &le; x&le; 1&amp;&amp;&minus; 1&le; y&le; 1&amp;&amp;&minus; 1 &le; c[3,6]&le; 1,
</p>
<p>{x,&minus;1,1},{y,&minus;1,1}]{x,&minus;1,1},{y,&minus;1,1}]{x,&minus;1,1},{y,&minus;1,1}]</p>
<p/>
</div>
<div class="page"><p/>
<p>24.4 Projection onto the x, y Plane 199
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>Out[25] =
</p>
<p>That is, the allowed region is the triangle with the vertices (&minus;1,&minus;1), (&minus;1,1/3), and
(1/3,&minus;1).
</p>
<p>Solutions with x=&minus;1/3
</p>
<p>The second equation is satisfied at x=&minus;1/3. What about the other ones?
In[26] := Eq = {p1,p3,p4}/.x&minus;&gt;&minus; 1/3In[26] := Eq = {p1,p3,p4}/.x&minus;&gt;&minus; 1/3In[26] := Eq = {p1,p3,p4}/.x&minus;&gt;&minus; 1/3
Out[26] =
</p>
<p>{
</p>
<p>&minus;56
9
</p>
<p>&minus; 80y
3
</p>
<p>&minus; 24y2, 20
9
</p>
<p>+
20y
</p>
<p>3
+
</p>
<p>20z
</p>
<p>3
+ 20yz,&minus;56
</p>
<p>9
&minus; 80z
</p>
<p>3
&minus; 24z2
</p>
<p>}
</p>
<p>In[27] := GB = GroebnerBasis[Eq,{z,y}]In[27] := GB = GroebnerBasis[Eq,{z,y}]In[27] := GB = GroebnerBasis[Eq,{z,y}]
Out[27] =
</p>
<p>{
</p>
<p>7+ 30y+ 27y2,1+ 3y+ 3z+ 9yz,7+30z+27z2
}
</p>
<p>In[28] := GB = Map[Factor,GB]In[28] := GB = Map[Factor,GB]In[28] := GB = Map[Factor,GB]
Out[28] = {(1+ 3y)(7+ 9y),(1+ 3y)(1+3z),(1+3z)(7+9z)}
So, we have found the solutions x = y = z = &minus;1/3; x = y = &minus;1/3, z = &minus;7/9; and
x= z=&minus;1/3, y=&minus;7/9.
In[29] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}In[29] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}In[29] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}
Out[29] = {0,0,0}
In[30] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 7/9}In[30] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 7/9}In[30] := Eq/.{y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 7/9}
Out[30] = {0,0,0}</p>
<p/>
</div>
<div class="page"><p/>
<p>200 24 Cyclohexane
</p>
<p>In[31] := Eq/.{y&minus;&gt;&minus; 7/9,z&minus;&gt;&minus; 1/3}In[31] := Eq/.{y&minus;&gt;&minus; 7/9,z&minus;&gt;&minus; 1/3}In[31] := Eq/.{y&minus;&gt;&minus; 7/9,z&minus;&gt;&minus; 1/3}
Out[31] = {0,0,0}
It is clear from the symmetry argument that y = z = &minus;1/3, x = &minus;7/9 is also a
solution.
</p>
<p>In[32] := {p1,p2,p3,p4}/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}In[32] := {p1,p2,p3,p4}/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}In[32] := {p1,p2,p3,p4}/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3,z&minus;&gt;&minus; 1/3}
Out[32] = {0,0,0,0}
</p>
<p>Other Solutions
</p>
<p>The first equation contains only x and y.
</p>
<p>In[33] := p1In[33] := p1In[33] := p1
Out[33] =&minus;15&minus; 34x&minus; 23x2&minus; 34y&minus; 20xy+ 6x2y&minus; 23y2+ 6xy2 + 9x2y2
In[34] := P1 = ContourPlot[p1 == 0,{x,&minus;1,0},{y,&minus;1,0}]In[34] := P1 = ContourPlot[p1 == 0,{x,&minus;1,0},{y,&minus;1,0}]In[34] := P1 = ContourPlot[p1 == 0,{x,&minus;1,0},{y,&minus;1,0}]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>Out[34] =
</p>
<p>This equation is quadratic in y.
</p>
<p>In[35] := Do[c[i] = Coefficient[p1,y, i],{i,0,2}]In[35] := Do[c[i] = Coefficient[p1,y, i],{i,0,2}]In[35] := Do[c[i] = Coefficient[p1,y, i],{i,0,2}]
Does c[2] vanish somewhere?
In[36] := s= Solve[c[2] == 0,x]In[36] := s= Solve[c[2] == 0,x]In[36] := s= Solve[c[2] == 0,x]
</p>
<p>Out[36] =
</p>
<p>{{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;1&minus; 2
&radic;
</p>
<p>6
)
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;1+ 2
&radic;
</p>
<p>6
)
</p>
<p>}}</p>
<p/>
</div>
<div class="page"><p/>
<p>24.4 Projection onto the x, y Plane 201
</p>
<p>In[37] := N[x/.s]In[37] := N[x/.s]In[37] := N[x/.s]
Out[37] = {&minus;1.96633,1.29966}
In our region c[2]&gt; 0. The discriminant:
In[38] := d = Factor[c[1]&and;2&minus; 4 &lowast; c[0]&lowast; c[2]]In[38] := d = Factor[c[1]&and;2&minus; 4 &lowast; c[0]&lowast; c[2]]In[38] := d = Factor[c[1]&and;2&minus; 4 &lowast; c[0]&lowast; c[2]]
Out[38] = 32(&minus;1+ x)(7+ 9x)
</p>
<p>(
</p>
<p>1+ 6x+ 3x2
)
</p>
<p>In[39] := s= Solve[d == 0,x]In[39] := s= Solve[d == 0,x]In[39] := s= Solve[d == 0,x]
</p>
<p>Out[39] =
</p>
<p>{{
</p>
<p>x&rarr;&minus;7
9
</p>
<p>}
</p>
<p>,{x&rarr; 1},
{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;3&minus;
&radic;
</p>
<p>6
)
</p>
<p>}
</p>
<p>,
{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;3+
&radic;
</p>
<p>6
)
</p>
<p>}}
</p>
<p>In[40] := N[x/.s]In[40] := N[x/.s]In[40] := N[x/.s]
Out[40] = {&minus;0.777778,1,&minus;1.8165,&minus;0.183503}
The discriminant is positive between x=&minus;7/9 and
In[41] := xmax = x/.s[[4]]In[41] := xmax = x/.s[[4]]In[41] := xmax = x/.s[[4]]
</p>
<p>Out[41] =
1
</p>
<p>3
</p>
<p>(
</p>
<p>&minus;3+
&radic;
</p>
<p>6
)
</p>
<p>In[42] := Clear[s]In[42] := Clear[s]In[42] := Clear[s]
Two values of y (with pm =&plusmn;1) correspond to each x from this interval.
In[43] := y1 = (&minus;c[1]+ pm&lowast;Sqrt[d])/(2 &lowast; c[2])In[43] := y1 = (&minus;c[1]+ pm&lowast;Sqrt[d])/(2 &lowast; c[2])In[43] := y1 = (&minus;c[1]+ pm&lowast;Sqrt[d])/(2 &lowast; c[2])
Out[43] =
</p>
<p>(
</p>
<p>34+ 20x&minus; 6x2+ 4
&radic;
</p>
<p>2pm
</p>
<p>&radic;
</p>
<p>(&minus;1+ x)(7+ 9x)(1+ 6x+ 3x2)
)
</p>
<p>/
(
</p>
<p>2
(
</p>
<p>&minus;23+ 6x+ 9x2
))
</p>
<p>In[44] := Clear[d]In[44] := Clear[d]In[44] := Clear[d]
Do the points we found earlier lie on this curve?
</p>
<p>In[45] := {p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3},p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 7/9},In[45] := {p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3},p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 7/9},In[45] := {p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3},p1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 7/9},
p1/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3}}p1/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3}}p1/.{x&minus;&gt;&minus; 7/9,y&minus;&gt;&minus; 1/3}}
</p>
<p>Out[45] = {0,0,0}
Yes, they do. Let&rsquo;s denote these points A, B, C.
</p>
<p>In[46] := pA = {&minus;1/3,&minus;1/3}; pB = {&minus;1/3,&minus;7/9}; pC = {&minus;7/9,&minus;1/3};In[46] := pA = {&minus;1/3,&minus;1/3}; pB = {&minus;1/3,&minus;7/9}; pC = {&minus;7/9,&minus;1/3};In[46] := pA = {&minus;1/3,&minus;1/3}; pB = {&minus;1/3,&minus;7/9}; pC = {&minus;7/9,&minus;1/3};
So, all solutions we are interested in project onto this curve in the x, y plane.
</p>
<p>We shall need a few extra points on this curve. Let&rsquo;s find the second intersection
</p>
<p>with the diagonal x= y (the first one is the point A).
In[47] := s= Solve[(p1/.y&minus;&gt;x) == 0,x]In[47] := s= Solve[(p1/.y&minus;&gt;x) == 0,x]In[47] := s= Solve[(p1/.y&minus;&gt;x) == 0,x]
Out[47] =
</p>
<p>{
</p>
<p>{x&rarr;&minus;3},
{
</p>
<p>x&rarr;&minus;1
3
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>3&minus; 2
&radic;
</p>
<p>6
)
</p>
<p>}
</p>
<p>,
{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>3+ 2
&radic;
</p>
<p>6
)
</p>
<p>}}
</p>
<p>In[48] := N[x/.s]In[48] := N[x/.s]In[48] := N[x/.s]
Out[48] = {&minus;3.,&minus;0.333333,&minus;0.632993,2.63299}
In[49] := x0 = x/.s[[3]]In[49] := x0 = x/.s[[3]]In[49] := x0 = x/.s[[3]]
</p>
<p>Out[49] =
1
</p>
<p>3
</p>
<p>(
</p>
<p>3&minus; 2
&radic;
</p>
<p>6
)
</p>
<p>Let&rsquo;s call this point D.
</p>
<p>In[50] := pD = {x0,x0};In[50] := pD = {x0,x0};In[50] := pD = {x0,x0};
In[51] := Clear[s,x0]In[51] := Clear[s,x0]In[51] := Clear[s,x0]</p>
<p/>
</div>
<div class="page"><p/>
<p>202 24 Cyclohexane
</p>
<p>Finally, let&rsquo;s introduce some additional point between A and B (rather arbitrarily;
</p>
<p>e.g., let it have x=&minus;1/4) and call it E. Let its mirror image be the point F.
In[52] := x0 =&minus;1/4;In[52] := x0 =&minus;1/4;In[52] := x0 =&minus;1/4;
In[53] := y0 = Simplify[y1/.{x&minus;&gt;x0,pm&minus;&gt;1}]In[53] := y0 = Simplify[y1/.{x&minus;&gt;x0,pm&minus;&gt;1}]In[53] := y0 = Simplify[y1/.{x&minus;&gt;x0,pm&minus;&gt;1}]
Out[53] =
</p>
<p>1
</p>
<p>383
</p>
<p>(
</p>
<p>&minus;229&minus; 10
&radic;
</p>
<p>38
)
</p>
<p>In[54] := pE = {x0,y0}; pF = {y0,x0};In[54] := pE = {x0,y0}; pF = {y0,x0};In[54] := pE = {x0,y0}; pF = {y0,x0};
In[55] := Clear[x0,y0]In[55] := Clear[x0,y0]In[55] := Clear[x0,y0]
This is shown in the plot.
</p>
<p>In[56] := P2 = Graphics[{PointSize[Large],In[56] := P2 = Graphics[{PointSize[Large],In[56] := P2 = Graphics[{PointSize[Large],
Red,Point[pA],Text[Style[A,Large],pA,{&minus;1,&minus;1}],Red,Point[pA],Text[Style[A,Large],pA,{&minus;1,&minus;1}],Red,Point[pA],Text[Style[A,Large],pA,{&minus;1,&minus;1}],
Point[pB],Text[Style[B,Large],pB,{0,1}],Point[pB],Text[Style[B,Large],pB,{0,1}],Point[pB],Text[Style[B,Large],pB,{0,1}],
Point[pC],Text[Style[C,Large],pC,{1,0}],Point[pC],Text[Style[C,Large],pC,{1,0}],Point[pC],Text[Style[C,Large],pC,{1,0}],
Darker[Green],Point[pD],Text[Style[D,Large],pD,{1,1}],Darker[Green],Point[pD],Text[Style[D,Large],pD,{1,1}],Darker[Green],Point[pD],Text[Style[D,Large],pD,{1,1}],
Point[pE],Text[Style[E,Large],pE,{&minus;1,1}],Point[pE],Text[Style[E,Large],pE,{&minus;1,1}],Point[pE],Text[Style[E,Large],pE,{&minus;1,1}],
Point[pF],Text[Style[F,Large],pF,{1,&minus;1}]}];Point[pF],Text[Style[F,Large],pF,{1,&minus;1}]}];Point[pF],Text[Style[F,Large],pF,{1,&minus;1}]}];
</p>
<p>In[57] := Show[P1,P2]In[57] := Show[P1,P2]In[57] := Show[P1,P2]
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>Out[57] =
</p>
<p>What&rsquo;s the reason for introducing the points D, E, F? Now it is easy to write
</p>
<p>down our curve parametrically. For t &isin; [0,1] let the point move from F to A, the
motion along x being uniform.
</p>
<p>In[58] := pFA[t ] := With[{xt = (1&minus; t)&lowast; pF[[1]]+ t &lowast; pA[[1]]},In[58] := pFA[t ] := With[{xt = (1&minus; t)&lowast; pF[[1]]+ t &lowast; pA[[1]]},In[58] := pFA[t ] := With[{xt = (1&minus; t)&lowast; pF[[1]]+ t &lowast; pA[[1]]},
{xt,y1/.{x&minus;&gt;xt,pm&minus;&gt;&minus; 1}}]{xt,y1/.{x&minus;&gt;xt,pm&minus;&gt;&minus; 1}}]{xt,y1/.{x&minus;&gt;xt,pm&minus;&gt;&minus; 1}}]
</p>
<p>In[59] := P1 = ParametricPlot[pFA[t],{t,0,1},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[59] := P1 = ParametricPlot[pFA[t],{t,0,1},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[59] := P1 = ParametricPlot[pFA[t],{t,0,1},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];</p>
<p/>
</div>
<div class="page"><p/>
<p>24.4 Projection onto the x, y Plane 203
</p>
<p>In[60] := Show[P1,P2]In[60] := Show[P1,P2]In[60] := Show[P1,P2]
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[60] =
</p>
<p>For t &isin; [1,2] let the point move from A to E; this segment is mirror-symmetric to
the previous one.
</p>
<p>In[61] := pAE[t ] := With[{y0 = (2&minus; t)&lowast; pA[[2]]+ (t&minus; 1)&lowast; pE[[2]]},In[61] := pAE[t ] := With[{y0 = (2&minus; t)&lowast; pA[[2]]+ (t&minus; 1)&lowast; pE[[2]]},In[61] := pAE[t ] := With[{y0 = (2&minus; t)&lowast; pA[[2]]+ (t&minus; 1)&lowast; pE[[2]]},
{y1/.{x&minus;&gt;y0,pm&minus;&gt;&minus; 1},y0}]{y1/.{x&minus;&gt;y0,pm&minus;&gt;&minus; 1},y0}]{y1/.{x&minus;&gt;y0,pm&minus;&gt;&minus; 1},y0}]
</p>
<p>In[62] := P1 = ParametricPlot[pAE[t],{t,1,2},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[62] := P1 = ParametricPlot[pAE[t],{t,1,2},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[62] := P1 = ParametricPlot[pAE[t],{t,1,2},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];
In[63] := Show[P1,P2]In[63] := Show[P1,P2]In[63] := Show[P1,P2]
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[63] =</p>
<p/>
</div>
<div class="page"><p/>
<p>204 24 Cyclohexane
</p>
<p>For t &isin; [2,3] the point moves from E to D, the motion along x being uniform.
In[64] := pED[t ] := With[{x0 = (3&minus; t)&lowast; pE[[1]]+ (t&minus; 2)&lowast; pD[[1]]},In[64] := pED[t ] := With[{x0 = (3&minus; t)&lowast; pE[[1]]+ (t&minus; 2)&lowast; pD[[1]]},In[64] := pED[t ] := With[{x0 = (3&minus; t)&lowast; pE[[1]]+ (t&minus; 2)&lowast; pD[[1]]},
</p>
<p>{x0,y1/.{x&minus;&gt;x0,pm&minus;&gt;1}}]{x0,y1/.{x&minus;&gt;x0,pm&minus;&gt;1}}]{x0,y1/.{x&minus;&gt;x0,pm&minus;&gt;1}}]
In[65] := P1 = ParametricPlot[pED[t],{t,2,3},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[65] := P1 = ParametricPlot[pED[t],{t,2,3},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[65] := P1 = ParametricPlot[pED[t],{t,2,3},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];
In[66] := Show[P1,P2]In[66] := Show[P1,P2]In[66] := Show[P1,P2]
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[66] =
</p>
<p>Finally, for t &isin; [3,4] the point moves from D to F; this segment is mirror-symmetric
to the previous one.
</p>
<p>In[67] := pDF[t ] := With[{y0 = (4&minus; t)&lowast; pD[[2]]+ (t&minus; 3)&lowast; pF[[2]]},In[67] := pDF[t ] := With[{y0 = (4&minus; t)&lowast; pD[[2]]+ (t&minus; 3)&lowast; pF[[2]]},In[67] := pDF[t ] := With[{y0 = (4&minus; t)&lowast; pD[[2]]+ (t&minus; 3)&lowast; pF[[2]]},
{y1/.{x&minus;&gt;y0,pm&minus;&gt;1},y0}]{y1/.{x&minus;&gt;y0,pm&minus;&gt;1},y0}]{y1/.{x&minus;&gt;y0,pm&minus;&gt;1},y0}]
</p>
<p>In[68] := P1 = ParametricPlot[pDF[t],{t,3,4},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[68] := P1 = ParametricPlot[pDF[t],{t,3,4},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];In[68] := P1 = ParametricPlot[pDF[t],{t,3,4},PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0}}];
In[69] := Show[P1,P2]In[69] := Show[P1,P2]In[69] := Show[P1,P2]
</p>
<p>Out[69]=
</p>
<p>&minus; &minus; &minus; &minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;</p>
<p/>
</div>
<div class="page"><p/>
<p>24.5 Complete Analysis of the Solutions 205
</p>
<p>Later we shall join these segments and construct a parametric curve in the 3-
</p>
<p>dimensional space x, y, z.
</p>
<p>24.5 Complete Analysis of the Solutions
</p>
<p>How to find the value (or values) of z corresponding to some point x, y on our curve?
</p>
<p>It is easiest to use the second equation&mdash;it is linear in z.
</p>
<p>In[70] := p2In[70] := p2In[70] := p2
Out[70] =&minus;34&minus; 20x+ 6x2&minus; 23y+ 6xy+ 9x2y&minus; 23z+ 6xz+ 9x2z
In[71] := Do[c[i] = Coefficient[p2,z, i],{i,0,1}]In[71] := Do[c[i] = Coefficient[p2,z, i],{i,0,1}]In[71] := Do[c[i] = Coefficient[p2,z, i],{i,0,1}]
Does c[1] vanish somewhere in our region?
In[72] := s= Solve[c[1] == 0,x]In[72] := s= Solve[c[1] == 0,x]In[72] := s= Solve[c[1] == 0,x]
</p>
<p>Out[72] =
</p>
<p>{{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;1&minus; 2
&radic;
</p>
<p>6
)
</p>
<p>}
</p>
<p>,
</p>
<p>{
</p>
<p>x&rarr; 1
3
</p>
<p>(
</p>
<p>&minus;1+ 2
&radic;
</p>
<p>6
)
</p>
<p>}}
</p>
<p>In[73] := N[x/.s]In[73] := N[x/.s]In[73] := N[x/.s]
Out[73] = {&minus;1.96633,1.29966}
No, it does not.
</p>
<p>In[74] := Clear[s]In[74] := Clear[s]In[74] := Clear[s]
So there is a single solution:
</p>
<p>In[75] := z1 =&minus;c[0]/c[1]In[75] := z1 =&minus;c[0]/c[1]In[75] := z1 =&minus;c[0]/c[1]
</p>
<p>Out[75] =
34+ 20x&minus; 6x2+ 23y&minus; 6xy&minus; 9x2y
</p>
<p>&minus;23+ 6x+ 9x2
And what about the third and fourth equations?
</p>
<p>In[76] := p3 = Numerator[Together[p3/.z&minus;&gt;z1]]In[76] := p3 = Numerator[Together[p3/.z&minus;&gt;z1]]In[76] := p3 = Numerator[Together[p3/.z&minus;&gt;z1]]
Out[76] =&minus;20
</p>
<p>(
</p>
<p>&minus;15&minus; 34x&minus; 23x2&minus; 34y&minus; 20xy+ 6x2y&minus; 23y2+ 6xy2 + 9x2y2
)
</p>
<p>In[77] := p4 = Numerator[Together[p4/.z&minus;&gt;z1]]In[77] := p4 = Numerator[Together[p4/.z&minus;&gt;z1]]In[77] := p4 = Numerator[Together[p4/.z&minus;&gt;z1]]
Out[77] =&minus;15&minus; 34x&minus; 23x2&minus; 34y&minus; 20xy+ 6x2y&minus; 23y2+ 6xy2 + 9x2y2
In[78] := Cancel[p3/p1]In[78] := Cancel[p3/p1]In[78] := Cancel[p3/p1]
Out[78] =&minus;20
In[79] := Cancel[p4/p1]In[79] := Cancel[p4/p1]In[79] := Cancel[p4/p1]
Out[79] = 1
They are satisfied automatically. What z corresponds to x= y=&minus;1/3?
In[80] := z1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3}In[80] := z1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3}In[80] := z1/.{x&minus;&gt;&minus; 1/3,y&minus;&gt;&minus; 1/3}
Out[80] =&minus;7
</p>
<p>9
So, one of the solutions found earlier, namely x= y= z=&minus;1/3, does not belong to
our one-dimensional family of solutions. To summarize: we have found one isolated
</p>
<p>solution plus a one-dimensional family of solutions. In the parametric form:
</p>
<p>In[81] := xyz[t ] := With[{xy = Which[t &lt; 1,pFA[t], t &lt; 2,pAE[t],In[81] := xyz[t ] := With[{xy = Which[t &lt; 1,pFA[t], t &lt; 2,pAE[t],In[81] := xyz[t ] := With[{xy = Which[t &lt; 1,pFA[t], t &lt; 2,pAE[t],
t &lt; 3,pED[t],True,pDF[t]]},t &lt; 3,pED[t],True,pDF[t]]},t &lt; 3,pED[t],True,pDF[t]]},
</p>
<p>{xy[[1]],xy[[2]],z1/.{x&minus;&gt;xy[[1]],y&minus;&gt;xy[[2]]}}]{xy[[1]],xy[[2]],z1/.{x&minus;&gt;xy[[1]],y&minus;&gt;xy[[2]]}}]{xy[[1]],xy[[2]],z1/.{x&minus;&gt;xy[[1]],y&minus;&gt;xy[[2]]}}]
In[82] := P1 = ParametricPlot3D[xyz[t],{t,0,4},In[82] := P1 = ParametricPlot3D[xyz[t],{t,0,4},In[82] := P1 = ParametricPlot3D[xyz[t],{t,0,4},
</p>
<p>PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0},{&minus;1,0}},ViewPoint&minus;&gt;{10,11,12}];PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0},{&minus;1,0}},ViewPoint&minus;&gt;{10,11,12}];PlotRange&minus;&gt;{{&minus;1,0},{&minus;1,0},{&minus;1,0}},ViewPoint&minus;&gt;{10,11,12}];
In[83] := p0 = {&minus;1/3,&minus;1/3,&minus;1/3};In[83] := p0 = {&minus;1/3,&minus;1/3,&minus;1/3};In[83] := p0 = {&minus;1/3,&minus;1/3,&minus;1/3};</p>
<p/>
</div>
<div class="page"><p/>
<p>206 24 Cyclohexane
</p>
<p>In[84] := P2 = Graphics3D[{Darker[Green],PointSize[Large],Point[p0]}];In[84] := P2 = Graphics3D[{Darker[Green],PointSize[Large],Point[p0]}];In[84] := P2 = Graphics3D[{Darker[Green],PointSize[Large],Point[p0]}];
In[85] := Show[P1,P2]In[85] := Show[P1,P2]In[85] := Show[P1,P2]
</p>
<p>&minus;
</p>
<p>&minus; &minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>&minus;
</p>
<p>Out[85] =
</p>
<p>You can rotate this plot with your mouse to understand it better.
</p>
<p>24.6 Shape of the Molecule
</p>
<p>What does the cyclohexane molecule look like? Let&rsquo;s direct the x-axis along a[1]:
In[86] := a[1] = {1,0,0}In[86] := a[1] = {1,0,0}In[86] := a[1] = {1,0,0}
Out[86] = {1,0,0}
Let a[2] lie in the x, y plane:
In[87] := a[2] = {1/3,2 &lowast;Sqrt[2]/3,0}In[87] := a[2] = {1/3,2 &lowast;Sqrt[2]/3,0}In[87] := a[2] = {1/3,2 &lowast;Sqrt[2]/3,0}
</p>
<p>Out[87] =
</p>
<p>{
</p>
<p>1
</p>
<p>3
,
</p>
<p>2
&radic;
</p>
<p>2
</p>
<p>3
,0
</p>
<p>}
</p>
<p>That is, the unit vector along y is a combination of a[1] and a[2]:
In[88] := (3 &lowast; a[2]&minus; a[1])/(2 &lowast;Sqrt[2])In[88] := (3 &lowast; a[2]&minus; a[1])/(2 &lowast;Sqrt[2])In[88] := (3 &lowast; a[2]&minus; a[1])/(2 &lowast;Sqrt[2])
Out[88] = {0,1,0}
The projections of a[3] onto x and y are c[1,3] = x and
In[89] := (3 &lowast; c[2,3]&minus; c[1,3])/(2 &lowast;Sqrt[2])In[89] := (3 &lowast; c[2,3]&minus; c[1,3])/(2 &lowast;Sqrt[2])In[89] := (3 &lowast; c[2,3]&minus; c[1,3])/(2 &lowast;Sqrt[2])
Out[89] =
</p>
<p>1&minus; x
2
&radic;
</p>
<p>2</p>
<p/>
</div>
<div class="page"><p/>
<p>24.6 Shape of the Molecule 207
</p>
<p>The projection of a[3] onto the z axis can be found from normalization:
In[90] := a[3] = {x,(1&minus; x)/(2 &lowast;Sqrt[2]),In[90] := a[3] = {x,(1&minus; x)/(2 &lowast;Sqrt[2]),In[90] := a[3] = {x,(1&minus; x)/(2 &lowast;Sqrt[2]),
</p>
<p>pm&lowast;Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]/(2 &lowast;Sqrt[2])}pm&lowast;Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]/(2 &lowast;Sqrt[2])}pm&lowast;Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]/(2 &lowast;Sqrt[2])}
</p>
<p>Out[90] =
</p>
<p>{
</p>
<p>x,
1&minus; x
2
&radic;
</p>
<p>2
,
</p>
<p>pm
&radic;
</p>
<p>(1&minus; x)(7+ 9x)
2
&radic;
</p>
<p>2
</p>
<p>}
</p>
<p>where pm =&plusmn;1. Two molecule shapes correspond to a single set of values of x, y, z;
they differ by the mirror reflection of the z coordinates. We shall discuss this matter
</p>
<p>in a moment.
</p>
<p>In[91] := Table[Expand[a[i].a[3]]/.pm&and;2&minus;&gt;1,{i,1,3}]In[91] := Table[Expand[a[i].a[3]]/.pm&and;2&minus;&gt;1,{i,1,3}]In[91] := Table[Expand[a[i].a[3]]/.pm&and;2&minus;&gt;1,{i,1,3}]
Out[91] =
</p>
<p>{
</p>
<p>x,
1
</p>
<p>3
,1
</p>
<p>}
</p>
<p>That is, the unit vector along the z axis is a combination of a[1], a[2], a[3]:
In[92] := Simplify[2 &lowast;Sqrt[2]/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;In[92] := Simplify[2 &lowast;Sqrt[2]/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;In[92] := Simplify[2 &lowast;Sqrt[2]/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;
</p>
<p>(a[3]&minus; 3/8 &lowast; (1&minus; x)&lowast;a[2]+ (1&minus;9&lowast; x)/8&lowast;a[1])](a[3]&minus; 3/8 &lowast; (1&minus; x)&lowast;a[2]+ (1&minus;9&lowast; x)/8&lowast;a[1])](a[3]&minus; 3/8 &lowast; (1&minus; x)&lowast;a[2]+ (1&minus;9&lowast; x)/8&lowast;a[1])]
Out[92] = {0,0,pm}
The rest is easy.
</p>
<p>In[93] := Do[Print[a[i] = Simplify[{c[1, i],(3 &lowast; c[2, i]&minus; c[1, i])/(2 &lowast;Sqrt[2]),In[93] := Do[Print[a[i] = Simplify[{c[1, i],(3 &lowast; c[2, i]&minus; c[1, i])/(2 &lowast;Sqrt[2]),In[93] := Do[Print[a[i] = Simplify[{c[1, i],(3 &lowast; c[2, i]&minus; c[1, i])/(2 &lowast;Sqrt[2]),
2 &lowast;Sqrt[2]&lowast; pm/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;2 &lowast;Sqrt[2]&lowast; pm/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;2 &lowast;Sqrt[2]&lowast; pm/Sqrt[(1&minus; x)&lowast; (7+ 9 &lowast; x)]&lowast;
</p>
<p>(c[3, i]&minus; 3/8 &lowast; (1&minus; x)&lowast; c[2, i]+ (1&minus;9&lowast; x)/8&lowast; c[1, i])}]],(c[3, i]&minus; 3/8 &lowast; (1&minus; x)&lowast; c[2, i]+ (1&minus;9&lowast; x)/8&lowast; c[1, i])}]],(c[3, i]&minus; 3/8 &lowast; (1&minus; x)&lowast; c[2, i]+ (1&minus;9&lowast; x)/8&lowast; c[1, i])}]],
{i,4,6}]{i,4,6}]{i,4,6}]
</p>
<p>{
</p>
<p>&minus;5
3
&minus; x&minus; z,
</p>
<p>5
3 + x+ 4z
</p>
<p>2
&radic;
</p>
<p>2
,
</p>
<p>pm
(
</p>
<p>1+ 9x2&minus; 4z+ 2x(7+ 6z)
)
</p>
<p>2
&radic;
</p>
<p>2
&radic;
</p>
<p>7+ 2x&minus; 9x2
</p>
<p>}
</p>
<p>{
</p>
<p>z,&minus;5+ 3y+ 4z
2
&radic;
</p>
<p>2
,&minus;pm(&minus;5&minus; 11y&minus; 4z+ x(5+3y+12z))
</p>
<p>2
&radic;
</p>
<p>2
&radic;
</p>
<p>7+ 2x&minus; 9x2
</p>
<p>}
</p>
<p>{
</p>
<p>1
</p>
<p>3
,
&minus;1+ 9y
</p>
<p>6
&radic;
</p>
<p>2
,
</p>
<p>pm(&minus;13&minus; 11y+ x(&minus;11+3y))
2
&radic;
</p>
<p>2
&radic;
</p>
<p>7+ 2x&minus; 9x2
</p>
<p>}
</p>
<p>Let&rsquo;s write a function which constructs the molecule for a given values of x, y, z
</p>
<p>and of the sign pm.
</p>
<p>In[94] := rc = 0.1; rs = 0.25;In[94] := rc = 0.1; rs = 0.25;In[94] := rc = 0.1; rs = 0.25;
In[95] := Molecule[xyz ,s ] := Module[{r = {0,0,0}, r2, l = {Blue},In[95] := Molecule[xyz ,s ] := Module[{r = {0,0,0}, r2, l = {Blue},In[95] := Molecule[xyz ,s ] := Module[{r = {0,0,0}, r2, l = {Blue},
</p>
<p>S = {x&minus;&gt;xyz[[1]],y&minus;&gt;xyz[[2]],z&minus;&gt;xyz[[3]],pm&minus;&gt;s}},S = {x&minus;&gt;xyz[[1]],y&minus;&gt;xyz[[2]],z&minus;&gt;xyz[[3]],pm&minus;&gt;s}},S = {x&minus;&gt;xyz[[1]],y&minus;&gt;xyz[[2]],z&minus;&gt;xyz[[3]],pm&minus;&gt;s}},
Do[r2 = r+(a[i]/.S); l = Append[l,Cylinder[{r, r2}, rc]]; r = r2,{i,1,6}];Do[r2 = r+(a[i]/.S); l = Append[l,Cylinder[{r, r2}, rc]]; r = r2,{i,1,6}];Do[r2 = r+(a[i]/.S); l = Append[l,Cylinder[{r, r2}, rc]]; r = r2,{i,1,6}];
r = {0,0,0}; l = Append[l,Red];r = {0,0,0}; l = Append[l,Red];r = {0,0,0}; l = Append[l,Red];
Do[r2 = r+(a[i]/.S); l = Append[l,Sphere[r, rs]]; r = r2,{i,1,6}];Do[r2 = r+(a[i]/.S); l = Append[l,Sphere[r, rs]]; r = r2,{i,1,6}];Do[r2 = r+(a[i]/.S); l = Append[l,Sphere[r, rs]]; r = r2,{i,1,6}];
Graphics3D[l]]Graphics3D[l]]Graphics3D[l]]
</p>
<p>This is the isolated conformation of the cyclohexane molecule with x = y= z=
&minus;1/3. Use your mouse to understand it better.
In[96] := Show[Molecule[p0,1],ViewPoint&minus;&gt;{15,&minus;5,5},Boxed&minus;&gt;False]In[96] := Show[Molecule[p0,1],ViewPoint&minus;&gt;{15,&minus;5,5},Boxed&minus;&gt;False]In[96] := Show[Molecule[p0,1],ViewPoint&minus;&gt;{15,&minus;5,5},Boxed&minus;&gt;False]</p>
<p/>
</div>
<div class="page"><p/>
<p>208 24 Cyclohexane
</p>
<p>And this is the one-parameter family of conformations. To ensure smooth de-
</p>
<p>pendence on t, it is necessary to flip the sign pm when passing through the point C
</p>
<p>(where the expression under the radical sign vanishes). This happens at
</p>
<p>In[97] := t0 = (621&minus; 8 &lowast;Sqrt[6])/159In[97] := t0 = (621&minus; 8 &lowast;Sqrt[6])/159In[97] := t0 = (621&minus; 8 &lowast;Sqrt[6])/159
Out[97] =
</p>
<p>1
</p>
<p>159
</p>
<p>(
</p>
<p>621&minus; 8
&radic;
</p>
<p>6
)
</p>
<p>So, the molecule returns to its initial shape after we traverse the loop in the x, y,
</p>
<p>z space twice. You can see this conformation family especially clearly if you start
</p>
<p>animation.
</p>
<p>In[98] := Manipulate[Show[In[98] := Manipulate[Show[In[98] := Manipulate[Show[
Molecule[If[t &gt; 4,xyz[t&minus; 4],xyz[t]], If[t &gt; t0&amp;&amp;t &lt; t0+ 4,&minus;1,+1]],Molecule[If[t &gt; 4,xyz[t&minus; 4],xyz[t]], If[t &gt; t0&amp;&amp;t &lt; t0+ 4,&minus;1,+1]],Molecule[If[t &gt; 4,xyz[t&minus; 4],xyz[t]], If[t &gt; t0&amp;&amp;t &lt; t0+ 4,&minus;1,+1]],
PlotRange&minus;&gt;{{&minus;0.7,1.7},{&minus;0.5,1.9},{&minus;1.7,1.7}},PlotRange&minus;&gt;{{&minus;0.7,1.7},{&minus;0.5,1.9},{&minus;1.7,1.7}},PlotRange&minus;&gt;{{&minus;0.7,1.7},{&minus;0.5,1.9},{&minus;1.7,1.7}},
ViewPoint&minus;&gt;{10,&minus;10,4},Boxed&minus;&gt;False],ViewPoint&minus;&gt;{10,&minus;10,4},Boxed&minus;&gt;False],ViewPoint&minus;&gt;{10,&minus;10,4},Boxed&minus;&gt;False],
</p>
<p>{t,0,8}]{t,0,8}]{t,0,8}]
</p>
<p>Out[98] =</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 25
</p>
<p>Problems for Students
</p>
<p>1. Write a procedure which returns the hydrogen wave function (in spherical coor-
</p>
<p>dinates, i. e., an expression containing r, θ , φ ) for given quantum numbers n, l, m.
Write a procedure to calculate the rate of the electric dipole transition [22] from the
</p>
<p>state n, l, m to the state n&prime;, l&prime;, m&prime;.
</p>
<p>2. Calculate Poisson brackets of the Hamiltonian, the angular momentum com-
</p>
<p>ponents, and the Runge&ndash;Lenz vector components [19] for a particle in the
</p>
<p>Coulomb fieldU =&minus;a/r. Calculate commutators of the same quantities in quantum
mechanics [18].
</p>
<p>3. The hypergeometric function [23, 24, 27] is defined as the sum of the series
</p>
<p>F(a,b,c,x) =
&infin;
</p>
<p>&sum;
n=0
</p>
<p>(a)n(b)n
(c)n
</p>
<p>xn
</p>
<p>n!
,
</p>
<p>where (x)n = x(x+ 1) &middot; &middot; &middot;(x+ n&minus; 1) is the Pochhammer symbol. In many cases it
can be expressed via simpler functions. Write a list of substitutions for simplifying
</p>
<p>hypergeometric functions. It is sufficient to consider only simplifications valid for
</p>
<p>an arbitrary x (not for specific values) where results are expressed via elementary
</p>
<p>functions. More general substitutions should be near the beginning of the list, then
</p>
<p>their particular cases can be eliminated.
</p>
<p>4. Consider indefinite integrals of the form
</p>
<p>&int;
</p>
<p>A(x) logB(x)dx ,
</p>
<p>where A(x) and B(x) are rational functions of x. Mathematica can calculate such
integrals, but often produces results in which some terms have imaginary parts in
</p>
<p>the region of x we are interested in. It is not easy to trace their cancellations. We&rsquo;ll
</p>
<p>suppose that A(x) and B(x) contain no parameters (except x), only numbers. We&rsquo;ll
also suppose that Mathematica is able to find all roots of the denominator of A(x),
as well as of the numerator and the denominator of B(x), and all these roots are real.
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3 25, &copy; Springer International Publishing Switzerland 2014
</p>
<p>209</p>
<p/>
</div>
<div class="page"><p/>
<p>210 25 Problems for Students
</p>
<p>We are interested in a neighborhood of some point x0; we want to get a result all
</p>
<p>terms of which are real near this point (if this is possible, of course). Implement the
</p>
<p>following obvious approach:
</p>
<p>&bull; Expand A(x) into partial fractions with respect to x.
&bull; Replace logB(x) by a combination of terms log(x&minus; ai) and log(ai&minus; x) (plus a
</p>
<p>constant) in such a way that they are all real near x0.
</p>
<p>&bull; Multiply.
&bull; Take integrals of xn log(x&minus; a) (n &ge; 0), log(x&minus; a)/(x&minus; b)n (n &ge; 2) by parts to
</p>
<p>eliminate the logarithm. Don&rsquo;t use the Mathematica integrator&mdash;it can produce
</p>
<p>log(x&minus; a) where log(a&minus; x) is needed.
&bull; We are left with the most difficult terms of the forms log(x&minus; a)/(x&minus; b) and
</p>
<p>log(a&minus; x)/(x&minus; b). By linear substitutions they reduce to 3 cases:
&int;
</p>
<p>log(y+ 1)
</p>
<p>y
dy = &minus;Li2(&minus;y) ,
</p>
<p>&int;
</p>
<p>log(y&minus; 1)
y
</p>
<p>dy = log(y) log(y&minus; 1)+Li2(1&minus; y) ,
&int;
</p>
<p>log(1&minus; y)
y
</p>
<p>dy = &minus;Li2(y) ,
</p>
<p>where y is positive near x = x0 (the third formula is the definition of Li2(y); the
first one follows from it using the substitution y &rarr; &minus;y; the second one&mdash;using
integration by parts).
</p>
<p>The result must be real (log(x) is real at x&gt; 0; Li2(x)&mdash;at x&lt; 1). If this is impossi-
ble, print an error message.
</p>
<p>5. Implement the algebra of Boolean expressions. They consist of the constants true
</p>
<p>and false, variables, the function not (one argument), and the functions and, or (an
</p>
<p>arbitrary number of arguments). The last two functions are commutative and asso-
</p>
<p>ciative. Take into account simplifications when one of the arguments is true or false;
</p>
<p>when two arguments coincide or equal to a and not[a]. Expressions should be re-
duced to the disjunctive normal form: &ldquo;or&rdquo; at the top level; its arguments can be
</p>
<p>&ldquo;and&rdquo;; their arguments can be &ldquo;not&rdquo; or variables.
</p>
<p>6. Implement the algebra of quaternions.
</p>
<p>7. Implement Dirac γ-matrix expressions, including trace calculations (in 4 dimen-
sions [22] or in the general case of dimensional regularization, see, e.g., [24]). Pay
</p>
<p>no attention to efficiency.
</p>
<p>8. Implement calculation of color factors of Feynman diagrams for the color group
</p>
<p>SU(Nc) using the Cvitanović algorithm [27] (see also [24]).
</p>
<p>9. Write a procedure to calculate two-loop massless propagator diagrams using in-
</p>
<p>tegration by parts (see, e.g., [24]). Results should be linear combinations of the two
</p>
<p>basis integrals.</p>
<p/>
</div>
<div class="page"><p/>
<p>25 Problems for Students 211
</p>
<p>10. Hypergeometric functions whose argument is 1 and whose parameters contain
</p>
<p>a small parameters ε and tend to integers at ε &rarr; 0 can be expanded in series in ε .
The algorithm is described, e.g., in [24]; implement it.
</p>
<p>11. Any polynomial over the field of complex numbers can be factorized into linear
</p>
<p>factors:
</p>
<p>p(x) =&prod;(x&minus; ai)di ,
where ai are its roots and di are their multiplicities (to simplify formulas, we have
</p>
<p>assumed that the leading coefficient is 1). Let&rsquo;s group factors with equal di:
</p>
<p>p(x) =&prod; pdii ,
</p>
<p>where all di are distinct and the polynomials pi(x) have only simple zeros (are
square-free). This square-free factorization can be obtained by a simple algorithm
</p>
<p>which uses only gcd (this is much simpler than the full factorization). Namely,
</p>
<p>gcd(p, p&prime;) =&prod; pdi&minus;1i .
</p>
<p>Indeed, the polynomial p(x) has zero of the order di at x&rarr; ai, and its derivative p&prime;(x)
has zero of the order di&minus; 1. Write a function to calculate square-free factorization
using only gcd.</p>
<p/>
</div>
<div class="page"><p/>
<p>References
</p>
<p>1. Buchberger, B., Collins, G.E., Loos, R. (ed.): Computer Algebra: Symbolic and Algebraic
Computation, 2nd edn. Springer, Vienna (1983)
</p>
<p>2. Davenport, J.H., Siret, Y., Tournier, E.: Computer Algebra: Systems and Algorithms for Alge-
braic Computation, 2nd edn. Academic Press, London (1993)
</p>
<p>3. Geddes, K.O., Czapor, S.R., Labahn, G.: Algorithms for Computer Algebra. Kluwer Aca-
demic Publishers, Boston (1992)
</p>
<p>4. von zur Gathen, J., Gerhard, J.: Modern Computer Algebra, 2nd edn. Cambridge University
Press, Cambridge (2003)
</p>
<p>5. Grozin, A.G.: Using REDUCE in High Energy Physics. Cambridge University Press, New
York (1997); paperback edition (2005)
</p>
<p>6. Wolfram, S.: The Mathematica Book, 5th edn. Wolfram Media, Champaign (2003)
7. Trott, M.: The Mathematica GuideBook for Symbolics. Springer Science+Business Media,
</p>
<p>Inc., New York (2006)
8. Trott, M.: The Mathematica GuideBook for Numerics. Springer Science+Business Media,
</p>
<p>Inc., New York (2006)
9. Trott, M.: The Mathematica GuideBook for Graphics. Springer, New York (2004)
</p>
<p>10. Trott, M.: The Mathematica GuideBook for Programming. Springer, New York (2004)
</p>
<p>11. Mangano, S.: Mathematica Cookbook, O&rsquo;Reilly Media, Inc., Sebastopol, CA (2010)
12. Cox, D., Little, J., O&rsquo;Shea, D.: Ideals, Varieties, and Algorithms, 3rd edn. Springer, New York
</p>
<p>(2007)
13. Arzhantsev, I.V.: Gröbner Bases and Systems of Algebraic Equations (in Russian), 3rd edn.
</p>
<p>MCCMO, Moscow (2003). http://www.mccme.ru/free-books/dubna/arjantsev.pdf
14. Kredel, H., Weispfenning, V.: J. Symbolic Computing dimension and independent sets for
</p>
<p>polynomial ideals 6, 231 (1988)
15. Fateman, R.J.: A review of Mathematica. J. Symbolic Comput. 13, 545 (1992). (http://www.
</p>
<p>cs.berkeley.edu/&sim;fateman/papers/mma.pdf); http://www.cs.berkeley.edu/&sim;fateman/papers/
mma6rev.pdf
</p>
<p>16. Bronstein, M.: Symbolic Integration I. Springer, Berlin (1997)
17. Davenport, J.H.: On the integration of algebraic functions. In: Lecture notes in computer sci-
</p>
<p>ence, vol. 102. Springer, New York (1981)
18. Landau, L.D., Lifshitz, E.M.: Quantum Mechanics: Non-relativistic Theory, 3rd edn.
</p>
<p>Butterworth-Heinemann, Oxford (1981)
19. Landau, L.D., Lifshitz, E.M.: Mechanics, 3rd edn. Butterworth-Heinemann, Oxford (1982)
20. Landau, L.D., Lifshitz, E.M.: The Classical Theory of Fields, 4th edn. Butterworth-
</p>
<p>Heinemann, Oxford (1980)
21. Landau, L.D., Lifshitz, E.M., Pitaevskii, L.P.: Electrodynamics of Continuous Media, 2nd edn.
</p>
<p>Butterworth-Heinemann, Oxford (1995)
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3, &copy; Springer International Publishing Switzerland 2014
</p>
<p>213</p>
<p/>
<div class="annotation"><a href="http://www.mccme.ru/free-books/dubna/arjantsev.pdf">http://www.mccme.ru/free-books/dubna/arjantsev.pdf</a></div>
<div class="annotation"><a href="http://www.cs.berkeley.edu/~fateman/papers/mma.pdf">http://www.cs.berkeley.edu/~fateman/papers/mma.pdf</a></div>
<div class="annotation"><a href="http://www.cs.berkeley.edu/~fateman/papers/mma.pdf">http://www.cs.berkeley.edu/~fateman/papers/mma.pdf</a></div>
<div class="annotation"><a href="http://www.cs.berkeley.edu/~fateman/papers/mma6rev.pdf">http://www.cs.berkeley.edu/~fateman/papers/mma6rev.pdf</a></div>
<div class="annotation"><a href="http://www.cs.berkeley.edu/~fateman/papers/mma6rev.pdf">http://www.cs.berkeley.edu/~fateman/papers/mma6rev.pdf</a></div>
</div>
<div class="page"><p/>
<p>214 References
</p>
<p>22. Berestetskii, V.B., Lifshitz, E.M., Pitaevskii, L.P.: Quantum Electrodynamics, 2nd edn.
Butterworth-Heinemann, Oxford (1982)
</p>
<p>23. Prudnikov, A.P., Brychkov, Yu.A., Marichev, O.I.: Integrals and Series, vol. 3, Chapter 7.
Gordon and Breach, New York (1990)
</p>
<p>24. NIST Handbook of Mathematical Functions, ed. by F.W.J. Olver, D.W. Lozier, R.F. Boisvert,
C.W. Clark, Cambridge University Press, Cambridge (2010). http://dlmf.nist.gov/
</p>
<p>25. http://functions.wolfram.com/
</p>
<p>26. Grozin, A.G.: Lectures on QED and QCD: Practical calculation and renormalization of one-
and multi-loop Feynman diagrams. World Scientific (2007)
</p>
<p>27. Cvitanović, P.: Group Theory. Princeton University Press, Princeton (2008). http://www.nbi.
dk/GroupTheory/:</p>
<p/>
<div class="annotation"><a href="http://dlmf.nist.gov/">http://dlmf.nist.gov/</a></div>
<div class="annotation"><a href="http://functions.wolfram.com/">http://functions.wolfram.com/</a></div>
<div class="annotation"><a href="http://www.nbi.dk/GroupTheory/">http://www.nbi.dk/GroupTheory/</a></div>
<div class="annotation"><a href="http://www.nbi.dk/GroupTheory/">http://www.nbi.dk/GroupTheory/</a></div>
</div>
<div class="page"><p/>
<p>Index
</p>
<p>Symbols
</p>
<p>&rdquo; &rdquo;, 22, 43&ndash;46, 77, 99&ndash;104, 106&ndash;107, 130,
131, 136, 141, 151, 161&ndash;162, 166, 169,
173&ndash;174, 177&ndash;178, 185
</p>
<p>!=, 45, 47
., 93&ndash;97, 194
/., 17&ndash;19, 27&ndash;28, 38, 40
//., 28&ndash;33, 167&ndash;170, 177
/ :, 41&ndash;42
/;, 32&ndash;33, 39, 103, 135, 194
::, 9, 107&ndash;108, 161
</p>
<p>:=, 35&ndash;41, 43, 44, 46, 48, 51&ndash;52, 68, 74,
81&ndash;89, 100&ndash;101, 107, 120, 125, 126,
128, 129, 134, 135, 139, 154, 156, 159,
161, 162, 167&ndash;170, 174, 178, 181, 186,
188, 194, 196, 202&ndash;205, 207
</p>
<p>: &gt;, 35&ndash;36, 167&ndash;169, 171
;, 9, 43&ndash;44
</p>
<p>; ;, 23&ndash;24, 76
</p>
<p>?, 37&ndash;38, 41, 108
</p>
<p>[[ ]], 14, (23, 18&ndash;24, 57, 58, 60, 61, 74, 76, 78,
80, 82, 83, 85&ndash;89, 92, 95, 196
</p>
<p>[ ], 9, 12&ndash;13, 22
%, 12, 57, 58, 67, 68
</p>
<p>&amp;&amp;, 118, 123, 198, 208
</p>
<p>, 27&ndash;28, 45&ndash;46, 103
</p>
<p>?, 32
</p>
<p>., 30&ndash;32, 146, 148, 150
, 33, 103
</p>
<p>, 33, 40, 103, 167&ndash;170
</p>
<p>,̀ 24&ndash;25, 37&ndash;38, 41, 73&ndash;75, 105&ndash;108
</p>
<p>&sim;&sim;, 103&ndash;104
{}, 14
&lowast;=, 47
++, 47, 92
+=, 92, 156, 159
&minus;=, 141
</p>
<p>&minus;&gt;, 17&ndash;19, 27&ndash;28, 35&ndash;36, 65
&lt;&lt;, 99&ndash;101, 106, 108, 158
&lt;&gt;, 102
=!=, 45, 161&ndash;162
=, 9, 22, 35&ndash;39, 51&ndash;52, 92&ndash;93, 95&ndash;96
==, 18, 33, 44&ndash;45, 60, 70&ndash;71, 76, 78, 80, 82&ndash;
</p>
<p>89, 116, 123, 129, 134&ndash;135, 147&ndash;150,
156, 159, 168, 170&ndash;171, 177, 180, 183,
185, 190, 195, 200, 201, 205
</p>
<p>===, 45, 162
&gt;&gt;, 100
&and;:=, 41
&and;=, 42
‖, 33
|, 97, 103
$Assumptions, 69, 97&ndash;98
</p>
<p>$Context, 105&ndash;107
$ContextPath, 105&ndash;107
</p>
<p>$KernelID, 50&ndash;51
</p>
<p>$Path, 100, 106
$RecursionLimit, 9
</p>
<p>A
</p>
<p>Abort, 161
</p>
<p>Abs, 126, 156, 180, 188&ndash;190
Accuracy, 74
</p>
<p>AccuracyGoal, 77
</p>
<p>All, 92, 120, 177, 181
Antisymmetric, 97
</p>
<p>Apart, 12
Appearance, 11, 130, 131, 136
</p>
<p>Append, 100, 168, 196, 207
</p>
<p>Apply, 48, 175, 179, 182, 184, 188
ArcSin, 69, 173, 177, 180, 181, 184&ndash;186, 190
</p>
<p>ArcTan, 66, 177
</p>
<p>Array, 91&ndash;92, 195
Arrays, 97&ndash;98
</p>
<p>A. Grozin, Introduction to Mathematica� for Physicists, Graduate Texts in Physics,
DOI 10.1007/978-3-319-00894-3, &copy; Springer International Publishing Switzerland 2014
</p>
<p>215</p>
<p/>
</div>
<div class="page"><p/>
<p>216 Index
</p>
<p>Assumptions, 69, 135
</p>
<p>AtomQ, 24
</p>
<p>Attributes, 40&ndash;41, 52&ndash;53
</p>
<p>Automatic, 75
</p>
<p>AxesLabel, 155
</p>
<p>B
</p>
<p>Begin, 106&ndash;108
</p>
<p>BeginPackage, 107&ndash;108
</p>
<p>BesselI, 69
</p>
<p>Binomial, 70
</p>
<p>Blank, 32&ndash;33, 103
</p>
<p>Block, 49
</p>
<p>Boxed, 184, 207, 208
</p>
<p>C
</p>
<p>Cancel, 12, 88, 131, 205
</p>
<p>CForm, 102
</p>
<p>Circle, 173&ndash;175, 179, 182, 188
</p>
<p>Clear, 9, 12, 14, 18, 19, 22, 24&ndash;26, 28, 31&ndash;33,
35&ndash;44, 46&ndash;53, 57, 59&ndash;61, 64&ndash;67, 74,
76, 78, 80, 82&ndash;84, 86&ndash;89, 93&ndash;95, 97,
100&ndash;103, 105, 107, 118, 121, 122, 129,
135, 140, 147, 149, 159, 168, 170, 177,
181, 185, 194, 195, 197, 201, 202, 205
</p>
<p>ClearAll, 41, 52
</p>
<p>Close, 101
</p>
<p>Coefficient, 11, 80, 82&ndash;89, 146&ndash;150, 200, 205
</p>
<p>Collect, 11, 156, 159
</p>
<p>Complex, 24
</p>
<p>ComplexExpand, 60
</p>
<p>ComplexInfinity, 76
</p>
<p>ComposeSeries, 65&ndash;66
</p>
<p>CompoundExpression, 43
</p>
<p>Condition, 32&ndash;33
</p>
<p>ConditionalExpression, 69
</p>
<p>Cone, 184
</p>
<p>Conjugate, 137
</p>
<p>Context, 105&ndash;107
</p>
<p>ContourPlot, 116, 200
</p>
<p>ContourPlot3D, 123
</p>
<p>Contours, 116
</p>
<p>Cos, 12&ndash;13, (64, (64, (67, 15&ndash;67, 71, 78,
112, 113, 121, 122, 125&ndash;126, 135&ndash;136,
146&ndash;151, 163, 173&ndash;174, 176&ndash;177,
179&ndash;182, 184&ndash;186, 188
</p>
<p>Cot, 63, 134, 163
</p>
<p>Cross, 97
</p>
<p>Csc, 69, 71
</p>
<p>Cycles, 97&ndash;98
</p>
<p>Cylinder, 193, 207
</p>
<p>D
</p>
<p>D, 13&ndash;14, 38, 65, 67&ndash;68, 80&ndash;81, 83&ndash;89, 128,
134, 146&ndash;151, 158, 161, 162, 177, 181,
183, 186, 190
</p>
<p>Darker, 202, 206
</p>
<p>Dashed, 113
DeclarePackage, 106
Degree, 190
</p>
<p>DegreeLexicographic, 59, 61&ndash;62
Denominator, 25, 126
</p>
<p>Derivative, 67&ndash;68
Det, 94&ndash;95, 196
Dimensions, 93
</p>
<p>DirectedInfinity, 64
Disk, 139
</p>
<p>DistributeDefinitions, 50&ndash;51
Do, 46, 63, 74, 95, 126, 141, 148, 150, 154,
</p>
<p>156, 159, (162, (162, 161&ndash;162, 188, 194,
196, 200, 205, 207
</p>
<p>DSolve, 70&ndash;71, 78, 129, 134&ndash;135
</p>
<p>E
</p>
<p>E, 10, 12, 68, 70&ndash;71
</p>
<p>Eigensystem, 95&ndash;97
Eigenvalues, 95
Eigenvectors, 95
</p>
<p>Element, 95, 97&ndash;98
EllipticF, 69
</p>
<p>End, 106&ndash;108
EndPackage, 107&ndash;108
Erfi, 69
</p>
<p>EulerSum, 106
Evaluate, 52&ndash;53, 66, 130, 163, 176, 180, 189
</p>
<p>EvenQ, 126, 150
Exp, 12&ndash;13, 15, 63, 65&ndash;69, (134, 76&ndash;135
Expand, 10&ndash;11, 35&ndash;36, 38, 41, 57, 58, 60, 67,
</p>
<p>68, 84, 87, 107, 135, 141, 157, 167, 169,
207
</p>
<p>ExpandAll, 82, 88, 89, 147&ndash;151
Exponent, 11
</p>
<p>Extension, 11, 12
</p>
<p>F
</p>
<p>Factor, 11&ndash;12, 61, 135, 156, 198&ndash;199, 201
Factorial, 10
False, 24&ndash;25, 39, 45, 93, 104, 184, 193, 207,
</p>
<p>208
</p>
<p>FilePrint, 99&ndash;102, 107
FindIntegerNullVector, 77
</p>
<p>First, 18, 47
Fit, 117
Flat, 40
</p>
<p>For, 47
FortranForm, 102</p>
<p/>
</div>
<div class="page"><p/>
<p>Index 217
</p>
<p>FractionalPart, 125
</p>
<p>FreeQ, 45
FullForm, 24&ndash;26, 28&ndash;33, 35, 43, 63&ndash;64, 67&ndash;68,
</p>
<p>73&ndash;74, 102&ndash;103
Function, 47&ndash;49, 51, 91&ndash;92, 141
</p>
<p>G
</p>
<p>Gamma, 69, 135
Get, 100
Global, 37, 38, 105&ndash;107
</p>
<p>Graphics, 139&ndash;140, 173&ndash;176, 178&ndash;179, 182,
188, 202
</p>
<p>Graphics3D, 184, 193, 205&ndash;207
Greater, 33
GroebnerBasis, 59&ndash;62, 198&ndash;199
</p>
<p>H
</p>
<p>Head, 22&ndash;24, 27, 48
Hold, 9, 25&ndash;26, 29, 43, 53
</p>
<p>HoldAll, 52&ndash;53
HoldFirst, 52
Hypergeometric2F1Regularized, 69
</p>
<p>I
</p>
<p>I, 11&ndash;12, 21, 24, 131, 134&ndash;135
If, 44, 126, 139, 141, 150, 154, 156, 159,
</p>
<p>161&ndash;162, 168, 175, 179, 182, 186, 188,
196, 208
</p>
<p>Im, 25
</p>
<p>Import, 166, 169, 185
Indeterminate, 76
Infinity, 14, 64, 67, 70, 77, 129, 131
Inset, 173&ndash;174, 178
</p>
<p>Integer, 24, 27, 32&ndash;33, 125
IntegerQ, 25
Integrate, 14, 51, 65, 68&ndash;69, 129, 131, 135, 137
InterpolatingFunction, 78
Inverse, 94, 96, 161
</p>
<p>InverseSeries, 65&ndash;66, 158&ndash;159
</p>
<p>J
</p>
<p>Join, 100, 139, 168, 174&ndash;176, 179, 181&ndash;182,
</p>
<p>184, 188
JordanDecomposition, 96
</p>
<p>K
</p>
<p>KroneckerDelta, 70
</p>
<p>L
</p>
<p>Length, 22, 161
</p>
<p>Line, 139, 173&ndash;174, 178&ndash;179, 181&ndash;182, 184,
188
</p>
<p>LinearSolve, 94
List, 25, 28, 32, 50, 63&ndash;64
</p>
<p>Listable, 41, 50
</p>
<p>ListPlot, (117, 75&ndash;117
Log, 12&ndash;14, 64, 68&ndash;69, 77, 80, 83&ndash;84, 86&ndash;88
LogIntegral, 68
</p>
<p>LogLogPlot, 114&ndash;115
LogPlot, 114
</p>
<p>M
</p>
<p>MachineNumberQ, 73
MachinePrecision, 73
Manipulate, (15, (16, (121, 11&ndash;122, 130&ndash;131,
</p>
<p>136, 174&ndash;176, 179, 182, 188, 208
Map, 48&ndash;49, 75, 76, 146&ndash;151, 167&ndash;171, 198,
</p>
<p>199
MatchQ, 45
Matrices, 97
MatrixForm, 91&ndash;96, 194&ndash;195
</p>
<p>MatrixPower, 94
MatrixQ, 93
MatrixRank, 95
</p>
<p>Max, 156
Message, 161
Method, 77
</p>
<p>Min, 156
Mod, 135, 188&ndash;190
Module, 49, 74, 126, 141, 161, 162, 167&ndash;170,
</p>
<p>181, 184, 188, 207
</p>
<p>N
</p>
<p>N, 10, 73&ndash;74, 117, 126, 201, 205
ND, 106
</p>
<p>NDSolve, 78
NIntegrate, 77
NLimit, 106
</p>
<p>Normal, 66, 151
Not, 39, 45
NResidue, 106
NSeries, 106
</p>
<p>NSolve, 76
NSum, 77
NSumTerms, 77
</p>
<p>Null, 43
NullSpace, 95
NumberQ, 32, 45
</p>
<p>Numerator, 25, 205
NumericalCalculus, 106
NumericQ, 45
</p>
<p>O
</p>
<p>OddQ, 150
Opacity, 184
</p>
<p>OpenWrite, 101
Options, 40, 162
OptionsPattern, 40, 161</p>
<p/>
</div>
<div class="page"><p/>
<p>218 Index
</p>
<p>OptionValue, 40, 162
</p>
<p>OrderedQ, 39
Orderless, 40&ndash;41
OutputStream, 101
</p>
<p>P
</p>
<p>Parallelize, 50&ndash;51, 131
</p>
<p>ParametricPlot, (115, 15&ndash;115, 154&ndash;156,
185&ndash;186, 202&ndash;204
</p>
<p>ParametricPlot3D, (121, 16&ndash;122, 205&ndash;206
Part, 22&ndash;23
</p>
<p>Pattern, 32&ndash;33, 103
Pi, 10, 12, 16&ndash;17, 45, 51, 53, 66, 69, (125,
</p>
<p>76&ndash;126, 131, 135, 137
Plot, (52, 15&ndash;53, 66, (78, (111, 76&ndash;114, 117,
</p>
<p>130&ndash;131, 176&ndash;178, 180&ndash;181, 183,
186&ndash;190
</p>
<p>Plot3D, 15&ndash;16, 101, 120
PlotMarkers, 75
PlotPoints, 123
</p>
<p>PlotRange, 15, 16, 75, 114, 120, 122, 130, 131,
155, 174&ndash;179, 181, 182, 185, 187&ndash;188,
202&ndash;205, 208
</p>
<p>PlotStyle, 112&ndash;113, 177, 181, 185, 187, 189,
190
</p>
<p>Plus, 25&ndash;27, 31&ndash;33, 40, 41, 46, 48, 67
</p>
<p>Point, 202, 205&ndash;206
PointSize, 202, 205&ndash;206
PolyLog, 68
</p>
<p>PolynomialReduce, 57&ndash;59
Power, 25&ndash;26, 28&ndash;31, 64, 67, 102
Precision, 73&ndash;76
</p>
<p>PrecisionGoal, 77
Prepend, 66, 100
Print, 43, 44, 46&ndash;47, 50, 63, 95, 101, 141, 148,
</p>
<p>156, 159, 162, 207
</p>
<p>Put, 100
</p>
<p>Q
</p>
<p>Quaternion, 106
Quaternions, 106
Quotient, 135
</p>
<p>R
</p>
<p>Random, 184
Rational, 24&ndash;25, 28, 63&ndash;64, 125
</p>
<p>Re, 25
Real, 24
Reals, 76, 95, 97&ndash;98
</p>
<p>RegionPlot, 118, 198
RegionPlot3D, 123
ReleaseHold, 53
</p>
<p>Remove, 105
ReplaceAll, 29
</p>
<p>ReplaceRepeated, 29
</p>
<p>Rest, 47
Rule, 29, 32&ndash;33
</p>
<p>S
</p>
<p>Save, 101, 151
Select, 48
</p>
<p>Series, 14, 63&ndash;66, 145&ndash;150, 157&ndash;159
SeriesCoefficient, 63, 66&ndash;67, 146, 148, 150
</p>
<p>SeriesData, 63&ndash;64
Set, 25&ndash;26, 52
SetDelayed, 35, 52
</p>
<p>Show, 117&ndash;118, 140, 166, 169, 185&ndash;186,
202&ndash;204, 206&ndash;208
</p>
<p>Simplify, 13, 95, 126, 151, 154, 156, 158&ndash;159,
161, 162, 177, 180&ndash;181, 187, 191, 202,
207
</p>
<p>Sin, 12&ndash;13, (64, 15&ndash;67, 69, 71, (102, 76&ndash;102,
112&ndash;113, 115, 117, 120&ndash;122, 125,
134&ndash;137, 163, 173&ndash;174, 177, (179, (180,
179&ndash;182, 184&ndash;186, 188
</p>
<p>Solve, 18&ndash;19, 45, 60, 80, 129, 135, 147&ndash;150,
170&ndash;171, 176&ndash;177, 180, 183&ndash;185, 190,
195, 200&ndash;201, 205
</p>
<p>Span, 23
Sphere, 193, 207
</p>
<p>Sqrt, 11&ndash;13, 28, 64, 120, 128&ndash;129, 131, 135,
141, 151, 154, 173, 174, 179&ndash;181, 185,
188, 193, 201, 206&ndash;208
</p>
<p>StreamPlot, 119
</p>
<p>StringExpression, 103
StringFreeQ, 104
StringLength, 103
</p>
<p>StringMatchQ, 103&ndash;104
StringReplace, 103
</p>
<p>StringSplit, 104
Style, 173&ndash;174, 178, 202
</p>
<p>Sum, 14, 67, 70, 81, 83&ndash;89, 146&ndash;150, 157, 162,
195
</p>
<p>Switch, 45&ndash;46
Symmetric, 97&ndash;98
</p>
<p>System, 105, 107
</p>
<p>T
</p>
<p>Table, (50, 50&ndash;51, 53, 66, 74, 80, 82&ndash;89,
91&ndash;92, 117, 125, 129&ndash;131, 135&ndash;137,
139, 156, 159, 161&ndash;163, 165, 168, 175,
179, 182, 184, 188&ndash;191, 194&ndash;196, 207
</p>
<p>Tan, 64&ndash;65, 113&ndash;114, 174, 184
TensorContract, 97&ndash;98
</p>
<p>TensorDimensions, 98
TensorProduct, 97&ndash;98
</p>
<p>TensorRank, 98
TensorReduce, 97&ndash;98</p>
<p/>
</div>
<div class="page"><p/>
<p>Index 219
</p>
<p>TensorSymmetry, 98
TeXForm, 102
Text, 139, 202
Ticks, 155
Times, 25, 28&ndash;33, 40&ndash;41, 46, 48, 50, 64, 67
Together, 12, 14, 26, 80, 94, 95, 128, 134, 205
Tr, 94
</p>
<p>Transpose, 94
TreeForm, (26, 23&ndash;26
TrigExpand, 13, 180, 185, 187, 191
TrigReduce, 13, 146&ndash;151
True, 24&ndash;25, 39, 44&ndash;45, 67, 69, 73, 82&ndash;86, 88,
</p>
<p>93, 98, 104, 126, 161, 162, 205
</p>
<p>V
</p>
<p>VectorPlot, 119
</p>
<p>VectorQ, 93
</p>
<p>Vectors, 97
</p>
<p>ViewPoint, 123, 184, 193, 205, 207, 208
</p>
<p>W
</p>
<p>Which, 44, 125, 205
</p>
<p>While, 47
</p>
<p>With, 50, 120, 139, 173&ndash;175, 179, 181&ndash;182,
184, 188, 202&ndash;205
</p>
<p>WorkingPrecision, 77
</p>
<p>Write, 101
</p>
<p>Z
</p>
<p>Zeta, 14, 77, 165, 170</p>
<p/>
</div>
<ul>	<li>Preface</li>
	<li>Contents</li>
	<li>Part I Lectures</li>
<ul>	<li>1 Computer Algebra Systems</li>
	<li>2 Overview of Mathematica</li>
<ul>	<li>2.1 Symbols</li>
	<li>2.2 Numbers</li>
	<li>2.3 Polynomials and Rational Functions</li>
	<li>2.4 Elementary Functions</li>
	<li>2.5 Calculus</li>
	<li>2.6 Lists</li>
	<li>2.7 Plots</li>
	<li>2.8 Substitutions</li>
	<li>2.9 Equations</li>
</ul>
	<li>3 Expressions</li>
<ul>	<li>3.1 Atoms</li>
	<li>3.2 Composite Expressions</li>
	<li>3.3 Queries</li>
	<li>3.4 Forms of an Expression</li>
</ul>
	<li>4 Patterns and Substitutions</li>
<ul>	<li>4.1 Simple Patterns</li>
	<li>4.2 One-Shot and Repeated Substitutions</li>
	<li>4.3 Products</li>
	<li>4.4 Sums</li>
	<li>4.5 Conditions</li>
	<li>4.6 Variable Number of Arguments</li>
</ul>
	<li>5 Functions</li>
<ul>	<li>5.1 Immediate and Delayed Assignment</li>
	<li>5.2 Functions</li>
	<li>5.3 Functions Remembering Their Values</li>
	<li>5.4 Fibonacci Numbers</li>
	<li>5.5 Functions from Expressions</li>
	<li>5.6 Antisymmetric Functions</li>
	<li>5.7 Functions with Options</li>
	<li>5.8 Attributes</li>
	<li>5.9 Upvalues</li>
</ul>
	<li>6 Mathematica as a Programming Language</li>
<ul>	<li>6.1 Compound Expressions</li>
	<li>6.2 Conditional Expressions</li>
	<li>6.3 Loops</li>
	<li>6.4 Functions</li>
	<li>6.5 Local Variables</li>
	<li>6.6 Table</li>
	<li>6.7 Parallelization</li>
	<li>6.8 Functions with an Index</li>
	<li>6.9 Hold and Evaluate</li>
</ul>
	<li>7 Gr&ouml;bner Bases</li>
<ul>	<li>7.1 Statement of the Problem</li>
	<li>7.2 Monomial Orders</li>
	<li>7.3 Reduction of Polynomials</li>
	<li>7.4 S-Polynomials</li>
	<li>7.5 Buchberger Algorithm</li>
	<li>7.6 Is the System Compatible?</li>
	<li>7.7 Gr&ouml;bner Bases with Respect to Lexicographic Order</li>
	<li>7.8 Is the Number of Solutions Finite?</li>
</ul>
	<li>8 Calculus</li>
<ul>	<li>8.1 Series</li>
	<li>8.2 Differentiation</li>
	<li>8.3 Integration</li>
	<li>8.4 Summation</li>
	<li>8.5 Differentiol Equations</li>
</ul>
	<li>9 Numerical Calculations</li>
<ul>	<li>9.1 Approximate Numbers in Mathematica</li>
	<li>9.2 Solving Equations</li>
	<li>9.3 Numerical Integration and Summation</li>
	<li>9.4 Differential Equations</li>
</ul>
	<li>10 Risch Algorithm</li>
<ul>	<li>10.1 Rational Functions</li>
	<li>10.2 Logarithmic Extension</li>
	<li>10.3 Exponential Extension</li>
	<li>10.4 Elementary Functions</li>
</ul>
	<li>11 Linear Algebra</li>
<ul>	<li>11.1 Constructing Matrices</li>
	<li>11.2 Parts of a Matrix</li>
	<li>11.3 Queries</li>
	<li>11.4 Operations with Matrices and Vectors</li>
	<li>11.5 Eigenvalues and Eigenvectors</li>
	<li>11.6 Jordan Form</li>
	<li>11.7 Symbolic Vectors, Matrices, and Tensors</li>
</ul>
	<li>12 Input&ndash;Output and Strings</li>
<ul>	<li>12.1 Reading and Writing .m Files</li>
	<li>12.2 Output</li>
	<li>12.3 C, Fortran, and TeX Forms</li>
	<li>12.4 Strings</li>
</ul>
	<li>13 Packages</li>
<ul>	<li>13.1 Contexts</li>
	<li>13.2 Packages</li>
	<li>13.3 Writing Your Own Package</li>
</ul>
</ul>
	<li>Part II Computer Classes</li>
<ul>	<li>14 Plots</li>
<ul>	<li>14.1 2D Plots</li>
	<li>14.2 3D Plots</li>
</ul>
	<li>15 Trigonometric Functions</li>
	<li>16 Quantum Oscillator</li>
<ul>	<li>16.1 Lowering and Raising Operators</li>
	<li>16.2 Ground State</li>
	<li>16.3 Excited States</li>
	<li>16.4 Some Properties</li>
</ul>
	<li>17 Spherical Harmonics</li>
<ul>	<li>17.1 Angular Momentum in Quantum Mechanics</li>
	<li>17.2 Yll(θ ,ϕ)&#13;</li>
	<li>17.3 Ylm(θ ,ϕ)&#13;</li>
</ul>
	<li>18 Adding Angular Momenta in Quantum Mechanics</li>
	<li>19 Classical Nonlinear Oscillator</li>
<ul>	<li>19.1 Statement of the Problem</li>
	<li>19.2 The First Correction</li>
	<li>19.3 The Second Correction</li>
	<li>19.4 The nth Correction</li>
</ul>
	<li>20 Quantum Nonlinear Oscillator</li>
<ul>	<li>20.1 Perturbation Theory</li>
	<li>20.2 Nonlinear Oscillator</li>
	<li>20.3 Energy Levels</li>
	<li>20.4 Correspondence Principle</li>
	<li>20.5 States</li>
</ul>
	<li>21 Riemann Curvature Tensor</li>
	<li>22 Multi- Functions</li>
<ul>	<li>22.1 Definition</li>
	<li>22.2 Stuffling Relations</li>
	<li>22.3 Integral Representation</li>
	<li>22.4 Shuffling Relations</li>
	<li>22.5 Duality Relations</li>
	<li>22.6 Weight 4</li>
	<li>22.7 Weight 5</li>
</ul>
	<li>23 Rainbow</li>
<ul>	<li>23.1 Statement of the Problem</li>
	<li>23.2 0 Ray Segments Inside the Drop</li>
	<li>23.3 1 Ray Segment Inside the Drop</li>
	<li>23.4 2 Ray Segments Inside the Drop</li>
	<li>23.5 L Ray Segments Inside the Drop</li>
</ul>
	<li>24 Cyclohexane</li>
<ul>	<li>24.1 Statement of the Problem</li>
	<li>24.2 First Steps</li>
	<li>24.3 Equations</li>
	<li>24.4 Projection onto the x, y Plane</li>
	<li>24.5 Complete Analysis of the Solutions</li>
	<li>24.6 Shape of the Molecule</li>
</ul>
	<li>25 Problems for Students</li>
</ul>
	<li>References</li>
	<li>Index</li>
</ul>
</body></html>