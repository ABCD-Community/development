<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Untitled</title>
</head>
<body><div class="page"><p/>
<p>Introduction to
Logic Circuits
&amp; Logic Design
with Verilog
</p>
<p>Brock J. LaMeres
</p>
<p>Second Edition</p>
<p/>
</div>
<div class="page"><p/>
<p>INTRODUCTION TO LOGIC CIRCUITS &amp;
</p>
<p>LOGIC DESIGN WITH VERILOG</p>
<p/>
</div>
<div class="page"><p/>
<p>INTRODUCTION TO LOGIC CIRCUITS &amp;
</p>
<p>LOGIC DESIGN WITH VERILOG
2ND EDITION
</p>
<p>Brock J. LaMeres</p>
<p/>
</div>
<div class="page"><p/>
<p>Brock J. LaMeres
Department of Electrical &amp; Computer Engineering
Montana State University
Bozeman, MT, USA
</p>
<p>ISBN 978-3-030-13604-8 ISBN 978-3-030-13605-5 (eBook)
https://doi.org/10.1007/978-3-030-13605-5
</p>
<p>Library of Congress Control Number: 2019934718
</p>
<p># Springer Nature Switzerland AG 2019
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is
concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction
on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic
adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not
imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and
regulations and therefore free for general use.
The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed
to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty,
express or implied, with respect to the material contained herein or for any errors or omissions that may have been
made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.
</p>
<p>This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland</p>
<p/>
<div class="annotation"><a href="https://doi.org/10.1007/978-3-030-13605-5">https://doi.org/10.1007/978-3-030-13605-5</a></div>
</div>
<div class="page"><p/>
<p>Preface
The overall goal of this book is to fill a void that has appeared in the instruction of digital circuits over
</p>
<p>the past decade due to the rapid abstraction of system design. Up until the mid-1980s, digital circuits
</p>
<p>were designed using classical techniques. Classical techniques relied heavily on manual design
</p>
<p>practices for the synthesis, minimization, and interfacing of digital systems. Corresponding to this design
</p>
<p>style, academic textbooks were developed that taught classical digital design techniques. Around 1990,
</p>
<p>large-scale digital systems began being designed using hardware description languages (HDL) and
</p>
<p>automated synthesis tools. Broad-scale adoption of this modern design approach spread through the
</p>
<p>industry during this decade. Around 2000, hardware description languages and the modern digital
</p>
<p>design approach began to be taught in universities, mainly at the senior and graduate level. There
</p>
<p>were a variety of reasons that the modern digital design approach did not penetrate the lower levels of
</p>
<p>academia during this time. First, the design and simulation tools were difficult to use and overwhelmed
</p>
<p>freshman and sophomore students. Second, the ability to implement the designs in a laboratory setting
</p>
<p>was infeasible. The modern design tools at the time were targeted at custom integrated circuits, which
</p>
<p>are cost- and time-prohibitive to implement in a university setting. Between 2000 and 2005, rapid
</p>
<p>advances in programmable logic and design tools allowed the modern digital design approach to be
</p>
<p>implemented in a university setting, even in lower-level courses. This allowed students to learn the
</p>
<p>modern design approach based on HDLs and prototype their designs in real hardware, mainly field-
</p>
<p>programmable gate arrays (FPGAs). This spurred an abundance of textbooks to be authored, teaching
</p>
<p>hardware description languages and higher levels of design abstraction. This trend has continued until
</p>
<p>today. While abstraction is a critical tool for engineering design, the rapid movement toward teaching only
</p>
<p>the modern digital design techniques has left a void for freshman- and sophomore-level courses in digital
</p>
<p>circuitry. Legacy textbooks that teach the classical design approach are outdated and do not contain
</p>
<p>sufficient coverage of HDLs to prepare the students for follow-on classes. Newer textbooks that teach
</p>
<p>the modern digital design approach move immediately into high-level behavioral modeling with minimal
</p>
<p>or no coverage of the underlying hardware used to implement the systems. As a result, students are not
</p>
<p>being provided the resources to understand the fundamental hardware theory that lies beneath the
</p>
<p>modern abstraction such as interfacing, gate-level implementation, and technology optimization.
</p>
<p>Students moving too rapidly into high levels of abstraction have little understanding of what is going
</p>
<p>on when they click the &ldquo;compile and synthesize&rdquo; button of their design tool. This leads to graduates who
</p>
<p>can model a breadth of different systems in an HDL but have no depth into how the system is
</p>
<p>implemented in hardware. This becomes problematic when an issue arises in a real design and there
</p>
<p>is no foundational knowledge for the students to fall back on in order to debug the problem.
</p>
<p>This new book addresses the lower-level foundational void by providing a comprehensive, bottoms-
</p>
<p>up, coverage of digital systems. The book begins with a description of lower-level hardware including
</p>
<p>binary representations, gate-level implementation, interfacing, and simple combinational logic design.
</p>
<p>Only after a foundation has been laid in the underlying hardware theory is the Verilog language
</p>
<p>introduced. The Verilog introduction gives only the basic concepts of the language in order to model,
</p>
<p>simulate, and synthesize combinational logic. This allows the students to gain familiarity with the
</p>
<p>language and the modern design approach without getting overwhelmed by the full capability of the
</p>
<p>language. The book then covers sequential logic and finite-state machines at the structural level. Once
</p>
<p>this secondary foundation has been laid, the remaining capabilities of Verilog are presented that allow
</p>
<p>sophisticated, synchronous systems to be modeled. An entire chapter is then dedicated to examples of
</p>
<p>sequential system modeling, which allows the students to learn by example. The second part of the
</p>
<p>textbook introduces the details of programmable logic, semiconductor memory, and arithmetic circuits.
</p>
<p>The book culminates with a discussion of computer system design, which incorporates all of the
</p>
<p>v</p>
<p/>
</div>
<div class="page"><p/>
<p>knowledge gained in the previous chapters. Each component of a computer system is described with an
</p>
<p>accompanying Verilog implementation, all while continually reinforcing the underlying hardware beneath
</p>
<p>the HDL abstraction.
</p>
<p>Written the Way It Is Taught
</p>
<p>The organization of this book is designed to follow the way in which the material is actually learned.
</p>
<p>Topics are presented only once sufficient background has been provided by earlier chapters to fully
</p>
<p>understand the material. An example of this learning-oriented organization is how the Verilog language is
</p>
<p>broken into two chapters. Chapter 5 presents an introduction to Verilog and the basic constructs to model
</p>
<p>combinational logic. This is an ideal location to introduce the language because the reader has just
</p>
<p>learned about combinational logic theory in Chap. 4. This allows the student to begin gaining experience
</p>
<p>using the Verilog simulation tools on basic combinational logic circuits. The more advanced constructs of
</p>
<p>Verilog, such as sequential modeling and test benches, are presented in Chap. 8 only after a thorough
</p>
<p>background in sequential logic is presented in Chap. 7. Another example of this learning-oriented
</p>
<p>approach is how arithmetic circuits are not introduced until Chap. 12. While technically the arithmetic
</p>
<p>circuits in Chap. 12 are combinational logic circuits and could be presented in Chap. 4, the student does
</p>
<p>not have the necessary background in Chap. 4 to fully understand the operation of the arithmetic
</p>
<p>circuitry, so its introduction is postponed.
</p>
<p>This incremental, just-in-time presentation of material allows the book to follow the way the material
</p>
<p>is actually taught in the classroom. This design also avoids the need for the instructor to assign sections
</p>
<p>that move back and forth through the text. This not only reduces course design effort for the instructor but
</p>
<p>allows the student to know where they are in the sequence of learning. At any point, the student should
</p>
<p>know the material in prior chapters and be moving toward understanding the material in
</p>
<p>subsequent ones.
</p>
<p>An additional advantage of this book&rsquo;s organization is that it supports giving the student hands-on
</p>
<p>experience with digital circuitry for courses with an accompanying laboratory component. The flow is
</p>
<p>designed to support lab exercises that begin using discrete logic gates on a breadboard and then move
</p>
<p>into HDL-based designs implemented on off-the-shelf FPGA boards. Using this approach to a laboratory
</p>
<p>experience gives the student experience with the basic electrical operation of digital circuits, interfacing,
</p>
<p>and HDL-based designs.
</p>
<p>Learning Outcomes
</p>
<p>Each chapter begins with an explanation of its learning objective followed by a brief preview of the
</p>
<p>chapter topics. The specific learning outcomes are then presented for the chapter in the form of concise
</p>
<p>statements about the measurable knowledge and/or skills the student will be able to demonstrate by the
</p>
<p>end of the chapter. Each section addresses a single, specific learning outcome. This eases the process
</p>
<p>of assessment and gives specific details on student performance. There are over 1000 assessment tools
</p>
<p>in the form of exercise problems and concept check questions that are tied directly to specific learning
</p>
<p>outcomes for both formative and summative assessment.
</p>
<p>Teaching by Example
</p>
<p>With nearly 250 worked examples, concept checks for each section, 200+ supporting figures, and
</p>
<p>1000+ assessment problems, students are provided with multiple ways to learn. Each topic is described
</p>
<p>in a clear, concise written form with accompanying figures as necessary. This is then followed by
</p>
<p>annotated worked examples that match the form of the exercise problems at the end of each chapter.
</p>
<p>Additionally, concept check questions are placed at the end of each section in the book to measure the
</p>
<p>vi &bull; Preface</p>
<p/>
</div>
<div class="page"><p/>
<p>student&rsquo;s general understanding of the material using a concept inventory assessment style. These
</p>
<p>features provide the student multiple ways to learn the material and build an understanding of digital
</p>
<p>circuitry.
</p>
<p>Course Design
</p>
<p>The book can be used in multiple ways. The first is to use the book to cover two, semester-based
</p>
<p>college courses in digital logic. The first course in this sequence is an introduction to logic circuits and
</p>
<p>covers Chaps. 1, 2, 3, 4, 5, 6, and 7. This introductory course, which is found in nearly all accredited
</p>
<p>electrical and computer engineering programs, gives students a basic foundation in digital hardware and
</p>
<p>interfacing. Chapters 1, 2, 3, 4, 5, 6, and 7 only cover relevant topics in digital circuits to make room for a
</p>
<p>thorough introduction to Verilog. At the end of this course, students have a solid foundation in digital
</p>
<p>circuits and are able to design and simulate Verilog models of concurrent and hierarchical systems. The
</p>
<p>second course in this sequence covers logic design using Chaps. 8, 9, 10, 11, 12, and 13. In this second
</p>
<p>course, students learn the advanced features of Verilog such as procedural assignments, sequential
</p>
<p>behavioral modeling, system tasks, and test benches. This provides the basis for building larger digital
</p>
<p>systems such as registers, finite-state machines, and arithmetic circuits. Chapter 13 brings all of the
</p>
<p>concepts together through the design of a simple 8-bit computer system that can be simulated and
</p>
<p>implemented using many off-the-shelf FPGA boards.
</p>
<p>This book can also be used in a more accelerated digital logic course that reaches a higher level of
</p>
<p>abstraction in a single semester. This is accomplished by skipping some chapters and moving quickly
</p>
<p>through others. In this use model, it is likely that Chap. 2 on number systems and Chap. 3 on digital
</p>
<p>circuits would be quickly referenced but not covered in detail. Chapters 4 and 7 could also be covered
</p>
<p>quickly in order to move rapidly into Verilog modeling without spending significant time looking at the
</p>
<p>underlying hardware implementation. This approach allows a higher level of abstraction to be taught but
</p>
<p>provides the student with the reference material so that they can delve into the details of the hardware
</p>
<p>implementation if interested.
</p>
<p>All exercise and concept problems that do not involve a Verilog model are designed so that they can
</p>
<p>be implemented as a multiple-choice or numeric entry question in a standard course management
</p>
<p>system. This allows the questions to be automatically graded. For the Verilog design questions, it is
</p>
<p>expected that the students will upload their Verilog source files and screenshots of their simulation
</p>
<p>waveforms to the course management system for manual grading by the instructor or teaching assistant.
</p>
<p>Instructor Resources
</p>
<p>Instructors adopting this book can access a growing collection of supplementary learning resources
</p>
<p>including YouTube videos created by the author, a solutions manual, a laboratory manual, and Verilog
</p>
<p>test benches for all problems. Additional resources are made available as demand grows. The growing
</p>
<p>library of YouTube videos can provide supplementary learning materials for students or facilitate fully
</p>
<p>online or flipped delivery of this material. The videos are found at https://www.youtube.com/c/
</p>
<p>DigitalLogicProgramming_LaMeres. The solutions manual contains a graphic-rich description of select
</p>
<p>exercise problems. A complementary lab manual has also been developed to provide additional learning
</p>
<p>activities based on both the 74HC discrete logic family and an off-the-shelf FPGA board. This manual is
</p>
<p>provided separately from the book in order to support the ever-changing technology options available for
</p>
<p>laboratory exercises.
</p>
<p>Preface &bull; vii</p>
<p/>
<div class="annotation"><a href="https://www.youtube.com/c/DigitalLogicProgramming_LaMeres">https://www.youtube.com/c/DigitalLogicProgramming_LaMeres</a></div>
<div class="annotation"><a href="https://www.youtube.com/c/DigitalLogicProgramming_LaMeres">https://www.youtube.com/c/DigitalLogicProgramming_LaMeres</a></div>
</div>
<div class="page"><p/>
<p>What&rsquo;s New in the Second Edition
</p>
<p>The most common request from adopters of the first edition of this book was more assessment
</p>
<p>problems and accompanying videos. As a result, the second edition now contains over 1000 assess-
</p>
<p>ment questions and a growing library of YouTube videos. Additionally, more worked examples have been
</p>
<p>added so that every section has abundant examples of how to apply the content to designing and
</p>
<p>analyzing digital circuits.
</p>
<p>Bozeman, MT, USA Brock J. LaMeres
</p>
<p>viii &bull; Preface</p>
<p/>
</div>
<div class="page"><p/>
<p>Acknowledgment
</p>
<p>For JoAnn, Alexis, and Kylie. Thank you for your endless support of this project. You are my
</p>
<p>inspiration.
</p>
<p>ix</p>
<p/>
</div>
<div class="page"><p/>
<p>Contents
1: INTRODUCTION: ANALOG VERSUS DIGITAL .................................................... 1
</p>
<p>1.1 DIFFERENCES BETWEEN ANALOG AND DIGITAL SYSTEMS ................................................ 1
</p>
<p>1.2 ADVANTAGES OF DIGITAL SYSTEMS OVER ANALOG SYSTEMS ........................................... 3
</p>
<p>2: NUMBER SYSTEMS .............................................................................................. 7
</p>
<p>2.1 POSITIONAL NUMBER SYSTEMS ................................................................................... 7
</p>
<p>2.1.1 Generic Structure .......................................................................................... 8
</p>
<p>2.1.2 Decimal Number System (Base 10) .............................................................. 9
</p>
<p>2.1.3 Binary Number System (Base 2) .................................................................. 9
</p>
<p>2.1.4 Octal Number System (Base 8) .................................................................... 10
</p>
<p>2.1.5 Hexadecimal Number System (Base 16) ...................................................... 10
</p>
<p>2.2 BASE CONVERSION ................................................................................................... 11
</p>
<p>2.2.1 Converting to Decimal ................................................................................... 11
</p>
<p>2.2.2 Converting from Decimal ............................................................................... 14
</p>
<p>2.2.3 Converting Between 2n Bases ...................................................................... 18
</p>
<p>2.3 BINARY ARITHMETIC .................................................................................................. 22
</p>
<p>2.3.1 Addition (Carries) ........................................................................................... 22
</p>
<p>2.3.2 Subtraction (Borrows) .................................................................................... 23
</p>
<p>2.4 UNSIGNED AND SIGNED NUMBERS ............................................................................... 25
</p>
<p>2.4.1 Unsigned Numbers ........................................................................................ 25
</p>
<p>2.4.2 Signed Numbers ............................................................................................ 26
</p>
<p>3: DIGITAL CIRCUITRY AND INTERFACING ............................................................ 43
</p>
<p>3.1 BASIC GATES ........................................................................................................... 43
</p>
<p>3.1.1 Describing the Operation of a Logic Circuit .................................................. 43
</p>
<p>3.1.2 The Buffer ...................................................................................................... 45
</p>
<p>3.1.3 The Inverter ................................................................................................... 46
</p>
<p>3.1.4 The AND Gate ............................................................................................... 46
</p>
<p>3.1.5 The NAND Gate ............................................................................................ 47
</p>
<p>3.1.6 The OR Gate ................................................................................................. 47
</p>
<p>3.1.7 The NOR Gate ............................................................................................... 47
</p>
<p>3.1.8 The XOR Gate ............................................................................................... 48
</p>
<p>3.1.9 The XNOR Gate ............................................................................................ 49
</p>
<p>3.2 DIGITAL CIRCUIT OPERATION ...................................................................................... 50
</p>
<p>3.2.1 Logic Levels ................................................................................................... 51
</p>
<p>3.2.2 Output DC Specifications .............................................................................. 51
</p>
<p>3.2.3 Input DC Specifications ................................................................................. 53
</p>
<p>3.2.4 Noise Margins ................................................................................................ 53
</p>
<p>3.2.5 Power Supplies ............................................................................................. 54
</p>
<p>3.2.6 Switching Characteristics .............................................................................. 56
</p>
<p>3.2.7 Data Sheets ................................................................................................... 57
</p>
<p>xi</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3 LOGIC FAMILIES ........................................................................................................ 62
</p>
<p>3.3.1 Complementary Metal-Oxide Semiconductors (CMOS) ............................... 62
</p>
<p>3.3.2 Transistor-Transistor Logic (TTL) .................................................................. 71
</p>
<p>3.3.3 The 7400 Series Logic Families .................................................................... 73
</p>
<p>3.4 DRIVING LOADS ........................................................................................................ 77
</p>
<p>3.4.1 Driving Other Gates ....................................................................................... 77
</p>
<p>3.4.2 Driving Resistive Loads ................................................................................. 79
</p>
<p>3.4.3 Driving LEDs .................................................................................................. 81
</p>
<p>4: COMBINATIONAL LOGIC DESIGN ....................................................................... 93
</p>
<p>4.1 BOOLEAN ALGEBRA ................................................................................................... 93
</p>
<p>4.1.1 Operations ..................................................................................................... 94
</p>
<p>4.1.2 Axioms ........................................................................................................... 94
</p>
<p>4.1.3 Theorems ....................................................................................................... 95
</p>
<p>4.1.4 Functionally Complete Operation Sets ......................................................... 110
</p>
<p>4.2 COMBINATIONAL LOGIC ANALYSIS ................................................................................ 111
</p>
<p>4.2.1 Finding the Logic Expression from a Logic Diagram .................................... 111
</p>
<p>4.2.2 Finding the Truth Table from a Logic Diagram .............................................. 112
</p>
<p>4.2.3 Timing Analysis of a Combinational Logic Circuit ......................................... 113
</p>
<p>4.3 COMBINATIONAL LOGIC SYNTHESIS .............................................................................. 115
</p>
<p>4.3.1 Canonical Sum of Products ........................................................................... 115
</p>
<p>4.3.2 The Minterm List (Σ) ...................................................................................... 116
</p>
<p>4.3.3 Canonical Product of Sums (POS) ............................................................... 118
</p>
<p>4.3.4 The Maxterm List (Π) .................................................................................... 120
</p>
<p>4.3.5 Minterm and Maxterm List Equivalence ........................................................ 122
</p>
<p>4.4 LOGIC MINIMIZATION .................................................................................................. 124
</p>
<p>4.4.1 Algebraic Minimization .................................................................................. 124
</p>
<p>4.4.2 Minimization Using Karnaugh Maps ............................................................. 125
</p>
<p>4.4.3 Don&rsquo;t Cares .................................................................................................... 137
</p>
<p>4.4.4 Using XOR Gates .......................................................................................... 138
</p>
<p>4.5 TIMING HAZARDS AND GLITCHES ................................................................................. 141
</p>
<p>5: VERILOG (PART 1) ................................................................................................ 153
</p>
<p>5.1 HISTORY OF HARDWARE DESCRIPTION LANGUAGES ....................................................... 154
</p>
<p>5.2 HDL ABSTRACTION .................................................................................................. 157
</p>
<p>5.3 THE MODERN DIGITAL DESIGN FLOW .......................................................................... 161
</p>
<p>5.4 VERILOG CONSTRUCTS .............................................................................................. 164
</p>
<p>5.4.1 Data Types .................................................................................................... 165
</p>
<p>5.4.2 The Module .................................................................................................... 168
</p>
<p>5.4.3 Verilog Operators .......................................................................................... 171
</p>
<p>5.5 MODELING CONCURRENT FUNCTIONALITY IN VERILOG .................................................... 175
</p>
<p>5.5.1 Continuous Assignment ................................................................................ 176
</p>
<p>5.5.2 Continuous Assignment with Logical Operators ........................................... 176
</p>
<p>5.5.3 Continuous Assignment with Conditional Operators .................................... 177
</p>
<p>5.5.4 Continuous Assignment with Delay .............................................................. 179
</p>
<p>xii &bull; Contents</p>
<p/>
</div>
<div class="page"><p/>
<p>5.6 STRUCTURAL DESIGN AND HIERARCHY ......................................................................... 182
</p>
<p>5.6.1 Lower-Level Module Instantiation ................................................................. 182
</p>
<p>5.6.2 Gate-Level Primitives .................................................................................... 184
</p>
<p>5.6.3 User-Defined Primitives ................................................................................. 185
</p>
<p>5.6.4 Adding Delay to Primitives ............................................................................ 186
</p>
<p>5.7 OVERVIEW OF SIMULATION TEST BENCHES ................................................................... 187
</p>
<p>6: MSI LOGIC .............................................................................................................. 195
</p>
<p>6.1 DECODERS .............................................................................................................. 195
</p>
<p>6.1.1 Example: One-Hot Decoder .......................................................................... 195
</p>
<p>6.1.2 Example: 7-Segment Display Decoder ......................................................... 198
</p>
<p>6.2 ENCODERS .............................................................................................................. 202
</p>
<p>6.2.1 Example: One-Hot Binary Encoder ............................................................... 203
</p>
<p>6.3 MULTIPLEXERS ......................................................................................................... 204
</p>
<p>6.4 DEMULTIPLEXERS ...................................................................................................... 207
</p>
<p>7: SEQUENTIAL LOGIC DESIGN .............................................................................. 213
</p>
<p>7.1 SEQUENTIAL LOGIC STORAGE DEVICES ........................................................................ 213
</p>
<p>7.1.1 The Cross-Coupled Inverter Pair .................................................................. 213
</p>
<p>7.1.2 Metastability ................................................................................................... 214
</p>
<p>7.1.3 The SR Latch ................................................................................................. 216
</p>
<p>7.1.4 The S&rsquo;R&rsquo; Latch ............................................................................................... 219
</p>
<p>7.1.5 SR Latch with Enable .................................................................................... 222
</p>
<p>7.1.6 The D-Latch ................................................................................................... 223
</p>
<p>7.1.7 The D-Flip-Flop .............................................................................................. 225
</p>
<p>7.2 SEQUENTIAL LOGIC TIMING CONSIDERATIONS ................................................................ 229
</p>
<p>7.3 COMMON CIRCUITS BASED ON SEQUENTIAL STORAGE DEVICES ...................................... 230
</p>
<p>7.3.1 Toggle Flop Clock Divider ............................................................................. 230
</p>
<p>7.3.2 Ripple Counter ............................................................................................... 231
</p>
<p>7.3.3 Switch Debouncing ........................................................................................ 232
</p>
<p>7.3.4 Shift Registers ............................................................................................... 237
</p>
<p>7.4 FINITE-STATE MACHINES ............................................................................................ 238
</p>
<p>7.4.1 Describing the Functionality of a FSM .......................................................... 238
</p>
<p>7.4.2 Logic Synthesis for a FSM ............................................................................ 241
</p>
<p>7.4.3 FSM Design Process Overview .................................................................... 248
</p>
<p>7.4.4 FSM Design Examples .................................................................................. 249
</p>
<p>7.5 COUNTERS .............................................................................................................. 256
</p>
<p>7.5.1 2-Bit Binary Up Counter ................................................................................ 256
</p>
<p>7.5.2 2-Bit Binary Up/Down Counter ...................................................................... 257
</p>
<p>7.5.3 2-Bit Gray Code Up Counter ......................................................................... 259
</p>
<p>7.5.4 2-Bit Gray Code Up/Down Counter ............................................................... 261
</p>
<p>7.5.5 3-Bit One-Hot Up Counter ............................................................................. 263
</p>
<p>7.5.6 3-Bit One-Hot Up/Down Counter .................................................................. 265
</p>
<p>Contents &bull; xiii</p>
<p/>
</div>
<div class="page"><p/>
<p>7.6 FINITE-STATE MACHINE&rsquo;S RESET CONDITION ................................................................ 269
</p>
<p>7.7 SEQUENTIAL LOGIC ANALYSIS ..................................................................................... 270
</p>
<p>7.7.1 Finding the State Equations and Output Logic Expressions of a FSM ........ 270
</p>
<p>7.7.2 Finding the State Transition Table of a FSM ................................................. 271
</p>
<p>7.7.3 Finding the State Diagram of a FSM ............................................................. 272
</p>
<p>7.7.4 Determining the Maximum Clock Frequency of a FSM ................................ 273
</p>
<p>8: VERILOG (PART 2) ................................................................................................ 289
</p>
<p>8.1 PROCEDURAL ASSIGNMENT ........................................................................................ 289
</p>
<p>8.1.1 Procedural Blocks ......................................................................................... 289
</p>
<p>8.1.2 Procedural Statements .................................................................................. 292
</p>
<p>8.1.3 Statement Groups ......................................................................................... 297
</p>
<p>8.1.4 Local Variables .............................................................................................. 298
</p>
<p>8.2 CONDITIONAL PROGRAMMING CONSTRUCTS .................................................................. 298
</p>
<p>8.2.1 if-else Statements .......................................................................................... 298
</p>
<p>8.2.2 case Statements ............................................................................................ 300
</p>
<p>8.2.3 casez and casex Statements ........................................................................ 301
</p>
<p>8.2.4 forever Loops ................................................................................................. 301
</p>
<p>8.2.5 while Loops .................................................................................................... 302
</p>
<p>8.2.6 repeat Loops .................................................................................................. 303
</p>
<p>8.2.7 for loops ......................................................................................................... 303
</p>
<p>8.2.8 disable ........................................................................................................... 303
</p>
<p>8.3 SYSTEM TASKS ........................................................................................................ 304
</p>
<p>8.3.1 Text Output .................................................................................................... 304
</p>
<p>8.3.2 File Input/Output ............................................................................................ 306
</p>
<p>8.3.3 Simulation Control and Monitoring ................................................................ 308
</p>
<p>8.4 TEST BENCHES ........................................................................................................ 309
</p>
<p>8.4.1 Common Stimulus Generation Techniques .................................................. 309
</p>
<p>8.4.2 Printing Results to the Simulator Transcript .................................................. 311
</p>
<p>8.4.3 Automatic Result Checking ........................................................................... 313
</p>
<p>8.4.4 Using Loops to Generate Stimulus ............................................................... 314
</p>
<p>8.4.5 Using External Files in Test Benches ........................................................... 315
</p>
<p>9: BEHAVIORAL MODELING OF SEQUENTIAL LOGIC .......................................... 323
</p>
<p>9.1 MODELING SEQUENTIAL STORAGE DEVICES IN VERILOG ................................................. 323
</p>
<p>9.1.1 D-Latch .......................................................................................................... 323
</p>
<p>9.1.2 D-Flip-Flop ..................................................................................................... 324
</p>
<p>9.1.3 D-Flip-Flop with Asynchronous Reset .......................................................... 324
</p>
<p>9.1.4 D-Flip-Flop with Asynchronous Reset and Preset ........................................ 325
</p>
<p>9.1.5 D-Flip-Flop with Synchronous Enable .......................................................... 326
</p>
<p>9.2 MODELING FINITE-STATE MACHINES IN VERILOG ........................................................... 327
</p>
<p>9.2.1 Modeling the States ....................................................................................... 329
</p>
<p>9.2.2 The State Memory Block ............................................................................... 329
</p>
<p>9.2.3 The Next State Logic Block ........................................................................... 329
</p>
<p>9.2.4 The Output Logic Block ................................................................................. 330
</p>
<p>9.2.5 Changing the State Encoding Approach ....................................................... 332
</p>
<p>xiv &bull; Contents</p>
<p/>
</div>
<div class="page"><p/>
<p>9.3 FSM DESIGN EXAMPLES IN VERILOG .......................................................................... 333
</p>
<p>9.3.1 Serial Bit Sequence Detector in Verilog ........................................................ 333
</p>
<p>9.3.2 Vending Machine Controller in Verilog .......................................................... 336
</p>
<p>9.3.3 2-Bit, Binary Up/Down Counter in Verilog ..................................................... 338
</p>
<p>9.4 MODELING COUNTERS IN VERILOG .............................................................................. 340
</p>
<p>9.4.1 Counters in Verilog Using a Single-Procedural Block .................................. 340
</p>
<p>9.4.2 Counters with Range Checking .................................................................... 341
</p>
<p>9.4.3 Counters with Enables in Verilog .................................................................. 342
</p>
<p>9.4.4 Counters with Loads ...................................................................................... 343
</p>
<p>9.5 RTL MODELING ....................................................................................................... 344
</p>
<p>9.5.1 Modeling Registers in Verilog ....................................................................... 345
</p>
<p>9.5.2 Registers as Agents on a Data Bus .............................................................. 346
</p>
<p>9.5.3 Shift Registers in Verilog ............................................................................... 348
</p>
<p>10: MEMORY .............................................................................................................. 355
</p>
<p>10.1 MEMORY ARCHITECTURE AND TERMINOLOGY ................................................................ 355
</p>
<p>10.1.1 Memory Map Model ...................................................................................... 355
</p>
<p>10.1.2 Volatile Versus Non-volatile Memory ............................................................ 356
</p>
<p>10.1.3 Read-Only Versus Read/Write Memory ....................................................... 356
</p>
<p>10.1.4 Random Access Versus Sequential Access ................................................ 356
</p>
<p>10.2 NON-VOLATILE MEMORY TECHNOLOGY ......................................................................... 357
</p>
<p>10.2.1 ROM Architecture .......................................................................................... 357
</p>
<p>10.2.2 Mask Read-Only Memory (MROM) .............................................................. 360
</p>
<p>10.2.3 Programmable Read-Only Memory (PROM) ................................................ 361
</p>
<p>10.2.4 Erasable Programmable Read-Only Memory (EPROM) .............................. 362
</p>
<p>10.2.5 Electrically Erasable Programmable Read-Only Memory (EEPROM) ......... 364
</p>
<p>10.2.6 FLASH Memory ............................................................................................. 365
</p>
<p>10.3 VOLATILE MEMORY TECHNOLOGY ................................................................................ 365
</p>
<p>10.3.1 Static Random-Access Memory (SRAM) ..................................................... 366
</p>
<p>10.3.2 Dynamic Random-Access Memory (DRAM) ................................................ 369
</p>
<p>10.4 MODELING MEMORY WITH VERILOG ............................................................................. 376
</p>
<p>10.4.1 Read-Only Memory in Verilog ....................................................................... 376
</p>
<p>10.4.2 Read/Write Memory in Verilog ...................................................................... 377
</p>
<p>11: PROGRAMMABLE LOGIC ................................................................................... 383
</p>
<p>11.1 PROGRAMMABLE ARRAYS ........................................................................................... 383
</p>
<p>11.1.1 Programmable Logic Array (PLA) ................................................................. 383
</p>
<p>11.1.2 Programmable Array Logic (PAL) ................................................................. 384
</p>
<p>11.1.3 Generic Array Logic (GAL) ............................................................................ 385
</p>
<p>11.1.4 Hard Array Logic (HAL) ................................................................................. 386
</p>
<p>11.1.5 Complex Programmable Logic Devices (CPLD) .......................................... 386
</p>
<p>11.2 FIELD-PROGRAMMABLE GATE ARRAYS (FPGAS) .......................................................... 387
</p>
<p>11.2.1 Configurable Logic Block (or Logic Element) ................................................ 388
</p>
<p>11.2.2 Look-Up Tables (LUTs) .................................................................................. 389
</p>
<p>11.2.3 Programmable Interconnect Points (PIPs) .................................................... 392
</p>
<p>11.2.4 Input/Output Block (IOB) ............................................................................... 393
</p>
<p>11.2.5 Configuration Memory ................................................................................... 394
</p>
<p>Contents &bull; xv</p>
<p/>
</div>
<div class="page"><p/>
<p>12: ARITHMETIC CIRCUITS ...................................................................................... 397
</p>
<p>12.1 ADDITION ................................................................................................................. 397
</p>
<p>12.1.1 Half Adders .................................................................................................... 397
</p>
<p>12.1.2 Full Adders .................................................................................................... 398
</p>
<p>12.1.3 Ripple Carry Adder (RCA) ............................................................................ 400
</p>
<p>12.1.4 Carry Look Ahead Adder (CLA) .................................................................... 402
</p>
<p>12.1.5 Adders in Verilog ........................................................................................... 405
</p>
<p>12.2 SUBTRACTION .......................................................................................................... 410
</p>
<p>12.3 MULTIPLICATION ........................................................................................................ 413
</p>
<p>12.3.1 Unsigned Multiplication ................................................................................. 413
</p>
<p>12.3.2 A Simple Circuit to Multiply by Powers of Two ............................................. 416
</p>
<p>12.3.3 Signed Multiplication ..................................................................................... 417
</p>
<p>12.4 DIVISION ................................................................................................................. 419
</p>
<p>12.4.1 Unsigned Division ......................................................................................... 419
</p>
<p>12.4.2 A Simple Circuit to Divide by Powers of Two ............................................... 422
</p>
<p>12.4.3 Signed Division ............................................................................................. 423
</p>
<p>13: COMPUTER SYSTEM DESIGN ........................................................................... 427
</p>
<p>13.1 COMPUTER HARDWARE ............................................................................................. 427
</p>
<p>13.1.1 Program Memory ........................................................................................... 428
</p>
<p>13.1.2 Data Memory ................................................................................................. 428
</p>
<p>13.1.3 Input/Output Ports ......................................................................................... 428
</p>
<p>13.1.4 Central Processing Unit ................................................................................ 429
</p>
<p>13.1.5 A Memory-Mapped System .......................................................................... 430
</p>
<p>13.2 COMPUTER SOFTWARE .............................................................................................. 432
</p>
<p>13.2.1 Opcodes and Operands ................................................................................ 433
</p>
<p>13.2.2 Addressing Modes ........................................................................................ 433
</p>
<p>13.2.3 Classes of Instructions .................................................................................. 434
</p>
<p>13.3 COMPUTER IMPLEMENTATION: AN 8-BIT COMPUTER EXAMPLE ........................................ 441
</p>
<p>13.3.1 Top-Level Block Diagram .............................................................................. 441
</p>
<p>13.3.2 Instruction Set Design ................................................................................... 443
</p>
<p>13.3.3 Memory System Implementation .................................................................. 444
</p>
<p>13.3.4 CPU Implementation ..................................................................................... 447
</p>
<p>13.4 ARCHITECTURE CONSIDERATIONS ................................................................................ 468
</p>
<p>13.4.1 Von Neumann Architecture ........................................................................... 468
</p>
<p>13.4.2 Harvard Architecture ..................................................................................... 468
</p>
<p>APPENDIX A: LIST OF WORKED EXAMPLES ........................................................ 473
</p>
<p>APPENDIX B: CONCEPT CHECK SOLUTIONS ....................................................... 479
</p>
<p>INDEX .......................................................................................................................... 481
</p>
<p>xvi &bull; Contents</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 1: Introduction: Analog
</p>
<p>Versus Digital
We often hear that we live in a digital age. This refers to the massive adoption of computer systems
</p>
<p>within every aspect of our lives from smartphones to automobiles to household appliances. This
</p>
<p>statement also refers to the transformation that has occurred to our telecommunications infrastructure
</p>
<p>that now transmits voice, video, and data using 1&rsquo;s and 0&rsquo;s. There are a variety of reasons that digital
</p>
<p>systems have become so prevalent in our lives. In order to understand these reasons, it is good to start
</p>
<p>with an understanding of what a digital system is and how it compares to its counterpart, the analog
</p>
<p>system. The goal of this chapter is to provide an understanding of the basic principles of analog and
</p>
<p>digital systems.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>1.1 Describe the fundamental differences between analog and digital systems.
1.2 Describe the advantages of digital systems compared to analog systems.
</p>
<p>1.1 Differences Between Analog and Digital Systems
</p>
<p>Let&rsquo;s begin by looking at signaling. In electrical systems, signals represent information that is
</p>
<p>transmitted between devices using an electrical quantity (voltage or current). An analog signal is defined
</p>
<p>as a continuous, time-varying quantity that corresponds directly to the information it represents. An
</p>
<p>example of this would be a barometric pressure sensor that outputs an electrical voltage corresponding
</p>
<p>to the pressure being measured. As the pressure goes up, so does the voltage. While the range of the
</p>
<p>input (pressure) and output (voltage) will have different spans, there is a direct mapping between the
</p>
<p>pressure and voltage. Another example would be sound striking a traditional analog microphone. Sound
</p>
<p>is a pressure wave that travels through a medium such as air. As the pressure wave strikes the
</p>
<p>diaphragm in the microphone, the diaphragm moves back and forth. Through the process of inductive
</p>
<p>coupling, this movement is converted to an electric current. The characteristics of the current signal
</p>
<p>produced (e.g., frequency and magnitude) correspond directly to the characteristics of the incoming
</p>
<p>sound wave. The current can travel down a wire and go through another system that works in the
</p>
<p>opposite manner by inductively coupling the current onto another diaphragm, which in turn moves back
</p>
<p>and forth forming a pressure wave and thus sound (i.e., a speaker or earbud). In both of these examples,
</p>
<p>the electrical signal represents the actual information that is being transmitted and is considered analog.
</p>
<p>Analog signals can be represented mathematically as a function with respect to time.
</p>
<p>In digital signaling the electrical signal itself is not directly the information it represents; instead, the
</p>
<p>information is encoded. The most common type of encoding is binary (1&rsquo;s and 0&rsquo;s). The 1&rsquo;s and 0&rsquo;s are
</p>
<p>represented by the electrical signal. The simplest form of digital signaling is to define a threshold voltage
</p>
<p>directly in the middle of the range of the electrical signal. If the signal is above this threshold, the signal is
</p>
<p>representing a 1. If the signal is below this threshold, the signal is representing a 0. This type of signaling
</p>
<p>is not considered continuous as in analog signaling; instead, it is considered to be discrete because the
</p>
<p>information is transmitted as a series of distinct values. The signal transitions between a 1 to 0 and 0 to
</p>
<p>1 are assumed to occur instantaneously. While this is obviously impossible, for the purposes of
</p>
<p>information transmission, the values can be interpreted as a series of discrete values. This is a digital
</p>
<p>signal and is not the actual information, but rather the binary encoded representation of the original
</p>
<p>information. Digital signals are not represented using traditional mathematical functions; instead, the
</p>
<p>digital values are typically held in tables of 1&rsquo;s and 0&rsquo;s.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_1
</p>
<p>1</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_1&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_1&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>Examples of analog signals and systems The human interface to a computer, the electrical
signal representing sound that travels down the wire of a set of headphones, the actual sound coming out
</p>
<p>of headphones, electricity coming out of a wall outlet, and the voltage from a battery or solar cell.
</p>
<p>Examples of digital signals and systems Information stored on a computer; the computer
hardware that processes information; devices such as computers, tablets, and smartphones are also
</p>
<p>considered digital systems because their hardware and information being processed is digital; and the
</p>
<p>information being transmitted over the Internet and wireless networks is digital.
</p>
<p>Figure 1.1 shows an example of analog signal (left) and an example of digital signal (right). While the
</p>
<p>digital signal is in reality continuous, it represents a series of discrete 1 and 0 values.
</p>
<p>CONCEPT CHECK
</p>
<p>CC1.1 If a digital signal is only a discrete representation of real information, how is it possible to
produce high-quality music without hearing &ldquo;gaps&rdquo; in the output due to the digitization
process?
</p>
<p>A) The gaps are present, but they occur so quickly that the human ear can&rsquo;t
detect them.
</p>
<p>B) When the digital music is converted back to analog sound, the gaps are
smoothed out since an analog signal is by definition continuous.
</p>
<p>C) Digital information is a continuous, time-varying signal so there aren&rsquo;t gaps.
</p>
<p>D) The gaps can be heard if the music is played slowly, but at normal speed, they
can&rsquo;t be.
</p>
<p>Fig. 1.1
Analog (left) vs. digital (right) signals
</p>
<p>2 &bull; Chapter 1: Introduction: Analog Versus Digital</p>
<p/>
</div>
<div class="page"><p/>
<p>1.2 Advantages of Digital Systems over Analog Systems
</p>
<p>There are a variety of reasons that digital systems are preferred over analog systems. First is their
</p>
<p>ability to operate within the presence of noise. Since an analog signal is a direct representation of the
</p>
<p>physical quantity it is transmitting, any noise that is coupled onto the electrical signal is interpreted as
</p>
<p>noise on the original physical quantity. An example of this is when you are listening to an AM/FM radio
</p>
<p>and you hear distortion of the sound coming out of the speaker. The distortion you hear is not due to
</p>
<p>actual distortion of the music as it was played at the radio station, but rather electrical noise that was
</p>
<p>coupled onto the analog signal transmitted to your radio prior to being converted back into sound by the
</p>
<p>speakers. Since the signal in this case is analog, the speaker simply converts it in its entirety (noise +
</p>
<p>music) into sound. In the case of digital signaling, a significant amount of noise can be added to the
</p>
<p>signal while still preserving the original 1&rsquo;s and 0&rsquo;s that are being transmitted. For example, if the signal is
</p>
<p>representing a 0, the receiver will still interpret the signal as a 0 as long as the noise doesn&rsquo;t cause the
</p>
<p>level to exceed the threshold. Once the receiver interprets the signal as a 0, it stores the encoded value
</p>
<p>as a 0, thus ignoring any noise present during the original transmission. Figure 1.2 shows the exact same
</p>
<p>noise added to the analog and digital signals from Fig. 1.1. The analog signal is distorted; however, the
</p>
<p>digital signal is still able to transmit the 0&rsquo;s and 1&rsquo;s that represent the information.
</p>
<p>Another reason that digital systems are preferred over analog ones is the simplicity of the circuitry. In
</p>
<p>order to produce a 1 and 0, you simply need an electrical switch. If the switch connects the output to a
</p>
<p>voltage below the threshold, then it produces a 0. If the switch connects the output to a voltage above the
</p>
<p>threshold, then it produces a 1. It is relatively simple to create such a switching circuit using modern
</p>
<p>transistors. Analog circuitry, however, needs to perform the conversion of the physical quantity it is
</p>
<p>representing (e.g., pressure, sound) into an electrical signal all the while maintaining a direct correspon-
</p>
<p>dence between the input and output. Since analog circuits produce a direct, continuous representation of
</p>
<p>Fig. 1.2
Noise on analog (left) and digital (right) signals
</p>
<p>1.2 Advantages of Digital Systems over Analog Systems &bull; 3</p>
<p/>
</div>
<div class="page"><p/>
<p>information, they require more complicated designs to achieve linearity in the presence of environmental
</p>
<p>variations (e.g., power supply, temperature, fabrication differences). Since digital circuits only produce a
</p>
<p>discrete representation of the information, they can be implemented with simple switches that are only
</p>
<p>altered when information is produced or retrieved. Figure 1.3 shows an example comparison between an
</p>
<p>analog-inverting amplifier and a digital inverter. The analog amplifier uses dozens of transistors (inside
</p>
<p>the triangle) and two resistors to perform the inversion of the input. The digital inverter uses two
</p>
<p>transistors that act as switches to perform the inversion.
</p>
<p>A final reason that digital systems are being widely adopted is their reduced power consumption.
</p>
<p>With the advent of complementary metal-oxide transistors (CMOS), electrical switches can be created
</p>
<p>that consume very little power to turn on or off and consume relatively negligible amounts of power to
</p>
<p>keep on or off. This has allowed large-scale digital systems to be fabricated without excessive levels of
</p>
<p>power consumption. For stationary digital systems such as servers and workstations, extremely large
</p>
<p>and complicated systems can be constructed that consume reasonable amounts of power. For portable
</p>
<p>digital systems such as smartphones and tablets, this means useful tools can be designed that are able
</p>
<p>to run on portable power sources. Analog circuits, on the other hand, require continuous power to
</p>
<p>accurately convert and transmit the electrical signal representing the physical quantity. Also, the circuit
</p>
<p>techniques that are required to compensate for variances in power supply and fabrication processes in
</p>
<p>analog systems require additional power consumption. For these reasons, analog systems are being
</p>
<p>replaced with digital systems wherever possible to exploit their noise immunity, simplicity, and low-power
</p>
<p>consumption. While analog systems will always be needed at the transition between the physical (e.g.,
</p>
<p>microphones, camera lenses, sensors, video displays) and the electrical world, it is anticipated that the
</p>
<p>push toward digitization of everything in between (e.g., processing, transmission, storage) will continue.
</p>
<p>Fig. 1.3
Analog (left) vs. digital (right) circuits
</p>
<p>4 &bull; Chapter 1: Introduction: Analog Versus Digital</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC1.2 When does the magnitude of electrical noise on a digital signal prevent the original
information from being determined?
</p>
<p>A) When it causes the system to draw too much power.
</p>
<p>B) When the shape of the noise makes the digital signal look smooth and
continuous like a sine wave.
</p>
<p>C) When the magnitude of the noise is large enough that it causes the signal to
inadvertently cross the threshold voltage.
</p>
<p>D) It doesn&rsquo;t. A digital signal can withstand any magnitude of noise.
</p>
<p>Summary
</p>
<p>v An analog system uses a direct mapping
between an electrical quantity and the infor-
mation being processed. A digital system, on
the other hand, uses a discrete representa-
tion of the information.
</p>
<p>v Using a discrete representation allows the
digital signals to be more immune to noise
in addition to requiring simple circuits that
require less power to perform the
computations.
</p>
<p>Exercise Problems
</p>
<p>Section 1.1: Differences Between Analog
and Digital Systems
</p>
<p>1.1.1 If an electrical signal is a direct function of a
physical quantity, is it considered analog or
digital?
</p>
<p>1.1.2 If an electrical signal is a discrete representa-
tion of information, is it considered analog or
digital?
</p>
<p>1.1.3 What part of any system will always require an
analog component?
</p>
<p>1.1.4 Is the sound coming out of earbuds analog or
digital?
</p>
<p>1.1.5 Is the MP3 file stored on an iPod analog or
digital?
</p>
<p>1.1.6 Is the circuitry that reads the MP3 file from
memory in an iPod analog or digital?
</p>
<p>1.1.7 Is the electrical signal that travels down ear-
phone wires analog or digital?
</p>
<p>1.1.8 Is the voltage coming out of the battery in an
iPod analog or digital?
</p>
<p>1.1.9 Is the physical interface on the touch display of
an iPod analog or digital?
</p>
<p>1.1.10 Take a look around right now, and identify two
digital technologies in use.
</p>
<p>1.1.11 Take a look around right now, and identify two
analog technologies in use.
</p>
<p>1.1.12 Using the terminology from this chapter,
describe the difference between an analog
clock with a smooth moving second hand and
a digital clock.
</p>
<p>1.1.13 Using the terminology from this chapter,
describe the difference between an analog
and digital thermometer.
</p>
<p>Section 1.2: Advantages of Digital
Systems over Analog Systems
</p>
<p>1.2.1 Give three advantages of using digital systems
over analog.
</p>
<p>1.2.2 Name a technology or device that has evolved
from analog to digital in your lifetime.
</p>
<p>1.2.3 Name an analog technology or device that has
become obsolete in your lifetime.
</p>
<p>1.2.4 Name an analog technology or device that has
been replaced by digital technology but is still
in use due to nostalgia.
</p>
<p>Exercise Problems &bull; 5</p>
<p/>
</div>
<div class="page"><p/>
<p>1.2.5 Name a technology or device invented in your
lifetime that could not have been possible with-
out digital technology.
</p>
<p>1.2.6 In this chapter it was discussed that in digital
circuits, a transistor is used to create a simple
switch. Doing a quick Internet search, about
how many transistors are in a modern
microprocessor?
</p>
<p>1.2.7 In this chapter it was discussed that in analog
circuits, the circuit design is more complex, and
as a result, fewer transistors are used. The
analog circuit shown in Fig. 1.3 is based on
an analog device called an operational ampli-
fier. Doing a quick Internet search, about how
many transistors are in an operational amplifier
device?
</p>
<p>6 &bull; Chapter 1: Introduction: Analog Versus Digital</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 2: Number Systems
Logic circuits are used to generate and transmit 1&rsquo;s and 0&rsquo;s to compute and convey information. This
</p>
<p>two-valued number system is called binary. As presented earlier, there are many advantages of using a
</p>
<p>binary system; however, the human brain has been taught to count, label, and measure using the
</p>
<p>decimal number system. The decimal number system contains ten unique symbols (0 ! 9) commonly
</p>
<p>referred to as the Arabic numerals. Each of these symbols is assigned a relative magnitude to the other
</p>
<p>symbols. For example, 0 is less than 1, 1 is less than 2, etc. It is often conjectured that the 10-symbol
</p>
<p>number system that we humans use is due to the availability of our ten fingers (or digits) to visualize
</p>
<p>counting up to 10. Regardless, our brains are trained to think of the real world in terms of a decimal
</p>
<p>system. In order to bridge the gap between the way our brains think (decimal) and how we build our
</p>
<p>computers (binary), we need to understand the basics of number systems. This includes the formal
</p>
<p>definition of a positional number system and how it can be extended to accommodate any arbitrarily large
</p>
<p>(or small) value. This also includes how to convert between different number systems that contain
</p>
<p>different numbers of symbols. In this chapter, we cover 4 different number systems: decimal
</p>
<p>(10 symbols), binary (2 symbols), octal (8 symbols), and hexadecimal (16 symbols). The study of
</p>
<p>decimal and binary is obvious as they represent how our brains interpret the physical world (decimal)
</p>
<p>and how our computers work (binary). Hexadecimal is studied because it is a useful means to represent
</p>
<p>large sets of binary values using a manageable number of symbols. Octal is rarely used but is studied as
</p>
<p>an example of how the formalization of the number systems can be applied to all systems regardless of
</p>
<p>the number of symbols they contain. This chapter will also discuss how to perform basic arithmetic in the
</p>
<p>binary number system and represent negative numbers. The goal of this chapter is to provide an
</p>
<p>understanding of the basic principles of binary number systems.
</p>
<p>Learning outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>2.1 Describe the formation and use of positional number systems.
2.2 Convert numbers between different bases.
2.3 Perform binary addition and subtraction by hand.
2.4 Use two&rsquo;s complement numbers to represent negative numbers.
</p>
<p>2.1 Positional Number Systems
</p>
<p>A positional number system allows the expansion of the original set of symbols so that they can be
</p>
<p>used to represent any arbitrarily large (or small) value. For example, if we use the 10 symbols in our
</p>
<p>decimal system, we can count from 0 to 9. Using just the individual symbols, we do not have enough
</p>
<p>symbols to count beyond 9. To overcome this, we use the same set of symbols but assign a different
</p>
<p>value to the symbol based on its position within the number. The position of the symbol with respect to
</p>
<p>other symbols in the number allows an individual symbol to represent greater (or lesser) values. We can
</p>
<p>use this approach to represent numbers larger than the original set of symbols. For example, let&rsquo;s say we
</p>
<p>want to count from 0 upward by 1. We begin counting 0, 1, 2, 3, 4, 5, 6, 7, 8 to 9. When we are out of
</p>
<p>symbols and wish to go higher, we bring on a symbol in a different position with that position being valued
</p>
<p>higher and then start counting over with our original symbols (e.g., . . ., 9, 10, 11,... 19, 20, 21,...). This is
</p>
<p>repeated each time a position runs out of symbols (e.g., . . ., 99, 100, 101. . . 999, 1000, 1001,. . .).
</p>
<p>First, let&rsquo;s look at the formation of a number system. The first thing that is needed is a set of symbols.
</p>
<p>The formal term for one of the symbols in a number system is a numeral. One or more numerals are used
</p>
<p>to form a number. We define the number of numerals in the system using the terms radix or base. For
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_2
</p>
<p>7</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_2&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_2&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>example, our decimal number system is said to be base 10 or have a radix of 10 because it consists of
</p>
<p>ten unique numerals or symbols.
</p>
<p>Radix &frac14; Base � the number of numerals in the number system
</p>
<p>The next thing that is needed is the relative value of each numeral with respect to the other numerals in
</p>
<p>the set. We can say 0 &lt; 1 &lt; 2 &lt; 3, etc. to define the relative magnitudes of the numerals in this set. The
</p>
<p>numerals are defined to be greater or less than their neighbors by a magnitude of 1. For example, in the
</p>
<p>decimal number system, each of the subsequent numerals is greater than its predecessor by exactly
</p>
<p>1. When we define this relative magnitude, we are defining that the numeral 1 is greater than the numeral
</p>
<p>0 by a magnitude of 1, the numeral 2 is greater than the numeral 1 by a magnitude of 1, etc. At this point we
</p>
<p>have the ability to count from0 to 9 by 1&rsquo;s.We also have the basic structure formathematical operations that
</p>
<p>have results that fall within the numeral set from 0 to 9 (e.g., 1 + 2 &frac14; 3). In order to expand the values that
</p>
<p>these numerals can represent, we need to define the rules of a positional number system.
</p>
<p>2.1.1 Generic Structure
</p>
<p>In order to represent larger or smaller numbers than the lone numerals in a number system can
</p>
<p>represent, we adopt a positional system. In a positional number system, the relative position of the
</p>
<p>numeral within the overall number dictates its value. When we begin talking about the position of a
</p>
<p>numeral, we need to define a location to which all of the numerals are positioned with respect to. We
</p>
<p>define the radix point as the point within a number to which numerals to the left represent whole numbers
</p>
<p>and numerals to the right represent fractional numbers. The radix point is denoted with a period (i.e., &ldquo;.&rdquo;).
</p>
<p>A particular number system often renames this radix point to reflect its base. For example, in the base
</p>
<p>10 number system (i.e., decimal), the radix point is commonly called the decimal point; however, the term
</p>
<p>radix point can be used across all number systems as a generic term. If the radix point is not present in a
</p>
<p>number, it is assumed to be to the right of number. Figure 2.1 shows an example number highlighting the
</p>
<p>radix point and the relative positions of the whole and fractional numerals.
</p>
<p>Next, we need to define the position of each numeral with respect to the radix point. The position of
</p>
<p>the numeral is assigned a whole number with the number to the left of the radix point having a position
</p>
<p>value of 0. The position number increases by 1 as numerals are added to the left (2, 3, 4. . .) and
</p>
<p>decreased by 1 as numerals are added to the right (�1, �2, �3). We will use the variable p to represent
</p>
<p>position. The position number will be used to calculate the value of each numeral in the number based on
</p>
<p>its relative position to the radix point. Figure 2.2 shows the example number with the position value of
</p>
<p>each numeral highlighted.
</p>
<p>Fig. 2.1
Definition of radix point
</p>
<p>Fig. 2.2
Definition of position number (p) within the number
</p>
<p>8 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>In order to create a generalized format of a number, we assign the term digit (d ) to each of the
</p>
<p>numerals in the number. The term digit signifies that the numeral has a position. The position of the digit
</p>
<p>within the number is denoted as a subscript. The term digit can be used as a generic term to describe a
</p>
<p>numeral across all systems, although some number systems will use a unique term instead of digit which
</p>
<p>indicates its base. For example, the binary system uses the term bit instead of digit; however, using the
</p>
<p>term digit to describe a generic numeral in any system is still acceptable. Figure 2.3 shows the generic
</p>
<p>subscript notation used to describe the position of each digit in the number.
</p>
<p>We write a number from left to right starting with the highest position digit that is greater than 0 and
</p>
<p>ending with the lowest position digit that is greater than 0. This reduces the number of numerals that are
</p>
<p>written; however, a number can be represented with an arbitrary number of 0&rsquo;s to the left of the highest
</p>
<p>position digit greater than 0 and an arbitrary number of 0&rsquo;s to the right of the lowest position digit greater
</p>
<p>than 0 without affecting the value of the number. For example, the number 132.654 could be written as
</p>
<p>0132.6540 without affecting the value of the number. The 0&rsquo;s to the left of the number are called leading
</p>
<p>0&rsquo;s and the 0&rsquo;s to the right of the number are called trailing 0&rsquo;s. The reason this is being stated is because
</p>
<p>when a number is implemented in circuitry, the number of numerals is fixed, and each numeral must have
</p>
<p>a value. The variable n is used to represent the number of numerals in a number. If a number is defined
</p>
<p>with n &frac14; 4, that means 4 numerals are always used. The number 0 would be represented as 0000 with
</p>
<p>both representations having an equal value.
</p>
<p>2.1.2 Decimal Number System (Base 10)
</p>
<p>As mentioned earlier, the decimal number system contains ten unique numerals (0, 1, 2, 3, 4, 5, 6, 7,
</p>
<p>8 and 9). This system is thus a base 10 or a radix 10 system. The relative magnitudes of the symbols are
</p>
<p>0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9.
</p>
<p>2.1.3 Binary Number System (Base 2)
</p>
<p>The binary number system contains two unique numerals (0 and 1). This system is thus a base 2 or
</p>
<p>a radix 2 system. The relative magnitudes of the symbols are 0 &lt; 1. At first glance, this system looks very
</p>
<p>limited in its ability to represent large numbers due to the small number of numerals. When counting up,
</p>
<p>as soon as you count from 0 to 1, you are out of symbols and must increment the p + 1 position in order to
</p>
<p>represent the next number (e.g., 0, 1, 10, 11, 100, 101, etc.); however, magnitudes of each position scale
</p>
<p>quickly so that circuits with a reasonable amount of digits can represent very large numbers. The term bit
</p>
<p>is used instead of digit in this system to describe the individual numerals and at the same time indicate
</p>
<p>the base of the number.
</p>
<p>Due to the need for multiple bits to represent meaningful information, there are terms dedicated to
</p>
<p>describing the number of bits in a group. When 4 bits are grouped together, they are called a nibble.
</p>
<p>When 8 bits are grouped together, they are called a byte. Larger groupings of bits are calledwords. The
</p>
<p>size of the word can be stated as either an n-bit word or omitted if the size of the word is inherently
</p>
<p>implied. For example, if you were using a 32-bit microprocessor, using the term word would be
</p>
<p>Fig. 2.3
Digit notation
</p>
<p>2.1 Positional Number Systems &bull; 9</p>
<p/>
</div>
<div class="page"><p/>
<p>interpreted as a 32-bit word. For example, if there was a 32-bit grouping, it would be referred to as a 32-bit
</p>
<p>word. The leftmost bit in a binary number is called theMost Significant Bit (MSB). The rightmost bit in a
</p>
<p>binary number is called the Least Significant Bit (LSB).
</p>
<p>2.1.4 Octal Number System (Base 8)
</p>
<p>The octal number system contains eight unique numerals (0, 1, 2, 3, 4, 5, 6, 7). This system is thus a
</p>
<p>base 8 or a radix 8 system. The relative magnitudes of the symbols are 0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7. We
</p>
<p>use the generic term digit to describe the numerals within an octal number.
</p>
<p>2.1.5 Hexadecimal Number System (Base 16)
</p>
<p>The hexadecimal number system contains 16 unique numerals. This system is most often referred
</p>
<p>to in spoken word as &ldquo;hex&rdquo; for short. Since we only have ten Arabic numerals in our familiar decimal
</p>
<p>system, we need to use other symbols to represent the remaining six numerals. We use the alphabetic
</p>
<p>characters A&ndash;F in order to expand the system to 16 numerals. The 16 numerals in the hexadecimal
</p>
<p>system are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F. The relative magnitudes of the symbols are
</p>
<p>0 &lt; 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; A &lt; B &lt; C &lt; D &lt; E &lt; F. We use the generic term digit to describe the
</p>
<p>numerals within a hexadecimal number.
</p>
<p>At this point, it becomes necessary to indicate the base of a written number. The number 10 has an
</p>
<p>entirely different value if it is a decimal number or binary number. In order to handle this, a subscript is
</p>
<p>typically included at the end of the number to denote its base. For example, 1010 indicates that this
</p>
<p>number is decimal &ldquo;ten.&rdquo; If the number was written as 102, this number would represent binary &ldquo;one zero.&rdquo;
</p>
<p>Table 2.1 lists the equivalent values in each of the four number systems just described for counts from
</p>
<p>010 to 1510. The left side of the table does not include leading 0&rsquo;s. The right side of the table contains the
</p>
<p>same information but includes the leading zeros. The equivalencies of decimal, binary, and hexadecimal
</p>
<p>in this table are typically committed to memory.
</p>
<p>Table 2.1
Number system equivalency
</p>
<p>10 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC2.1 The base of a number system is arbitrary and is commonly selected to match a particular
aspect of the physical system in which it is used (e.g., base 10 corresponds to our ten
fingers; base 2 corresponds to the two states of a switch). If a physical system contained
three unique modes and a base of 3 was chosen for the number system, what is the
base 3 equivalent of the decimal number 3?
</p>
<p>A) 310 &frac14; 113 B) 310 &frac14; 33 C) 310 &frac14; 103 D) 310 &frac14; 213
</p>
<p>2.2 Base Conversion
</p>
<p>Now we look at converting between bases. There are distinct techniques for converting to and from
</p>
<p>decimal. There are also techniques for converting between bases that are powers of 2 (e.g., base 2, 4,
</p>
<p>8, 16, etc.).
</p>
<p>2.2.1 Converting to Decimal
</p>
<p>The value of each digit within a number is based on the individual digit value and the digit&rsquo;s position.
</p>
<p>Each position in the number contains a different weight based on its relative location to the radix point.
</p>
<p>The weight of each position is based on the radix of the number system that is being used. The weight of
</p>
<p>each position in decimal is defined as:
</p>
<p>Weight &frac14; Radix&eth; &THORN;p
</p>
<p>This expression gives the number system the ability to represent fractional numbers since an
</p>
<p>expression with a negative exponent (e.g., x�y) is evaluated as one over the expression with the
</p>
<p>exponent change to positive (e.g., 1/xy). Figure 2.4 shows the generic structure of a number with its
</p>
<p>positional weight highlighted.
</p>
<p>In order to find the decimal value of each of the numerals in the number, its individual numeral value
</p>
<p>is multiplied by its positional weight. In order to find the value of the entire number, each value of the
</p>
<p>individual numeral-weight products is summed. The generalized format of this conversion is written as:
</p>
<p>Total Decimal Value &frac14;
X
</p>
<p>pmax
</p>
<p>i&frac14;pmin
</p>
<p>d i ∙ radix&eth; &THORN;
i
</p>
<p>Fig. 2.4
Weight definition
</p>
<p>2.2 Base Conversion &bull; 11</p>
<p/>
</div>
<div class="page"><p/>
<p>In this expression, pmax represents the highest position number that contains a numeral greater than
</p>
<p>0. The variable pmin represents the lowest position number that contains a numeral greater than 0. These
</p>
<p>limits are used to simplify the hand calculations; however, these terms theoretically could be +1 to �1
</p>
<p>with no effect on the result since the summation of every leading 0 and every trailing 0 contributes
</p>
<p>nothing to the result.
</p>
<p>As an example, let&rsquo;s evaluate this expression for a decimal number. The result will yield the original
</p>
<p>number but will illustrate how positional weight is used. Let&rsquo;s take the number 132.65410. To find the
</p>
<p>decimal value of this number, each numeral is multiplied by its positional weight, and then all of the
</p>
<p>products are summed. The positional weight for the digit 1 is (radix)p or (10)2. In decimal this is called the
</p>
<p>hundred&rsquo;s position. The positional weight for the digit 3 is (10)1, referred to as the ten&rsquo;s position. The
</p>
<p>positional weight for digit 2 is (10)0, referred to as the one&rsquo;s position. The positional weight for digit 6 is
</p>
<p>(10)�1, referred to as the tenth&rsquo;s position. The positional weight for digit 5 is (10)�2, referred to as the
</p>
<p>hundredth&rsquo;s position. The positional weight for digit 4 is (10)�3, referred to as the thousandth&rsquo;s position.
</p>
<p>When these weights are multiplied by their respective digits and summed, the result is the original
</p>
<p>decimal number 132.65410. Example 2.1 shows this process step-by-step.
</p>
<p>This process is used to convert between any other base to decimal.
</p>
<p>2.2.1.1 Binary to Decimal
</p>
<p>Let&rsquo;s convert 101.112 to decimal. The same process is followed with the exception that the base in
</p>
<p>the summation is changed to 2. Converting from binary to decimal can be accomplished quickly in your
</p>
<p>head due to the fact that the bit values in the products are either 1 or 0. That means any bit that is a 0 has
</p>
<p>no impact on the outcome and any bit that is a 1 simply yields the weight of its position. Example 2.2
</p>
<p>shows the step-by-step process converting a binary number to decimal.
</p>
<p>Example 2.1
Converting decimal to decimal
</p>
<p>12 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.1.2 Octal to Decimal
</p>
<p>When converting from octal to decimal, the same process is followed with the exception that the
</p>
<p>base in the weight is changed to 8. Example 2.3 shows an example of converting an octal number to
</p>
<p>decimal.
</p>
<p>Example 2.2
Converting binary to decimal
</p>
<p>Example 2.3
Converting octal to decimal
</p>
<p>2.2 Base Conversion &bull; 13</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.1.3 Hexadecimal to Decimal
</p>
<p>Let&rsquo;s convert 1AB.EF16 to decimal. The same process is followed with the exception that the base is
</p>
<p>changed to 16. When performing the conversion, the decimal equivalent of the numerals A&ndash;F needs to
</p>
<p>be used. Example 2.4 shows the step-by-step process converting a hexadecimal number to decimal.
</p>
<p>In some cases, it is desired to specify a level of accuracy for the conversion in order to bound the
</p>
<p>number of fractional digits in the final result. For example, if the conversion in Example 2.4 was stated as
</p>
<p>&ldquo;convert 1AB.EF16 to decimal with a fractional accuracy of 2 digits,&rdquo; the final result would be 427.9310.
</p>
<p>How rounding is handled can also be specified with the two options being with or without rounding. In the
</p>
<p>case where the conversion is performed with rounding, additional fractional digits may need to be
</p>
<p>computed to determine if the least significant digit of the new decimal fraction needs to be altered. For
</p>
<p>example, let&rsquo;s say the conversion in Example 2.4 is stated as &ldquo;convert 1AB.EF16 to decimal with a
</p>
<p>fractional accuracy of 4 digits with rounding.&rdquo; In this case, the final result would be 427.933610. Notice
</p>
<p>how rounding was applied to the digit in position p &frac14; �3 changing it from a 5 to a 6 based on the value in
</p>
<p>position p &frac14; �4. Now let&rsquo;s say the conversion in Example 2.4 is stated as &ldquo;convert 1AB.EF16 to decimal
</p>
<p>with a fractional accuracy of 4 digits without rounding.&rdquo; In this case, the final result would be 427.933510.
</p>
<p>Notice how without rounding simply drops all of the digits beyond the specified level of accuracy.
</p>
<p>2.2.2 Converting from Decimal
</p>
<p>The process of converting from decimal to another base consists of two separate algorithms. There
</p>
<p>is one algorithm for converting the whole number portion of the number and another algorithm for
</p>
<p>converting the fractional portion of the number. The process for converting the whole number portion
</p>
<p>Example 2.4
Converting hexadecimal to decimal
</p>
<p>14 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>is to divide the decimal number by the base of the system you wish to convert to. The division will result in
</p>
<p>a quotient and a whole number remainder. The remainder is recorded as the least significant numeral in
</p>
<p>the converted number. The resulting quotient is then divided again by the base, which results in a new
</p>
<p>quotient and new remainder. The remainder is recorded as the next higher-order numeral in the new
</p>
<p>number. This process is repeated until a quotient of 0 is achieved. At that point the conversion is
</p>
<p>complete. The remainders will always be within the numeral set of the base being converted to.
</p>
<p>The process for converting the fractional portion is to multiply just the fractional component of the
</p>
<p>number by the base. This will result in a product that contains a whole number and a fraction. The whole
</p>
<p>number is recorded as themost significant digit of the new converted number. The new fractional portion
</p>
<p>is then multiplied again by the base with the whole number portion being recorded as the next lower-
</p>
<p>order numeral. This process is repeated until the product yields a fractional component equal to zero or
</p>
<p>the desired level of accuracy has been achieved. The level of accuracy is specified by the number of
</p>
<p>numerals in the new converted number. For example, the conversion would be stated as &ldquo;convert this
</p>
<p>decimal number to binary with a fractional accuracy of 4 bits.&rdquo; This means the final result would only have
</p>
<p>4 bits in the fraction. In cases where the conversion does not yield exactly 4 fractional bits, there are two
</p>
<p>approaches that can be used. The first is to have no rounding, which means the conversion simply stops
</p>
<p>at the desired accuracy. The second is to apply rounding, which means additional bits beyond the
</p>
<p>desired accuracy are computed in order to determine whether the least significant bit reported.
</p>
<p>2.2.2.1 Decimal to Binary
</p>
<p>Let&rsquo;s convert 11.37510 to binary. Example 2.5 shows the step-by-step process converting a decimal
</p>
<p>number to binary.
</p>
<p>2.2 Base Conversion &bull; 15</p>
<p/>
</div>
<div class="page"><p/>
<p>Many times when converting to binary, the number of fractional bits that result from the conversion is
</p>
<p>more than which is needed. In this case, rounding is applied to limit the fractional accuracy. The simplest
</p>
<p>rounding approach for binary numbers is to continue the conversion for one more bit beyond the desired
</p>
<p>fractional accuracy. If the next bit is a 0, then you leave the fractional component of the number as is. If the
</p>
<p>next bit is a 1, you round the least significant bit of your number up. Often this rounding will result in a
</p>
<p>cascade of roundings from the LSB to the MSB. As an example, let&rsquo;s say that the conversion in Example
</p>
<p>2.5 was specified to have a fractional accuracy of 2 bits. If the bit in position p&frac14;�3 was a 0 (which it is not,
</p>
<p>but let&rsquo;s just say it is for the sake of this example), then the number would be left as is, and the final
</p>
<p>converted number would be 1011.012. However, if the bit in position p &frac14; �3 was a 1 (as it actually is in
</p>
<p>Example 2.5), then we would need to apply rounding. We would start with the bit in position p&frac14;�2. Since
</p>
<p>it is a 1, we would round that up to a 0, but we would need to apply the overflow of this rounding to the
</p>
<p>next higher-order bit in position p &frac14; �1. That would then cause the value of p &frac14; �1 to go from a 0 to a
</p>
<p>1. The final result of the conversion with rounding would be 1011.102.
</p>
<p>Example 2.5
Converting decimal to binary
</p>
<p>16 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.2.2 Decimal to Octal
</p>
<p>Let&rsquo;s convert 10.410 to octal with an accuracy of 4 fractional digits. When converting the fractional
</p>
<p>component of the number, the algorithm is continued until 4 digits worth of fractional numerals have been
</p>
<p>achieved. Once the accuracy has been achieved, the conversion is finished even though a product with
</p>
<p>a zero fractional value has not been obtained. Example 2.6 shows the step-by-step process converting a
</p>
<p>decimal number to octal with a fractional accuracy of 4 digits.
</p>
<p>Rounding of octal digits uses a similar approach as when rounding decimal numbers, with the
</p>
<p>exception that the middle of the range of the numbers lies between digits 38 and 48. This means that any
</p>
<p>number to be rounded that is 48 or greater will be rounded up. Numbers that are 38 or less will be rounded
</p>
<p>down, which means the fractional component of the converted number is left as in.
</p>
<p>Example 2.6
Converting decimal to octal
</p>
<p>2.2 Base Conversion &bull; 17</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.2.3 Decimal to Hexadecimal
</p>
<p>Let&rsquo;s convert 254.65510 to hexadecimal with an accuracy of 3 fractional digits. When doing this
</p>
<p>conversion, all of the divisions and multiplications are done using decimal. If the results end up between
</p>
<p>1010 and 1510, then the decimal numbers are substituted with their hex symbol equivalent (i.e., A to F).
</p>
<p>Example 2.7 shows the step-by-step process of converting a decimal number to hex with a fractional
</p>
<p>accuracy of 3 digits.
</p>
<p>Rounding of hexadecimal digits uses a similar approach as when rounding decimal numbers, with
</p>
<p>the exception that the middle of the range of the numbers lies between digits 716 and 816. This means that
</p>
<p>any number to be rounded that is 816 or greater will be rounded up. Numbers that are 716 or less will be
</p>
<p>rounded down, which means the fractional component of the converted number is left as in.
</p>
<p>2.2.3 Converting Between 2n Bases
</p>
<p>Converting between 2n bases (e.g., 2, 4, 8, 16, etc.) takes advantage of the direct mapping that each
</p>
<p>of these bases has back to binary. Base 8 numbers take exactly 3 binary bits to represent all 8 symbols
</p>
<p>Example 2.7
Converting decimal to hexadecimal
</p>
<p>18 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>(i.e., 08 &frac14; 0002, 78 &frac14; 1112). Base 16 numbers take exactly 4 binary bits to represent all 16 symbols (i.e.,
</p>
<p>016 &frac14; 00002, F16 &frac14; 11112).
</p>
<p>When converting from binary to any other 2n base, the whole number bits are grouped into the
</p>
<p>appropriate-sized sets starting from the radix point and working left. If the final leftmost grouping does not
</p>
<p>have enough symbols, it is simply padded on left with leading 0&rsquo;s. Each of these groups is then directly
</p>
<p>substituted with their 2n base symbol. The fractional number bits are also grouped into the appropriate-
</p>
<p>sized sets starting from the radix point, but this time working right. Again, if the final rightmost grouping
</p>
<p>does not have enough symbols, it is simply padded on the right with trailing 0&rsquo;s. Each of these groups is
</p>
<p>then directly substituted with their 2n base symbol.
</p>
<p>2.2.3.1 Binary to Octal
</p>
<p>Example 2.8 shows the step-by-step process of converting a binary number to octal.
</p>
<p>2.2.3.2 Binary to Hexadecimal
</p>
<p>Example 2.9 shows the step-by-step process of converting a binary number to hexadecimal.
</p>
<p>Example 2.8
Converting binary to octal
</p>
<p>2.2 Base Conversion &bull; 19</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.3.3 Octal to Binary
</p>
<p>When converting to binary from any 2n base, each of the symbols in the originating number are
</p>
<p>replaced with the appropriate-sized number of bits. An octal symbol will be replaced with 3 binary bits,
</p>
<p>while a hexadecimal symbol will be replaced with 4 binary bits. Any leading or trailing 0&rsquo;s can be removed
</p>
<p>from the converted number once complete. Example 2.10 shows the step-by-step process of converting
</p>
<p>an octal number to binary.
</p>
<p>Example 2.9
Converting binary to hexadecimal
</p>
<p>Example 2.10
Converting octal to binary
</p>
<p>20 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.3.4 Hexadecimal to Binary
</p>
<p>Example 2.11 shows the step-by-step process of converting a hexadecimal number to binary.
</p>
<p>2.2.3.5 Octal to Hexadecimal
</p>
<p>When converting between 2n bases (excluding binary), the number is first converted into binary and
</p>
<p>then converted from binary into the final 2n base using the algorithms described before. Example 2.12
</p>
<p>shows the step-by-step process of converting an octal number to hexadecimal.
</p>
<p>Example 2.11
Converting hexadecimal to binary
</p>
<p>Example 2.12
Converting octal to hexadecimal
</p>
<p>2.2 Base Conversion &bull; 21</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.3.6 Hexadecimal to Octal
</p>
<p>Example 2.13 shows the step-by-step process of converting a hexadecimal number to octal.
</p>
<p>CONCEPT CHECK
</p>
<p>CC2.2 A &ldquo;googol&rdquo; is the term for the decimal number 1e100. When written out manually, this
number is a 1 with 100 zeros after it (e.g., 10,000,000,000,000,000,000,000,
000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,0-
00,000,000,000,000,000,000). This term is more commonly associated with the search
engine company Google, which uses a different spelling but is pronounced the same.
How many bits does it take to represent a googol in binary?
</p>
<p>A) 100 bits B) 256 bits C) 332 bits D) 333 bits
</p>
<p>2.3 Binary Arithmetic
</p>
<p>2.3.1 Addition (Carries)
</p>
<p>Binary addition is a straightforward process that mirrors the approach we have learned for longhand
</p>
<p>decimal addition. The two numbers (or terms) to be added are aligned at the radix point, and addition
</p>
<p>begins at the least significant bit. If the sum of the least significant position yields a value with 2 bits (e.g.,
</p>
<p>102), then the least significant bit is recorded, and the most significant bit is carried to the next higher
</p>
<p>position. The sum of the next higher position is then performed including the potential carry bit from the
</p>
<p>prior addition. This process continues from the least significant position to the most significant position.
</p>
<p>Example 2.14 shows how addition is performed on two individual bits.
</p>
<p>Example 2.13
Converting hexadecimal to octal
</p>
<p>22 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>When performing binary addition, the width of the inputs and output is fixed (i.e., n-bits). Carries that
</p>
<p>exist within the n-bits are treated in the normal fashion of including them in the next higher position sum;
</p>
<p>however, if the highest position summation produces a carry, this is a uniquely named event. This event
</p>
<p>is called a carry out or the sum is said to generate a carry. The reason this type of event is given special
</p>
<p>terminology is because in real circuitry, the number of bits of the inputs and output is fixed in hardware
</p>
<p>and the carry out is typically handled by a separate circuit. Example 2.15 shows this process when
</p>
<p>adding two 4-bit numbers.
</p>
<p>The largest decimal sum that can result from the addition of two binary numbers is given by 2�(2n
</p>
<p>�1). For example, two 8-bit numbers to be added could both represent their highest decimal value of (2n
</p>
<p>�1) or 25510 (i.e., 111111112). The sum of this number would result in 51010 or (1111111102). Notice that
</p>
<p>the largest sum achievable would only require one additional bit. This means that a single carry bit is
</p>
<p>sufficient to handle all possible magnitudes for binary addition.
</p>
<p>2.3.2 Subtraction (Borrows)
</p>
<p>Binary subtraction also mirrors longhand decimal subtraction. In subtraction, the formal terms for the
</p>
<p>two numbers being operated on are minuend and subtrahend. The subtrahend is subtracted from the
</p>
<p>minuend to find the difference. In longhand subtraction, the minuend is the top number and the
</p>
<p>subtrahend is the bottom number. For a given position, if the minuend is less than the subtrahend, it
</p>
<p>Example 2.14
Single-bit binary addition
</p>
<p>Example 2.15
Multiple-bit binary addition
</p>
<p>2.3 Binary Arithmetic &bull; 23</p>
<p/>
</div>
<div class="page"><p/>
<p>needs to borrow from the next higher-order position to produce a difference that is positive. If the next
</p>
<p>higher position does not have a value that can be borrowed from (i.e., 0), then it in turn needs to borrow
</p>
<p>from the next higher position, and so forth. Example 2.16 shows how subtraction is performed on two
</p>
<p>individual bits.
</p>
<p>As with binary addition, binary subtraction is accomplished on fixed widths of inputs and outputs
</p>
<p>(i.e., n-bits). The minuend and subtrahend are aligned at the radix point, and subtraction begins at the
</p>
<p>least significant bit position. Borrows are used as necessary as the subtractions move from the least
</p>
<p>significant position to the most significant position. If the most significant position requires a borrow, this
</p>
<p>is a uniquely named event. This event is called a borrow in or the subtraction is said to require a borrow.
</p>
<p>Again, the reason this event is uniquely named is because in real circuitry, the number of bits of the input
</p>
<p>and output is fixed in hardware and the borrow in is typically handled by a separate circuit. Example 2.17
</p>
<p>shows this process when subtracting two 4-bit numbers.
</p>
<p>Notice that if the minuend is less than the subtrahend, then the difference will be negative. At this
</p>
<p>point, we need a way to handle negative numbers.
</p>
<p>Example 2.16
Single-bit binary subtraction
</p>
<p>Example 2.17
Multiple-bit binary subtraction
</p>
<p>24 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC2.3 If an 8-bit computer system can only perform unsigned addition on 8-bit inputs and
produce an 8-bit sum, how is it possible for this computer to perform addition on
numbers that are larger than what can be represented with 8 bits (e.g.,
100010 + 100010 &frac14; 200010)?
</p>
<p>A) There are multiple 8-bit adders in a computer to handle large numbers.
</p>
<p>B) The result is simply rounded to the nearest 8-bit number.
</p>
<p>C) The computer returns an error and requires smaller numbers to be entered.
</p>
<p>D) The computer keeps track of the carry out and uses it in a subsequent 8-bit
addition, which enables larger numbers to be handled.
</p>
<p>2.4 Unsigned and Signed Numbers
</p>
<p>All of the number systems presented in the prior sections were positive. We need to also have a
</p>
<p>mechanism to indicate negative numbers. When looking at negative numbers, we only focus on the
</p>
<p>mapping between decimal and binary since octal and hexadecimal are used as just another representa-
</p>
<p>tion of a binary number. In decimal, we are able to use the negative sign in front of a number to indicate it
</p>
<p>is negative (e.g., �3410). In binary, this notation works fine for writing numbers on paper (e.g., �10102),
</p>
<p>but we need a mechanism that can be implemented using real circuitry. In a real digital circuit, the circuits
</p>
<p>can only deal with 0&rsquo;s and 1&rsquo;s. There is no &ldquo;�&ldquo; in a digital circuit. Since we only have 0&rsquo;s and 1&rsquo;s in the
</p>
<p>hardware, we use a bit to represent whether a number is positive or negative. This is referred to as the
</p>
<p>sign bit. If a binary number is not going to have any negative values, then it is called an unsigned
</p>
<p>number, and it can only represent positive numbers. If a binary number is going to allow negative
</p>
<p>numbers, it is called a signed number. It is important to always keep track of the type of number we
</p>
<p>are using as the same bit values can represent very different numbers depending on the coding
</p>
<p>mechanism that is being used.
</p>
<p>2.4.1 Unsigned Numbers
</p>
<p>An unsigned number is one that does not allow negative numbers. When talking about this type of
</p>
<p>code, the number of bits is fixed and stated up front. We use the variable n to represent the number of bits
</p>
<p>in the number. For example, if we had an 8-bit number, we would say, &ldquo;This is an 8-bit, unsigned number.&rdquo;
</p>
<p>The number of unique codes in an unsigned number is given by 2n. For example, if we had an 8-bit
</p>
<p>number, we would have 28 or 256 unique codes (e.g., 0000 00002 to 1111 11112).
</p>
<p>The range of an unsigned number refers to the decimal values that the binary code can represent. If
</p>
<p>we use the notationNunsigned to represent any possible value that an n-bit, unsigned number can take on,
</p>
<p>the range would be defined as 0 &lt; Nunsigned &lt; (2
n � 1).
</p>
<p>Range of an UNSIGNED number ) 0 � Nunsigned � 2
n � 1&eth; &THORN;
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 25</p>
<p/>
</div>
<div class="page"><p/>
<p>For example, if we had an unsigned number with n &frac14; 4, it could take on a range of values from +010
(00002) to +1510 (11112). Notice that while this number has 16 unique possible codes, the highest
</p>
<p>decimal value it can represent is 1510. This is because one of the unique codes represents 010. This is
</p>
<p>the reason that the highest decimal value that can be represented is given by (2n�1). Example 2.18
</p>
<p>shows this process for a 16-bit number.
</p>
<p>2.4.2 Signed Numbers
</p>
<p>Signed numbers are able to represent both positive and negative numbers. The most significant bit
</p>
<p>of these numbers is always the sign bit, which represents whether the number is positive or negative.
</p>
<p>The sign bit is defined to be a 0 if the number is positive and 1 if the number is negative. When using
</p>
<p>signed numbers, the number of bits is fixed so that the sign bit is always in the same position. There are a
</p>
<p>variety of ways to encode negative numbers using a sign bit. The encoding method used exclusively in
</p>
<p>modern computers is called two&rsquo;s complement. There are two other encoding techniques called signed
</p>
<p>magnitude and one&rsquo;s complement that are rarely used but are studied to motivate the power of two&rsquo;s
</p>
<p>complement. When talking about a signed number, the number of bits and the type of encoding are
</p>
<p>always stated. For example, we would say, &ldquo;This is an 8-bit, two&rsquo;s complement number.&rdquo;
</p>
<p>2.4.2.1 Signed Magnitude
</p>
<p>Signed magnitude is the simplest way to encode a negative number. In this approach, the most
</p>
<p>significant bit (i.e., leftmost bit) of the binary number is considered the sign bit (0&frac14; positive, 1&frac14; negative).
</p>
<p>The rest of the bits to the right of the sign bit represent the magnitude or absolute value of the number. As
</p>
<p>an example of this approach, let&rsquo;s look at the decimal values that a 4-bit, signed magnitude number can
</p>
<p>take on. These are shown in Example 2.19.
</p>
<p>Example 2.18
Finding the range of an unsigned number
</p>
<p>26 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>There are drawbacks of signed magnitude encoding that are apparent from this example. First, the
</p>
<p>value of 010 has two signed magnitude codes (00002 and 10002). This is an inefficient use of the
</p>
<p>available codes and leads to complexity when building arithmetic circuitry since it must account for
</p>
<p>two codes representing the same number.
</p>
<p>The second drawback is that addition using the negative numbers does not directly map to how
</p>
<p>decimal addition works. For example, in decimal if we added (�5) + (1), the result would be�4. In signed
</p>
<p>magnitude, adding these numbers using a traditional adder would produce (�5) + (1) &frac14; (�6). This is
</p>
<p>because the traditional addition would take place on the magnitude portion of the number. A 510 is
</p>
<p>represented with 1012. Adding 1 to this number would result in the next higher binary code 1102 or 610.
</p>
<p>Since the sign portion is separate, the addition is performed on |5|, thus yielding 6. Once the sign bit is
</p>
<p>included, the resulting number is �6. It is certainly possible to build an addition circuit that works on
</p>
<p>signed magnitude numbers, but it is more complex than a traditional adder because it must perform a
</p>
<p>different addition operation for the negative numbers versus the positive numbers. It is advantageous to
</p>
<p>have a single adder that works across the entire set of numbers.
</p>
<p>Due to the duplicate codes for 0, the range of decimal numbers that signedmagnitude can represent
</p>
<p>is reduced by 1 compared to unsigned encoding. For an n-bit number, there are 2n unique binary codes
</p>
<p>available, but only 2n�1 can be used to represent unique decimal numbers. If we use the notationNSM to
</p>
<p>represent any possible value that an n-bit, signed magnitude number can take on, the range would be
</p>
<p>defined as:
</p>
<p>Range of a SIGNED MAGNITUDE number )2 2n-1 2 1
� �
</p>
<p>� NSM � &thorn; 2
n-1
</p>
<p>2 1
� �
</p>
<p>Example 2.20 shows how to use this expression to find the range of decimal values that an 8-bit,
</p>
<p>signed magnitude code can represent.
</p>
<p>Example 2.19
Decimal values that a 4-bit, signed magnitude code can represent
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 27</p>
<p/>
</div>
<div class="page"><p/>
<p>The process to determine the decimal value from a signed magnitude binary code involves treating
</p>
<p>the sign bit separately from the rest of the code. The sign bit provides the polarity of the decimal number
</p>
<p>(0 &frac14; positive, 1 &frac14; negative). The remaining bits in the code are treated as unsigned numbers and
</p>
<p>converted to decimal using the standard conversion procedure described in the prior sections. This
</p>
<p>conversion yields the magnitude of the decimal number. The final decimal value is found by applying the
</p>
<p>sign. Example 2.21 shows an example of this process.
</p>
<p>Example 2.20
Finding the range of a signed magnitude number
</p>
<p>Example 2.21
Finding the decimal value of a signed magnitude number
</p>
<p>28 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.4.2.2 One&rsquo;s Complement
</p>
<p>One&rsquo;s complement is another simple way to encode negative numbers. In this approach, the
</p>
<p>negative number is obtained by taking its positive equivalent and flipping all of the 1&rsquo;s to 0&rsquo;s and 0&rsquo;s to
</p>
<p>1&rsquo;s. This procedure of flipping the bits is called a complement (notice the two e&rsquo;s). In this way, the most
</p>
<p>significant bit of the number is still the sign bit (0 &frac14; positive, 1 &frac14; negative). The rest of the bits represent
</p>
<p>the value of the number, but in this encoding scheme, the negative number values are less intuitive. As
</p>
<p>an example of this approach, let&rsquo;s look at the decimal values that a 4-bit, one&rsquo;s complement number can
</p>
<p>take on. These are shown in Example 2.22.
</p>
<p>Again, we notice that there are two different codes for 010 (00002 and 11112). This is a drawback of
</p>
<p>one&rsquo;s complement because it reduces the possible range of numbers that can be represented from 2n to
</p>
<p>(2n�1) and requires arithmetic operations that take into account the gap in the number system. There are
</p>
<p>advantages of one&rsquo;s complement, however. First, the numbers are ordered such that traditional addition
</p>
<p>works on both positive and negative numbers (excluding the double 0 gap). Taking the example of
</p>
<p>(�5) + (1) again, in one&rsquo;s complement the result yields �4, just as in a traditional decimal system. Notice
</p>
<p>in one&rsquo;s complement, �510 is represented with 10102. Adding 1 to this entire binary code would result in
</p>
<p>the next higher binary code 10112 or � 410 from the above table. This makes addition circuitry less
</p>
<p>complicated, but still not as simple as if the double 0 gap was eliminated. Another advantage of one&rsquo;s
</p>
<p>complement is that as the numbers are incremented beyond the largest value in the set, they roll over
</p>
<p>and start counting at the lowest number. For example, if you increment the number 01112 (710), it goes to
</p>
<p>the next higher binary code 10002, which is �710. The ability to have the numbers roll over is a useful
</p>
<p>feature for computer systems.
</p>
<p>If we use the notation N1comp to represent any possible value that an n-bit, one&rsquo;s complement
</p>
<p>number can take on, the range is defined as:
</p>
<p>Range of a ONE&rsquo;S COMPLEMENT number ) 2 2n-1 2 1
� �
</p>
<p>� N1&lsquo;s comp � &thorn; 2
n-1
</p>
<p>2 1
� �
</p>
<p>Example 2.22
Decimal values that a 4-bit, one&rsquo;s complement code can represent
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 29</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 2.23 shows how to use this expression to find the range of decimal values that a 24-bit,
</p>
<p>one&rsquo;s complement code can represent.
</p>
<p>The process of finding the decimal value of a one&rsquo;s complement number involves first identifying
</p>
<p>whether the number is positive or negative by looking at the sign bit. If the number is positive (i.e., the
</p>
<p>sign bit is 0), then the number is treated as an unsigned code and is converted to decimal using the
</p>
<p>standard conversion procedure described in prior sections. If the number is negative (i.e., the sign bit is
</p>
<p>1), then the number sign is recorded separately, and the code is complemented in order to convert it to its
</p>
<p>positive magnitude equivalent. This new positive number is then converted to decimal using the standard
</p>
<p>conversion procedure. As the final step, the sign is applied. Example 2.24 shows an example of this
</p>
<p>process.
</p>
<p>Example 2.23
Finding the range of a 1&rsquo;s complement number
</p>
<p>Example 2.24
Finding the decimal value of a 1&rsquo;s complement number
</p>
<p>30 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.4.2.3 Two&rsquo;s Complement
</p>
<p>Two&rsquo;s complement is an encoding scheme that addresses the double 0 issue in signed magnitude
</p>
<p>and 1&rsquo;s complement representations. In this approach, the negative number is obtained by subtracting its
</p>
<p>positive equivalent from 2n. This is identical to performing a complement on the positive equivalent and
</p>
<p>then adding one. If a carry is generated, it is discarded. This procedure is called taking the two&rsquo;s
</p>
<p>complement of a number. The procedure of complementing each bit and adding one is the most common
</p>
<p>technique to perform a two&rsquo;s complement. In this way, the most significant bit of the number is still the
</p>
<p>sign bit (0 &frac14; positive, 1 &frac14; negative), but all of the negative numbers are in essence shifted up so that the
</p>
<p>double 0 gap is eliminated. Taking the two&rsquo;s complement of a positive number will give its negative
</p>
<p>counterpart and vice versa. Let&rsquo;s look at the decimal values that a 4-bit, two&rsquo;s complement number can
</p>
<p>take on. These are shown in Example 2.25.
</p>
<p>There are many advantages of two&rsquo;s complement encoding. First, there is no double 0 gap, which
</p>
<p>means that all possible 2n unique codes that can exist in an n-bit number are used. This gives the largest
</p>
<p>possible range of numbers that can be represented. Another advantage of two&rsquo;s complement is that
</p>
<p>addition with negative numbers works exactly the same as decimal. In our example of (�5) + (1), the
</p>
<p>result is (�4). Arithmetic circuitry can be built to mimic the way our decimal arithmetic works without the
</p>
<p>need to consider the double 0 gap. Finally, the roll over characteristic is preserved from one&rsquo;s comple-
</p>
<p>ment. Incrementing +7 by +1 will result in �8.
</p>
<p>If we use the notation N2comp to represent any possible value that an n-bit, two&rsquo;s complement
</p>
<p>number can take on, the range is defined as:
</p>
<p>Range of a TWO&rsquo;S COMPLEMENT number ) 2 2n-1
� �
</p>
<p>� N2&rsquo;s comp � &thorn; 2
n-1
</p>
<p>2 1
� �
</p>
<p>Example 2.26 shows how to use this expression to find the range of decimal values that a 32-bit,
</p>
<p>two&rsquo;s complement code can represent.
</p>
<p>Example 2.25
Decimal values that a 4-bit, two&rsquo;s complement code can represent
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 31</p>
<p/>
</div>
<div class="page"><p/>
<p>The process of finding the decimal value of a two&rsquo;s complement number involves first identifying
</p>
<p>whether the number is positive or negative by looking at the sign bit. If the number is positive (i.e., the
</p>
<p>sign bit is 0), then the number is treated as an unsigned code and is converted to decimal using the
</p>
<p>standard conversion procedure described in prior sections. If the number is negative (i.e., the sign bit is
</p>
<p>1), then the number sign is recorded separately, and a two&rsquo;s complement is performed on the code in
</p>
<p>order to convert it to its positive magnitude equivalent. This new positive number is then converted to
</p>
<p>decimal using the standard conversion procedure. The final step is to apply the sign. Example 2.27
</p>
<p>shows an example of this process.
</p>
<p>Example 2.26
Finding the range of a two&rsquo;s complement number
</p>
<p>Example 2.27
Finding the decimal value of a two&rsquo;s complement number
</p>
<p>32 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>To convert a decimal number into its two&rsquo;s complement code, the range is first checked to determine
</p>
<p>whether the number can be represented with the allocated number of bits. The next step is to convert the
</p>
<p>decimal number into unsigned binary. The final step is to apply the sign bit. If the original decimal number
</p>
<p>was positive, then the conversion is complete. If the original decimal number was negative, then the
</p>
<p>two&rsquo;s complement is taken on the unsigned binary code to find its negative equivalent. Example 2.28
</p>
<p>shows this procedure when converting �9910 to its 8-bit, two&rsquo;s complement code.
</p>
<p>Example 2.28
Finding the two&rsquo;s complement code of a decimal number
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 33</p>
<p/>
</div>
<div class="page"><p/>
<p>2.4.2.4 Arithmetic with Two&rsquo;s Complement
</p>
<p>Two&rsquo;s complement has a variety of arithmetic advantages. First, the operations of addition, subtrac-
</p>
<p>tion, and multiplication are handled exactly the same as when using unsigned numbers. This means that
</p>
<p>duplicate circuitry is not needed in a system that uses both number types. Second, the ability to convert a
</p>
<p>number from positive to its negative representation by performing a two&rsquo;s complement means that an
</p>
<p>adder circuit can be used for subtraction. For example, if we wanted to perform the subtraction 1310 &ndash;
</p>
<p>410 &frac14; 910, this is the same as performing 1310 + (�410) &frac14; 910. This allows us to use a single adder circuit
</p>
<p>to perform both addition and subtraction as long as we have the ability to take the two&rsquo;s complement of a
</p>
<p>number. Creating a circuit to perform two&rsquo;s complement can be simpler and faster than building a
</p>
<p>separate subtraction circuit, so this approach can sometimes be advantageous.
</p>
<p>There are specific rules for performing two&rsquo;s complement arithmetic that must be followed to ensure
</p>
<p>proper results. First, any carry or borrow that is generated is ignored. The second rule that must be
</p>
<p>followed is to always check if two&rsquo;s complement overflow occurred. Two&rsquo;s complement overflow refers
</p>
<p>to when the result of the operation falls outside of the range of values that can be represented by the
</p>
<p>number of bits being used. For example, if you are performing 8-bit, two&rsquo;s complement addition, the
</p>
<p>range of decimal values that can be represented is �12810 to +12710. Having two input terms of 12710
(0111 11112) is perfectly legal because they can be represented by the 8 bits of the two&rsquo;s complement
</p>
<p>number; however, the summation of 12710 + 12710 &frac14; 25410 (111111102). This number does not fit within
</p>
<p>the range of values that can be represented and is actually the two&rsquo;s complement code for�210, which is
</p>
<p>obviously incorrect. Two&rsquo;s complement overflow occurs if any of the following occurs:
</p>
<p>&bull; The sum of like signs results in an answer with opposite sign
(i.e., positive + positive &frac14; negative or negative + negative &frac14; positive).
</p>
<p>&bull; The subtraction of a positive number from a negative number results in a positive number
(i.e., negative &ndash; positive &frac14; positive).
</p>
<p>&bull; The subtraction of a negative number from a positive number results in a negative number
(i.e., positive &ndash; negative &frac14; negative).
</p>
<p>Computer systems that use two&rsquo;s complement have a dedicated logic circuit that monitors for any of
</p>
<p>these situations and lets the operator know that overflow has occurred. These circuits are straightforward
</p>
<p>since they simply monitor the sign bits of the input and output codes. Example 2.29 shows how to use
</p>
<p>two&rsquo;s complement in order to perform subtraction using an addition operation.
</p>
<p>34 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC2.4 A 4-bit, two&rsquo;s complement number has 16 unique codes and can represent decimal
numbers between �810 and +710. If the number of unique codes is even, why is it that
the range of integers it can represent is not symmetrical about zero?
</p>
<p>A) One of the positive codes is used to represent zero. This prevents the highest
positive number from reaching +810 and being symmetrical.
</p>
<p>B) It is asymmetrical because the system allows the numbers to roll over.
</p>
<p>C) It isn&rsquo;t asymmetrical if zero is considered a positive integer. That way there are
eight positive numbers and eight negatives numbers.
</p>
<p>D) It is asymmetrical because there are duplicate codes for 0.
</p>
<p>Example 2.29
Two&rsquo;s complement addition
</p>
<p>2.4 Unsigned and Signed Numbers &bull; 35</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v The base, or radix, of a number system refers
to the number of unique symbols within its
set. The definition of a number system
includes both the symbols used and the rela-
tive values of each symbol within the set.
</p>
<p>v Themost common number systems are base
10 (decimal), base 2 (binary), and base
16 (hexadecimal). Base 10 is used because
it is how the human brain has been trained to
treat numbers. Base 2 is used because the
two values are easily represented using elec-
trical switches. Base 16 is a convenient way
to describe large groups of bits.
</p>
<p>v A positional number system allows larger
(or smaller) numbers to be represented
beyond the values within the original symbol
set. This is accomplished by having each
position within a number have a different
weight.
</p>
<p>v There are specific algorithms that are used to
convert any base to or from decimal. There
are also algorithms to convert between num-
ber systems that contain a power-of-two
symbols (e.g., binary to hexadecimal and
hexadecimal to binary).
</p>
<p>v Binary arithmetic is performed on a fixed
width of bits (n). When an n-bit addition
results in a sum that cannot fit within n-bits,
it generates a carry out bit. In an n-bit sub-
traction, if the minuend is smaller than the
subtrahend, a borrow in can be used to com-
plete the operation.
</p>
<p>v Binary codes can represent both unsigned
and signed numbers. For an arbitrary n-bit
binary code, it is important to know the
encoding technique and the range of values
that can be represented.
</p>
<p>v Signed numbers use the most significant
position to represent whether the number is
negative (0 &frac14; positive, 1 &frac14; negative). The
width of a signed number is always fixed.
</p>
<p>v Two&rsquo;s complement is the most common
encoding technique for signed numbers. It
has an advantage that there are no duplicate
codes for zero and that the encoding
approach provides a monotonic progression
of codes from the most negative number that
can be represented to the most positive. This
allows addition and subtraction to work the
same on two&rsquo;s complement numbers as it
does on unsigned numbers.
</p>
<p>v When performing arithmetic using two&rsquo;s com-
plement codes, the carry bit is ignored.
</p>
<p>v When performing arithmetic using two&rsquo;s com-
plement codes, if the result lies outside of the
range that can be represented, it is called
two&rsquo;s complement overflow. Two&rsquo;s comple-
ment overflow can be determined by looking
at the sign bits of the input arguments and the
sign bit of the result.
</p>
<p>Exercise Problems
</p>
<p>Section 2.1: Positional Number Systems
</p>
<p>2.1.1 What is the radix of the binary number system?
</p>
<p>2.1.2 What is the radix of the decimal number
system?
</p>
<p>2.1.3 What is the radix of the hexadecimal number
system?
</p>
<p>2.1.4 What is the radix of the octal number system?
</p>
<p>2.1.5 What is the radix of a number systemwith base
3?
</p>
<p>2.1.6 For the number 261.367, what position (p) is
the number 2 in?
</p>
<p>2.1.7 For the number 261.367, what position (p) is
the number leftmost 6 in?
</p>
<p>2.1.8 For the number 261.367, what position (p) is
the number 1 in?
</p>
<p>2.1.9 For the number 261.367, what position (p) is
the number 3 in?
</p>
<p>2.1.10 For the number 261.367, what position (p) is
the number rightmost 6 in?
</p>
<p>2.1.11 For the number 261.367, what position (p) is
the number 7 in?
</p>
<p>2.1.12 What is the name of the number system
containing 102?
</p>
<p>2.1.13 What is the name of the number system
containing 1010?
</p>
<p>2.1.14 What is the name of the number system
containing 1016?
</p>
<p>2.1.15 What is the name of the number system
containing 108?
</p>
<p>2.1.16 Which of the four number systems covered in
this chapter (i.e., binary, decimal, hexadecimal,
and octal) could the number 22 be part of?
Give all that are possible.
</p>
<p>2.1.17 Which of the four number systems covered in
this chapter (i.e., binary, decimal, hexadecimal,
</p>
<p>36 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>and octal) could the number 99 be part of?
Give all that are possible.
</p>
<p>2.1.18 Which of the four number systems covered in
this chapter (i.e., binary, decimal, hexadecimal,
and octal) could the number 1F be part of?
Give all that are possible.
</p>
<p>2.1.19 Which of the four number systems covered in
this chapter (i.e., binary, decimal, hexadecimal,
and octal) could the number 88 be part of?
Give all that are possible.
</p>
<p>2.1.20 Which symbols could be used in all of the four
number systems covered in this chapter (i.e.,
binary, decimal, hexadecimal, and octal)?
</p>
<p>2.1.21 What is the only symbol that could be used in
every number system from base 1 to base 1?
</p>
<p>Section 2.2: Base Conversions
</p>
<p>2.2.1 If the number 101.111 has a radix of 2, what is
the weight of the position containing the left-
most 1?
</p>
<p>2.2.2 If the number 101.111 has a radix of 2, what is
the weight of the position containing the bit 0?
</p>
<p>2.2.3 If the number 101.111 has a radix of 2, what is
the weight of the position containing the
1 immediately to the left of the radix point?
</p>
<p>2.2.4 If the number 101.111 has a radix of 2, what is
the weight of the position containing the
1 immediately to the right of the radix point?
</p>
<p>2.2.5 If the number 101.111 has a radix of 2, what is
the weight of the position containing the 1 that
second to the right of the radix point?
</p>
<p>2.2.6 If the number 101.111 has a radix of 2, what is
the weight of the position containing the right-
most 1?
</p>
<p>2.2.7 If the number 261.367 has a radix of 10, what is
the weight of the position containing the
numeral 2?
</p>
<p>2.2.8 If the number 261.367 has a radix of 10, what is
the weight of the position containing the left-
most 6?
</p>
<p>2.2.9 If the number 261.367 has a radix of 10, what is
the weight of the position containing the
numeral 1?
</p>
<p>2.2.10 If the number 261.367 has a radix of 10, what is
the weight of the position containing the
numeral 3?
</p>
<p>2.2.11 If the number 261.367 has a radix of 10, what is
the weight of the position containing the right-
most 6?
</p>
<p>2.2.12 If the number 261.367 has a radix of 10, what is
the weight of the position containing the
numeral 7?
</p>
<p>2.2.13 If the number 261.367 has a radix of 16, what is
the weight of the position containing the
numeral 2?
</p>
<p>2.2.14 If the number 261.367 has a radix of 16, what is
the weight of the position containing the left-
most 6?
</p>
<p>2.2.15 If the number 261.367 has a radix of 16, what is
the weight of the position containing the
numeral 1?
</p>
<p>2.2.16 If the number 261.367 has a radix of 16, what is
the weight of the position containing the
numeral 3?
</p>
<p>2.2.17 If the number 261.367 has a radix of 16, what is
the weight of the position containing the right-
most 6?
</p>
<p>2.2.18 If the number 261.367 has a radix of 16, what is
the weight of the position containing the
numeral 7?
</p>
<p>2.2.19 If the number 261.367 has a radix of 8, what is
the weight of the position containing the
numeral 2?
</p>
<p>2.2.20 If the number 261.367 has a radix of 8, what is
the weight of the position containing the left-
most 6?
</p>
<p>2.2.21 If the number 261.367 has a radix of 8, what is
the weight of the position containing the
numeral 1?
</p>
<p>2.2.22 If the number 261.367 has a radix of 8, what is
the weight of the position containing the
numeral 3?
</p>
<p>2.2.23 If the number 261.367 has a radix of 8, what is
the weight of the position containing the right-
most 6?
</p>
<p>2.2.24 If the number 261.367 has a radix of 8, what is
the weight of the position containing the
numeral 7?
</p>
<p>2.2.25 Convert 11 11112 to decimal. Treat all numbers
as unsigned.
</p>
<p>2.2.26 Convert 10 10012 to decimal. Treat all numbers
as unsigned.
</p>
<p>2.2.27 Convert 1100 11002 to decimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.28 Convert 1001 10012 to decimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.29 Convert 0.11112 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.30 Convert 0.11112 to decimal with a fractional
accuracy of 2 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.31 Convert 0.11112 to decimal with a fractional
accuracy of 2 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.32 Convert 11.012 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.33 Convert 11.012 to decimal with a fractional
accuracy of 1 digit without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.34 Convert 11.012 to decimal with a fractional
accuracy of 1 digit with rounding. Treat all num-
bers as unsigned.
</p>
<p>Exercise Problems &bull; 37</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.35 Convert 1001.10012 to decimal. Provide the
full answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.36 Convert 1001.10012 to decimal with a frac-
tional accuracy of 3 digits without rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.37 Convert 1001.10012 to decimal with a frac-
tional accuracy of 3 digits with rounding. Treat
all numbers as unsigned.
</p>
<p>2.2.38 Convert 1100.11012 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.39 Convert 1100.11012 to decimal with a fractional
accuracy of 3 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.40 Convert 1100.11012 to decimal with a fractional
accuracy of 3 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.41 Convert 728 to decimal. Treat all numbers as
unsigned.
</p>
<p>2.2.42 Convert 7778 to decimal. Treat all numbers as
unsigned.
</p>
<p>2.2.43 Convert 1238 to decimal. Treat all numbers as
unsigned.
</p>
<p>2.2.44 Convert 76548 to decimal. Treat all numbers as
unsigned
</p>
<p>2.2.45 Convert 0.7778 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.46 Convert 0.7778 to decimal with a fractional
accuracy of 2 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.47 Convert 0.7778 to decimal with a fractional
accuracy of 2 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.48 Convert 12.578 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.49 Convert 12.578 to decimal with a fractional
accuracy of 4 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.50 Convert 12.578 to decimal with a fractional
accuracy of 4 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.51 Convert 123.1238 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.52 Convert 123.1238 to decimal with a fractional
accuracy of 1 digit without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.53 Convert 123.1238 to decimal with a fractional
accuracy of 1 digit with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.54 Convert 7654.76548 to decimal. Provide the
full answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.55 Convert 7654.76548 to decimal with a frac-
tional accuracy of 4 digits without rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.56 Convert 7654.76548 to decimal with a frac-
tional accuracy of 4 digits with rounding. Treat
all numbers as unsigned.
</p>
<p>2.2.57 Convert F316 to decimal. Treat all numbers as
unsigned.
</p>
<p>2.2.58 Convert FFF16 to decimal. Treat all numbers as
unsigned.
</p>
<p>2.2.59 Convert FACE16 to decimal. Treat all numbers
as unsigned.
</p>
<p>2.2.60 Convert BEEF FEED16 to decimal. Treat all
numbers as unsigned.
</p>
<p>2.2.61 Convert 0.FF16 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.62 Convert 0.FF16 to decimal with a fractional
accuracy of 4 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.63 Convert 0.FF16 to decimal with a fractional
accuracy of 4 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.64 Convert EE.0F16 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.65 Convert EE.0F 16 to decimal with a fractional
accuracy of 4 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.66 Convert EE.0F 16 to decimal with a fractional
accuracy of 4 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.67 Convert 15B.CEF16 to decimal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.68 Convert 15B.CEF16 to decimal with a fractional
accuracy of 2 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.69 Convert 15B.CEF16 to decimal with a fractional
accuracy of 2 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.70 Convert 1ACE.E1F16 to decimal. Provide the
full answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.71 Convert 1ACE.E1F16 to decimal with a frac-
tional accuracy of 4 digits without rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.72 Convert 1ACE.E1F16 to decimal with a frac-
tional accuracy of 4 digits with rounding. Treat
all numbers as unsigned.
</p>
<p>2.2.73 Convert 6710 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.74 Convert 10010 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.75 Convert 99910 to binary. Treat all numbers as
unsigned.
</p>
<p>38 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.76 Convert 111110 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.77 Convert 0.87510 to binary. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.78 Convert 0.87510 to binary with a fractional
accuracy of 2 bits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.79 Convert 0.87510 to binary with a fractional
accuracy of 2 bits with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.80 Convert 1.437510 to binary. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.81 Convert 1.437510 to binary with a fractional
accuracy of 3 bits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.82 Convert 1.437510 to binary with a fractional
accuracy of 3 bits with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.83 Convert 31.6562510 to binary. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.84 Convert 31.6562510 to binary with a fractional
accuracy of 3 bits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.85 Convert 31.6562510 to binary with a fractional
accuracy of 3 bits with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.86 Convert 252.98710 to binary. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.87 Convert 252.98710 to binary with a fractional
accuracy of 4 bits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.88 Convert 252.98710 to binary with a fractional
accuracy of 4 bits with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.89 Convert 6710 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.90 Convert 10110 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.91 Convert 77710 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.92 Convert 765410 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.93 Convert 0.1875 10 to octal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.94 Convert 0.187510 to octal with a fractional
accuracy of 1 digit without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.95 Convert 0.187510 to octal with a fractional
accuracy of 1 digit with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.96 Convert 4.562510 to octal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.97 Convert 4.562510 to octal with a fractional
accuracy of 1 digit without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.98 Convert 4.562510 to octal with a fractional
accuracy of 1 digit with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.99 Convert 77.1562510 to octal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.100 Convert 77.1562510 to octal with a fractional
accuracy of 1 digit without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.101 Convert 77.1562510 to octal with a fractional
accuracy of 1 digit with rounding. Treat all num-
bers as unsigned.
</p>
<p>2.2.102 Convert 22.289062510 to octal. Provide the full
answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.103 Convert 22.289062510 to octal with a fractional
accuracy of 2 digits without rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.104 Convert 22.289062510 to octal with a fractional
accuracy of 2 digits with rounding. Treat all
numbers as unsigned.
</p>
<p>2.2.105 Convert 6710 to hexadecimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.106 Convert 10010 to hexadecimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.107 Convert 99910 to hexadecimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.108 Convert 678910 to hexadecimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.109 Convert 0.10937510 to hexadecimal. Provide
the full answer without limiting its accuracy or
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.110 Convert 0.10937510 to hexadecimal with a
fractional accuracy of 1 digit without rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.111 Convert 0.10937510 to hexadecimal with a
fractional accuracy of 1 digit with rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.112 Convert 10.664062510 to hexadecimal. Pro-
vide the full answer without limiting its accuracy
or rounding. Treat all numbers as unsigned.
</p>
<p>2.2.113 Convert 10.664062510 to hexadecimal with a
fractional accuracy of 1 digit without rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.114 Convert 10.664062510 to hexadecimal with a
fractional accuracy of 1 digit with rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.115 Convert 186.6679687510 to hexadecimal. Pro-
vide the full answer without limiting its accuracy
or rounding. Treat all numbers as unsigned.
</p>
<p>2.2.116 Convert 186.6679687510 to hexadecimal with
a fractional accuracy of 2 digits without
rounding. Treat all numbers as unsigned.
</p>
<p>Exercise Problems &bull; 39</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2.117 Convert 186.6679687510 to hexadecimal with
a fractional accuracy of 2 digits with rounding.
Treat all numbers as unsigned.
</p>
<p>2.2.118 Convert 57005.7456054687510 to hexadeci-
mal. Provide the full answer without limiting its
accuracy or rounding. Treat all numbers as
unsigned.
</p>
<p>2.2.119 Convert 57005.7456054687510 to hexadeci-
mal with a fractional accuracy of 2 digits with-
out rounding. Treat all numbers as unsigned.
</p>
<p>2.2.120 Convert 57005.7456054687510 to hexadeci-
mal with a fractional accuracy of 2 digits with
rounding. Treat all numbers as unsigned.
</p>
<p>2.2.121 Convert 11 11102 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.122 Convert 10 1010.012 to octal. Treat all num-
bers as unsigned.
</p>
<p>2.2.123 Convert 1010 1010.01012 to octal. Treat all
numbers as unsigned.
</p>
<p>2.2.124 Convert 1 0000 11112 to octal. Treat all num-
bers as unsigned.
</p>
<p>2.2.125 Convert 11 11102 to hexadecimal. Treat all
numbers as unsigned.
</p>
<p>2.2.126 Convert 10 1010.012 to hexadecimal. Treat all
numbers as unsigned.
</p>
<p>2.2.127 Convert 1010 1010.01012 to hexadecimal.
Treat all numbers as unsigned.
</p>
<p>2.2.128 Convert 1 0000 1111.0112 to hexadecimal.
Treat all numbers as unsigned.
</p>
<p>2.2.129 Convert 778 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.130 Convert 77.78 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.131 Convert 123.48 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.132 Convert 261.3678 to binary. Treat all numbers
as unsigned.
</p>
<p>2.2.133 Convert AB16 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.134 Convert F.A16 to binary. Treat all numbers as
unsigned.
</p>
<p>2.2.135 Convert AB.CD16 to binary. Treat all numbers
as unsigned.
</p>
<p>2.2.136 Convert 261.36716 to binary. Treat all numbers
as unsigned.
</p>
<p>2.2.137 Convert 668 to hexadecimal. Treat all numbers
as unsigned.
</p>
<p>2.2.138 Convert 66.78 to hexadecimal. Treat all num-
bers as unsigned.
</p>
<p>2.2.139 Convert 261.3678 to hexadecimal. Treat all
numbers as unsigned.
</p>
<p>2.2.140 Convert 1234.56788 to hexadecimal. Treat all
numbers as unsigned.
</p>
<p>2.2.141 Convert AB16 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.142 Convert AB.D16 to octal. Treat all numbers as
unsigned.
</p>
<p>2.2.143 Convert ABC.DE16 to octal. Treat all numbers
as unsigned.
</p>
<p>2.2.144 Convert BABE.FACE16 to octal. Treat all num-
bers as unsigned.
</p>
<p>Section 2.3: Binary Arithmetic
</p>
<p>2.3.1 Compute 112 + 012 by hand. Treat all numbers
as unsigned. Provide the 2-bit sum, and indi-
cate whether a carry out occurred.
</p>
<p>2.3.2 Compute 10102 + 10112 by hand. Treat all
numbers as unsigned. Provide the 4-bit sum,
and indicate whether a carry out occurred.
</p>
<p>2.3.3 Compute 1111 11112 + 0000 00012 by hand.
Treat all numbers as unsigned. Provide the
8-bit sum, and indicate whether a carry out
occurred.
</p>
<p>2.3.4 Compute 1010.10102 + 1011.10112 by hand.
Treat all numbers as unsigned. Provide the
8-bit sum, and indicate whether a carry out
occurred.
</p>
<p>2.3.5 Compute 1111 1111.10112 + 0000 0001.11002
by hand. Treat all numbers as unsigned. Pro-
vide the 12-bit sum, and indicate whether a
carry out occurred.
</p>
<p>2.3.6 Compute 102 � 012 by hand. Treat all numbers
as unsigned. Provide the 2-bit difference, and
indicate whether a borrow in occurred.
</p>
<p>2.3.7 Compute 10102 � 10112 by hand. Treat all
numbers as unsigned. Provide the 4-bit differ-
ence, and indicate whether a borrow in
occurred.
</p>
<p>2.3.8 Compute 1111 11112 � 0000 00012 by hand.
Treat all numbers as unsigned. Provide the
8-bit difference, and indicate whether a borrow
in occurred.
</p>
<p>2.3.9 Compute 1010.10102 � 1011.10112 by hand.
Treat all numbers as unsigned. Provide the
8-bit difference, and indicate whether a borrow
in occurred.
</p>
<p>2.3.10 Compute 1111 1111.10112 � 0000 0001.11002
by hand. Treat all numbers as unsigned. Pro-
vide the 12-bit difference, and indicate whether
a borrow in occurred.
</p>
<p>Section 2.4: Unsigned and Signed Numbers
</p>
<p>2.4.1 What range of decimal numbers can be
represented by 8-bit, two&rsquo;s complement
numbers?
</p>
<p>2.4.2 What range of decimal numbers can be
represented by 16-bit, two&rsquo;s complement
numbers?
</p>
<p>2.4.3 What range of decimal numbers can be
represented by 32-bit, two&rsquo;s complement
numbers?
</p>
<p>40 &bull; Chapter 2: Number Systems</p>
<p/>
</div>
<div class="page"><p/>
<p>2.4.4 What range of decimal numbers can be
represented by 64-bit, two&rsquo;s complement
numbers?
</p>
<p>2.4.5 What is the 8-bit, two&rsquo;s complement code for
+8810?
</p>
<p>2.4.6 What is the 8-bit, two&rsquo;s complement code for
�8810?
</p>
<p>2.4.7 What is the 8-bit, two&rsquo;s complement code for
�12810?
</p>
<p>2.4.8 What is the 8-bit, two&rsquo;s complement code for
�110?
</p>
<p>2.4.9 What is the decimal value of the 4-bit, two&rsquo;s
complement code 00102?
</p>
<p>2.4.10 What is the decimal value of the 4-bit, two&rsquo;s
complement code 10102?
</p>
<p>2.4.11 What is the decimal value of the 8-bit, two&rsquo;s
complement code 0111 11102?
</p>
<p>2.4.12 What is the decimal value of the 8-bit, two&rsquo;s
complement code 1111 11102?
</p>
<p>2.4.13 Compute 11102 + 10112 by hand. Treat all
numbers as 4-bit, two&rsquo;s complement codes.
Provide the 4-bit sum and indicate whether
two&rsquo;s complement overflow occurred.
</p>
<p>2.4.14 Compute 1101 11112 + 0000 00012 by hand.
Treat all numbers as 8-bit, two&rsquo;s complement
codes. Provide the 8-bit sum, and indicate
whether two&rsquo;s complement overflow occurred.
</p>
<p>2.4.15 Compute 1010.10102 + 1000.10112 by hand.
Treat all numbers as 8-bit, two&rsquo;s complement
codes. Provide the 8-bit sum, and indicate
whether two&rsquo;s complement overflow occurred.
</p>
<p>2.4.16 Compute 1110 1011.10012 + 0010 0001.11012
by hand. Treat all numbers as 12-bit, two&rsquo;s
complement codes. Provide the 12-bit sum,
and indicate whether two&rsquo;s complement over-
flow occurred.
</p>
<p>2.4.17 Compute 410 � 510 using 4-bit two&rsquo;s comple-
ment addition. You will need to first convert
each number into its 4-bit two&rsquo;s complement
code and then perform binary addition (i.e.,
410 + (�510)). Provide the 4-bit result, and
</p>
<p>indicate whether two&rsquo;s complement overflow
occurred. Check your work by converting the
4-bit result back to decimal.
</p>
<p>2.4.18 Compute 710 � 710 using 4-bit two&rsquo;s comple-
ment addition. You will need to first convert
each decimal number into its 4-bit two&rsquo;s com-
plement code and then perform binary addition
(i.e., 710 + (�710)). Provide the 4-bit result, and
indicate whether two&rsquo;s complement overflow
occurred. Check your work by converting the
4-bit result back to decimal.
</p>
<p>2.4.19 Compute 710 + 110 using 4-bit two&rsquo;s comple-
ment addition. You will need to first convert
each decimal number into its 4-bit two&rsquo;s com-
plement code and then perform binary addi-
tion. Provide the 4-bit result, and indicate
whether two&rsquo;s complement overflow occurred.
Check your work by converting the 4-bit result
back to decimal.
</p>
<p>2.4.20 Compute 6410&ndash;10010 using 8-bit two&rsquo;s comple-
ment addition. You will need to first convert
each number into its 8-bit two&rsquo;s complement
code and then perform binary addition (i.e,
6410 + (�10010)). Provide the 8-bit result and
indicate whether two&rsquo;s complement overflow
occurred. Check your work by converting the
8-bit result back to decimal.
</p>
<p>2.4.21 Compute (�99)10� 1110 using 8-bit two&rsquo;s com-
plement addition. You will need to first convert
each decimal number into its 8-bit two&rsquo;s com-
plement code and then perform binary addition
(i.e., (�9910) + (�1110)). Provide the 8-bit
result, and indicate whether two&rsquo;s complement
overflow occurred. Check your work by
converting the 8-bit result back to decimal.
</p>
<p>2.4.22 Compute 5010 + 10010 using 8-bit two&rsquo;s com-
plement addition. You will need to first convert
each decimal number into its 8-bit two&rsquo;s com-
plement code and then perform binary addi-
tion. Provide the 8-bit result, and indicate
whether two&rsquo;s complement overflow occurred.
Check your work by converting the 8-bit result
back to decimal.
</p>
<p>Exercise Problems &bull; 41</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 3: Digital Circuitry
</p>
<p>and Interfacing
Now we turn our attention to the physical circuitry and electrical quantities that are used to represent
</p>
<p>and operate on the binary codes 1 and 0. In this chapter we begin by looking at how logic circuits are
</p>
<p>described and introduce the basic set of gates used for all digital logic operations. We then look at the
</p>
<p>underlying circuitry that implements the basic gates including digital signaling and how voltages are used
</p>
<p>to represent 1&rsquo;s and 0&rsquo;s. We then look at interfacing between two digital circuits and how to ensure that
</p>
<p>when one circuit sends a binary code, the receiving circuit is able to determine which code was sent.
</p>
<p>Logic families are then introduced, and the details of how basic gates are implemented at the switch level
</p>
<p>are presented. Finally, interfacing considerations are covered for the most common types of digital loads
</p>
<p>(i.e., other gates, resistors, and LEDs). The goal of this chapter is to provide an understanding of the
</p>
<p>basic electrical operation of digital circuits.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>3.1 Describe the functional operation of a basic logic gate using truth tables, logic expressions,
and logic waveforms.
</p>
<p>3.2 Analyze the DC and AC behavior of a digital circuit to verify it is operating within
specification.
</p>
<p>3.3 Describe the meaning of a logic family and the operation of the most common technologies
used today.
</p>
<p>3.4 Determine the operating conditions of a logic circuit when driving various types of loads.
</p>
<p>3.1 Basic Gates
</p>
<p>The term gate is used to describe a digital circuit that implements the most basic functions possible
</p>
<p>within the binary system. When discussing the operation of a logic gate, we ignore the details of how the
</p>
<p>1&rsquo;s and 0&rsquo;s are represented with voltages and manipulated using transistors. We instead treat the inputs
</p>
<p>and output as simply ideal 1&rsquo;s and 0&rsquo;s. This allows us to design more complex logic circuits without going
</p>
<p>into the details of the underlying physical hardware.
</p>
<p>3.1.1 Describing the Operation of a Logic Circuit
</p>
<p>3.1.1.1 The Logic Symbol
</p>
<p>A logic symbol is a graphical representation of the circuit that can be used in a schematic to show
</p>
<p>how circuits in a system interface to one another. For the set of basic logic gates, there are uniquely
</p>
<p>shaped symbols that graphically indicate their functionality. For more complex logic circuits that are
</p>
<p>implemented with multiple basic gates, a simple rectangular symbol is used. Inputs of the logic circuit are
</p>
<p>typically shown on the left of the symbol and outputs are on the right. Figure 3.1 shows two example logic
</p>
<p>symbols.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_3
</p>
<p>43</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_3&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_3&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>3.1.1.2 The Truth Table
</p>
<p>We formally define the functionality of a logic circuit using a truth table. In a truth table, each and
</p>
<p>every possible input combination is listed, and the corresponding output of the logic circuit is given. If a
</p>
<p>logic circuit has n inputs, then it will have 2n possible input codes. The binary codes are listed in
</p>
<p>ascending order within the truth table mimicking a binary count starting at 0. By always listing the input
</p>
<p>codes in this way, we can assign a row number to each input that is the decimal equivalent of the binary
</p>
<p>input code. Row numbers can be used to simplify the notation for describing the functionality of larger
</p>
<p>circuits. Figure 3.2 shows the formation of an example 3-input truth table.
</p>
<p>3.1.1.3 The Logic Function
</p>
<p>A logic expression, (also called a logic function), is an equation that provides the functionality of
</p>
<p>each output in the circuit as a function of the inputs. The logic operations for the basic gates are given a
</p>
<p>symbolic set of operators (e.g., +, ∙,
L
</p>
<p>), the details of which will be given in the next sections. The logic
</p>
<p>function describes the operations that are necessary to produce the outputs listed in the truth table. A
</p>
<p>logic function is used to describe a single output that can take on only the values 1 and 0. If a circuit
</p>
<p>contains multiple outputs, then a logic function is needed for each output. The input variables can be
</p>
<p>included in the expression description just as in an analog function. For example, &ldquo;F(A,B,C) &frac14; . . .&rdquo; would
</p>
<p>state that &ldquo;F is a function of the inputs A, B, and C.&rdquo; This can also be written as &ldquo;FA,B,C &frac14; . . . .&rdquo; The input
</p>
<p>variables can also be excluded for brevity as in &ldquo;F &frac14; . . . .&rdquo; Figure 3.3 shows the formation of an example
</p>
<p>3-input logic expression.
</p>
<p>Fig. 3.1
Example logic symbols
</p>
<p>Fig. 3.2
Truth table formation
</p>
<p>44 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.1.4 The Logic Waveform
</p>
<p>A logicwaveform is a graphical depiction of the relationship of the output to the inputs with respect to
</p>
<p>time. This is often a useful description of behavior since it mimics the format that is typically observed
</p>
<p>when measuring a real digital circuit using test equipment such as an oscilloscope. In the waveform,
</p>
<p>each signal can only take on a value of 1 or 0. It is useful to write the logic values of the signal at each
</p>
<p>transition in the waveform for readability. Figure 3.4 shows an example logic waveform.
</p>
<p>3.1.2 The Buffer
</p>
<p>The first basic gate is the buffer. The output of a buffer is simply the input. The logic symbol, truth
</p>
<p>table, logic function, and logic waveform for the buffer are given in Fig. 3.5.
</p>
<p>Fig. 3.3
Logic function formation
</p>
<p>Fig. 3.4
Example logic waveform
</p>
<p>Fig. 3.5
Buffer symbol, truth table, logic function, and logic waveform
</p>
<p>3.1 Basic Gates &bull; 45</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.3 The Inverter
</p>
<p>The next basic gate is the inverter. The output of an inverter is the complement of the input. Inversion
</p>
<p>is also often called the not operation. In spoken word, we might say &ldquo;A is equal to not B;&rdquo; thus this gate is
</p>
<p>also often called a not gate. The symbol for the inverter is the same as the buffer with the exception that
</p>
<p>an inversion bubble (i.e., a circle) is placed on the output. The inversion bubble is a common way to show
</p>
<p>inversions in schematics and will be used by many of the basic gates. In the logic function, there are two
</p>
<p>common ways to show this operation. The first way is by placing a prime (&lsquo;) after the input variable (e.g.,
</p>
<p>Out&frac14; In0). This notation has the advantage that it is supported in all text editors but has the drawback that
</p>
<p>it can sometimes be difficult to see. The second way to indicate inversion in a logic function is by placing
</p>
<p>an inversion bar over the input variable (e.g., Out&frac14; In). The advantage of this notation is that it is easy to
</p>
<p>see but has the drawback that it is not supported by many text editors. In this text, both conventions will
</p>
<p>be used to provide exposure to each. The logic symbol, truth table, logic function, and logic waveform for
</p>
<p>the inverter are given in Fig. 3.6.
</p>
<p>3.1.4 The AND Gate
</p>
<p>The next basic gate is the AND gate. The output of an AND gate will only be true (i.e., a logic 1) if all
</p>
<p>of the inputs are true. This operation is also called a logical product because if the inputs were
</p>
<p>multiplied together, the only time the output would be a 1 is if each and every input was a 1. As a result,
</p>
<p>the logic operator is the dot (∙). Another notation that is often seen is the ampersand (&amp;). The logic
</p>
<p>symbol, truth table, logic function, and logic waveform for a 2-input AND gate are given in Fig. 3.7.
</p>
<p>Ideal AND gates can have any number of inputs. The operation of an n-bit, AND gates still follows
</p>
<p>the rule that the output will only be true when all of the inputs are true. Later sections will discuss the
</p>
<p>limitations on expanding the number of inputs of these basic gates indefinitely.
</p>
<p>Fig. 3.6
Inverter symbol, truth table, logic function, and logic waveform
</p>
<p>Fig. 3.7
2-input AND gate symbol, truth table, logic function, and logic waveform
</p>
<p>46 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.5 The NAND Gate
</p>
<p>The NAND gate is identical to the AND gate with the exception that the output is inverted. The &ldquo;N&rdquo; in
</p>
<p>NAND stands for &ldquo;NOT,&rdquo; which represents the inversion. The symbol for a NAND gate is an AND gate
</p>
<p>with an inversion bubble on the output. The logic expression for a NAND gate is the same as an AND
</p>
<p>gate but with an inversion bar over the entire operation. The logic symbol, truth table, logic function, and
</p>
<p>logic waveform for a 2-input NAND gate are given in Fig. 3.8. Ideal NAND gates can have any number of
</p>
<p>inputs with the operation of an n-bit, NAND gate following the rule that the output is always the inversion
</p>
<p>of an n-bit, AND operation.
</p>
<p>3.1.6 The OR Gate
</p>
<p>The next basic gate is the OR gate. The output of an OR gate will be true when any of the inputs
</p>
<p>are true. This operation is also called a logical sum because of its similarity to logical disjunction in which
</p>
<p>the output is true if at least one of the inputs is true. As a result, the logic operator is the plus sign (+). The
</p>
<p>logic symbol, truth table, logic function, and logic waveform for a 2-input OR gate are given in Fig. 3.9.
</p>
<p>Ideal OR gates can have any number of inputs. The operation of an n-bit, OR gates still follows the rule
</p>
<p>that the output will be true if any of the inputs are true.
</p>
<p>3.1.7 The NOR Gate
</p>
<p>The NOR gate is identical to the OR gate with the exception that the output is inverted. The symbol
</p>
<p>for a NOR gate is an OR gate with an inversion bubble on the output. The logic expression for a NOR
</p>
<p>gate is the same as an OR gate but with an inversion bar over the entire operation. The logic symbol,
</p>
<p>truth table, logic function, and logic waveform for a 2-input NOR gate are given in Fig. 3.10. Ideal NOR
</p>
<p>gates can have any number of inputs with the operation of an n-bit, NOR gate following the rule that the
</p>
<p>output is always the inversion of an n-bit, OR operation.
</p>
<p>Fig. 3.8
2-input NAND gate symbol, truth table, logic function, and logic waveform
</p>
<p>Fig. 3.9
2-input OR gate symbol, truth table, logic function, and logic waveform
</p>
<p>3.1 Basic Gates &bull; 47</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.8 The XOR Gate
</p>
<p>The next basic gate is the exclusive-OR gate or XOR gate for short. This gate is also called a
</p>
<p>difference gate because for the 2-input configuration, its output will be true when the input codes are
</p>
<p>different from one another. The logic operator is a circle around a plus sign (
L
</p>
<p>). The logic symbol, truth
</p>
<p>table, logic function, and logic waveform for a 2-input XOR gate are given in Fig. 3.11.
</p>
<p>Using the formal definition of an XOR gate (i.e., the output is true if any of the input codes are
</p>
<p>different from one another), an XOR gate with more than two inputs can be built. The truth table for a
</p>
<p>3-bit, XOR gate using this definition is shown in Fig. 3.12. In modern electronics, this type of gate has
</p>
<p>found little use since it is much simpler to build this functionality using a combination of AND and OR
</p>
<p>gates. As such, XOR gates with greater than two inputs do not implement the difference function.
</p>
<p>Instead, a more useful functionality has been adopted in which the output of the n-bit, XOR gate is the
</p>
<p>result of a cascade of 2-input XOR gates. This results in an ultimate output that is true when there is an
</p>
<p>ODD number of 1&rsquo;s on the inputs. This functionality is much more useful in modern electronics for error
</p>
<p>correction codes and arithmetic. As such, this is the functionality that is seen in modern n-bit, XOR gates.
</p>
<p>This functionality is also shown in Fig. 3.12.
</p>
<p>Fig. 3.10
2-input NOR gate symbol, truth table, logic function, and logic waveform
</p>
<p>Fig. 3.11
2-input XOR gate symbol, truth table, logic function, and logic waveform
</p>
<p>48 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.9 The XNOR Gate
</p>
<p>The exclusive-NOR gate is identical to the XOR gate with the exception that the output is inverted.
</p>
<p>This gate is also called an equivalence gate because for the 2-input configuration, its output will be true
</p>
<p>when the input codes are equivalent to one another. The symbol for an XNOR gate is an XOR gate
</p>
<p>with an inversion bubble on the output. The logic expression for an XNOR gate is the same as an XOR
</p>
<p>gate but with an inversion bar over the entire operation. The logic symbol, truth table, logic function, and
</p>
<p>logic waveform for a 2-input XNOR gate are given in Fig. 3.13. XNOR gates can have any number of
</p>
<p>inputs with the operation of an n-bit, XNOR gate following the rule that the output is always the inversion
</p>
<p>of an n-bit, XOR operation (i.e., the output is true if there is an ODD number of 1&rsquo;s on the inputs).
</p>
<p>Fig. 3.12
3-input XOR gate implementation
</p>
<p>Fig. 3.13
2-input XNOR gate symbol, truth table, logic function, and logic waveform
</p>
<p>3.1 Basic Gates &bull; 49</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC3.1 Given the following logic diagram, which is the correct logic expression for F?
</p>
<p>A) F &frac14; (A�B)&rsquo;
L
</p>
<p>C
</p>
<p>B) F &frac14; (A&rsquo;�B&rsquo;)
L
</p>
<p>C
</p>
<p>C) F &frac14; (A&rsquo;�B&rsquo;
L
</p>
<p>C)
</p>
<p>D) F &frac14; A�B&rsquo;
L
</p>
<p>C
</p>
<p>3.2 Digital Circuit Operation
</p>
<p>Now we turn our attention to the physical hardware that is used to build the basic gates just
</p>
<p>described and how electrical quantities are used to represent and communicate the binary values
</p>
<p>1 and 0. We begin by looking at digital signaling. Digital signaling refers to how binary codes are
</p>
<p>generated and transmitted successfully between two digital circuits using electrical quantities (e.g.,
</p>
<p>voltage and current). Consider the digital system shown in Fig. 3.14. In this system, the sending circuit
</p>
<p>generates a binary code. The sending circuit is called either the transmitter (Tx) or driver. The transmitter
</p>
<p>represents the binary code using an electrical quantity such as voltage. The receiving circuit
</p>
<p>(Rx) observes this voltage and is able to determine the value of the binary code. In this way, 1&rsquo;s and
</p>
<p>0&rsquo;s can be communicated between the two digital circuits. The transmitter and receiver are both
</p>
<p>designed to use the same digital signaling scheme so that they are able to communicate with each
</p>
<p>other. It should be noted that all digital circuits contain both inputs (Rx) and outputs (Tx) but are not
</p>
<p>shown in this figure for simplicity.
</p>
<p>Fig. 3.14
Generic digital transmitter/receiver circuit
</p>
<p>50 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2.1 Logic Levels
</p>
<p>A logic level is the term to describe all possible states that a signal can have. We will focus explicitly
</p>
<p>on circuits that represent binary values, so these will only have two finite states (1 and 0). To begin, we
</p>
<p>define a simplistic model of how to represent the binary codes using an electrical quantity. This model
</p>
<p>uses a voltage threshold (Vth) to represent the switching point between the binary codes. If the voltage of
</p>
<p>the signal (Vsig) is above this threshold, it is considered a logic HIGH. If the voltage is below this
</p>
<p>threshold, it is considered a logic LOW. A graphical depiction of this is shown in Fig. 3.15. The terms
</p>
<p>HIGH and LOW are used to describe which logic level corresponds to the higher or lower voltage.
</p>
<p>It is straightforward to have the HIGH level correspond to the binary code 1 and the LOW level
</p>
<p>correspond to the binary code 0; however, it is equally valid to have the HIGH level correspond to the binary
</p>
<p>code 0 and the LOW level correspond to the binary code 1. As such, we need to define how the logic levels
</p>
<p>HIGH and LOWmap to the binary codes 1 and 0. We define two types of digital assignments: positive logic
</p>
<p>and negative logic. In positive logic, the logic HIGH level represents a binary 1, and the logic LOW level
</p>
<p>represents a binary 0. In negative logic, the logic HIGH level represents a binary 0, and the logic LOW level
</p>
<p>represents abinary 1. Table 3.1 shows the definition of positive andnegative logic. There are certain typesof
</p>
<p>digital circuits that benefit from using negative logic; however, we will focus specifically on systems that use
</p>
<p>positive logic since it is more intuitive when learning digital design for the first time. The transformation
</p>
<p>between positive and negative logic is straightforward and will be covered in Chap. 4.
</p>
<p>3.2.2 Output DC Specifications
</p>
<p>Transmitting circuits provide specifications on the range of output voltages (VO) that they are
</p>
<p>guaranteed to provide when outputting a logic 1 or 0. These are called the DC output specifications.
</p>
<p>There are four DC voltage specifications that specify this range: VOH-max, VOH-min, VOL-max, and VOL-min.
</p>
<p>Fig. 3.15
Definition of logic HIGH and LOW
</p>
<p>Table 3.1
Definition of positive and negative logic
</p>
<p>3.2 Digital Circuit Operation &bull; 51</p>
<p/>
</div>
<div class="page"><p/>
<p>The VOH-max and VOH-min specifications provide the range of voltages the transmitter is guaranteed to
</p>
<p>provide when outputting a logic HIGH (or logic 1 when using positive logic). The VOL-max and VOL-min
specifications provide the range of voltages the transmitter is guaranteed to provide when outputting a
</p>
<p>logic LOW (or logic 0 when using positive logic). In the subscripts for these specifications, the &ldquo;O&rdquo;
</p>
<p>signifies &ldquo;output&rdquo; and the &ldquo;L&rdquo; or &ldquo;H&rdquo; signifies &ldquo;LOW&rdquo; or &ldquo;HIGH,&rdquo; respectively.
</p>
<p>The maximum amount of current that can flow through the transmitter&rsquo;s output (IO) is also specified.
</p>
<p>The specification IOH-max is the maximum amount of current that can flow through the transmitter&rsquo;s output
</p>
<p>when sending a logic HIGH. The specification IOL-max is the maximum amount of current that can flow
</p>
<p>through the transmitter&rsquo;s output when sending a logic LOW. When the maximum output currents are
</p>
<p>violated, it usually damages the part. Manufacturers will also provide a recommended amount of current
</p>
<p>for IO that will guarantee the specified operating parameters throughout the life of the part. Figure 3.16
</p>
<p>shows a graphical depiction of these DC specifications. When the transmitter output is providing current
</p>
<p>to the receiving circuit (aka, the load), it is said to be sourcing current. When the transmitter output is
</p>
<p>drawing current from the receiving circuit, it is said to be sinking current. In most cases, the transmitter
</p>
<p>sources current when driving a logic HIGH and sinks current when driving a logic LOW. Figure 3.16
</p>
<p>shows a graphical depiction of these specifications.
</p>
<p>Fig. 3.16
DC specifications of a digital circuit
</p>
<p>52 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2.3 Input DC Specifications
</p>
<p>Receiving circuits provide specifications on the range of input voltages (VI) that they will interpret as
</p>
<p>either a logic HIGH or LOW. These are called the DC input specifications. There are four DC voltage
</p>
<p>specifications that specify this range: VIH-max, VIH-min, VIL-max, and VIL-min. The VIH-max and VIH-min
specifications provide the range of voltages that the receiver will interpret as a logic HIGH (or logic
</p>
<p>1 when using positive logic). The VIL-max and VIL-min specifications provide the range of voltages that the
</p>
<p>receiver will interpret as a logic LOW (or logic 0 when using positive logic). In the subscripts for these
</p>
<p>specifications, the &ldquo;I&rdquo; signifies &ldquo;input.&rdquo;
</p>
<p>The maximum amount of current that the receiver will draw, or take in, when connected is also
</p>
<p>specified II). The specification IIH-max is the maximum amount of current that the receiver will draw when it
</p>
<p>is being driven with a logic HIGH. The specification IIL-max is the maximum amount of current that the
</p>
<p>receiver will draw when it is being driven with a logic LOW. Again, Fig. 3.16 shows a graphical depiction
</p>
<p>of these DC specifications.
</p>
<p>3.2.4 Noise Margins
</p>
<p>For digital circuits that are designed to operate with each other, the VOH-max and VIH-max
specifications have equal voltages. Similarly, the VOL-min and VIL-min specifications have equal voltages.
</p>
<p>The VOH-max and VOL-min output specifications represent the best-case scenario for digital signaling as
</p>
<p>the transmitter is sending the largest (or smallest) signal possible. If there is no loss in the interconnect
</p>
<p>between the transmitter and receiver, the full voltage levels will arrive at the receiver and be interpreted
</p>
<p>as the correct logic states (HIGH or LOW).
</p>
<p>The worst-case scenario for digital signaling is when the transmitter outputs its levels at VOH-min and
</p>
<p>VOL-max. These levels represent the furthest away from an ideal voltage level that the transmitter can
</p>
<p>send to the receiver and are susceptible to loss and noise that may occur in the interconnect system. In
</p>
<p>order to compensate for potential loss or noise, digital circuits have a predefined amount of margin built
</p>
<p>into their worst-case specifications. Let&rsquo;s take the worst-case example of a transmitter sending a logic
</p>
<p>HIGH at the level VOH-min. If the receiver was designed to have VIH-min (i.e., the lowest voltage that would
</p>
<p>still be interpreted as a logic 1) equal to VOH-min and then if even the smallest amount of the output signal
</p>
<p>was attenuated as it traveled through the interconnect, it would arrive at the receiver below VIH-min and
</p>
<p>would not be interpreted as a logic 1. Since there will always be some amount of loss in any interconnect
</p>
<p>system, the specifications for VIH-min are always less than VOH-min. The difference between these two
</p>
<p>quantities is called the noise margin. More specifically, it is called the noise margin HIGH (or NMH) to
</p>
<p>signify how much margin is built into the Tx/Rx circuit when communicating a logic 1. Similarly, the VIL-
</p>
<p>max specification is always higher than the VOL-max specification to account for any voltage added to the
</p>
<p>signal in the interconnect. The difference between these two quantities is called the noise margin LOW
</p>
<p>(or NML) to signify how much margin is built into the Tx/Rx circuit when communicating a logic 0. Noise
</p>
<p>margins are always specified as positive quantities; thus the order of the subtrahend and minuend in
</p>
<p>these differences.
</p>
<p>NMH &frac14; VOH-min � VIH-min
NML &frac14; VIL-max � VOL-max
</p>
<p>Figure 3.16 includes the graphical depiction of the noise margins. Notice in this figure that there is a
</p>
<p>region of voltages that the receiver will not interpret as either a HIGH or LOW. This region lies between
</p>
<p>the VIH-min and VIL-max specifications. This is the uncertainty region and should be avoided. Signals in
</p>
<p>this region will cause the receiver&rsquo;s output to go to an unknown voltage. Digital transmitters are designed
</p>
<p>to transition between the LOWand HIGH states quickly enough so that the receiver does not have time to
</p>
<p>react to the input being in the uncertainty region.
</p>
<p>3.2 Digital Circuit Operation &bull; 53</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2.5 Power Supplies
</p>
<p>All digital circuits require a power supply voltage and a ground. There are some types of digital
</p>
<p>circuits that may require multiple power supplies. For simplicity, we will focus on digital circuits that only
</p>
<p>require a single power supply voltage and ground. The power supply voltage is commonly given the
</p>
<p>abbreviations of either VCC or VDD. The &ldquo;CC&rdquo; and &ldquo;DD&rdquo; have to do with how the terminals of the
</p>
<p>transistors inside of the digital circuit are connected (i.e., &ldquo;collector to collector&rdquo; or &ldquo;drain to drain&rdquo;). Digital
</p>
<p>circuits will specify the required power supply voltage. Ground is considered an ideal 0v. Digital circuits
</p>
<p>will also specify the maximum amount of DC current that can flow through the VCC (ICC) and GND (IGND)
</p>
<p>pins before damaging the part.
</p>
<p>There are two components of power supply current. The first is the current that is required for the
</p>
<p>functional operation of the device. This is called the quiescent current (Iq). The second component of the
</p>
<p>power supply current is the output currents (IO). Any current that flows out of a digital circuit must also
</p>
<p>flow into it. When a transmitting circuit sources current to a load on its output pin, it must bring in that
</p>
<p>same amount of current on another pin. This is accomplished using the power supply pin (VCC).
</p>
<p>Conversely, when a transmitting circuit sinks current from a load on its output pin, an equal amount of
</p>
<p>current must exit the circuit on a different pin. This is accomplished using the GND pin. This means that
</p>
<p>the amount of current flowing through the VCC and GND pins will vary depending on the logic states that
</p>
<p>are being driven on the outputs. Since a digital circuit may contain numerous output pins, the maximum
</p>
<p>amount of current flowing through the VCC and GND pins can scale quickly and care must be taken not to
</p>
<p>damage the device.
</p>
<p>The quiescent current is often specified using the term ICC. This should not be confused with the
</p>
<p>specification for the maximum amount of current that can flow through the VCC pin, which is often called
</p>
<p>ICC-max. It is easy to tell the difference because ICC (or Iq) is much smaller than ICC-max for CMOS parts.
</p>
<p>ICC (or Iq) is specified in the uA to nA range, while the maximum current that can flow through the VCC pin
</p>
<p>is specified in the mA range. Example 3.1 shows the process of calculating the ICC and IGND currents
</p>
<p>when sourcing multiple loads.
</p>
<p>54 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 3.2 shows the process of calculating the ICC and IGND currents when both sourcing and
</p>
<p>sinking loads.
</p>
<p>Example 3.1
Calculating ICC and IGND when sourcing multiple loads
</p>
<p>3.2 Digital Circuit Operation &bull; 55</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2.6 Switching Characteristics
</p>
<p>Switching characteristics refer to the transient behavior of the logic circuits. The first group of
</p>
<p>switching specifications characterize the propagation delay of the gate. The propagation delay is the
</p>
<p>time it takes for the output to respond to a change on the input. The propagation delay is formally defined
</p>
<p>Example 3.2
Calculating ICC and IGND when both sourcing and sinking loads
</p>
<p>56 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>as the time it takes from the point at which the input has transitioned to 50% of its final value to the point at
</p>
<p>which the output has transitioned to 50% of its final value. The initial and final voltages for the input are
</p>
<p>defined to be GND and VCC, while the output initial and final voltages are defined to be VOL and VOH.
</p>
<p>Specifications are given for the propagation delay when transitioning from a LOW to HIGH (tPLH) and
</p>
<p>from a HIGH to LOW (tPHL). When these specifications are equal, the values are often given as a single
</p>
<p>specification of tpd. These specifications are shown graphically in Fig. 3.17.
</p>
<p>The second group of switching specifications characterize how quickly the output switches between
</p>
<p>states. The transition time is defined as the time it takes for the output to transition from 10% to 90% of
</p>
<p>the output voltage range. The rise time (tr) is the time it takes for this transition when going from a LOW to
</p>
<p>HIGH, and the fall time (tf) is the time it takes for this transition when going from a HIGH to LOW. When
</p>
<p>these specifications are equal, the values are often given as a single specification of tt. These
</p>
<p>specifications are shown graphically in Fig. 3.17.
</p>
<p>3.2.7 Data Sheets
</p>
<p>The specifications for a particular part are given in its data sheet. The data sheet contains all of the
</p>
<p>operating characteristics for a part, in addition to functional information such as package geometries and
</p>
<p>pin assignments. The data sheet is usually the first place a designer will look when selecting a part.
</p>
<p>Figures 3.18, 3.19, and 3.20 show excerpts from an example data sheet highlighting some of the
</p>
<p>specifications just covered.
</p>
<p>Fig. 3.17
Switching characteristics of a digital circuit
</p>
<p>3.2 Digital Circuit Operation &bull; 57</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.18
Example data sheet excerpt (1)
</p>
<p>58 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.19
Example data sheet excerpt (2)
</p>
<p>3.2 Digital Circuit Operation &bull; 59</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.20
Example data sheet excerpt (3)
</p>
<p>60 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC3.2(a) Given the following DC specifications for a driver/receiver pair, in what situation may
a logic signal transmitted not be successfully received?
</p>
<p>VOH-max &frac14; +3.4v VIH-max &frac14; +3.4v
</p>
<p>VOH-min &frac14; +2.5v VIH-min &frac14; +2.5v
</p>
<p>VOL-max &frac14; +1.5v VIL-max &frac14; +2.0v
</p>
<p>VOL-min &frac14; 0v VIL-min &frac14; 0v
</p>
<p>A) Driving a HIGH with Vo &frac14; +3.4v
</p>
<p>B) Driving a HIGH with Vo &frac14; +2.5v
</p>
<p>C) Driving a LOW with Vo &frac14; +1.5v
</p>
<p>D) Driving a LOW with Vo &frac14; 0v
</p>
<p>CC3.2(b) For the following driver configuration, which of the following is a valid constraint that
could be put in place to prevent a violation of the maximum power supply currents
(ICC-max and IGND-max)?
</p>
<p>A) Modify the driver transistors so that they can&rsquo;t provide more than 5 mA on
any output.
</p>
<p>B) Apply a cooling system (e.g., a heat sink or fan) to the driver chip.
</p>
<p>C) Design the logic so that no more than half of the outputs are HIGH at any
given time.
</p>
<p>D) Drive multiple receivers with the same output pin.
</p>
<p>CC3.2(c) Why is it desirable to have the output of a digital circuit transition quickly between the
logic LOW and logic HIGH levels?
</p>
<p>A) So that the outputs are not able to respond as the input transitions through
the uncertainty region. This avoids unwanted transitions.
</p>
<p>B) So that all signals look like square waves.
</p>
<p>C) To reduce power by minimizing the time spent switching.
</p>
<p>D) Because the system can only have two states, a LOW and a HIGH.
</p>
<p>3.2 Digital Circuit Operation &bull; 61</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3 Logic Families
</p>
<p>It is apparent from the prior discussion of operating conditions that digital circuits need to have
</p>
<p>comparable input and output specifications in order to successfully communicate with each other. If a
</p>
<p>transmitter outputs a logic HIGH as +3.4v and the receiver needs a logic HIGH to be above +4v to be
</p>
<p>successfully interpreted as a logic HIGH, then these two circuits will not be able to communicate. In order
</p>
<p>to address this interoperability issue, digital circuits are grouped into logic families. A logic family is a
</p>
<p>group of parts that all adhere to a common set of specifications so that they work together. The logic
</p>
<p>family is given a specific name, and once the specifications are agreed upon, different manufacturers
</p>
<p>produce parts that work within the particular family. Within a logic family, parts will all have the same
</p>
<p>power supply requirements and DC input/output specifications such that if connected directly, they will be
</p>
<p>able to successfully communicate with each other. The phrase &ldquo;connected directly&rdquo; is emphasized
</p>
<p>because it is very possible to insert an interconnect circuit between two circuits within the same logic
</p>
<p>family and alter the output voltage enough so that the receiver will not be able to interpret the correct logic
</p>
<p>level. Analyzing the effect of the interconnect circuit is part of the digital design process. There are many
</p>
<p>logic families that exist (up to 100 different types!), and more emerge each year as improvements are
</p>
<p>made to circuit fabrication processes that create smaller, faster, and lower power circuits.
</p>
<p>3.3.1 Complementary Metal-Oxide Semiconductors (CMOS)
</p>
<p>The first group of logic families we will discuss is called complementary metal-oxide
</p>
<p>semiconductors, or CMOS. This is currently the most popular group of logic families for digital circuits
</p>
<p>implemented on the same integrated circuit (IC). An integrated circuit is where the entire circuit is
</p>
<p>implemented on a single piece of semiconductor material (or chip). The IC can contain transistors,
</p>
<p>resistors, capacitors, inductors, wires, and insulators. Modern integrated circuits can contain billions of
</p>
<p>devices and meters of interconnect. The opposite of implementing the circuit on an integrated circuit is to
</p>
<p>use discrete components. Using discrete components refers to where every device (transistor, resistor,
</p>
<p>etc.) is its own part and is wired together externally using either a printed circuit board (PCB) or jumper
</p>
<p>wires as on a breadboard. The line between ICs and discrete parts has blurred in the past decades
</p>
<p>because modern discrete parts are actually fabricated as an IC and regularly contain multiple devices
</p>
<p>(e.g., four logic gates per chip). Regardless, the term discrete is still used to describe components that
</p>
<p>only contain a few components where the term IC typically refers to a much larger system that is custom
</p>
<p>designed.
</p>
<p>The term CMOS comes from the use of particular types of transistors to implement the digital
</p>
<p>circuits. The transistors are created using a metal-oxide semiconductor (MOS) structure. These
</p>
<p>transistors are turned on or off based on an electric field, so they are given the name metal-oxide
</p>
<p>semiconductor field-effect transistors, or MOSFETs. There are two transistors that can be built using this
</p>
<p>approach that operate complementary to each other, thus the term complementary metal-oxide
</p>
<p>semiconductors. To understand the basic operation of CMOS logic, we begin by treating the MOSFETs
</p>
<p>as ideal switches. This allows us to understand the basic functionality without diving into the detailed
</p>
<p>electronic analysis of the transistors.
</p>
<p>3.3.1.1 CMOS Operation
</p>
<p>In CMOS, there is a single power supply (VCC or VDD) and a single ground (GND). The ground signal
</p>
<p>is sometimes called VSS. Themaximum input and output DC specifications are equal to the power supply
</p>
<p>(VCC &frac14; VOH-max &frac14; VIH-max). The minimum input and output DC specification are equal to ground
</p>
<p>(GND &frac14; 0v &frac14; VOL-min &frac14; VIL-min). In this way, using CMOS simplifies many of the specifications. If you
</p>
<p>state that you are using &ldquo;CMOS with a +3.4v power supply,&rdquo; you are inherently stating that
</p>
<p>VCC &frac14; VOH-max &frac14; VIH-max &frac14; +3.4v and that VOL-min &frac14; VIL-min &frac14; 0v. Many times, the name of the logic
</p>
<p>62 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>family will be associated with the power supply voltage. For example, a logic family may go by the
</p>
<p>name &ldquo;+3.3v CMOS&rdquo; or &ldquo;+2.5v CMOS.&rdquo; These names give a first-level description of the logic family
</p>
<p>operation, but more details about the operation must be looked up in the data sheet.
</p>
<p>There are two types of transistors used in CMOS. The transistors will be closed or open based on an
</p>
<p>input logic level. The first transistor is called an N-type MOSFET, or NMOS. This transistor will turn on, or
</p>
<p>close, when the voltage between the gate and source (VGS) is greater than its threshold voltage. The
</p>
<p>threshold voltage (VT) is the amount of voltage needed to create a conduction path between the drain
</p>
<p>and the source terminals. The threshold voltage of an NMOS transistor is typically between 0.2v and 1v
</p>
<p>and much less than the VCC voltage in the system. The second transistor is called a P-type MOSFET, or
</p>
<p>PMOS. This transistor turns on, or closes, when the voltage between the gate and the source (VGS) is
</p>
<p>less than VT, where the VT for a PMOS is a negative value. This means that to turn on a PMOS transistor,
</p>
<p>the gate terminal needs to be at a lower voltage than the source. The type of transistor (i.e., P-type or
</p>
<p>N-type) has to do with the type of semiconductor material used to conduct current through the transistor.
</p>
<p>An NMOS transistor uses negative charge to conduct current (i.e., negative-type), while a PMOS uses
</p>
<p>positive charge (i.e., positive-type). Figure 3.21 shows the symbols for the PMOS and NMOS, the
</p>
<p>fabrication cross sections, and their switch-level equivalents.
</p>
<p>The basic operation of CMOS is that when driving a logic HIGH, the switches are used to connect
</p>
<p>the output to the power supply (VCC), and when driving a logic LOW, the switches are used to connect the
</p>
<p>output to GND. In CMOS, VCC is considered an ideal logic HIGH and GND is considered an ideal logic
</p>
<p>Fig. 3.21
CMOS transistors
</p>
<p>3.3 Logic Families &bull; 63</p>
<p/>
</div>
<div class="page"><p/>
<p>LOW. VCC is typically much larger than VTso using these levels can easily turn on and off the transistors.
</p>
<p>The design of the circuit must never connect the output to VCC and GND at the same time or else the
</p>
<p>device itself will be damaged due to the current flowing directly from VCC to GND through the transistors.
</p>
<p>Due to the device physics of the MOSFETS, PMOS transistors are used to form the network that will
</p>
<p>connect the output to VCC (aka, the pull-up network), and NMOS transistors are used to form the network
</p>
<p>that will connect the output to GND (aka, the pull-down network). Since PMOS transistors are closed
</p>
<p>when the input is a 0 (thus providing a logic HIGH on the output) and NMOS transistors are closed when
</p>
<p>the input is a 1 (thus providing a logic LOW on the output), CMOS implements negative logic gates. This
</p>
<p>means CMOS can implement inverters, NAND and NOR gates, but not buffers, AND and OR gates,
</p>
<p>directly. In order to create a CMOS AND gate, the circuit would implement a NAND gate followed by an
</p>
<p>inverter and similarly for an OR gate and buffer.
</p>
<p>3.3.1.2 CMOS Inverter
</p>
<p>Let&rsquo;s now look at how we can use these transistors to create a CMOS inverter. Consider the
</p>
<p>transistor arrangement shown in Fig. 3.22.
</p>
<p>The inputs of both the PMOS and NMOS are connected together. The PMOS is used to connect the
</p>
<p>output to VCC, and the NMOS is used to connect the output to GND. Since the inputs are connected
</p>
<p>together and the switches operate in a complementary manner, this circuit ensures that both transistors
</p>
<p>will never be on at the same time. When In&frac14; 0, the PMOS switch is closed and the NMOS switch is open.
</p>
<p>This connects the output directly to VCC, thus providing a logic HIGH on the output. When In &frac14; 1, the
</p>
<p>PMOS switch is open and the NMOS switch is closed. This connects the output directly to GND, thus
</p>
<p>providing a logic LOW. This configuration yields an inverter. This operation is shown graphically in
</p>
<p>Fig. 3.23.
</p>
<p>Fig. 3.22
CMOS inverter schematic
</p>
<p>64 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3.1.3 CMOS NAND Gate
</p>
<p>Let&rsquo;s now look at how we use a similar arrangement of transistors to implement a 2-input NAND
</p>
<p>gate. Consider the transistor configuration shown in Fig. 3.24.
</p>
<p>Fig. 3.23
CMOS inverter operation
</p>
<p>Fig. 3.24
CMOS 2-input NAND gate schematic
</p>
<p>3.3 Logic Families &bull; 65</p>
<p/>
</div>
<div class="page"><p/>
<p>The pull-down network consists of two NMOS transistors in series (M1 and M2), and the pull-up
</p>
<p>network consists of two PMOS transistors in parallel (M3 and M4). Let&rsquo;s go through each of the input
</p>
<p>conditions and examine which transistors are on and which are off and how they impact the output.
</p>
<p>The first input condition is when A &frac14; 0 and B &frac14; 0. This condition turns on both M3 and M4 creating two
</p>
<p>parallel paths between the output and VCC. At the same time, it turns off both M1 and M2 preventing a
</p>
<p>path between the output and GND. This input condition results in an output that is connected to VCC
resulting in a logic HIGH. The second input condition is when A&frac14; 0 and B&frac14; 1. This condition turns onM3
</p>
<p>in the pull-up network and M2 in the pull-down network. This condition also turns off M4 in the pull-up
</p>
<p>network and M1 in the pull-down network. Since the pull-up network is a parallel combination of PMOS
</p>
<p>transistors, there is still a path between the output and VCC through M3. Since the pull-down network is a
</p>
<p>series combination of NMOS transistors, both M1 and M2 must be on in order to connect the output to
</p>
<p>GND. This input condition results in an output that is connected to VCC resulting in a logic HIGH. The third
</p>
<p>input condition is when A &frac14; 1 and B &frac14; 0. This condition again provides a path between the output and
</p>
<p>VCC through M4 and prevents a path between the output and ground by having M2 open. This input
</p>
<p>condition results in an output that is connected to VCC resulting in a logic HIGH. The final input condition
</p>
<p>is when A &frac14; 1 and B &frac14; 1. In this input condition, both of the PMOS transistors in the pull-up network
</p>
<p>(M3 and M4) are off preventing the output from being connected to VCC. At the same time, this input turns
</p>
<p>on both M1 and M2 in the pull-down network connecting the output to GND. This input condition results in
</p>
<p>an output that is connected to GND resulting in a logic LOW. Based on the resulting output values
</p>
<p>corresponding to the four input codes, this circuit yields the logic operation of a 2-input NAND gate. This
</p>
<p>operation is shown graphically in Fig. 3.25.
</p>
<p>66 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>Creating a CMOS NAND gate with more than two inputs is accomplished by adding additional
</p>
<p>PMOS transistors to the pull-up network in parallel and additional NMOS transistors to the pull-down
</p>
<p>network in series. Figure 3.26 shows the schematic for a 3-input NAND gate. This procedure is followed
</p>
<p>for creating NAND gates with larger numbers of inputs.
</p>
<p>Fig. 3.25
CMOS 2-input NAND gate operation
</p>
<p>3.3 Logic Families &bull; 67</p>
<p/>
</div>
<div class="page"><p/>
<p>If the CMOS transistors were ideal switches, the approach of increasing the number of inputs could
</p>
<p>be continued indefinitely. In reality, the transistors are not ideal switches, and there is a limit on howmany
</p>
<p>transistors can be added in series and continue to operate. The limitation has to do with ensuring that
</p>
<p>each transistor has enough voltage to properly turn on or off. This is a factor in the series network
</p>
<p>because the drain terminals of the NMOS transistors are not all connected to GND. If a voltage develops
</p>
<p>across one of the lower transistors (e.g., M3), then it takes more voltage on the input to turn on the next
</p>
<p>transistor up (e.g., M2). If too many transistors are added in series, then the uppermost transistor in the
</p>
<p>series may not be able to be turned on or off by the input signals. The number of inputs that a logic gate
</p>
<p>can have within a particular logic family is called its fan-in specification. When a logic circuit requires a
</p>
<p>number of inputs that exceed the fan-in specification for a particular logic family, then additional logic
</p>
<p>gates must be used. For example, if a circuit requires a 5-input NAND gate but the logic family has a
</p>
<p>fan-in specification of 4, this means that the largest NAND gate available only has 4-inputs. The 5-input
</p>
<p>NAND operation must be accomplished using additional circuit design techniques that use gates with
</p>
<p>4 or less inputs. These design techniques will be covered in Chap. 4.
</p>
<p>3.3.1.4 CMOS NOR Gate
</p>
<p>A CMOS NOR gate is created using a similar topology as a NAND gate with the exception that the
</p>
<p>pull-up network consists of PMOS transistors in series and the pull-down network that consists of NMOS
</p>
<p>transistors in parallel. Consider the transistor configuration shown in Fig. 3.27.
</p>
<p>Fig. 3.26
CMOS 3-input NAND gate schematic
</p>
<p>68 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>The series configuration of the pull-up network will only connect the output to VCC when both inputs
</p>
<p>are 0. Conversely, the pull-down network prevents connecting the output to GND when both inputs are
</p>
<p>0. When either or both of the inputs are true, the pull-up network is off, and the pull-down network is
</p>
<p>on. This yields the logic function for a NOR gate. This operation is shown graphically in Fig. 3.28. As with
</p>
<p>the NAND gate, the number of inputs can be increased by adding more PMOS transistors in series in the
</p>
<p>pull-up network and more NMOS transistors in parallel in the pull-down network.
</p>
<p>Fig. 3.27
CMOS 2-input NOR gate schematic
</p>
<p>3.3 Logic Families &bull; 69</p>
<p/>
</div>
<div class="page"><p/>
<p>The schematic for a 3-input NOR gate is given in Fig. 3.29. This approach can be used to increase
</p>
<p>the number of inputs up until the fan-in specification of the logic family is reached.
</p>
<p>Fig. 3.28
CMOS 2-input NOR gate operation
</p>
<p>70 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3.2 Transistor-Transistor Logic (TTL)
</p>
<p>One of the first logic families that emerged after the invention of the integrated circuit was transistor-
</p>
<p>transistor logic (TTL). This logic family uses bipolar junction transistor (BJT) as its fundamental switching
</p>
<p>item. This logic family defined a set of discrete parts that contained all of the basic gates in addition to
</p>
<p>more complex building blocks. TTL was used to build the first computer systems in the 1960s. TTL is not
</p>
<p>widely used today other than for specific applications because it consumes more power than CMOS and
</p>
<p>cannot achieve the density required for today&rsquo;s computer systems. TTL is discussed because it was the
</p>
<p>original logic family based on integrated circuits, so it provides a historical perspective of digital logic.
</p>
<p>Furthermore, the discrete logic pin-outs and part-numbering schemes are still used today for discrete
</p>
<p>CMOS parts.
</p>
<p>3.3.2.1 TTL Operation
</p>
<p>TTL logic uses BJT transistors and resistors to accomplish the logic operations. The operation of a
</p>
<p>BJT transistor is more complicated than a MOSFET; however, it performs essentially the same switch
</p>
<p>operation when used in a digital logic circuit. An input is used to turn the transistor on, which in turn allows
</p>
<p>current to flow between two other terminals. Figure 3.30 shows the symbol for the two types of BJT
</p>
<p>transistors. The PNP transistor is analogous to a PMOS and the NPN is analogous to an NMOS. Current
</p>
<p>will flow between the emitter and collector terminals when there is a sufficient voltage on the base
</p>
<p>terminal. The amount of current that flows between the emitter and collector is related to the current
</p>
<p>flowing into the base. The primary difference in operation between BJTs and MOSFETs is that BJTs
</p>
<p>require proper voltage biasing in order to turn on and also draw current through the base in order to stay
</p>
<p>on. The detailed operation of BJTs is beyond the scope of this text, so an overly simplified model of TTL
</p>
<p>logic gates is given.
</p>
<p>Fig. 3.29
CMOS 3-input NOR gate schematic
</p>
<p>3.3 Logic Families &bull; 71</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 3.31 shows a simplified model of how TTL logic operates using BJTs and resistors. This
</p>
<p>simplified model does not show all of the transistors that are used in modern TTL circuits but instead is
</p>
<p>intended to provide a high-level overview of the operation. This gate is an inverter that is created with an
</p>
<p>NPN transistor and a resistor. When the input is a logic HIGH, the NPN transistor turns on and conducts
</p>
<p>current between its collector and emitter terminals. This in effect closes the switch and connects the
</p>
<p>output to GND providing a logic LOW. During this state, current will also flow through the resistor to GND
</p>
<p>through Q1, thus consuming more power than the equivalent gate in CMOS. When the input is a logic
</p>
<p>LOW, the NPN transistor turns off and no current flows between its collector and emitter. This, in effect, is
</p>
<p>an open circuit leaving only the resistor connected to the output. The resistor pulls the output up to VCC
providing a logic HIGH on the output. One drawback of this state is that there will be a voltage drop
</p>
<p>across the resistor, so the output is not pulled fully to VCC.
</p>
<p>Fig. 3.30
PNP and NPN transistors
</p>
<p>72 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3.3 The 7400 Series Logic Families
</p>
<p>The 7400 series of TTL circuits became popular in the 1960s and 1970s. This family was based on
</p>
<p>TTL and contained hundreds of different digital circuits. The original circuits came in either plastic or
</p>
<p>ceramic dual-in-line packages (DIP). The 7400 TTL logic family was powered off of a +5v supply. As
</p>
<p>mentioned before, this logic family set the pin-outs and part-numbering schemes for modern logic
</p>
<p>families. There were many derivatives of the original TTL logic family that made modifications to improve
</p>
<p>speed and reliability, decrease power, and reduce power supplies. Today&rsquo;s CMOS logic families within
</p>
<p>the 7400 series still use the same pin-outs and numbering schemes as the original TTL family. It is useful
</p>
<p>to understand the history of this series because these parts are often used in introductory laboratory
</p>
<p>exercises to learn how to interface digital logic circuits.
</p>
<p>3.3.3.1 Part-Numbering Scheme
</p>
<p>The part-numbering scheme for the 7400 series and its derivatives contains five different fields:
</p>
<p>(1) manufacturer, (2) temperature range, (3) logic family, (4) logic function, and (5) package type. The
</p>
<p>breakdown of these fields is shown in Fig. 3.32.
</p>
<p>Fig. 3.31
TTL inverter
</p>
<p>3.3 Logic Families &bull; 73</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3.3.2 DC Operating Conditions
</p>
<p>Table 3.2 gives the DC operating conditions for a few of the logic families within the 7400 series.
</p>
<p>Notice that the CMOS families consume much less power than the TTL families. Also notice that the TTL
</p>
<p>output currents are asymmetrical. The differences between the IOH and IOL within the TTL families have
</p>
<p>to do with the nature of the bipolar transistors and the resistors used to create the pull-up networks within
</p>
<p>the devices. CMOS has symmetrical drive currents due to using complementary transistors for the pull-
</p>
<p>up (PMOS) and pull-down networks (NMOS).
</p>
<p>Fig. 3.32
7400 series part-numbering scheme
</p>
<p>74 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3.3.3 Pin-Out Information for the DIP Packages
</p>
<p>Figure 3.33 shows the pin-out assignments for a subset of the basic gates from the 74HC logic
</p>
<p>family in the dual-in-line package form factor. Most of the basic gates within the 7400 series follow these
</p>
<p>assignments. Notice that each of these basic gates comes in a 14-pin DIP package, each with a single
</p>
<p>VCC and single GND pin. It is up to the designer to ensure that the maximum current flowing through the
</p>
<p>VCC and GND pins does not exceed the maximum specification. This is particularly important for parts
</p>
<p>that contain numerous gates. For example, the 74HC00 part contains four, 2-input NAND gates. If each
</p>
<p>of the NAND gates was driving a logic HIGH at its maximum allowable output current (i.e., 25 mA from
</p>
<p>Fig. 3.19), then a total of 4∙25 mA + Iq&frac14; ~100 mA would be flowing through its VCC pin. Since the VCC pin
</p>
<p>can only tolerate a maximum of 50 mA of current (from Fig. 3.19), the part would be damaged since the
</p>
<p>output current of ~100 mA would also flow through the VCC pin. The pin-outs in Fig. 3.33 are useful when
</p>
<p>first learning to design logic circuits because the DIP packages plug directly into a standard breadboard.
</p>
<p>Table 3.2
DC operating conditions for a sample of 7400 series logic families
</p>
<p>3.3 Logic Families &bull; 75</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.33
Pin-outs for a subset of basic gates from the 74HC logic family in DIP packages
</p>
<p>76 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC3.3 Why doesn&rsquo;t the following CMOS transistor configuration yield a buffer?
</p>
<p>A) In order to turn on the NMOS transistor, VGS needs to be greater than zero. In
the given configuration, the gate terminal of the NMOS (G) needs to be driven
above the source terminal (S). If the source terminal was at +3.4v, then the
input (In) would never be able to provide a positive enough voltage to ensure
the NMOS is on because &ldquo;In&rdquo; doesn&rsquo;t go above +3.4v.
</p>
<p>B) There is no way to turn on both transistors in this configuration.
</p>
<p>C) The power consumption will damage the device because both transistors will
potentially be on.
</p>
<p>D) The sources of the two devices can&rsquo;t be connected together without causing a
short in the device.
</p>
<p>3.4 Driving Loads
</p>
<p>At this point we&rsquo;ve discussed in depth how proper care must be taken to ensure that not only do the
</p>
<p>output voltages of the driving gate meet the input specifications of the receiver in order to successfully
</p>
<p>transmit 1&rsquo;s and 0&rsquo;s but that the output current of the driver does not exceed the maximum specifications
</p>
<p>so that the part is not damaged. The output voltage and current for a digital circuit depend greatly on the
</p>
<p>load that is being driven. The following sections discuss the impact of driving some of the most common
</p>
<p>digital loads.
</p>
<p>3.4.1 Driving Other Gates
</p>
<p>Within a logic family, all digital circuits are designed to operate with one another. If there is minimal
</p>
<p>loss or noise in the interconnect system, then 1&rsquo;s and 0&rsquo;s will be successfully transmitted, and no current
</p>
<p>specifications will be exceeded. Consider the example in Example 3.3 for an inverter driving another
</p>
<p>inverter from the same logic family.
</p>
<p>3.4 Driving Loads &bull; 77</p>
<p/>
</div>
<div class="page"><p/>
<p>From this example, it is clear that there are no issues when a gate is driving another gate from
</p>
<p>the same family. This is as expected because that is the point of a logic family. In fact, gates are
</p>
<p>designed to drive multiple gates from within their own family. Based solely on the DC specifications for
</p>
<p>input and output current, it could be assumed that the number of other gates that can be driven is simply
</p>
<p>IO-max/II-max. For the example in Example 3.3, this would result in a 74HC gate being able to drive 25,000
</p>
<p>other gates (i.e., 25 mA/1uA &frac14; 25,000). In reality, the maximum number of gates that can be driven is
</p>
<p>dictated by the switching characteristics. This limit is called the fan-out specification. The fan-out
</p>
<p>specification states the maximum number of other gates from within the same family that can be driven.
</p>
<p>As discussed earlier, the output signal needs to transition quickly through the uncertainty region so that
</p>
<p>the receiver does not have time to react and go to an unknown state. As more and more gates are driven,
</p>
<p>this transition time is slowed down. The fan-out specification provides a limit to the maximum number of
</p>
<p>gates from the same family that can be driven while still ensuring that the output signal transitions
</p>
<p>between states fast enough to avoid the receivers from going to an unknown state. Example 3.4 shows
</p>
<p>the process of determining the maximum output current that a driver will need to provide when driving the
</p>
<p>maximum number of gates allowed by the fan-out specification.
</p>
<p>Example 3.3
Determining if specifications are violated when driving another gate as a load
</p>
<p>78 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.4.2 Driving Resistive Loads
</p>
<p>There are many situations where a resistor is the load in a digital circuit. A resistive load can be an
</p>
<p>actual resistor that is present for some other purpose such as a pull-up, pull-down, or for impedance
</p>
<p>matching. More complex loads such as buzzers, relays, or other electronics can also be modeled as a
</p>
<p>resistor. When a resistor is the load in a digital circuit, care must be taken to avoid violating the output
</p>
<p>current specifications of the driver. The electrical circuit analysis technique that is used to evaluate how a
</p>
<p>resistive load impacts a digital circuit is Ohm&rsquo;s law. Ohm&rsquo;s law is a very simple relationship between the
</p>
<p>current and voltage in a resistor. Figure 3.34 gives a primer on Ohm&rsquo;s law. For use in digital circuits, there
</p>
<p>are only a select few cases that this technique will be applied to, so no prior experience with Ohm&rsquo;s law is
</p>
<p>required at this point.
</p>
<p>Example 3.4
Determining the output current when driving multiple gates as the load
</p>
<p>Fig. 3.34
A primer on Ohm&rsquo;s law
</p>
<p>3.4 Driving Loads &bull; 79</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s see how we can use Ohm&rsquo;s law to analyze the impact of a resistive load in a digital circuit.
</p>
<p>Consider the circuit configuration in Example 3.5 and how we can use Ohm&rsquo;s law to determine the output
</p>
<p>current of the driver. The load in this case is a resistor connected between the output of the driver and the
</p>
<p>power supply (+5v). When driving a logic HIGH, the output level will be approximately equal to the power
</p>
<p>supply (i.e., +5v). Since in this situation both terminals of the resistor are at +5v, there is no voltage
</p>
<p>difference present. That means when plugging into Ohm&rsquo;s law, the voltage component is 0v, which gives
</p>
<p>0 amps of current. In the case where the driver is outputting a logic LOW, the output will be approximately
</p>
<p>GND. In this case, there is a voltage drop of +5v across the resistor (5v&ndash;0v). Plugging this into Ohm&rsquo;s law
</p>
<p>yields a current of 50 mA flowing through the resistor. This can become problematic because the current
</p>
<p>flows through the resistor and then into the output of the driver. For the 74HC logic family, this would
</p>
<p>exceed the IO max specification of 25 mA and damage the part. Additionally, as more current is drawn
</p>
<p>through the output, the output voltage becomes less and less ideal. In this example, the first-order
</p>
<p>analysis uses VO &frac14; GND. In reality, as the output current increases, the output voltage will move further
</p>
<p>away from its ideal value and may eventually reach a value within the uncertainty region.
</p>
<p>Example 3.5
Determining the output current when driving a pull-up resistor as the load
</p>
<p>80 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>A similar process can be used to determine the output current when driving a resistive load between
</p>
<p>the output and GND. This process is shown in Example 3.6.
</p>
<p>3.4.3 Driving LEDs
</p>
<p>A light-emitting diode (LED) is a very common type of load that is driven using a digital circuit. The
</p>
<p>behavior of diodes is typically covered in an analog electronics class. Since it is assumed that the reader
</p>
<p>has not been exposed to the operation of diodes, the behavior of the LED will be described using a highly
</p>
<p>simplified model. A diode has two terminals, the anode and cathode. Current that flows from the anode to
</p>
<p>the cathode is called the forward current. A voltage that is developed across a diode from its anode to
</p>
<p>cathode is called the forward voltage. A diode has a unique characteristic that when a forward voltage is
</p>
<p>supplied across its terminal, it will only increase up to a certain point. The amount is specified as the LED&rsquo;s
</p>
<p>forward voltage (vf) and is typically between 1.5v and 2v in modern LEDs. When a power supply circuit is
</p>
<p>connected to the LED, no current will flow until this forward voltage has been reached. Once it has been
</p>
<p>reached, current will begin to flow, and the LED will prevent any further voltage from developing across
</p>
<p>it. Once current flows, the LEDwill begin emitting light. Themore current that flows, the more light that will
</p>
<p>be emitted up until the point that the maximum allowable current through the LED is reached and then the
</p>
<p>device will be damaged. When using an LED, there are two specifications of interest: the forward voltage
</p>
<p>and the recommended forward current. The symbols for a diode and an LED are given in Fig. 3.35.
</p>
<p>Example 3.6
Determining the output current when driving a pull-down resistor as the load
</p>
<p>3.4 Driving Loads &bull; 81</p>
<p/>
</div>
<div class="page"><p/>
<p>When designing an LED driver circuit, a voltage must be supplied in order to develop the forward
</p>
<p>voltage across the LED so that current will flow. A resistor is included in series with the LED for two
</p>
<p>reasons. The first reason is to provide a place for any additional voltage provided by the driver to develop
</p>
<p>in the situation that Vo &gt; Vf, which is most often the case. The second reason for the resistor is to set the
</p>
<p>output current. Since the voltage across the resistor will be a fixed amount (i.e., Vo�Vf), then the value of
</p>
<p>the resistor can be chosen to set the current. This current is typically set to an optimum value that turns
</p>
<p>on the LED to a desired luminosity while also ensuring that the maximum output current of the driver is
</p>
<p>not violated. Consider the LED driver configuration shown in Example 3.7 where the LED will be turned
</p>
<p>on when the driver outputs a HIGH.
</p>
<p>Fig. 3.35
Symbols for a diode and a light-emitting diode
</p>
<p>Example 3.7
Determining the output current when driving an LED where HIGH &frac14; ON
</p>
<p>82 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 3.8 shows another example of driving an LED, but this time using a different configuration
</p>
<p>where the LED will be on when the driver outputs a logic LOW.
</p>
<p>CONCEPT CHECK
</p>
<p>CC3.4 A fan-out specification is typically around 6&ndash;12. If a logic family has a maximum output
current specification of IO-max&frac14; 25mA and amaximum input current specification of only
II-max&frac14; 1uA, a driver could conceivably source up to 25,000 gates (IO-max/II-max&frac14; 25mA/
1uA &frac14; 25,000) without violating its maximum output current specification. Why isn&rsquo;t the
fan-out specification then closer to 25,000?
</p>
<p>A) The fan-out specification has significant margin built into it in order to protect
the driver.
</p>
<p>B) Connecting 25,000 loads to the driver would cause significant wiring
congestion and would be impractical.
</p>
<p>C) The fan-out specification is in place to reduce power, so keeping it small is
desirable.
</p>
<p>D) The fan-out specification is in place for AC behavior. It ensures that the AC
loading on the driver doesn&rsquo;t slow down its output rise and fall times. If too
many loads are connected, the output transition will be too slow, and it will
reside in the uncertainty region for too long leading to unwanted switching on
the receivers.
</p>
<p>Example 3.8
Determining the Output Current When Driving an LED where HIGH&frac14;OFF
</p>
<p>3.4 Driving Loads &bull; 83</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v The operation of a logic circuit can be
described using either a logic symbol, a
truth table, a logic expression, or a logic
waveform.
</p>
<p>v Logic gates represent the most basic
operations that can be performed on binary
numbers. They are BUF, INV, AND, NAND,
OR, NOR, XOR, and XNOR.
</p>
<p>v XOR gates that have a number of inputs
greater than two are created using a cascade
of 2-input XOR gates. This implementation
has more practical applications such as arith-
metic and error detection codes.
</p>
<p>v The logic level describes whether the electri-
cal signal representing one of two states is
above or below a switching threshold region.
The two possible values that a logic level can
be are HIGH or LOW.
</p>
<p>v The logic value describes how the logic
levels are mapped into the two binary codes
0 and 1. In positive logic a HIGH &frac14; 1 and a
LOW&frac14; 0. In negative logic a HIGH&frac14; 0 and a
LOW &frac14; 1.
</p>
<p>v Logic circuits have DC specifications that
describe how input voltage levels are
interpreted as either HIGHs or LOWs (VIH-
max, VIH-min, VIL-max, and VIL-min).
Specifications are also given on what output
voltages will be produced when driving a
HIGH or LOW (VOH-max, VOH-min, VOL-max,
and VOL-min).
</p>
<p>v In order to successfully transmit digital infor-
mation, the output voltages of the driver that
represent a HIGH and LOW must arrive at
the receiver within the voltage ranges that
are interpreted as a HIGH and LOW. If the
voltage arrives at the receiver outside of
these specified input ranges, the receiver
will not know whether a HIGH or LOW is
being transmitted.
</p>
<p>v Logic circuits also specify maximum current
levels on the power supplies (IVCC, Ignd),
inputs (II-max), and outputs (IO-max) that may
not be exceeded. If these levels are
</p>
<p>exceeded, the circuit may not operate prop-
erly or be damaged.
</p>
<p>v The current exiting a logic circuit is equal to
the current entering.
</p>
<p>v When a logic circuit sources current to a load,
an equivalent current is drawn into the circuit
through its power supply pin.
</p>
<p>v When a logic circuit sinks current from a load,
an equivalent current flows out of the circuit
through its ground pin.
</p>
<p>v The type of load that is connected to the
output of a logic circuit dictates how much
current will be drawn from the driver.
</p>
<p>v The quiescent current (Iq or Icc) is the current
that the circuit always draws independent of
the input/output currents.
</p>
<p>v Logic circuits have AC specifications that
describe the delay from the input to the out-
put (tPLH, tPHL) and also how fast the outputs
transition between the HIGH and LOW levels
(tr, tf).
</p>
<p>v A logic family is a set of logic circuits that are
designed to operate with each other.
</p>
<p>v The fan-in of a logic family describes the
maximum number of inputs that a gate
may have.
</p>
<p>v The fan-out of a logic family describes the
maximum number of other gates from within
the same family that can be driven simulta-
neously by one gate.
</p>
<p>v Complementary metal-oxide semiconductor
(CMOS) logic is the most popular family
series in use today. CMOS logic uses two
transistors (NMOS and PMOS) that act as
complementary switches. CMOS transistors
draw very low quiescent current and can be
fabricated with extremely small feature sizes.
</p>
<p>v In CMOS, only inverters, NAND gates, and
NOR gates can be created directly. If it is
desired to create a buffer, AND gate, or OR
gate, an inverter is placed on the output of
the original inverter, NAND, or NOR gate.
</p>
<p>Exercise Problems
</p>
<p>Section 3.1: Basic Gates
</p>
<p>3.1.1 Give the truth table for a 3-input AND gate with
the input variables A, B, C and output F.
</p>
<p>3.1.2 Give the truth table for a 3-input OR gate with
the input variables A, B, C and output F.
</p>
<p>3.1.3 Give the truth table for a 3-input XNOR gate
with the input variables A, B, C and output F.
</p>
<p>3.1.4 Give the truth table for a 4-input XNOR gate
with the input variables A, B, C and output F.
</p>
<p>3.1.5 Give the logic expression for a 3-input AND
gate with the input variables A, B, C and
output F.
</p>
<p>3.1.6 Give the logic expression for a 3-input OR gate
with the input variables A, B, C and output F.
</p>
<p>84 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>3.1.7 Give the logic expression for a 3-input XNOR
gate with the input variables A, B, C and
output F.
</p>
<p>3.1.8 Give the logic expression for a 4-input XNOR
gate with the input variables A, B, C and
output F.
</p>
<p>3.1.9 Give the logic waveform for a 3-input AND gate
with the input variables A, B, C and output F.
</p>
<p>3.1.10 Give the logic waveform for a 3-input OR gate
with the input variables A, B, C and output F.
</p>
<p>3.1.11 Give the logic waveform for a 3-input XNOR
gate with the input variables A, B, C and
output F.
</p>
<p>3.1.12 Give the logic waveform for a 4-input XNOR
gate with the input variables A, B, C and
output F.
</p>
<p>Section 3.2: Digital Circuit Operation
</p>
<p>3.2.1 Using the DC operating conditions from
Table 3.2, give the noise margin HIGH (NMH)
for the 74LS logic family.
</p>
<p>3.2.2 Using the DC operating conditions from
Table 3.2, give the noise margin LOW (NML)
for the 74LS logic family.
</p>
<p>3.2.3 Using the DC operating conditions from
Table 3.2, give the noise margin HIGH (NMH)
for the 74HC logic family with VCC &frac14; +5v.
</p>
<p>3.2.4 Using the DC operating conditions from
Table 3.2, give the noise margin LOW (NML)
for the 74HC logic family with VCC &frac14; +5v.
</p>
<p>3.2.5 Using the DC operating conditions from
Table 3.2, give the noise margin HIGH (NMH)
for the 74HC logic family with VCC &frac14; +3.4v.
</p>
<p>3.2.6 Using the DC operating conditions from
Table 3.2, give the noise margin LOW (NML)
for the 74HC logic family with VCC &frac14; +3.4v.
</p>
<p>3.2.7 Using the DC operating conditions from
Table 3.2, give the noise margin HIGH (NMH)
for the 74HC logic family with VCC &frac14; +2.5v.
</p>
<p>3.2.8 Using the DC operating conditions from
Table 3.2, give the noise margin LOW (NML)
for the 74HC logic family with VCC &frac14; +2.5v.
</p>
<p>3.2.9 For the driver configuration in Fig. 3.36, give
the current flowing through the VCC pin.
</p>
<p>Fig. 3.36
Driver configuration 1
</p>
<p>3.2.10 For the driver configuration in Fig. 3.36, give
the current flowing through the GND pin.
</p>
<p>3.2.11 For the driver configuration in Fig. 3.37, give
the current flowing through the VCC pin.
</p>
<p>Fig. 3.37
Driver configuration 2
</p>
<p>3.2.12 For the driver configuration in Fig. 3.37, give
the current flowing through the GND pin.
</p>
<p>3.2.13 For the driver configuration in Fig. 3.38, give
the current flowing through the VCC pin if all of
the output pins are driving a HIGH.
</p>
<p>Exercise Problems &bull; 85</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.38
Driver configuration 3
</p>
<p>3.2.14 For the driver configuration in Fig. 3.38, give
the current flowing through the GND pin if all of
the output pins are driving a HIGH.
</p>
<p>3.2.15 For the driver configuration in Fig. 3.38, give
the current flowing through the VCC pin if all of
the output pins are driving a LOW.
</p>
<p>3.2.16 For the driver configuration in Fig. 3.38, give
the current flowing through the GND pin if all of
the output pins are driving a LOW.
</p>
<p>3.2.17 For the driver configuration in Fig. 3.38, give
the current flowing through the VCC pin if half of
the output pins are driving a HIGH and the
other half are driving a LOW.
</p>
<p>3.2.18 For the driver configuration in Fig. 3.38, give
the current flowing through the GND pin if half
of the output pins are driving a HIGH and the
other half are driving a LOW.
</p>
<p>3.2.19 For the driver configuration in Fig. 3.38, give
the current flowing through the VCC pin if six of
the output pins are driving a HIGH and two are
driving a LOW.
</p>
<p>3.2.20 For the driver configuration in Fig. 3.38, give
the current flowing through the GND pin if six of
the output pins are driving a HIGH and two are
driving a LOW.
</p>
<p>3.2.21 For the driver configuration in Fig. 3.38, give
the current flowing through the VCC pin if two of
the output pins are driving a HIGH and six are
driving a LOW.
</p>
<p>3.2.22 For the driver configuration in Fig. 3.38, give
the current flowing through the GND pin if two
of the output pins are driving a HIGH and six
are driving a LOW.
</p>
<p>3.2.23 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the VCC pin
is 25 mA, is this specification violated if all of
the outputs are driving a HIGH?
</p>
<p>3.2.24 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the VCC pin
is 25 mA, is this specification violated if six of
the outputs are driving a HIGH and two are
driving a LOW?
</p>
<p>3.2.25 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the VCC pin
is 25 mA, is this specification violated if half of
the outputs are driving a HIGH and half are
driving a LOW?
</p>
<p>3.2.26 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the VCC pin
is 25 mA, is this specification violated if two of
the outputs are driving a HIGH and six are
driving a LOW?
</p>
<p>3.2.27 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the VCC pin
is 25 mA, is this specification violated if all of
the outputs are driving a LOW?
</p>
<p>3.2.28 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the GND pin
is 25 mA, is this specification violated if all of
the outputs are driving a HIGH?
</p>
<p>3.2.29 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the GND pin
is 25 mA, is this specification violated if six of
the outputs are driving a HIGH and two are
driving a LOW?
</p>
<p>3.2.30 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the GND pin
is 25 mA, is this specification violated if half of
the outputs are driving a HIGH and half are
driving a LOW?
</p>
<p>3.2.31 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the GND pin
is 25 mA, is this specification violated if two of
the outputs are driving a HIGH and six are
driving a LOW?
</p>
<p>3.2.32 For the driver configuration in Fig. 3.38, if the
maximum current allowed through the GND pin
is 25 mA, is this specification violated if all of
the outputs are driving a LOW?
</p>
<p>3.2.33 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
the 74HC04 inverter when powered with
VCC &frac14; +2v.
</p>
<p>3.2.34 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 74HC04 inverter when
powered with VCC &frac14; +2v.
</p>
<p>3.2.35 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
</p>
<p>86 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>to low (tPHL) for the 74HC04 inverter when
powered with VCC &frac14; +2v.
</p>
<p>3.2.36 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
74HC04 inverter when powered with
VCC &frac14; +2v.
</p>
<p>3.2.37 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 74HC04
inverter when powered with VCC &frac14; +2v.
</p>
<p>3.2.38 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 74HC04
inverter when powered with VCC &frac14; +2v.
</p>
<p>3.2.39 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
the 74HC04 inverter when powered with
VCC &frac14; +4.5v.
</p>
<p>3.2.40 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 74HC04 inverter when
powered with VCC &frac14; +4.5v.
</p>
<p>3.2.41 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
to low (tPHL) for the 74HC04 inverter when
powered with VCC &frac14; +4.5v.
</p>
<p>3.2.42 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
74HC04 inverter when powered with
VCC &frac14; +4.5v.
</p>
<p>3.2.43 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 74HC04
inverter when powered with VCC &frac14; +4.5v.
</p>
<p>3.2.44 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 74HC04
inverter when powered with VCC &frac14; +4.5v.
</p>
<p>3.2.45 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
the 74HC04 inverter when powered with
VCC &frac14; +6v.
</p>
<p>3.2.46 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 74HC04 inverter when
powered with VCC &frac14; +6v.
</p>
<p>3.2.47 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
to low (tPHL) for the 74HC04 inverter when
powered with VCC &frac14; +6v.
</p>
<p>3.2.48 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
74HC04 inverter when powered with
VCC &frac14; +6v.
</p>
<p>3.2.49 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 74HC04
inverter when powered with VCC &frac14; +6v.
</p>
<p>3.2.50 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 74HC04
inverter when powered with VCC &frac14; +6v.
</p>
<p>3.2.51 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
</p>
<p>the 54HC04 inverter when powered with
VCC &frac14; +2v.
</p>
<p>3.2.52 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 54HC04 inverter when
powered with VCC &frac14; +2v.
</p>
<p>3.2.53 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
to low (tPHL) for the 54HC04 inverter when
powered with VCC &frac14; +2v.
</p>
<p>3.2.54 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
54HC04 inverter when powered with
VCC &frac14; +2v.
</p>
<p>3.2.55 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 54HC04
inverter when powered with VCC &frac14; +2v.
</p>
<p>3.2.56 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 54HC04
inverter when powered with VCC &frac14; +2v.
</p>
<p>3.2.57 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
the 54HC04 inverter when powered with
VCC &frac14; +4.5v.
</p>
<p>3.2.58 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 54HC04 inverter when
powered with VCC &frac14; +4.5v.
</p>
<p>3.2.59 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
to low (tPHL) for the 54HC04 inverter when
powered with VCC &frac14; +4.5v.
</p>
<p>3.2.60 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
54HC04 inverter when powered with
VCC &frac14; +4.5v.
</p>
<p>3.2.61 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 54HC04
inverter when powered with VCC &frac14; +4.5v.
</p>
<p>3.2.62 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 54HC04
inverter when powered with VCC &frac14; +4.5v.
</p>
<p>3.2.63 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay (tpd) for
the 54HC04 inverter when powered with
VCC &frac14; +6v.
</p>
<p>3.2.64 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from low
to high (tPLH) for the 54HC04 inverter when
powered with VCC &frac14; +6v.
</p>
<p>3.2.65 Using the data sheet excerpt from Fig. 3.20,
give the maximum propagation delay from high
to low (tPHL) for the 54HC04 inverter when
powered with VCC &frac14; +6v.
</p>
<p>3.2.66 Using the data sheet excerpt from Fig. 3.20,
give the maximum transition time (tt) for the
54HC04 inverter when powered with
VCC &frac14; +6v.
</p>
<p>Exercise Problems &bull; 87</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2.67 Using the data sheet excerpt from Fig. 3.20,
give the maximum rise time (tr) for the 54HC04
inverter when powered with VCC &frac14; +6v.
</p>
<p>3.2.68 Using the data sheet excerpt from Fig. 3.20,
give the maximum fall time (tf) for the 54HC04
inverter when powered with VCC &frac14; +6v.
</p>
<p>Section 3.3: Logic Families
</p>
<p>3.3.1 Provide the transistor-level schematic for a
4-input NAND gate.
</p>
<p>3.3.2 Provide the transistor-level schematic for a
4-input NOR gate.
</p>
<p>3.3.3 Provide the transistor-level schematic for a
5-input NAND gate.
</p>
<p>3.3.4 Provide the transistor-level schematic for a
5-input NOR gate.
</p>
<p>3.3.5 Provide the transistor-level schematic for a
NAND gate with a fan-in specification of 6.
</p>
<p>3.3.6 Provide the transistor-level schematic for a
NOR gate with a fan-in specification of 6.
</p>
<p>3.3.7 Provide the transistor-level schematic for a
2-input AND gate.
</p>
<p>3.3.8 Provide the transistor-level schematic for a
2-input OR gate.
</p>
<p>3.3.9 Provide the transistor-level schematic for a
buffer.
</p>
<p>Section 3.4: Driving Loads
</p>
<p>3.4.1 In the driver configuration shown in Fig. 3.39,
the buffer is driving its maximum fan-out speci-
fication of 6. The maximum input current for
this logic family is II &frac14; 1 nA. What is the maxi-
mum output current (IO) that the driver will need
to source?
</p>
<p>Fig. 3.39
Driver configuration 4
</p>
<p>3.4.2 In the driver configuration shown in Fig. 3.39,
the buffer is driving its maximum fan-out speci-
fication of 6. The maximum input current for
this logic family is II &frac14; 4 nA. What is the maxi-
mum output current (IO) that the driver will need
to source?
</p>
<p>3.4.3 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 50 Ω?
</p>
<p>Fig. 3.40
Driver configuration 5
</p>
<p>3.4.4 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 100 Ω?
</p>
<p>3.4.5 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 1 kΩ?
</p>
<p>3.4.6 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 50 Ω?
</p>
<p>3.4.7 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 100 Ω?
</p>
<p>3.4.8 For the pull-down driver configuration shown in
Fig. 3.40, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 1 kΩ?
</p>
<p>3.4.9 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +5v, R &frac14; 75 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.10 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +5v, R &frac14; 150 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.11 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +5v, R &frac14; 500 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.12 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +3.4v, R &frac14; 75 Ω, and IO-
MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.13 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +3.4v, R &frac14; 150 Ω, and IO-
MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.14 For the pull-down driver configuration shown in
Fig. 3.40, if VCC &frac14; +3.4v, R &frac14; 500 Ω, and IO-
</p>
<p>88 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.15 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +5v, calculate the value of
the pull-down resistor (R) in order to ensure
that the output current does not exceed 20 mA.
</p>
<p>3.4.16 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +5v, calculate the value of
the pull-down resistor (R) in order to ensure
that the output current does not exceed 25 mA.
</p>
<p>3.4.17 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +5v, calculate the value of
the pull-down resistor (R) in order to ensure
that the output current does not exceed 50 mA.
</p>
<p>3.4.18 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +3.4v, calculate the value
of the pull-down resistor (R) in order to ensure
that the output current does not exceed 20 mA.
</p>
<p>3.4.19 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +3.4v, calculate the value
of the pull-down resistor (R) in order to ensure
that the output current does not exceed 25 mA.
</p>
<p>3.4.20 For the pull-down driver configuration shown in
Fig. 3.40 with VCC &frac14; +3.4v, calculate the value
of the pull-down resistor (R) in order to ensure
that the output current does not exceed 50 mA.
</p>
<p>3.4.21 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 50 Ω?
</p>
<p>Fig. 3.41
Driver configuration 6
</p>
<p>3.4.22 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 100 Ω?
</p>
<p>3.4.23 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +5v and R &frac14; 1 kΩ?
</p>
<p>3.4.24 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 50 Ω?
</p>
<p>3.4.25 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 100 Ω?
</p>
<p>3.4.26 For the pull-up driver configuration shown in
Fig. 3.41, what is the output current (IO) if
VCC &frac14; +3.4v and R &frac14; 1 kΩ?
</p>
<p>3.4.27 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +5v, R &frac14; 75 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.28 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +5v, R &frac14; 150 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.29 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +5v, R &frac14; 500 Ω, and IO-
MAX &frac14; 50 mA, is the maximum output current
specification violated?
</p>
<p>3.4.30 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +3.4v, R &frac14; 75 Ω, and IO-
MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.31 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +3.4v, R &frac14; 150 Ω, and IO-
MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.32 For the pull-up driver configuration shown in
Fig. 3.41, if VCC &frac14; +3.4v, R &frac14; 500 Ω, and IO-
MAX &frac14; 25 mA, is the maximum output current
specification violated?
</p>
<p>3.4.33 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +5v, calculate the value
of the pull-up resistor (R) in order to ensure that
the output current does not exceed 20 mA.
</p>
<p>3.4.34 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +5v, calculate the value
of the pull-up resistor (R) in order to ensure that
the output current does not exceed 25 mA.
</p>
<p>3.4.35 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +5v, calculate the value
of the pull-up resistor (R) in order to ensure that
the output current does not exceed 50 mA.
</p>
<p>3.4.36 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +3.4v, calculate the value
of the pull-up resistor (R) in order to ensure that
the output current does not exceed 20 mA.
</p>
<p>3.4.37 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +3.4v, calculate the
value of the pull-up resistor (R) in order to
ensure that the output current does not exceed
25 mA.
</p>
<p>3.4.38 For the pull-up driver configuration shown in
Fig. 3.41 with VCC &frac14; +3.4v, calculate the
value of the pull-up resistor (R) in order to
ensure that the output current does not exceed
50 mA.
</p>
<p>3.4.39 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +5v, R &frac14; 50 Ω, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>Exercise Problems &bull; 89</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.42
Driver configuration 7
</p>
<p>3.4.40 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC&frac14; +5v, R&frac14; 100Ω, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.41 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +5v, R &frac14; 1 kΩ, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.42 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 50 Ω, and the LED has
a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.43 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 100 Ω, and the LED
has a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.44 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 1 kΩ, and the LED has
a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.45 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 75 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is the maximum
output current specification violated?
</p>
<p>3.4.46 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 150 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is the maximum
output current specification violated?
</p>
<p>3.4.47 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 500 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is the maximum
output current specification violated?
</p>
<p>3.4.48 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC &frac14; +3.4v, R &frac14; 75 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.49 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC&frac14; +3.4v, R&frac14; 150Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.50 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED, if VCC&frac14; +3.4v, R&frac14; 500Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.51 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 5 mA.
</p>
<p>3.4.52 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 12 mA.
</p>
<p>3.4.53 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 15 mA.
</p>
<p>3.4.54 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 5 mA.
</p>
<p>3.4.55 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 12 mA.
</p>
<p>3.4.56 For the LED driver configuration shown in
Fig. 3.42 where an output of HIGH on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 15 mA.
</p>
<p>3.4.57 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +5v, R &frac14; 50 Ω, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>90 &bull; Chapter 3: Digital Circuitry and Interfacing</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 3.43
Driver configuration 8
</p>
<p>3.4.58 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC&frac14; +5v, R&frac14; 100Ω, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.59 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +5v, R &frac14; 1 kΩ, and the LED has a
forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.60 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 50 Ω, and the LED has
a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.61 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 100 Ω, and the LED
has a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.62 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, what is the output current
(IO) if VCC &frac14; +3.4v, R &frac14; 1 kΩ, and the LED has
a forward voltage of Vf &frac14; 1.9v?
</p>
<p>3.4.63 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 75 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is the maximum
output current specification violated?
</p>
<p>3.4.64 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 150 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is the maximum
output current specification violated?
</p>
<p>3.4.65 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC &frac14; +5v, R &frac14; 500 Ω,
</p>
<p>Vf&frac14; 1.9v, and IO-MAX&frac14; 25mA, is themaximum
output current specification violated?
</p>
<p>3.4.66 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC &frac14; +3.4v, R &frac14; 75 Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.67 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC&frac14; +3.4v, R&frac14; 150Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.68 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED, if VCC&frac14; +3.4v, R&frac14; 500Ω,
Vf&frac14; 1.9v, and IO-MAX&frac14; 15mA, is themaximum
output current specification violated?
</p>
<p>3.4.69 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 5 mA.
</p>
<p>3.4.70 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 12 mA.
</p>
<p>3.4.71 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +5v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 15 mA.
</p>
<p>3.4.72 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 5 mA.
</p>
<p>3.4.73 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 12 mA.
</p>
<p>3.4.74 For the LED driver configuration shown in
Fig. 3.43 where an output of LOW on the driver
will turn on the LED with VCC &frac14; +3.4v and
Vf &frac14; 1.9v, calculate the value of the resistor
(R) in order to set the current through the LED
to be 15 mA.
</p>
<p>Exercise Problems &bull; 91</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 4: Combinational Logic
</p>
<p>Design
In this chapter we cover the techniques to synthesize, analyze, and manipulate logic functions. The
</p>
<p>purpose of these techniques is to ultimately create a logic circuit using the basic gates described in
</p>
<p>Chap. 3 from a truth table or word description. This process is called combinational logic design.
</p>
<p>Combinational logic refers to circuits where the output depends on the present value of the inputs.
</p>
<p>This simple definition implies that there is no storage capability in the circuitry and a change on the input
</p>
<p>immediately impacts the output. To begin, we first define the rules of Boolean algebra, which provide the
</p>
<p>framework for the legal operations and manipulations that can be taken on a two-valued number system
</p>
<p>(i.e., a binary system). We then explore a variety of logic design and manipulation techniques. These
</p>
<p>techniques allow us to directly create a logic circuit from a truth table and then to manipulate it to either
</p>
<p>reduce the number of gates necessary in the circuit or to convert the logic circuit into equivalent forms
</p>
<p>using alternate gates. The goal of this chapter is to provide an understanding of the basic principles of
</p>
<p>combinational logic design.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>4.1 Describe the fundamental principles and theorems of Boolean algebra and how to use
them to manipulate logic expressions.
</p>
<p>4.2 Analyze a combinational logic circuit to determine its logic expression, truth table, and
timing information.
</p>
<p>4.3 Synthesis a logic circuit in canonical form (sum of products or product of sums) from a
functional description including a truth table, minterm list, or maxterm list.
</p>
<p>4.4 Synthesize a logic circuit in minimized form (sum of products or product of sums) through
algebraic manipulation or with a Karnaugh map.
</p>
<p>4.5 Describe the causes of timing hazards in digital logic circuits and the approaches to
mitigate them.
</p>
<p>4.1 Boolean Algebra
</p>
<p>The term algebra refers to the rules of a number system. In Chap. 2 we discussed the number of
</p>
<p>symbols and relative values of some of the common number systems. Algebra defines the operations
</p>
<p>that are legal to perform on that system. Once we have defined the rules for a system, we can then use
</p>
<p>the system for more powerful mathematics such as solving for unknowns and manipulating into equiva-
</p>
<p>lent forms. The ability to manipulate into equivalent forms allows us to minimize the number of logic
</p>
<p>operations necessary and also put into a form that can be directly synthesized using modern logic
</p>
<p>circuits.
</p>
<p>In 1854, English mathematician George Boole presented an abstract algebraic framework for a
</p>
<p>system that contained only two states, true and false. This framework essentially launched the field of
</p>
<p>computer science even before the existence of the modern integrated circuits that are used to implement
</p>
<p>digital logic today. In 1930, American mathematician Claude Shannon applied Boole&rsquo;s algebraic frame-
</p>
<p>work to his work on switching circuits at Bell Labs, thus launching the field of digital circuit design and
</p>
<p>information theory. Boole&rsquo;s original framework is still used extensively in modern digital circuit design and
</p>
<p>thus bears the name Boolean algebra. Today, the term Boolean algebra is often used to describe not only
</p>
<p>George Boole&rsquo;s original work but all of those that contributed to the field after him.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_4
</p>
<p>93</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_4&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_4&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>4.1.1 Operations
</p>
<p>In Boolean algebra there are two valid states (true and false) and three core operations. The
</p>
<p>operations are conjunction (^, equivalent to the AND operation), disjunction (_, equivalent to the OR
</p>
<p>operation), and negation (&Oslash;, equivalent to the NOT operation). From these three operations, more
</p>
<p>sophisticated operations can be created including other logic functions (i.e., BUF, NAND, NOR, XOR,
</p>
<p>XNOR, etc.) and arithmetic. Engineers primarily use the terms AND, OR, and NOT instead of conjunc-
</p>
<p>tion, disjunction, and negation. Similarly, engineers primarily use the symbols for these operators
</p>
<p>described in Chap. 3 (e.g., ∙, +, and &lsquo;) instead of ^, _, and &Oslash;.
</p>
<p>4.1.2 Axioms
</p>
<p>An axiom is a statement of truth about a system that is accepted by the user. Axioms are very simple
</p>
<p>statements about a system but need to be established before more complicated theorems can be
</p>
<p>proposed. Axioms are so basic that they do not need to be proved in order to be accepted. Axioms
</p>
<p>can be thought of as the basic laws of the algebraic framework. The terms axiom and postulate are
</p>
<p>synonymous and used interchangeably. In Boolean algebra there are five main axioms. These axioms
</p>
<p>will appear redundant with the description of basic gates from Chap. 3 but must be defined in this
</p>
<p>algebraic context so that more powerful theorems can be proposed.
</p>
<p>4.1.2.1 Axiom #1: Logical Values
</p>
<p>This axiom states that in Boolean algebra, a variable A can only take on one of two values, 0 or 1. If
</p>
<p>the variable A is not 0, then it must be a 1, and conversely, if it is not a 1, then it must be a 0.
</p>
<p>Axiom #1 &ndash; Boolean values: A &frac14; 0 if A 6&frac14; 1, conversely A &frac14; 1 if A 6&frac14; 0.
</p>
<p>4.1.2.2 Axiom #2: Definition of Logical Negation
</p>
<p>This axiom defines logical negation. Negation is also called the NOT operation or taking the
</p>
<p>complement. The negation operation is denoted using either a prime (&lsquo;), an inversion bar or the negation
</p>
<p>symbol (&Oslash;). If the complement is taken on a 0, it becomes a 1. If the complement is taken on a 1, it
</p>
<p>becomes a 0.
</p>
<p>Axiom #2 &ndash; Definition of logical negation: if A &frac14; 0 then A&rsquo; &frac14; 1, conversely, if A &frac14; 1 then A&rsquo; &frac14; 0.
</p>
<p>4.1.2.3 Axiom #3: Definition of a Logical Product
</p>
<p>This axiom defines a logical product or multiplication. Logical multiplication is denoted using either a
</p>
<p>dot (∙), an ampersand (&amp;), or the conjunction symbol (^). The result of logical multiplication is true when
</p>
<p>both inputs are true and false otherwise.
</p>
<p>Axiom #3 &ndash; Definition of a logical product: A∙B &frac14; 1 if A &frac14; B &frac14; 1 and A∙B &frac14; 0 otherwise.
</p>
<p>4.1.2.4 Axiom #4: Definition of a Logical Sum
</p>
<p>This axiom defines a logical sum or addition. Logical addition is denoted using either a plus sign (+)
</p>
<p>or the disjunction symbol (_). The result of logical addition is true when any of the inputs are true and
</p>
<p>false otherwise.
</p>
<p>Axiom #4 &ndash; Definition of a logical sum: A + B &frac14; 1 if A &frac14; 1 or B &frac14; 1 and A + B &frac14; 0 otherwise.
</p>
<p>94 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.2.5 Axiom #5: Logical Precedence
</p>
<p>This axiom defines the order of precedence for the three operators. Unless the precedence is
</p>
<p>explicitly stated using parentheses, negation takes precedence over a logical product, and a logical
</p>
<p>product takes precedence over a logical sum.
</p>
<p>Axiom #5 &ndash; Definition of logical precedence: NOT precedes AND, and AND precedes OR.
</p>
<p>To illustrate Axiom #5, consider the logic function F&frac14;A&rsquo;∙B + C. In this function, the first operation that
</p>
<p>would take place is the NOT operation on A. This would be followed by the AND operation of A&rsquo; with
</p>
<p>B. Finally, the result would be OR&rsquo;d with C. The precedence of any function can also be explicitly stated
</p>
<p>using parentheses such as F &frac14; (((A&rsquo;) ∙ B) + C).
</p>
<p>4.1.3 Theorems
</p>
<p>A theorem is a more sophisticated truth about a system that is not intuitively obvious. Theorems are
</p>
<p>proposed and then must be proved. Once proved, they can be accepted as a truth about the system
</p>
<p>going forward. Proving a theorem in Boolean algebra is much simpler than in our traditional decimal
</p>
<p>system due to the fact that variables can only take on one of two values, true or false. Since the number
</p>
<p>of input possibilities is bounded, Boolean algebra theorems can be proved by simply testing the theorem
</p>
<p>using every possible input code. This is called proof by exhaustion. The following theorems are used
</p>
<p>widely in the manipulation of logic expressions and reduction of terms within an expression.
</p>
<p>4.1.3.1 De Morgan&rsquo;s Theorem of Duality
</p>
<p>Augustus De Morgan was a British mathematician and logician who lived during the time of George
</p>
<p>Boole. De Morgan is best known for his contribution to the field of logic through the creation of what have
</p>
<p>been later called the De Morgan&rsquo;s theorems (often called De Morgan&rsquo;s laws). There are two major
</p>
<p>theorems that De Morgan proposed that expanded Boolean algebra. The first theorem is named duality.
</p>
<p>Duality states that an algebraic equality will remain true if all 0&rsquo;s and 1&rsquo;s are interchanged and all AND
</p>
<p>and OR operations are interchanged. The new expression is called the dual of the original expression.
</p>
<p>Example 4.1 shows the process of proving duality using proof by exhaustion.
</p>
<p>4.1 Boolean Algebra &bull; 95</p>
<p/>
</div>
<div class="page"><p/>
<p>Duality is important for two reasons. First, it doubles the impact of a theorem. If a theorem is proved
</p>
<p>to be true, then the dual of that theorem is also proved to be true. This, in essence, gives twice the
</p>
<p>theorem with the same amount of proving. Boolean algebra theorems are almost always given in pairs,
</p>
<p>the original and the dual. That is why duality is covered as the first theorem.
</p>
<p>The second reason that duality is important is because it can be used to convert between positive
</p>
<p>and negative logic. Until now, we have used positive logic for all of our examples (i.e., a logic
</p>
<p>HIGH &frac14; true &frac14; 1 and a logic LOW &frac14; false &frac14; 0). As mentioned earlier, this convention is arbitrary, and
</p>
<p>we could have easily chosen a HIGH to be false and a LOW to be true (i.e., negative logic). Duality allows
</p>
<p>us to take a logic expression that has been created using positive logic (F) and then convert it into an
</p>
<p>equivalent expression that is valid for negative logic (FD). Example 4.2 shows the process for how this
</p>
<p>works.
</p>
<p>Example 4.1
Proving De Morgan&rsquo;s theorem of duality using proof by exhaustion
</p>
<p>96 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>One consideration when using duality is that the order of precedence follows the original function.
</p>
<p>This means that in the original function, the axiom for precedence states the order as NOT-AND-OR;
</p>
<p>however, this is not necessarily the correct precedence order in the dual. For example, if the original
</p>
<p>function was F&frac14;A�B + C, the AND operation of A and B would take place first, and then the result would
</p>
<p>be OR&rsquo;d with C. The dual of this expression is FD&frac14; A + B�C. If the expression for FD was evaluated using
</p>
<p>traditional Boolean precedence, it would show that FD does NOT give the correct result per the definition
</p>
<p>of a dual function (i.e., converting a function from positive to negative logic). The order of precedence for
</p>
<p>FD must correlate to the precedence in the original function. Since in the original function A and B were
</p>
<p>operated on first, they must also be operated on first in the dual. In order to easily manage this issue,
</p>
<p>parentheses can be used to track the order of operations from the original function to the dual. If we put
</p>
<p>parentheses in the original function to explicitly state the precedence of the operations, it would take the
</p>
<p>form F &frac14; (A�B) + C. These parentheses can be mapped directly to the dual yielding FD &frac14; (A + B)�C. This
</p>
<p>order of precedence in the dual is now correct.
</p>
<p>Example 4.2
Converting between positive and negative logic using duality
</p>
<p>4.1 Boolean Algebra &bull; 97</p>
<p/>
</div>
<div class="page"><p/>
<p>Now that we have covered the duality operation, its usefulness and its pitfalls, we can formally
</p>
<p>define this theorem as:
</p>
<p>De Morgan&rsquo;s Duality: An algebraic equality will remain true if all 0&rsquo;s and 1&rsquo;s are interchanged and all
</p>
<p>AND and OR operations are interchanged. Furthermore, taking the dual of a positive logic function will
</p>
<p>produce the equivalent function using negative logic if the original order of precedence is maintained.
</p>
<p>4.1.3.2 Identity
</p>
<p>An identity operation is one that when performed on a variable will yield itself regardless of the
</p>
<p>variable&rsquo;s value. The following is the formal definition of identity theorem. Figure 4.1 shows the gate-level
</p>
<p>depiction of this theorem.
</p>
<p>Identity:OR&rsquo;ing any variable with a logic 0 will yield the original variable. The dual: AND&rsquo;ing any variable
</p>
<p>with a logic 1 will yield the original variable.
</p>
<p>The identity theorem is useful for reducing circuitry when it is discovered that a particular input will
</p>
<p>never change values. When this is the case, the static input variable can simply be removed from the
</p>
<p>logic expression making the entire circuit a simple wire from the remaining input variable to the output.
</p>
<p>4.1.3.3 Null Element
</p>
<p>A null element operation is one that, when performed on a constant value, will yield that same
</p>
<p>constant value regardless of the values of any variables within the same operation. The following is the
</p>
<p>formal definition of null element. Figure 4.2 shows the gate-level depiction of this theorem.
</p>
<p>Null Element: OR&rsquo;ing any variable with a logic 1 will yield a logic 1 regardless of the value of the input
</p>
<p>variable. The dual: AND&rsquo;ing any variable with a logic 0 will yield a logic 0 regardless of the value of the
</p>
<p>input variable.
</p>
<p>Fig. 4.1
Gate-level depiction of the identity theorem
</p>
<p>Fig. 4.2
Gate-level depiction of the null element theorem
</p>
<p>98 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>The null element theorem is also useful for reducing circuitry when it is discovered that a particular
</p>
<p>input will never change values. It is also widely used in computer systems in order to set (i.e., force to a
</p>
<p>logic 1) or clear (i.e., force to a logic 0) the value of a storage element.
</p>
<p>4.1.3.4 Idempotent
</p>
<p>An idempotent operation is one that has no effect on the input, regardless of the number of times the
</p>
<p>operation is applied. The following is the formal definition of idempotence. Figure 4.3 shows the gate-
</p>
<p>level depiction of this theorem.
</p>
<p>Idempotent:OR&rsquo;ing a variable with itself results in itself. The dual: AND&rsquo;ing a variable with itself results in
</p>
<p>itself.
</p>
<p>This theorem also holds true for any number of operations such as A + A + A + . . . .. + A &frac14; A and
</p>
<p>A�A�A�. . . ..�A &frac14; A.
</p>
<p>4.1.3.5 Complements
</p>
<p>This theorem describes an operation of a variable with the variable&rsquo;s own complement. The
</p>
<p>following is the formal definition of complements. Figure 4.4 shows the gate-level depiction of this
</p>
<p>theorem.
</p>
<p>Complements: OR&rsquo;ing a variable with its complement will produce a logic 1. The dual: AND&rsquo;ing a
</p>
<p>variable with its complement will produce a logic 0.
</p>
<p>The complement theorem is again useful for reducing circuitry when these types of logic
</p>
<p>expressions are discovered.
</p>
<p>Fig. 4.3
Gate-level depiction of the idempotent theorem
</p>
<p>Fig. 4.4
Gate-level depiction of the complements theorem
</p>
<p>4.1 Boolean Algebra &bull; 99</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.3.6 Involution
</p>
<p>An involution operation describes the result of double negation. The following is the formal definition
</p>
<p>of involution. Figure 4.5 shows the gate-level depiction of this theorem.
</p>
<p>Involution: Taking the double complement of a variable will result in the original variable.
</p>
<p>This theorem is not only used to eliminate inverters but also provides us a powerful tool for inserting
</p>
<p>inverters in a circuit. We will see that this is used widely with the second of De Morgan&rsquo;s laws that will be
</p>
<p>introduced at the end of this section.
</p>
<p>4.1.3.7 Commutative Property
</p>
<p>The term commutative is used to describe an operation in which the order of the quantities or
</p>
<p>variables in the operation has no impact on the result. The following is the formal definition of the
</p>
<p>commutative property. Figure 4.6 shows the gate-level depiction of this theorem.
</p>
<p>Commutative Property: Changing the order of variables in an OR operation does not change the end
</p>
<p>result. The dual: Changing the order of variables in an AND operation does not change the end result.
</p>
<p>One practical use of the commutative property is when wiring or routing logic circuitry together.
</p>
<p>Example 4.3 shows how the commutative property can be used to untangle crossed wires when
</p>
<p>implementing a digital system.
</p>
<p>Fig. 4.5
Gate-level depiction of the involution theorem
</p>
<p>Fig. 4.6
Gate-level depiction of commutative property
</p>
<p>100 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.3.8 Associative Property
</p>
<p>The term associative is used to describe an operation in which the grouping of the quantities or
</p>
<p>variables in the operation has no impact on the result. The following is the formal definition of the
</p>
<p>associative property. Figure 4.7 shows the gate-level depiction of this theorem.
</p>
<p>Example 4.3
Using the commutative property to untangle crossed wires
</p>
<p>4.1 Boolean Algebra &bull; 101</p>
<p/>
</div>
<div class="page"><p/>
<p>Associative Property: The grouping of variables doesn&rsquo;t impact the result of an OR operation. The dual:
</p>
<p>The grouping of variables doesn&rsquo;t impact the result of an AND operation.
</p>
<p>One practical use of the associative property is addressing fan-in limitations of a logic family. Since
</p>
<p>the grouping of the input variables does not impact the result, we can accomplish operations with large
</p>
<p>numbers of inputs using multiple gates with fewer inputs. Example 4.4 shows the process of using the
</p>
<p>associative property to address a fan-in limitation.
</p>
<p>Fig. 4.7
Gate-level depiction of the associative property
</p>
<p>Example 4.4
Using the associative property to address fan-in limitations
</p>
<p>102 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.3.9 Distributive Property
</p>
<p>The term distributive describes how an operation on a parenthesized group of operations (or higher
</p>
<p>precedence operations) can be distributed through each term. The following is the formal definition of the
</p>
<p>distributive property. Figure 4.8 shows the gate-level depiction of this theorem.
</p>
<p>Distributive Property: An operation on a parenthesized operation(s), or higher precedence operator,
</p>
<p>will distribute through each term.
</p>
<p>The distributive property is used as a logic manipulation technique. It can be used to put a logic
</p>
<p>expression into a form more suitable for direct circuit synthesis or to reduce the number of logic gates
</p>
<p>necessary. Example 4.5 shows how to use the distributive property to reduce the number of gates in a
</p>
<p>logic circuit.
</p>
<p>Fig. 4.8
Gate-level depiction of the distributive property
</p>
<p>Example 4.5
Using the distributive property to reduce the number of logic gates in a circuit
</p>
<p>4.1 Boolean Algebra &bull; 103</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.3.10 Absorption
</p>
<p>The term absorption refers to when multiple logic terms within an expression produce the same
</p>
<p>results. This allows one of the terms to be eliminated from the expression, thus reducing the number of
</p>
<p>logic operations. The remaining terms essentially absorb the functionality of the eliminated term. This
</p>
<p>theorem is also called covering because the remaining term essentially covers the functionality of both
</p>
<p>itself and the eliminated term. The following is the formal definition of the absorption theorem. Figure 4.9
</p>
<p>shows the gate-level depiction of this theorem.
</p>
<p>Absorption: When a term within a logic expression produces the same output(s) as another term, the
</p>
<p>second term can be removed without affecting the result.
</p>
<p>This theorem is better understood by looking at the evaluation of each term with respect to the
</p>
<p>original expression. Example 4.6 shows how the absorption theorem can be proven through proof by
</p>
<p>exhaustion by evaluating each term in a logic expression.
</p>
<p>Fig. 4.9
Gate-level depiction of absorption
</p>
<p>Example 4.6
Proving the absorption theorem using proof by exhaustion
</p>
<p>104 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.1.3.11 Uniting
</p>
<p>The uniting theorem, also called combining orminimization, provides a way to remove variables from
</p>
<p>an expression when they have no impact on the outcome. This theorem is one of the most widely used
</p>
<p>techniques for the reduction of the number of gates needed in a combinational logic circuit. The following
</p>
<p>is the formal definition of the uniting theorem. Figure 4.10 shows the gate-level depiction of this theorem.
</p>
<p>Uniting: When a variable (B) and its complement (B&rsquo;) appear in multiple product terms with a common
</p>
<p>variable (A) within a logical OR operation, the variable B does not have any effect on the result and can
</p>
<p>be removed.
</p>
<p>This theorem can be proved using prior theorems. Example 4.7 shows how the uniting theorem can
</p>
<p>be proved using a combination of the distributive property, the complements theorem, and the identity
</p>
<p>theorem.
</p>
<p>4.1.3.12 De Morgan&rsquo;s Theorem
</p>
<p>Now we look at the second of De Morgan&rsquo;s laws. This second theorem is simply known as De
</p>
<p>Morgan&rsquo;s theorem. This theorem provides a technique to manipulate a logic expression that uses AND
</p>
<p>gates into one that uses OR gates and vice versa. It can also be used to manipulate traditional Boolean
</p>
<p>logic expressions that use AND-OR-NOT operators, into equivalent forms that uses NAND and NOR
</p>
<p>Fig. 4.10
Gate-level depiction of uniting
</p>
<p>Example 4.7
Proving of the uniting theorem
</p>
<p>4.1 Boolean Algebra &bull; 105</p>
<p/>
</div>
<div class="page"><p/>
<p>gates. The following is the formal definition of De Morgan&rsquo;s theorem. Figure 4.11 shows the gate-level
</p>
<p>depiction of this theorem.
</p>
<p>De Morgan&rsquo;s Theorem: An OR operation with both inputs inverted is equivalent to an AND operation
</p>
<p>with the output inverted. The dual: An AND operation with both inputs inverted is equivalent to an OR
</p>
<p>operation with the output inverted.
</p>
<p>This theorem is used widely in modern logic design because it bridges the gap between the design
</p>
<p>of logic circuitry using Boolean algebra and the physical implementation of the circuitry using CMOS.
</p>
<p>Recall that Boolean algebra is defined for only three operations, the AND, the OR, and the inversion.
</p>
<p>CMOS, on the other hand, can only directly implement negative-type gates such as NAND, NOR, and
</p>
<p>NOT. De Morgan&rsquo;s theorem allows us to design logic circuitry using Boolean algebra and synthesize
</p>
<p>logic diagrams with AND, OR, and NOT gates and then directly convert the logic diagrams into an
</p>
<p>equivalent form using NAND, NOR, and NOT gates. As we&rsquo;ll see in the next section, Boolean algebra
</p>
<p>produces logic expressions in two common forms. These are the sum of products (SOP) and the
</p>
<p>product of sums (POS) forms. Using a combination of involution and De Morgan&rsquo;s theorem, SOP and
</p>
<p>POS forms can be converted into equivalent logic circuits that use only NAND and NOR gates. Example
</p>
<p>4.8 shows a process to convert a sum of products form into one that uses only NAND gates.
</p>
<p>Fig. 4.11
Gate-level depiction of De Morgan&rsquo;s theorem
</p>
<p>106 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 4.9 shows a process to convert a product of sums form into one that uses only NOR gates.
</p>
<p>Example 4.8
Converting a sum of products form into one that uses only NAND gates
</p>
<p>4.1 Boolean Algebra &bull; 107</p>
<p/>
</div>
<div class="page"><p/>
<p>De Morgan&rsquo;s theorem can also be accomplished algebraically using a process known as breaking
</p>
<p>the bar and flipping the operator. This process again takes advantage of the involution theorem, which
</p>
<p>allows double negation without impacting the result. When using this technique in algebraic form,
</p>
<p>involution takes the form of a double inversion bar. If an inversion bar is broken, the expression will
</p>
<p>remain true as long as the operator directly below the break is flipped (AND to OR, OR to AND). Example
</p>
<p>4.10 shows how to use this technique when converting an OR gate with its inputs inverted into an AND
</p>
<p>gate with its output inverted.
</p>
<p>Example 4.9
Converting a product of sums form into one that uses only NOR gates
</p>
<p>108 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 4.11 shows how to use this technique when converting an AND gate with its inputs inverted
</p>
<p>into an OR gate with its output inverted.
</p>
<p>Example 4.10
Using De Morgan&rsquo;s theorem in algebraic form (1)
</p>
<p>Example 4.11
Using De Morgan&rsquo;s theorem in algebraic form (2)
</p>
<p>4.1 Boolean Algebra &bull; 109</p>
<p/>
</div>
<div class="page"><p/>
<p>Table 4.1 gives a summary of all the Boolean algebra theorems just covered. The theorems are
</p>
<p>grouped in this table with respect to the number of variables that they contain. This grouping is the most
</p>
<p>common way these theorems are presented.
</p>
<p>4.1.4 Functionally Complete Operation Sets
</p>
<p>A set of Boolean operators is said to be functionally complete when the set can implement all
</p>
<p>possible logic functions. The set of operators {AND, OR, NOT} is functionally complete because every
</p>
<p>other operation can be implemented using these three operators (i.e., NAND, NOR, BUF, XOR, XNOR).
</p>
<p>The De Morgan&rsquo;s theorem showed us that all AND and OR operations can be replaced with NAND and
</p>
<p>NOR operators. This means that NAND and NOR operations could be by themselves functionally
</p>
<p>complete if they could perform a NOToperation. Figure 4.12 shows how a NAND gate can be configured
</p>
<p>to perform a NOT operation. This configuration allows a NAND gate to be considered functionally
</p>
<p>complete because all other operations can be implemented.
</p>
<p>Table 4.1
Summary of Boolean algebra theorems
</p>
<p>Fig. 4.12
Configuration to use a NAND gate as an inverter
</p>
<p>110 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>This approach can also be used on a NOR gate to implement an inverter. Figure 4.13 shows how a
</p>
<p>NOR gate can be configured to perform a NOToperation, thus also making it functionally complete.
</p>
<p>CONCEPT CHECK
</p>
<p>CC4.1 If the logic expression F &frac14; A�B�C�D�E�F�G�H is implemented with only 2-input AND
gates, how many levels of logic will the final implementation have? Hint: Consider using
the associative property to manipulate the logic expression to use only 2-input AND
operations.
</p>
<p>A) 2 B) 3 C) 4 D) 5
</p>
<p>4.2 Combinational Logic Analysis
</p>
<p>Combinational logic analysis refers to the act of deciphering the operation of a circuit from its final
</p>
<p>logic diagram. This is a useful skill that can aid designers when debugging their circuits. This can also be
</p>
<p>used to understand the timing performance of a circuit and to reverse-engineer an unknown design.
</p>
<p>4.2.1 Finding the Logic Expression from a Logic Diagram
</p>
<p>Combinational logic diagrams are typically written with their inputs on the left and their output on the
</p>
<p>right. As the inputs change, the intermediate nodes, or connections, within the diagram hold the interim
</p>
<p>computations that contribute to the ultimate circuit output. These computations propagate from left to
</p>
<p>right until ultimately the final output of the system reaches its final steady-state value. When analyzing
</p>
<p>the behavior of a combinational logic circuit, a similar left-to-right approach is used. The first step is to
</p>
<p>label each intermediate node in the system. The second step is to write in the logic expression for each
</p>
<p>Fig. 4.13
Configuration to use a NOR gate as an inverter
</p>
<p>4.2 Combinational Logic Analysis &bull; 111</p>
<p/>
</div>
<div class="page"><p/>
<p>node based on the preceding logic operation(s). The logic expressions are written working left-to-right
</p>
<p>until the output of the system is reached and the final logic expression of the circuit has been found.
</p>
<p>Consider the example of this analysis in Example 4.12.
</p>
<p>4.2.2 Finding the Truth Table from a Logic Diagram
</p>
<p>The final truth table of a circuit can also be found in a similar manner as the logic expression. Each
</p>
<p>internal node within the logic diagram can be evaluated working from the left to the right for each possible
</p>
<p>input code. Each subsequent node can then be evaluated using the values of the preceding nodes.
</p>
<p>Consider the example of this analysis is Example 4.13.
</p>
<p>Example 4.12
Determining the logic expression from a logic diagram
</p>
<p>112 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.2.3 Timing Analysis of a Combinational Logic Circuit
</p>
<p>Real logic gates have a propagation delay (tpd, tPHL, or tPLH) as presented in Chap. 3. Performing a
</p>
<p>timing analysis on a combinational logic circuit refers to observing how long it takes for a change in the
</p>
<p>inputs to propagate to the output. Different paths through the combinational logic circuit will take different
</p>
<p>times to compute since they may use gates with different delays. When determining the delay of the
</p>
<p>entire combinational logic circuit, we always consider the longest delay path. This is because this delay
</p>
<p>represents the worst-case scenario. As long as we wait for the longest path to propagate through the
</p>
<p>circuit, then we are ensured that the output will always be valid after this time. To determine which signal
</p>
<p>path has the longest delay, we map out each and every path the inputs can take to the output of the
</p>
<p>circuit. We then sum up the gate delay along each path. The path with the longest delay dictates the
</p>
<p>delay of the entire combinational logic circuit. Consider this analysis shown in Example 4.14.
</p>
<p>Example 4.13
Determining the truth table from a logic diagram
</p>
<p>4.2 Combinational Logic Analysis &bull; 113</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC4.2 Does the delay specification of a combinational logic circuit change based on the input
values that the circuit is evaluating?
</p>
<p>A) Yes. There are times when the inputs switch between inputs codes that use
paths through the circuit with different delays.
</p>
<p>B) No. The delay is always specified as the longest delay path.
</p>
<p>C) Yes. The delay can vary between the longest delay path and zero. A delay of
zero occurs when the inputs switch between two inputs codes that produce the
same output.
</p>
<p>D) No. The output is always produced at a time equal to the longest delay path.
</p>
<p>Example 4.14
Determining the delay of a combinational logic circuit
</p>
<p>114 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3 Combinational Logic Synthesis
</p>
<p>4.3.1 Canonical Sum of Products
</p>
<p>One technique to directly synthesize a logic circuit from a truth table is to use a canonical sum of
</p>
<p>products topology based on minterms. The term canonical refers to this topology yielding potentially
</p>
<p>unminimized logic. A minterm is a product term (i.e., an AND operation) that will be true for one and only
</p>
<p>one input code. The minterm must contain every input variable in its expression. Complements are
</p>
<p>applied to the input variables as necessary in order to produce a true output for the individual input code.
</p>
<p>We define the word literal to describe an input variable which may or may not be complemented. This is a
</p>
<p>more useful word because if we say that a minterm &ldquo;must include all variables,&rdquo; it implies that all variables
</p>
<p>are included in the term uncomplemented. A more useful statement is that a minterm &ldquo;must include all
</p>
<p>literals.&rdquo; This now implies that each variable must be included, but it can be in the form of itself or its
</p>
<p>complement (e.g., A or A&rsquo;). Figure 4.14 shows the definition and gate-level depiction of a minterm
</p>
<p>expression. Each minterm can be denoted using the lower case &ldquo;m&rdquo; with the row number as a subscript.
</p>
<p>For an arbitrary truth table, a minterm can be used for each row corresponding to a true output. If
</p>
<p>each of these minterms&rsquo; outputs are fed into a single OR gate, then a sum of products logic circuit is
</p>
<p>formed that will produce the logic listed in the truth table. In this topology, any input code that corresponds
</p>
<p>to an output of 1 will cause its corresponding minterm to output a 1. Since a 1 on any input of an OR gate
</p>
<p>will cause the output to go to a 1, the output of the minterm is passed to the final result. Example 4.15
</p>
<p>shows this process. One important consideration of this approach is that no effort has been taken to
</p>
<p>minimize the logic expression. This unminimized logic expression is also called the canonical sum. The
</p>
<p>canonical sum is logically correct but uses the most amount of circuitry possible for a given truth table.
</p>
<p>This canonical sum can be the starting point for minimization using Boolean algebra.
</p>
<p>Fig. 4.14
Definition and gate-level depiction of a minterm
</p>
<p>4.3 Combinational Logic Synthesis &bull; 115</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.2 The Minterm List (Σ)
</p>
<p>Aminterm list is a compact way to describe the functionality of a logic circuit by simply listing the row
</p>
<p>numbers that correspond to an output of 1 in the truth table. The &sum; symbol is used to denote a minterm
</p>
<p>list. All input variables must be listed in the order they appear in the truth table. This is necessary because
</p>
<p>Example 4.15
Creating a canonical sum of products logic circuit using minterms
</p>
<p>116 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>since a minterm list uses only the row numbers to indicate which input codes result in an output of 1, the
</p>
<p>minterm list must indicate how many variables comprise the row number, which variable is in the most
</p>
<p>significant position, and which is in the least significant position. After the &sum; symbol, the row numbers
</p>
<p>corresponding to a true output are listed in a comma-delimited format within parentheses. Example 4.16
</p>
<p>shows the process for creating a minterm list from a truth table.
</p>
<p>A minterm list contains the same information as the truth table, the canonical sum and the canonical
</p>
<p>sum of products logic diagram. Since the minterms themselves are formally defined for an input code, it
</p>
<p>is trivial to go back and forth between the minterm list and these other forms. Example 4.17 shows how a
</p>
<p>minterm list can be used to generate an equivalent truth table, canonical sum, and canonical sum of
</p>
<p>products logic diagram.
</p>
<p>Example 4.16
Creating a minterm list from a truth table
</p>
<p>4.3 Combinational Logic Synthesis &bull; 117</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.3 Canonical Product of Sums (POS)
</p>
<p>Another technique to directly synthesize a logic circuit from a truth table is to use a canonical product
</p>
<p>of sums topology based onmaxterms. A maxterm is a sum term (i.e., an OR operation) that will be false
</p>
<p>for one and only one input code. The maxterm must contain every literal in its expression. Complements
</p>
<p>are applied to the input variables as necessary in order to produce a false output for the individual input
</p>
<p>code. Figure 4.15 shows the definition and gate-level depiction of a maxterm expression. Each maxterm
</p>
<p>can be denoted using the upper case &ldquo;M&rdquo; with the row number as a subscript.
</p>
<p>Example 4.17
Creating equivalent functional representations from a minterm list
</p>
<p>118 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>For an arbitrary truth table, a maxterm can be used for each row corresponding to a false output. If
</p>
<p>each of these maxterms outputs are fed into a single AND gate, then a product of sums logic circuit is
</p>
<p>formed that will produce the logic listed in the truth table. In this topology, any input code that corresponds
</p>
<p>to an output of 0 will cause its corresponding maxterm to output a 0. Since a 0 on any input of an AND
</p>
<p>gate will cause the output to go to a 0, the output of the maxterm is passed to the final result. Example
</p>
<p>4.18 shows this process. This approach is complementary to the sum of products approach. In the sum
</p>
<p>of products approach based on minterms, the circuit operates by producing 1&rsquo;s that are passed to the
</p>
<p>output for the rows that require a true output. For all other rows, the output is false. A product of sums
</p>
<p>approach based on maxterms operates by producing 0&rsquo;s that are passed to the output for the rows that
</p>
<p>require a false output. For all other rows, the output is true. These two approaches produce the
</p>
<p>equivalent logic functionality. Again, at this point no effort has been taken to minimize the logic expres-
</p>
<p>sion. This unminimized form is called a canonical product. The canonical product is logically correct but
</p>
<p>uses the most amount of circuitry possible for a given truth table. This canonical product can be the
</p>
<p>starting point for minimization using the Boolean algebra theorems.
</p>
<p>Fig. 4.15
Definition and gate-level depiction of a maxterm
</p>
<p>4.3 Combinational Logic Synthesis &bull; 119</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.4 The Maxterm List (Π)
</p>
<p>Amaxterm list is a compact way to describe the functionality of a logic circuit by simply listing the row
</p>
<p>numbers that correspond to an output of 0 in the truth table. The Π symbol is used to denote a maxterm
</p>
<p>list. All literals used in the logic expression must be listed in the order they appear in the truth table. After
</p>
<p>the Π symbol, the row numbers corresponding to a false output are listed in a comma-delimited format
</p>
<p>within parentheses. Example 4.19 shows the process for creating a maxterm list from a truth table.
</p>
<p>Example 4.18
Creating a product of sums logic circuit using maxterms
</p>
<p>120 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>A maxterm list contains the same information as the truth table, the canonical product, and the
</p>
<p>canonical product of sums logic diagram. Example 4.20 shows how a maxterm list can be used to
</p>
<p>generate these equivalent forms.
</p>
<p>Example 4.19
Creating a maxterm list from a truth table
</p>
<p>4.3 Combinational Logic Synthesis &bull; 121</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.5 Minterm and Maxterm List Equivalence
</p>
<p>The examples in Examples 4.17 and 4.20 illustrate how minterm and maxterm lists produce the
</p>
<p>exact same logic functionality but in a complementary fashion. It is trivial to switch back and forth
</p>
<p>between minterm lists and maxterm lists. This is accomplished by simply changing the list type (i.e.,
</p>
<p>min to max, max to min) and then switching the row numbers between those listed and those not listed.
</p>
<p>Example 4.21 shows multiple techniques for representing equivalent logic functionality as a truth table.
</p>
<p>Example 4.20
Creating equivalent functional representations from a maxterm list
</p>
<p>122 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 4.21
Creating equivalent forms to represent logic functionality
</p>
<p>4.3 Combinational Logic Synthesis &bull; 123</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC4.3 All logic functions can be implemented equivalently using either a canonical sum of
products (SOP) or canonical product of sums (POS) topology. Which of these
statements is true with respect to selecting a topology that requires the least amount
of gates?
</p>
<p>A) Since a minterm list and a maxterm list can both be written to describe the
same logic functionality, the number of gates in an SOP and POS will always
be the same.
</p>
<p>B) If a minterm list has over half of its row numbers listed, an SOP topology will
require fewer gates than a POS.
</p>
<p>C) A POS topology always requires more gates because it needs additional logic
to convert the inputs from positive to negative logic.
</p>
<p>D) If a minterm list has over half of its row numbers listed, a POS topology will
require fewer gates than SOP.
</p>
<p>4.4 Logic Minimization
</p>
<p>We now look at how to reduce the canonical expressions into equivalent forms that use less logic.
</p>
<p>This minimization is key to reducing the complexity of the logic prior to implementing in real circuitry. This
</p>
<p>reduces the number of gates needed, placement area, wiring, and power consumption of the logic circuit.
</p>
<p>4.4.1 Algebraic Minimization
</p>
<p>Canonical expressions can be reduced algebraically by applying the theorems covered in prior
</p>
<p>sections. This process typically consists of a series of factoring based on the distributive property
</p>
<p>followed by replacing variables with constants (i.e., 0&rsquo;s and 1&rsquo;s) using the complements theorem. Finally,
</p>
<p>constants are removed using the identity theorem. Example 4.22 shows this process.
</p>
<p>124 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>The primary drawback of this approach is that it requires recognition of where the theorems can be
</p>
<p>applied. This can often lead to missed minimizations. Computer automation is often the best mechanism
</p>
<p>to perform this minimization for large logic expressions.
</p>
<p>4.4.2 Minimization Using Karnaugh Maps
</p>
<p>A Karnaugh map is a graphical way to minimize logic expressions. This technique is named after
</p>
<p>Maurice Karnaugh, American physicist, who introduced themap in its latest form in 1953 while working at
</p>
<p>Bell Labs. The Karnaugh map (or K-map) is a way to put a truth table into a form that allows logic
</p>
<p>minimization through a graphical process. This technique provides a graphical process that
</p>
<p>accomplishes the same result as factoring variables via the distributive property and removing variables
</p>
<p>via the complements and identity theorems. K-maps present a truth table in a form that allows variables
</p>
<p>to be removed from the final logic expression in a graphical manner.
</p>
<p>Example 4.22
Minimizing a logic expression algebraically
</p>
<p>4.4 Logic Minimization &bull; 125</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.2.1 Formation of a K-Map
</p>
<p>A K-map is constructed as a two-dimensional grid. Each cell within the map corresponds to the
</p>
<p>output for a specific input code. The cells are positioned such that neighboring cells only differ by one bit
</p>
<p>in their input codes. Neighboring cells are defined as cells immediately adjacent horizontally and
</p>
<p>immediately adjacent vertically. Two cells positioned diagonally next to each other are not considered
</p>
<p>neighbors. The input codes for each variable are listed along the top and side of the K-map. Consider the
</p>
<p>construction of a 2-input K-map shown in Fig. 4.16.
</p>
<p>When constructing a 3-input K-map, it is important to remember that each input code can only differ
</p>
<p>from its neighbor by one bit. For example, the two codes 01 and 10 differ by two bits (i.e., the MSB is
</p>
<p>different and the LSB is different); thus they could not be neighbors; however, the codes 01-11 and 11-10
</p>
<p>can be neighbors. As such, the input codes along the top of the 3-input K-map must be ordered
</p>
<p>accordingly (i.e., 00-01-11-10). Consider the construction of a 3-input K-map shown in Fig. 4.17. The
</p>
<p>rows and columns that correspond to the input literals can now span multiple rows and columns. Notice
</p>
<p>how in this 3-input K-map, the literals A, A&rsquo;, B, and B&rsquo; all correspond to two columns. Also, notice that B&rsquo;
</p>
<p>spans two columns, but the columns are on different edges of the K-map. The side edges of the 3-input
</p>
<p>K-map are still considered neighbors because the input codes for these columns only differ by one bit.
</p>
<p>This is an important attribute once we get to the minimization of variables because it allows us to
</p>
<p>examine an input literal&rsquo;s impact not only within the obvious adjacent cells but also when the variables
</p>
<p>wrap around the edges of the K-map.
</p>
<p>Fig. 4.16
Formation of a 2-input K-map
</p>
<p>126 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>When constructing a 4-input K-map, the same rules apply that the input codes can only differ from
</p>
<p>their neighbors by one bit. Consider the construction of a 4-input K-map in Fig. 4.18. In a 4-input K-map,
</p>
<p>neighboring cells can wrap around both the top-to-bottom edges in addition to the side-to-side edges.
</p>
<p>Notice that all 16 cells are positioned within the map so that their neighbors on the top, bottom, and sides
</p>
<p>only differ by one bit in their input codes.
</p>
<p>Fig. 4.17
Formation of a 3-input K-map
</p>
<p>4.4 Logic Minimization &bull; 127</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.2.2 Logic Minimization Using K-Maps (Sum of Products)
</p>
<p>Now we look at using a K-map to create a minimized logic expression in a SOP form. Remember
</p>
<p>that each cell with an output of 1 has a minterm associated with it, just as in the truth table. When two
</p>
<p>neighboring cells have outputs of 1, it graphically indicates that the two minterms can be reduced into a
</p>
<p>minimized product term that will cover both outputs. Consider the example given in Fig. 4.19.
</p>
<p>Fig. 4.18
Formation of a 4-input K-map
</p>
<p>128 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>These observations can be put into a formal process to produce a minimized SOP logic expression
</p>
<p>using a K-map. The steps are as follows:
</p>
<p>1. Circle groups of 1&rsquo;s in the K-map following the rules:
</p>
<p>&bull; Each circle should contain the largest number of 1&rsquo;s possible.
</p>
<p>&bull; The circles encompass only neighboring cells (i.e., side-to-side sides and/or top and
bottom).
</p>
<p>&bull; The circles must contain a number of 1&rsquo;s that is a power of 2 (i.e., 1, 2, 4, 8, or 16).
</p>
<p>&bull; Enter as many circles as possible without having any circles fully cover another circle.
</p>
<p>&bull; Each circle is called a prime implicant.
</p>
<p>2. Create a product term for each prime implicant following the rules:
</p>
<p>&bull; Each variable in the K-map is evaluated one by one.
</p>
<p>&bull; If the circle covers a region where the input variable is a 1, then include it in the product
term uncomplemented.
</p>
<p>&bull; If the circle covers a region where the input variable is a 0, then include it in the product
term complemented.
</p>
<p>&bull; If the circle covers a region where the input variable is both a 0 and 1, then the variable is
excluded from the product term.
</p>
<p>3. Sum all of the product terms for each prime implicant.
</p>
<p>Fig. 4.19
Observing how K-maps visually highlight logic minimizations
</p>
<p>4.4 Logic Minimization &bull; 129</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s apply this approach to our 2-input K-map example. Example 4.23 shows the process of finding
</p>
<p>a minimized sum of products logic expression for a 2-input logic circuit using a K-map. This process
</p>
<p>yielded the same SOP expression as the algebraic minimization and observations shown in Fig. 4.19,
</p>
<p>but with a formalized process.
</p>
<p>Let&rsquo;s now apply this process to our 3-input K-map example. Example 4.24 shows the process of
</p>
<p>finding a minimized sum of products logic expression for a 3-input logic circuit using a K-map. This
</p>
<p>example shows circles that overlap. This is legal as long as one circle does not fully encompass another.
</p>
<p>Overlapping circles are common since the K-map process dictates that circles should be drawn that
</p>
<p>group the largest number of ones possible as long as they are in powers of 2. Forming groups of ones
</p>
<p>using ones that have already been circled is perfectly legal to accomplish larger groupings. The larger
</p>
<p>the grouping of ones, the more chance there is for a variable to be excluded from the product term. This
</p>
<p>results in better minimization of the logic.
</p>
<p>Example 4.23
Using a K-map to find a minimized sum of products expression (2-Input)
</p>
<p>130 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s now apply this process to our 4-input K-map example. Example 4.25 shows the process of
</p>
<p>finding a minimized sum of products logic expression for a 4-input logic circuit using a K-map.
</p>
<p>Example 4.24
Using a K-map to find a minimized sum of products expression (3-input)
</p>
<p>4.4 Logic Minimization &bull; 131</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.2.3 Logic Minimization Using K-Maps (Product of Sums)
</p>
<p>K-maps can also be used to create minimized product of sums logic expressions. This is the same
</p>
<p>concept as how a minterm list and maxterm list each produce the same logic function, but in comple-
</p>
<p>mentary fashions. When creating a product of sums expression from a K-map, groups of 0&rsquo;s are circled.
</p>
<p>For each circle, a sum term is derived with a negation of variables similar to when forming a maxterm
</p>
<p>(i.e., if the input variable is a 0, then it is included uncomplemented in the sum term and vice versa). The
</p>
<p>Example 4.25
Using a K-map to find a minimized sum of products expression (4-input)
</p>
<p>132 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>final step in forming the minimized POS expression is to AND all of the sum terms together. The formal
</p>
<p>process is as follows:
</p>
<p>1. Circle groups of 0&rsquo;s in the K-map following the rules:
</p>
<p>&bull; Each circle should contain the largest number of 0&rsquo;s possible.
</p>
<p>&bull; The circles encompass only neighboring cells (i.e., side-to-side sides and/or top and
bottom).
</p>
<p>&bull; The circles must contain a number of 0&rsquo;s that is a power of 2 (i.e., 1, 2, 4, 8, or 16).
</p>
<p>&bull; Enter as many circles as possible without having any circles fully cover another circle.
</p>
<p>&bull; Each circle is called a prime implicant.
</p>
<p>2. Create a sum term for each prime implicant following the rules:
</p>
<p>&bull; Each variable in the K-map is evaluated one by one.
</p>
<p>&bull; If the circle covers a region where the input variable is a 1, then include it in the sum term
complemented.
</p>
<p>&bull; If the circle covers a region where the input variable is a 0, then include it in the sum term
uncomplemented.
</p>
<p>&bull; If the circles cover a region where the input variable is both a 0 and 1, then the variable is
excluded from the sum term.
</p>
<p>3. Multiply all of the sum terms for each prime implicant.
</p>
<p>Let&rsquo;s apply this approach to our 2-input K-map example. Example 4.26 shows the process of finding
</p>
<p>a minimized product of sums logic expression for a 2-input logic circuit using a K-map. Notice that this
</p>
<p>process yielded the same logic expression as the SOP approach shown in Example 4.23. This illustrates
</p>
<p>that both the POS and SOP expressions produce the correct logic for the circuit.
</p>
<p>Example 4.26
Using a K-map to find a minimized product of sums expression (2-input)
</p>
<p>4.4 Logic Minimization &bull; 133</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s now apply this process to our 3-input K-map example. Example 4.27 shows the process of
</p>
<p>finding a minimized product of sums logic expression for a 3-input logic circuit using a K-map. Notice that
</p>
<p>the logic expression in POS form is not identical to the SOP expression found in Example 4.24; however,
</p>
<p>using a few steps of algebraic manipulation shows that the POS expression can be put into a form that is
</p>
<p>identical to the prior SOP expression. This illustrates that both the POS and SOP produce equivalent
</p>
<p>functionality for the circuit.
</p>
<p>Example 4.27
Using a K-map to find a minimized product of sums expression (3-input)
</p>
<p>134 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s now apply this process to our 4-input K-map example. Example 4.28 shows the process of
</p>
<p>finding a minimized product of sums logic expression for a 4-input logic circuit using a K-map.
</p>
<p>Example 4.28
Using a K-map to find a minimized product of sums expression (4-input)
</p>
<p>4.4 Logic Minimization &bull; 135</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.2.4 Minimal Sum
</p>
<p>One situation that arises when minimizing logic using a K-map is that some of the prime implicants
</p>
<p>may be redundant. Consider the example in Fig. 4.20.
</p>
<p>We need to define a formal process for identifying redundant prime implicants that can be removed
</p>
<p>without impacting the result of the logic expression. Let&rsquo;s start with examining the sum of products form.
</p>
<p>First, we define the term essential prime implicant as a prime implicant that cannot be removed from
</p>
<p>the logic expression without impacting its result. We then define the term minimal sum as a logic
</p>
<p>Fig. 4.20
Observing redundant prime implicants in a K-map
</p>
<p>136 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>expression that represents the most minimal set of logic operations to accomplish a sum of products
</p>
<p>form. There may be multiple minimal sums for a given truth table, but each would have the same number
</p>
<p>of logic operations. In order to determine if a prime implicant is essential, we first put in each and every
</p>
<p>possible prime implicant into the K-map. This gives a logic expression known as the complete sum.
</p>
<p>From this point we identify any cells that have only one prime implicant covering them. These cells are
</p>
<p>called distinguished one cells. Any prime implicant that covers a distinguished one cell is defined as an
</p>
<p>essential prime implicant. All prime implicants that are not essential are removed from the K-map. A
</p>
<p>minimal sum is then simply the sum of all remaining product terms associated with the essential prime
</p>
<p>implicants. Example 4.29 shows how to use this process.
</p>
<p>This process is identical for the product of sums form to produce the minimal product.
</p>
<p>4.4.3 Don&rsquo;t Cares
</p>
<p>There are often times when framing a design problem that there are specific input codes that require
</p>
<p>exact output values, but there are other codes where the output value doesn&rsquo;t matter. This can occur for a
</p>
<p>variety of reasons, such as knowing that certain input codes will never occur due to the nature of the
</p>
<p>problem or that the output of the circuit will only be used under certain input codes. We can take
</p>
<p>Example 4.29
Deriving the minimal sum from a K-map
</p>
<p>4.4 Logic Minimization &bull; 137</p>
<p/>
</div>
<div class="page"><p/>
<p>advantage of this situation to produce a more minimal logic circuit. We define an output as a don&rsquo;t care
</p>
<p>when it doesn&rsquo;t matter whether it is a 1 or 0 for the particular input code. The symbol for a don&rsquo;t care is &ldquo;X.&rdquo;
</p>
<p>We take advantage of don&rsquo;t cares when performing logic minimization by treating them as whatever
</p>
<p>output value will produce a minimal logic expression. Example 4.30 shows how to use this process.
</p>
<p>4.4.4 Using XOR Gates
</p>
<p>While Boolean algebra does not include the exclusive-OR and exclusive-NOR operations, XOR and
</p>
<p>XNOR gates do indeed exist in modern electronics. They can be a useful tool to provide logic circuitry
</p>
<p>with less operations, sometimes even compared to a minimal sum or product synthesized using the
</p>
<p>techniques just described. An XOR/XNOR operation can be identified by putting the values from a truth
</p>
<p>table into a K-map. The XOR/XNOR operations will result in a characteristic checkerboard pattern in the
</p>
<p>K-map. Consider the following patterns for XOR and XNOR gates in Figs. 4.21, 4.22, 4.23, and 4.24.
</p>
<p>Anytime these patterns are observed, it indicates an XOR/XNOR gate.
</p>
<p>Example 4.30
Using don&rsquo;t cares to produce a minimal SOP logic expression
</p>
<p>138 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 4.21
XOR and XNOR checkerboard patterns observed in K-maps (2-input)
</p>
<p>Fig. 4.22
XOR and XNOR checkerboard patterns observed in K-maps (3-input)
</p>
<p>Fig. 4.23
XOR checkerboard pattern observed in K-maps (4-input)
</p>
<p>4.4 Logic Minimization &bull; 139</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC4.4(a) Logic minimization is accomplished by removing variables from the original canonical
logic expression that don&rsquo;t impact the result. How does a Karnaugh map graphically
show what variables can be removed?
</p>
<p>A) K-maps contain the same information as a truth table but the data is
formatted as a grid. This allows variables to be removed by inspection.
</p>
<p>B) K-maps rearrange a truth table so that adjacent cells have one and only one
input variable changing at a time. If adjacent cells have the same output
value when an input variable is both a 0 and a 1, that variable has no impact
on the interim result and can be eliminated.
</p>
<p>C) K-maps list both the rows with outputs of 1&rsquo;s and 0&rsquo;s simultaneously. This
allows minimization to occur for a SOP and POS topology that each has the
same, but minimal, number of gates.
</p>
<p>D) K-maps display the truth table information in a grid format, which is a more
compact way of presenting the behavior of a circuit.
</p>
<p>CC4.4(b) A &ldquo;Don&rsquo;t Care&rdquo; can be used to minimize a logic expression by assigning the output of
a row to either a 1 or a 0 in order to form larger groupings within a K-map. How does
the output of the circuit behave when it processes the input code for a row containing
a don&rsquo;t care?
</p>
<p>A) The output will be whatever value was needed to form the largest grouping
in the K-map.
</p>
<p>B) The output will go to either a 0 or a 1, but the final value is random.
</p>
<p>C) The output can toggle between a 0 and a 1 when this input code is present.
</p>
<p>D) The output will be driven to exactly halfway between a 0 and a 1.
</p>
<p>Fig. 4.24
XNOR checkerboard pattern observed in K-maps (4-input)
</p>
<p>140 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.5 Timing Hazards and Glitches
</p>
<p>Timing hazards, or glitches, refer to unwanted transitions on the output of a combinational logic
</p>
<p>circuit. These are most commonly due to different delay paths through the gates in the circuit. In real
</p>
<p>circuitry there is always a finite propagation delay through each gate. Consider the circuit shown in
</p>
<p>Fig. 4.25 where gate delays are included and how they can produce unwanted transitions.
</p>
<p>These timing hazards are given unique names based on the type of transition that occurs. A static
</p>
<p>0 timing hazard is when the input switches between two input codes that both yield an output of 0 but the
</p>
<p>output momentarily switches to a 1. A static 1 timing hazard is when the input switches between two
</p>
<p>Fig. 4.25
Examining the source of a timing hazard (or glitch) in a combinational logic circuit
</p>
<p>4.5 Timing Hazards and Glitches &bull; 141</p>
<p/>
</div>
<div class="page"><p/>
<p>input codes that both yield an output of 1 but the output momentarily switches to a 0. A dynamic hazard
</p>
<p>is when the input switches between two input codes that result in a real transition on the output (i.e., 0 to
</p>
<p>1 or 1 to 0), but the output has a momentary glitch before reaching its final value. These definitions are
</p>
<p>shown in Fig. 4.26.
</p>
<p>Timing hazards can be addressed in a variety of ways. One way is to try to match the propagation
</p>
<p>delays through each path of the logic circuit. This can be difficult, particularly in modern logic families
</p>
<p>such as CMOS. In the example in Fig. 4.25, the root cause of the different propagation delays was due to
</p>
<p>an inverter on one of the variables. It seems obvious that this could be addressed by putting buffers on
</p>
<p>the other inputs with equal delays as the inverter. This would create a situation where all input codes
</p>
<p>would arrive at the first stage of AND gates at the same time regardless of whether they were inverted or
</p>
<p>not and eliminate the hazards; however, CMOS implements a buffer as two inverters in series, so it is
</p>
<p>difficult to insert a buffer in a circuit with an equal delay to an inverter. Addressing timing hazards in this
</p>
<p>way is possible, but it involves a time-consuming and tedious process of adjusting the transistors used to
</p>
<p>create the buffer and inverter to have equal delays.
</p>
<p>Another technique to address timing hazards is to place additional circuitry in the system that will
</p>
<p>ensure the correct output while the input codes switch. Consider how including a nonessential prime
</p>
<p>implicant can eliminate a timing hazard in Example 4.31. In this approach, the minimal sum from Fig. 4.25
</p>
<p>is instead replaced with the complete sum. The use of the complete sum instead of the minimal sum can
</p>
<p>be shown to eliminate both static and dynamic timing hazards. The drawback of this approach is the
</p>
<p>addition of extra circuitry in the combinational logic circuit (i.e., nonessential prime implicants).
</p>
<p>Fig. 4.26
Timing hazard definitions
</p>
<p>142 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC4.5 How long do you need to wait for all hazards to settle out?
</p>
<p>A) The time equal to the delay through the nonessential prime implicants.
</p>
<p>B) The time equal to the delay through the essential prime implicants.
</p>
<p>C) The time equal to the shortest delay path in the circuit.
</p>
<p>D) The time equal to the longest delay path in the circuit.
</p>
<p>Example 4.31
Eliminating a timing hazard by including nonessential product terms
</p>
<p>4.5 Timing Hazards and Glitches &bull; 143</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v Boolean algebra defines the axioms and
theorems that guide the operations that can
be performed on a two-valued number
system.
</p>
<p>v Boolean algebra theorems allow logic
expressions to be manipulated to make cir-
cuit synthesis simpler. They also allow logic
expressions to be minimized.
</p>
<p>v The delay of a combinational logic circuit is
always dictated by the longest delay path
from the inputs to the output.
</p>
<p>v The canonical form of a logic expression is
one that has not been minimized.
</p>
<p>v A canonical sum of products form is a logic
synthesis technique based on minterms. A
minterm is a product term that will output a
one for only one unique input code. A
minterm is used for each row of a truth table
corresponding to an output of a one. Each of
the minterms is then summed together to
create the final system output.
</p>
<p>v A minterm list is a shorthand way of describ-
ing the information in a truth table. The sym-
bol &ldquo;Σ&rdquo; is used to denote a minterm list. Each
of the input variables are added to this sym-
bol as comma-delimited subscripts. The row
number is then listed for each row
corresponding to an output of a one.
</p>
<p>v A canonical product of sums form is a logic
synthesis technique based on maxterms. A
maxterm is a sum term that will output a zero
for only one unique input code. A maxterm is
used for each row of a truth table
corresponding to an output of a zero. Each
of the maxterms is then multiplied together to
create the final system output.
</p>
<p>v Amaxterm list is a shorthand way of describ-
ing the information in a truth table. The sym-
bol &ldquo;Π&rdquo; is used to denote a maxterm list. Each
of the input variables are added to this sym-
bol as comma-delimited subscripts. The row
number is then listed for each row
corresponding to an output of a zero.
</p>
<p>v Canonical logic expressions can be
minimized through a repetitive process of
factoring common variables using the distrib-
utive property and then eliminating remaining
variables using a combination of the
complements and identity theorems.
</p>
<p>v A Karnaugh map (K-map) is a graphical
approach to minimizing logic expressions. A
K-map arranges a truth table into a grid in
which the neighboring cells have input codes
that differ by only one bit. This allows the
impact of an input variable on a group of
outputs to be quickly identified.
</p>
<p>v Aminimized sum of products expression can
be found from a K-map by circling neighbor-
ing ones to form groups that can be produced
by a single product term. Each product term
(aka prime implicant) is then summed
together to form the circuit output.
</p>
<p>v Aminimized product of sums expression can
be found from a K-map by circling neighbor-
ing zeros to form groups that can be pro-
duced by a single sum term. Each sum term
(aka prime implicant) is then multiplied
together to form the circuit output.
</p>
<p>v A minimal sum or minimal product is a logic
expression that contains only essential prime
implicants and represents the smallest num-
ber of logic operations possible to produce
the desired output.
</p>
<p>v A don&rsquo;t care (X) can be used when the output
of a truth table row can be either a zero or a
one without affecting the system behavior.
This typically occurs when some of the input
codes of a truth table will never occur. The
value for the row of a truth table containing a
don&rsquo;t care output can be chosen to give the
most minimal logic expression. In a K-map,
don&rsquo;t cares can be included to form the larg-
est groupings in order to give the least
amount of logic.
</p>
<p>v While exclusive-OR gates are not used in
Boolean algebra, they can be visually
identified in K-maps by looking for checker-
board patterns.
</p>
<p>v Timing hazards are temporary glitches that
occur on the output of a combinational logic
circuit due to timing mismatches through dif-
ferent paths in the circuit. Hazards can be
minimized by including additional circuitry in
the system or by matching the delay of all
signal paths.
</p>
<p>144 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Exercise Problems
</p>
<p>Section 4.1: Boolean Algebra
</p>
<p>4.1.1 Which Boolean algebra theorem describes the
situation where any variable OR&rsquo;d with itself
will yield itself?
</p>
<p>4.1.2 Which Boolean algebra theorem describes the
situation where any variable that is double
complemented will yield itself?
</p>
<p>4.1.3 Which Boolean algebra theorem describes the
situation where any variable OR&rsquo;d with a 1 will
yield a 1?
</p>
<p>4.1.4 Which Boolean algebra theorem describes the
situation where a variable that exists in multiple
product terms can be factored out?
</p>
<p>4.1.5 Which Boolean algebra theorem describes the
situation where when output(s) corresponding
to a term within an expression are handled by
another term the original term can be
removed?
</p>
<p>4.1.6 Which Boolean algebra theorem describes the
situation where any variable AND&rsquo;d with its
complement will yield a 0?
</p>
<p>4.1.7 Which Boolean algebra theorem describes the
situation where any variable AND&rsquo;d with a 0 will
yield a 0?
</p>
<p>4.1.8 Which Boolean algebra theorem describes the
situation where an AND gate with its inputs
inverted is equivalent to an OR gate with its
outputs inverted?
</p>
<p>4.1.9 Which Boolean algebra theorem describes the
situation where a variable that exists in multiple
sum terms can be factored out?
</p>
<p>4.1.10 Which Boolean algebra theorem describes the
situation where an OR gate with its inputs
inverted is equivalent to an AND gate with its
outputs inverted?
</p>
<p>4.1.11 Which Boolean algebra theorem describes the
situation where the grouping of variables in an
OR operation does not affect the result?
</p>
<p>4.1.12 Which Boolean algebra theorem describes the
situation where any variable AND&rsquo;d with itself
will yield itself?
</p>
<p>4.1.13 Which Boolean algebra theorem describes the
situation where the order of variables in an OR
operation does not affect the result?
</p>
<p>4.1.14 Which Boolean algebra theorem describes the
situation where any variable AND&rsquo;d with a 1 will
yield itself?
</p>
<p>4.1.15 Which Boolean algebra theorem describes the
situation where the grouping of variables in an
AND operation does not affect the result?
</p>
<p>4.1.16 Which Boolean algebra theorem describes the
situation where any variable OR&rsquo;d with its com-
plement will yield a 1?
</p>
<p>4.1.17 Which Boolean algebra theorem describes the
situation where the order of variables in an
AND operation does not affect the result?
</p>
<p>4.1.18 Which Boolean algebra theorem describes the
situation where a variable OR&rsquo;d with a 0 will
yield itself?
</p>
<p>4.1.19 Use proof by exhaustion to prove that an OR
gate with its inputs inverted is equivalent to an
AND gate with its outputs inverted.
</p>
<p>4.1.20 Use proof by exhaustion to prove that an AND
gate with its inputs inverted is equivalent to an
OR gate with its outputs inverted.
</p>
<p>Section 4.2: Combinational Logic
Analysis
</p>
<p>4.2.1 For the ogic diagram given in Fig. 4.27, give the
logic expression for the output F.
</p>
<p>Fig. 4.27
Combinational logic analysis 1
</p>
<p>4.2.2 For the logic diagram given in Fig. 4.27, give
the truth table for the output F.
</p>
<p>4.2.3 For the logic diagram given in Fig. 4.27, give
the delay.
</p>
<p>4.2.4 For the logic diagram given in Fig. 4.28, give
the logic expression for the output F.
</p>
<p>Fig. 4.28
Combinational logic analysis 2
</p>
<p>4.2.5 For the logic diagram given in Fig. 4.28, give
the truth table for the output F.
</p>
<p>4.2.6 For the logic diagram given in Fig. 4.28, give
the delay.
</p>
<p>4.2.7 For the logic diagram given in Fig. 4.29, give
the logic expression for the output F.
</p>
<p>Fig. 4.29
Combinational logic analysis 3
</p>
<p>4.2.8 For the logic diagram given in Fig. 4.29, give
the truth table for the output F.
</p>
<p>Exercise Problems &bull; 145</p>
<p/>
</div>
<div class="page"><p/>
<p>4.2.9 For the logic diagram given in Fig. 4.29, give
the delay.
</p>
<p>4.2.10 For the logic diagram given in Fig. 4.30, give
the logic expression for the output F.
</p>
<p>Fig. 4.30
Combinational logic analysis 4
</p>
<p>4.2.11 For the logic diagram given in Fig. 4.30, give
the truth table for the output F.
</p>
<p>4.2.12 For the logic diagram given in Fig. 4.30, give
the delay.
</p>
<p>4.2.13 For the logic diagram given in Fig. 4.31, give
the logic expression for the output F.
</p>
<p>Fig. 4.31
Combinational logic analysis 5
</p>
<p>4.2.14 For the logic diagram given in Fig. 4.31, give
the truth table for the output F.
</p>
<p>4.2.15 For the logic diagram given in Fig. 4.31, give
the delay.
</p>
<p>Section 4.3: Combinational Logic
Synthesis
</p>
<p>4.3.1 For the 2-input truth table in Fig. 4.32, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>Fig. 4.32
Combinational logic synthesis 1
</p>
<p>4.3.2 For the 2-input truth table in Fig. 4.32, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.3 For the 2-input truth table in Fig. 4.32, give the
minterm list.
</p>
<p>4.3.4 For the 2-input truth table in Fig. 4.32, give the
canonical product of sums (POS) logic
expression.
</p>
<p>4.3.5 For the 2-input truth table in Fig. 4.32, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.6 For the 2-input truth table in Fig. 4.32, give the
maxterm list.
</p>
<p>4.3.7 For the 2-input minterm list in Fig. 4.33, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.33
Combinational logic synthesis 2
</p>
<p>4.3.8 For the 2-input minterm list in Fig. 4.33, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.9 For the 2-input minterm list in Fig. 4.33, give
the truth table.
</p>
<p>4.3.10 For the 2-input minterm list in Fig. 4.33, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.11 For the 2-input minterm list in Fig. 4.33, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.12 For the 2-input minterm list in Fig. 4.33, give
the maxterm list.
</p>
<p>4.3.13 For the 2-input maxterm list in Fig. 4.34, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.34
Combinational logic synthesis 3
</p>
<p>4.3.14 For the 2-input maxterm list in Fig. 4.34, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.15 For the 2-input maxterm list in Fig. 4.34, give
the minterm list.
</p>
<p>4.3.16 For the 2-input maxterm list in Fig. 4.34, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.17 For the 2-input maxterm list in Fig. 4.34, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.18 For the 2-input maxterm list in Fig. 4.34, give
the truth table.
</p>
<p>4.3.19 For the 2-input truth table in Fig. 4.35, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>146 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 4.35
Combinational logic synthesis 4
</p>
<p>4.3.20 For the 2-input truth table in Fig. 4.35, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.21 For the 2-input truth table in Fig. 4.35, give the
minterm list.
</p>
<p>4.3.22 For the 2-input truth table in Fig. 4.35, give the
canonical product of sums (POS) logic
expression.
</p>
<p>4.3.23 For the 2-input truth table in Fig. 4.35, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.24 For the 2-input truth table in Fig. 4.35, give the
maxterm list.
</p>
<p>4.3.25 For the 3-input truth table in Fig. 4.36, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>Fig. 4.36
Combinational logic synthesis 5
</p>
<p>4.3.26 For the 3-input truth table in Fig. 4.36, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.27 For the 3-input truth table in Fig. 4.36, give the
minterm list.
</p>
<p>4.3.28 For the 3-input truth table in Fig. 4.36, give the
canonical product of sums (POS) logic
expression.
</p>
<p>4.3.29 For the 3-input truth table in Fig. 4.36, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.30 For the 3-input truth table in Fig. 4.36, give the
maxterm list.
</p>
<p>4.3.31 For the 3-input minterm list in Fig. 4.37, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.37
Combinational logic synthesis 6
</p>
<p>4.3.32 For the 3-input minterm list in Fig. 4.37, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.33 For the 3-input minterm list in Fig. 4.37, give
the truth table.
</p>
<p>4.3.34 For the 3-input minterm list in Fig. 4.37, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.35 For the 3-input minterm list in Fig. 4.37, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.36 For the 3-input minterm list in Fig. 4.37, give
the maxterm list.
</p>
<p>4.3.37 For the 3-input maxterm list in Fig. 4.38, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.38
Combinational logic synthesis 7
</p>
<p>4.3.38 For the 3-input maxterm list in Fig. 4.38, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.39 For the 3-input maxterm list in Fig. 4.38, give
the minterm list.
</p>
<p>4.3.40 For the 3-input maxterm list in Fig. 4.38, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.41 For the 3-input maxterm list in Fig. 4.38, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.42 For the 3-input maxterm list in Fig. 4.38, give
the truth table.
</p>
<p>4.3.43 For the 3-input truth table in Fig. 4.39, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>Fig. 4.39
Combinational logic synthesis 8
</p>
<p>4.3.44 For the 3-input truth table in Fig. 4.39, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.45 For the 3-input truth table in Fig. 4.39, give the
minterm list.
</p>
<p>4.3.46 For the 3-input truth table in Fig. 4.39, give the
canonical product of sums (POS) logic
expression.
</p>
<p>Exercise Problems &bull; 147</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.47 For the 3-input truth table in Fig. 4.39, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.48 For the 3-input truth table in Fig. 4.39, give the
maxterm list.
</p>
<p>4.3.49 For the 4-input truth table in Fig. 4.40, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>Fig. 4.40
Combinational logic synthesis 9
</p>
<p>4.3.50 For the 4-input truth table in Fig. 4.40, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.51 For the 4-input truth table in Fig. 4.40, give the
minterm list.
</p>
<p>4.3.52 For the 4-input truth table in Fig. 4.40, give the
canonical product of sums (POS) logic
expression.
</p>
<p>4.3.53 For the 4-input truth table in Fig. 4.40, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.54 For the 4-input truth table in Fig. 4.40, give the
maxterm list.
</p>
<p>4.3.55 For the 4-input minterm list in Fig. 4.41, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.41
Combinational logic synthesis 10
</p>
<p>4.3.56 For the 4-input minterm list in Fig. 4.41, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.57 For the 4-input minterm list in Fig. 4.41, give
the truth table.
</p>
<p>4.3.58 For the 4-input minterm list in Fig. 4.41, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.59 For the 4-input minterm list in Fig. 4.41, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.60 For the 4-input minterm list in Fig. 4.41, give
the maxterm list.
</p>
<p>4.3.61 For the 4-input maxterm list in Fig. 4.42, give
the canonical sum of products (SOP) logic
expression.
</p>
<p>Fig. 4.42
Combinational logic synthesis 11
</p>
<p>4.3.62 For the 4-input maxterm list in Fig. 4.42, give
the canonical sum of products (SOP) logic
diagram.
</p>
<p>4.3.63 For the 4-input maxterm list in Fig. 4.42, give
the minterm list.
</p>
<p>4.3.64 For the 4-input maxterm list in Fig. 4.42, give
the canonical product of sums (POS) logic
expression.
</p>
<p>4.3.65 For the 4-input maxterm list in Fig. 4.42, give
the canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.66 For the 4-input maxterm list in Fig. 4.42, give
the truth table.
</p>
<p>4.3.67 For the 4-input truth table in Fig. 4.43, give the
canonical sum of products (SOP) logic expres-
sion.
</p>
<p>Fig. 4.43
Combinational logic synthesis 12
</p>
<p>4.3.68 For the 4-input truth table in Fig. 4.43, give the
canonical sum of products (SOP) logic
diagram.
</p>
<p>148 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.3.69 For the 4-input truth table in Fig. 4.43, give the
minterm list.
</p>
<p>4.3.70 For the 4-input truth table in Fig. 4.43, give the
canonical product of sums (POS) logic
expression.
</p>
<p>4.3.71 For the 4-input truth table in Fig. 4.43, give the
canonical product of sums (POS) logic
diagram.
</p>
<p>4.3.72 For the 4-input truth table in Fig. 4.43, give the
maxterm list.
</p>
<p>Section 4.4: Logic Minimization
</p>
<p>4.4.1 For the 2-input truth table in Fig. 4.44, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.44
Logic minimization 1
</p>
<p>4.4.2 For the 2-input truth table in Fig. 4.44, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.3 For the 2-input truth table in Fig. 4.45, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.45
Logic minimization 2
</p>
<p>4.4.4 For the 2-input truth table in Fig. 4.45, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.5 For the 2-input truth table in Fig. 4.46, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.46
Logic minimization 3
</p>
<p>4.4.6 For the 2-input truth table in Fig. 4.46, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.7 For the 2-input truth table in Fig. 4.47, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.47
Logic minimization 4
</p>
<p>4.4.8 For the 2-input truth table in Fig. 4.47, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.9 For the 3-input truth table in Fig. 4.48, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.48
Logic minimization 5
</p>
<p>4.4.10 For the 3-input truth table in Fig. 4.48, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.11 For the 3-input truth table in Fig. 4.49, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.49
Logic minimization 6
</p>
<p>4.4.12 For the 3-input truth table in Fig. 4.49, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>Exercise Problems &bull; 149</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.13 For the 3-input truth table in Fig. 4.50, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.50
Logic minimization 7
</p>
<p>4.4.14 For the 3-input truth table in Fig. 4.50, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.15 For the 3-input truth table in Fig. 4.51, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.51
Logic minimization 8
</p>
<p>4.4.16 For the 3-input truth table in Fig. 4.51, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.17 For the 4-input truth table in Fig. 4.52, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.52
Logic minimization 9
</p>
<p>4.4.18 For the 4-input truth table in Fig. 4.52, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.19 For the 4-input truth table in Fig. 4.53, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.53
Combinational logic synthesis 10
</p>
<p>150 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.20 For the 4-input truth table in Fig. 4.53, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.21 For the 4-input truth table in Fig. 4.54, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.54
Combinational logic synthesis 11
</p>
<p>4.4.22 For the 4-input truth table in Fig. 4.54, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.23 For the 4-input truth table in Fig. 4.55, use a
K-map to derive a minimized sum of products
(SOP) logic expression.
</p>
<p>Fig. 4.55
Combinational logic synthesis 12
</p>
<p>4.4.24 For the 4-input truth table in Fig. 4.55, use a
K-map to derive a minimized product of sums
(POS) logic expression.
</p>
<p>4.4.25 For the 3-input truth table and K-map in
Fig. 4.56, provide the row number(s) of any
distinguished one-cells when deriving the min-
imal SOP logic expression.
</p>
<p>Fig. 4.56
Combinational logic synthesis 13
</p>
<p>4.4.26 For the 3-input truth table and K-map in
Fig. 4.56, give the product terms for the essen-
tial prime implicants when deriving the minimal
SOP logic expression.
</p>
<p>4.4.27 For the 3-input truth table and K-map in
Fig. 4.56, give the minimal sum of products
(SOP) logic expression.
</p>
<p>4.4.28 For the 3-input truth table and K-map in
Fig. 4.56, give the complete sum of products
(SOP) logic expression.
</p>
<p>4.4.29 For the 4-input truth table and K-map in
Fig. 4.57, provide the row number(s) of any
distinguished one-cells when deriving the min-
imal SOP logic expression.
</p>
<p>Fig. 4.57
Combinational logic synthesis 14
</p>
<p>4.4.30 For the 4-input truth table and K-map in
Fig. 4.57, give the product terms for the essen-
tial prime implicants when deriving the minimal
SOP logic expression.
</p>
<p>4.4.31 For the 4-input truth table and K-map in
Fig. 4.57, give the minimal sum of products
(SOP) logic expression.
</p>
<p>Exercise Problems &bull; 151</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4.32 For the 4-input truth table and K-map in
Fig. 4.57, give the complete sum of products
(SOP) logic expression.
</p>
<p>4.4.33 For the 4-input truth table and K-map in
Fig. 4.58, give the minimal sum of products
(SOP) logic expression by exploiting &ldquo;don&rsquo;t
cares.&rdquo;
</p>
<p>Fig. 4.58
Combinational logic synthesis 15
</p>
<p>4.4.34 For the 4-input truth table and K-map in
Fig. 4.58, give the minimal product of sums
(POS) logic expression by exploiting &ldquo;don&rsquo;t
cares.&rdquo;
</p>
<p>4.4.35 For the 4-input truth table and K-map in
Fig. 4.59, give the minimal sum of products
(SOP) logic expression by exploiting &ldquo;don&rsquo;t
cares.&rdquo;
</p>
<p>Fig. 4.59
Combinational logic synthesis 16
</p>
<p>4.4.36 For the 4-input truth table and K-map in
Fig. 4.59, give the minimal product of sums
(POS) logic expression by exploiting &ldquo;don&rsquo;t
cares.&rdquo;
</p>
<p>Section 4.5: Timing Hazards and Glitches
</p>
<p>4.5.1 Describe the situation in which a static-1 timing
hazard may occur.
</p>
<p>4.5.2 Describe the situation in which a static-0 timing
hazard may occur.
</p>
<p>4.5.3 In which topology will a static-1 timing hazard
occur (SOP, POS, or both)?
</p>
<p>4.5.4 In which topology will a static-0 timing hazard
occur (SOP, POS, or both)?
</p>
<p>4.5.5 For the 3-input truth table and K-map in
Fig. 4.56, give the product term that helps
eliminate static-1 timing hazards in this circuit.
</p>
<p>4.5.6 For the 3-input truth table and K-map in
Fig. 4.56, give the sum term that helps elimi-
nate static-0 timing hazards in this circuit.
</p>
<p>4.5.7 For the 4-input truth table and K-map in
Fig. 4.57, give the product term that helps
eliminate static-1 timing hazards in this circuit.
</p>
<p>4.5.8 For the 4-input truth table and K-map in
Fig. 4.57, give the sum term that helps elimi-
nate static-0 timing hazards in this circuit.
</p>
<p>152 &bull; Chapter 4: Combinational Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 5: Verilog (Part 1)
Based on the material presented in Chap. 4, there are a few observations about logic design that are
</p>
<p>apparent. First, the size of logic circuitry can scale quickly to the point where it is difficult to design by
</p>
<p>hand. Second, the process of moving from a high-level description of how a circuit works (e.g., a truth
</p>
<p>table) to a form that is ready to be implemented with real circuitry (e.g., a minimized logic diagram) is
</p>
<p>straightforward and well-defined. Both of these observations motivate the use of computer-aided design
</p>
<p>(CAD) tools to accomplish logic design. This chapter introduces hardware description languages (HDLs)
</p>
<p>as a means to describe digital circuitry using a text-based language. HDLs provide a means to describe
</p>
<p>large digital systems without the need for schematics, which can become impractical in very large
</p>
<p>designs. HDLs have evolved to support logic simulation at different levels of abstraction. This provides
</p>
<p>designers the ability to begin designing and verifying functionality of large systems at a high level of
</p>
<p>abstraction and postpone the details of the circuit implementation until later in the design cycle. This
</p>
<p>enables a top-down design approach that is scalable across different logic families. HDLs have also
</p>
<p>evolved to support automated synthesis, which allows the CAD tools to take a functional description of a
</p>
<p>system (e.g., a truth table) and automatically create the gate-level circuitry to be implemented in real
</p>
<p>hardware. This allows designers to focus their attention on designing the behavior of a system and not
</p>
<p>spend as much time performing the formal logic synthesis steps that were presented in Chap. 4. The
</p>
<p>intent of this chapter is to introduce HDLs and their use in the modern digital design flow. This chapter will
</p>
<p>cover the basics of designing combinational logic in an HDL and also hierarchical design. The more
</p>
<p>advanced concepts of HDLs such as sequential logic design, high-level abstraction, and test benches
</p>
<p>are covered later so that the reader can get started quickly using HDLs to gain experience with the
</p>
<p>languages and design flow.
</p>
<p>There are two dominant hardware description languages in use today. They are VHDL and Verilog.
</p>
<p>VHDL stands for very high-speed integrated circuit hardware description language. Verilog is not an
</p>
<p>acronym but rather a trade name. The use of these two HDLs is split nearly equally within the digital
</p>
<p>design industry. Once one language is learned, it is simple to learn the other language, so the choice of
</p>
<p>the HDL to learn first is somewhat arbitrary. In this text, we will use Verilog to learn the concepts of an
</p>
<p>HDL. Verilog is more similar to the programming language C and less strict in its type casting than VHDL.
</p>
<p>Verilog is also widely used in custom integrated circuit design so there is a great deal of documentation
</p>
<p>and examples readily available online. The goal of this chapter is to provide an understanding of the
</p>
<p>basic principles of hardware description languages.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>5.1 Describe the role of hardware description languages in modern digital design.
5.2 Describe the fundamentals of design abstraction in modern digital design.
5.3 Describe the modern digital design flow based on hardware description languages.
5.4 Describe the fundamental constructs of Verilog.
5.5 Design a Verilog model for a combinational logic circuit using concurrent modeling
</p>
<p>techniques (continuous signal assignment with logical operators and continuous signal
assignment with conditional operators).
</p>
<p>5.6 Design a Verilog model for a combinational logic circuit using a structural design approach
(gate-level primitives and user-defined primitives).
</p>
<p>5.7 Describe the role of a Verilog test bench.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_5
</p>
<p>153</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_5&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_5&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>5.1 History of Hardware Description Languages
</p>
<p>The invention of the integrated circuit is most commonly credited to two individuals who filed patents
</p>
<p>on different variations of the same basic concept within 6 months of each other in 1959. Jack Kilby filed
</p>
<p>the first patent on the integrated circuit in February of 1959 titled &ldquo;Miniaturized Electronic Circuits&rdquo; while
</p>
<p>working for Texas Instruments. Robert Noyce was the second to file a patent on the integrated circuit in
</p>
<p>July of 1959 titled &ldquo;Semiconductor Device and Lead Structure&rdquo; while at a company he cofounded called
</p>
<p>Fairchild Semiconductor. Kilby went on to win the Nobel Prize in Physics in 2000 for his invention, while
</p>
<p>Noyce went on to cofound Intel Corporation in 1968 with Gordon Moore. In 1971, Intel introduced the first
</p>
<p>single-chip microprocessor using integrated circuit technology, the Intel 4004. This microprocessor IC
</p>
<p>contained 2300 transistors. This series of inventions launched the semiconductor industry, which was
</p>
<p>the driving force behind the growth of Silicon Valley and led to 40 years of unprecedented advancement
</p>
<p>in technology that has impacted every aspect of the modern world.
</p>
<p>Gordon Moore, cofounder of Intel, predicted in 1965 that the number of transistors on an integrated
</p>
<p>circuit would double every 2 years. This prediction, now known as Moore&rsquo;s law, has held true since the
</p>
<p>invention of the integrated circuit. As the number of transistors on an integrated circuit grew, so did the
</p>
<p>size of the design and the functionality that could be implemented. Once the first microprocessor was
</p>
<p>invented in 1971, the capability of CAD tools increased rapidly enabling larger designs to be accom-
</p>
<p>plished. These larger designs, including newer microprocessors, enabled the CAD tools to become even
</p>
<p>more sophisticated and, in turn, yield even larger designs. The rapid expansion of electronic systems
</p>
<p>based on digital integrated circuits required that different manufacturers needed to produce designs that
</p>
<p>were compatible with each other. The adoption of logic family standards helped manufacturers ensure
</p>
<p>their parts would be compatible with other manufacturers at the physical layer (e.g., voltage and current);
</p>
<p>however, one challenge that was encountered by the industry was a way to document the complex
</p>
<p>behavior of larger systems. The use of schematics to document large digital designs became too
</p>
<p>cumbersome and difficult to understand by anyone besides the designer. Word descriptions of the
</p>
<p>behavior were easier to understand, but even this form of documentation became too voluminous to
</p>
<p>be effective for the size of designs that were emerging. Simultaneously there was a need to begin
</p>
<p>simulating the functionality of these large systems prior to fabrication to verify accuracy. Due to the
</p>
<p>complexity of these systems and the vast potential for design error, it became impractical to verify design
</p>
<p>accuracy through prototyping.
</p>
<p>In 1983, the US Department of Defense (DoD) sponsored a program to create a means to document
</p>
<p>the behavior of digital systems that could be used across all of its suppliers. This program was motivated
</p>
<p>by a lack of adequate documentation for the functionality of application-specific integrated circuits
</p>
<p>(ASICs) that were being supplied to the DoD. This lack of documentation was becoming a critical
</p>
<p>issue as ASICs would come to the end of their life cycle and need to be replaced. With the lack of a
</p>
<p>standardized documentation approach, suppliers had difficulty reproducing equivalent parts to those that
</p>
<p>had become obsolete. The DoD contracted three companies (Texas Instruments, IBM, and Intermetrics)
</p>
<p>to develop a standardized documentation tool that provided detailed information about both the interface
</p>
<p>(i.e., inputs and outputs) and the behavior of digital systems. The new tool was to be implemented in a
</p>
<p>format similar to a programming language. Due to the nature of this type of language-based tool, it was a
</p>
<p>natural extension of the original project scope to include the ability to simulate the behavior of a digital
</p>
<p>system. The simulation capability was desired to span multiple levels of abstraction to provide maximum
</p>
<p>flexibility. In 1985, the first version of this tool, called VHDL, was released. In order to gain widespread
</p>
<p>adoption and ensure consistency of use across the industry, VHDL was turned over to the Institute of
</p>
<p>Electrical and Electronic Engineers (IEEE) for standardization. IEEE is a professional association that
</p>
<p>defines a broad range of open technology standards. In 1987, IEEE released the first industry standard
</p>
<p>version of VHDL. The release was titled IEEE 1076-1987. Feedback from the initial version resulted in a
</p>
<p>major revision of the standard in 1993 titled IEEE 1076-1993. While many minor revisions have been
</p>
<p>154 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>made to the 1993 release, the 1076-1993 standard contains the vast majority of VHDL functionality in
</p>
<p>use today. The most recent VHDL standard is IEEE 1076-2008.
</p>
<p>Also in 1983, the Verilog HDL was developed by Automated Integrated Design Systems as a logic
</p>
<p>simulation language. The development of Verilog took place completely independent from the VHDL
</p>
<p>project. Automated Integrated Design Systems (renamed Gateway Design Automation in 1985) was
</p>
<p>acquired by CAD tool vendorCadence Design Systems in 1990. In response to the popularity of Verilog&rsquo;s
</p>
<p>intuitive programming and superior simulation support, and also to stay competitive with the emerging
</p>
<p>VHDL standard, Cadence made the Verilog HDL open to the public. IEEE once again developed the
</p>
<p>open standard for this HDL and in 1995 released the Verilog standard titled IEEE 1364-1995. This
</p>
<p>release has undergone numerous revisions with the most significant occurring in 2001. It is common to
</p>
<p>refer to the major releases as &ldquo;Verilog 1995&rdquo; and Verilog 2001&rdquo; instead of their official standard numbers.
</p>
<p>The development of CAD tools to accomplish automated logic synthesis can be dated back to the
</p>
<p>1970s when IBM began developing a series of practical synthesis engines that were used in the design
</p>
<p>of their mainframe computers; however, the main advancement in logic synthesis came with the founding
</p>
<p>of a company called Synopsis in 1986. Synopsis was the first company to focus on logic synthesis
</p>
<p>directly from HDLs. This was a major contribution because designers were already using HDLs to
</p>
<p>describe and simulate their digital systems, and now logic synthesis became integrated in the same
</p>
<p>design flow. Due to the complexity of synthesizing highly abstract functional descriptions, only lower
</p>
<p>levels of abstraction that were thoroughly elaborated were initially able to be synthesized. As CAD tool
</p>
<p>capability evolved, synthesis of higher levels of abstraction became possible, but even today not all
</p>
<p>functionality that can be described in an HDL can be synthesized.
</p>
<p>The history of HDLs, their standardization, and the creation of the associated logic synthesis tools is
</p>
<p>key to understanding the use and limitations of HDLs. HDLs were originally designed for documentation
</p>
<p>and behavioral simulation. Logic synthesis tools were developed independently and modified later to
</p>
<p>work with HDLs. This history provides some background into the most common pitfalls that beginning
</p>
<p>digital designers encounter, that being that most any type of behavior can be described and simulated in
</p>
<p>an HDL, but only a subset of well-described functionality can be synthesized. Beginning digital designers
</p>
<p>are often plagued by issues related to designs that simulate perfectly but that will not synthesize
</p>
<p>correctly. In this book, an effort is made to introduce Verilog at a level that provides a reasonable amount
</p>
<p>of abstraction while preserving the ability to be synthesized. Figure 5.1 shows a timeline of some of the
</p>
<p>major technology milestones that have occurred in the past 150 years in the field of digital logic and
</p>
<p>HDLs.
</p>
<p>5.1 History of Hardware Description Languages &bull; 155</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 5.1
Major milestones in the advancement of digital logic and HDLs
</p>
<p>156 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC5.1 Why does Verilog support modeling techniques that aren&rsquo;t synthesizable?
</p>
<p>A) There wasn&rsquo;t enough funding available to develop synthesis capability as it all
went to the VHDL project.
</p>
<p>B) At the time Verilog was created, synthesis was deemed too difficult to
implement.
</p>
<p>C) To allow Verilog to be used as a generic programming language.
</p>
<p>D) Verilog needs to support all steps in the modern digital design flow, some of
which are unsynthesizable such as test pattern generation and timing
verification.
</p>
<p>5.2 HDL Abstraction
</p>
<p>HDLs were originally defined to be able to model behavior at multiple levels of abstraction.
</p>
<p>Abstraction is an important concept in engineering design because it allows us to specify how systems
</p>
<p>will operate without getting consumed prematurely with implementation details. Also, by removing the
</p>
<p>details of the lower-level implementation, simulations can be conducted in reasonable amounts of time to
</p>
<p>model the higher-level functionality. If a full computer system was simulated using detailed models for
</p>
<p>every MOSFET, it would take an impracticable amount of time to complete. Figure 5.2 shows a graphical
</p>
<p>depiction of the different layers of abstraction in digital system design.
</p>
<p>5.2 HDL Abstraction &bull; 157</p>
<p/>
</div>
<div class="page"><p/>
<p>The highest level of abstraction is the system level. At this level, behavior of a system is described
</p>
<p>by stating a set of broad specifications. An example of a design at this level is a specification such as &ldquo;the
</p>
<p>computer system will perform 10 Tera Floating Point Operations per Second (10 TFLOPS) on double
</p>
<p>precision data and consume no more than 100 Watts of power.&rdquo; Notice that these specifications do not
</p>
<p>dictate the lower-level details such as the type of logic family or the type of computer architecture to use.
</p>
<p>One level down from the system level is the algorithmic level. At this level, the specifications begin to be
</p>
<p>broken down into sub-systems, each with an associated behavior that will accomplish a part of the
</p>
<p>primary task. At this level, the example computer specifications might be broken down into sub-systems
</p>
<p>such as a central processing unit (CPU) to perform the computation and random-access memory (RAM)
</p>
<p>to hold the inputs and outputs of the computation. One level down from the algorithmic level is the
</p>
<p>register transfer level (RTL). At this level, the details of how data is moved between and within
</p>
<p>sub-systems are described in addition to how the data is manipulated based on system inputs. One
</p>
<p>level down from the RTL level is the gate level. At this level, the design is described using basic gates and
</p>
<p>registers (or storage elements). The gate level is essentially a schematic (either graphically or text-
</p>
<p>based) that contains the components and connections that will implement the functionality from the
</p>
<p>above levels of abstraction. One level down from the gate level is the circuit level. The circuit level
</p>
<p>describes the operation of the basic gates and registers using transistors, wires, and other electrical
</p>
<p>Fig. 5.2
Levels of design abstraction
</p>
<p>158 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>components such as resistors and capacitors. Finally, the lowest level of design abstraction is the
</p>
<p>material level. This level describes how different materials are combined and shaped in order to
</p>
<p>implement the transistors, devices, and wires from the circuit level.
</p>
<p>HDLs are designed to model behavior at all of these levels with the exception of the material level.
</p>
<p>While there is some capability to model circuit level behavior such as MOSFETs as ideal switches and
</p>
<p>pull-up/pull-down resistors, HDLs are not typically used at the circuit level. Another graphical depiction of
</p>
<p>design abstraction is known as the Gajski and Kuhn&rsquo;s Y-chart. A Y-chart depicts abstraction across
</p>
<p>three different design domains: behavioral, structural, and physical. Each of these design domains
</p>
<p>contains levels of abstraction (i.e., system, algorithm, RTL, gate, and circuit). An example Y-chart is
</p>
<p>shown in Fig. 5.3.
</p>
<p>A Y-chart also depicts how the abstraction levels of different design domains are related to each
</p>
<p>other. A top-down design flow can be visualized in a Y-chart by spiraling inward in a clockwise direction.
</p>
<p>Moving from the behavioral domain to the structural domain is the process of synthesis. Whenever
</p>
<p>synthesis is performed, the resulting system should be compared with the prior behavioral description.
</p>
<p>This checking is called verification. The process of creating the physical circuitry corresponding to the
</p>
<p>structural description is called implementation. The spiral continues down through the levels of abstrac-
</p>
<p>tion until the design is implemented at a level that the geometries representing circuit elements
</p>
<p>(transistors, wires, etc.) are ready to be fabricated in silicon. Figure 5.4 shows the top-down design
</p>
<p>process depicted as an inward spiral on the Y-chart.
</p>
<p>Fig. 5.3
Y-chart of design abstraction
</p>
<p>5.2 HDL Abstraction &bull; 159</p>
<p/>
</div>
<div class="page"><p/>
<p>The Y-chart represents a formal approach for large digital systems. For large systems that are
</p>
<p>designed by teams of engineers, it is critical that a formal, top-down design process is followed to
</p>
<p>eliminate potentially costly design errors as the implementation is carried out at lower levels of
</p>
<p>abstraction.
</p>
<p>CONCEPT CHECK
</p>
<p>CC5.2 Why is abstraction an essential part of engineering design?
</p>
<p>A) Without abstraction all schematics would be drawn at the transistor level.
</p>
<p>B) Abstraction allows computer programs to aid in the design process.
</p>
<p>C) Abstraction allows the details of the implementation to be hidden while the
higher-level systems are designed. Without abstraction, the details of the
implementation would overwhelm the designer.
</p>
<p>D) Abstraction allows analog circuit designers to include digital blocks in their
systems.
</p>
<p>Fig. 5.4
Y-chart illustrating top-down design approach
</p>
<p>160 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.3 The Modern Digital Design Flow
</p>
<p>When performing a smaller design or the design of fully contained sub-systems, the process can be
</p>
<p>broken down into individual steps. These steps are shown in Fig. 5.5. This process is given generically
</p>
<p>and applies to both classical andmodern digital design. The distinction between classical and modern is
</p>
<p>that modern digital design uses HDLs and automated CAD tools for simulation, synthesis, place and
</p>
<p>route, and verification.
</p>
<p>This generic design process flow can be used across classical and modern digital design, although
</p>
<p>modern digital design allows additional verification at each step using automated CAD tools. Figure 5.6
</p>
<p>shows how this flow is used in the classical design approach of a combinational logic circuit.
</p>
<p>Fig. 5.5
Generic digital design flow
</p>
<p>5.3 The Modern Digital Design Flow &bull; 161</p>
<p/>
</div>
<div class="page"><p/>
<p>The modern design flow based on HDLs includes the ability to simulate functionality at each step of
</p>
<p>the process. Functional simulations can be performed on the initial behavioral description of the system.
</p>
<p>At each step of the design process, the functionality is described in more detail, ultimately moving toward
</p>
<p>the fabrication step. At each level, the detailed information can be included in the simulation to verify that
</p>
<p>the functionality is still correct and that the design is still meeting the original specifications. Figure 5.7
</p>
<p>shows the modern digital design flow with the inclusion of simulation capability at each step.
</p>
<p>Fig. 5.6
Classical digital design flow
</p>
<p>162 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC5.3 Why did digital designs move from schematic-entry to text-based HDLs?
</p>
<p>A) HDL models could be much larger by describing functionality in text similar to
traditional programming language.
</p>
<p>B) Schematics required sophisticated graphics hardware to display correctly.
</p>
<p>C) Schematics symbols became too small as designs became larger.
</p>
<p>D) Text was easier to understand by a broader range of engineers.
</p>
<p>Fig. 5.7
Modern digital design flow
</p>
<p>5.3 The Modern Digital Design Flow &bull; 163</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4 Verilog Constructs
</p>
<p>Now we begin looking at the details of Verilog. The original Verilog standard (IEEE 1364) has been
</p>
<p>updated numerous times since its creation in 1995. The most significant update occurred in 2001, which
</p>
<p>was titled IEEE 1394-2001. In 2005 minor corrections and improvements were added to the standard,
</p>
<p>which resulted in IEEE 1394-2005. The constructs described in this book reflect the functionality in the
</p>
<p>IEEE 1394-2005 standard. The functionality of Verilog (e.g., operators, signal types, functions, etc.) is
</p>
<p>defined within the Verilog standard; thus, it is not necessary to explicitly state that a design is using the
</p>
<p>IEEE 1394 package because it is inherent in the use of Verilog. This chapter gives an overview of the
</p>
<p>basic constructs of Verilog in order to model simple combinational logic circuits and begin gaining
</p>
<p>experience with logic simulations. The more advanced constructs of Verilog are covered in Chap. 8
</p>
<p>with examples given throughout Chaps. 9, 10, 11, 12, and 13.
</p>
<p>A Verilog design describes a single system in a single file. The file has the suffix *.v. Within the file,
</p>
<p>the system description is contained within a module. The module includes the interface to the system
</p>
<p>(i.e., the inputs and outputs) and the description of the behavior. Figure 5.8 shows a graphical depiction
</p>
<p>of a Verilog file.
</p>
<p>Verilog is case sensitive. Also, each Verilog assignment, definition, or declaration is terminated with
</p>
<p>a semicolon (;). As such, line wraps are allowed and do not signify the end of an assignment, definition, or
</p>
<p>declaration. Line wraps can be used to make Verilog more readable. Comments in Verilog are supported
</p>
<p>in two ways. The first way is called a line comment and is preceded with two slashes (i.e., //). Everything
</p>
<p>after the slashes is considered a comment until the end of the line. The second comment approach is
</p>
<p>called a block comment and begins with /* and ends with a */. Everything between /* and */ is considered
</p>
<p>a comment. A block comment can span multiple lines. All user-defined names in Verilog must start with
</p>
<p>an alphabetic letter, not a number. User-defined names are not allowed to be the same as any Verilog
</p>
<p>keyword. This chapter contains many definitions of syntax in Verilog. The following notations will be used
</p>
<p>throughout the chapter when introducing new constructs.
</p>
<p>bold &frac14; Verilog keyword, use as is, case sensitive.
</p>
<p>italics &frac14; User-defined name, case sensitive.
</p>
<p>&lt; &gt; &frac14; A required characteristic such as a data type, input/output, etc.
</p>
<p>Fig. 5.8
The anatomy of a Verilog file
</p>
<p>164 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4.1 Data Types
</p>
<p>In Verilog, every signal, constant, variable, and function must be assigned a data type. The IEEE
</p>
<p>1394-2005 standard provides a variety of pre-defined data types. Some data types are synthesizable,
</p>
<p>while others are only for modeling abstract behavior. The following are the most commonly used data
</p>
<p>types in the Verilog language.
</p>
<p>5.4.1.1 Value Set
</p>
<p>Verilog supports four basic values that a signal can take on: 0, 1, X, and Z. Most of the pre-defined
</p>
<p>data types in Verilog store these values. A description of each value supported is given below.
</p>
<p>Value Description
</p>
<p>0 A logic zero, or false condition.
</p>
<p>1 A logic one, or true condition.
</p>
<p>x or X Unknown or uninitialized.
</p>
<p>z or Z High impedance, tri-stated, or floating.
</p>
<p>In Verilog, these values also have an associated strength. The strengths are used to resolve the
</p>
<p>value of a signal when it is driven by multiple sources. The names, syntax, and relative strengths are
</p>
<p>given below.
</p>
<p>Strength Description Strength level
</p>
<p>supply1 Supply drive for VCC 7
</p>
<p>supply0 Supply drive for VSS, or GND 7
</p>
<p>strong1 Strong drive to logic one 6
</p>
<p>strong0 Strong drive to logic zero 6
</p>
<p>pull1 Medium drive to logic one 5
</p>
<p>pull0 Medium drive to logic zero 5
</p>
<p>large Large capacitive 4
</p>
<p>weak1 Weak drive to logic one 3
</p>
<p>weak0 Weak drive to logic zero 3
</p>
<p>medium Medium capacitive 2
</p>
<p>small Small capacitive 1
</p>
<p>highz1 High impedance with weak pull-up to logic one 0
</p>
<p>highz0 High impedance with weak pull-down to logic zero 0
</p>
<p>When a signal is driven by multiple drivers, it will take on the value of the driver with the highest
</p>
<p>strength. If the two drivers have the same strength, the value will be unknown. If the strength is not
</p>
<p>specified, it will default to strong drive, or level 6.
</p>
<p>5.4.1.2 Net Data Types
</p>
<p>Every signal within Verilog must be associated with a data type. A net data type is one that models
</p>
<p>an interconnection (aka., a net) between components and can take on the values 0, 1, X, and Z. A signal
</p>
<p>with a net data type must be driven at all times and updates its value when the driver value changes. The
</p>
<p>most common synthesizable net data type in Verilog is the wire. The type wire will be used throughout
</p>
<p>this text. There are also a variety of other more advanced net data types that model complex digital
</p>
<p>systems with multiple drivers for the same net. The syntax and description for all Verilog net data types
</p>
<p>are given below:
</p>
<p>5.4 Verilog Constructs &bull; 165</p>
<p/>
</div>
<div class="page"><p/>
<p>Type Description
</p>
<p>wire A simple connection between components.
</p>
<p>wor Wired-OR. If multiple drivers, their values are OR&rsquo;d together.
</p>
<p>wand Wired-AND&rsquo;d. If multiple drivers, their values are AND&rsquo;d together.
</p>
<p>supply0 Used to model the VSS, (GND), power supply (supply strength inherent).
</p>
<p>supply1 Used to model the VCC power supply (supply strength inherent).
</p>
<p>tri Identical to wire. Used for readability for a net driven by multiple sources.
</p>
<p>trior Identical to wor. Used for readability for nets driven by multiple sources.
</p>
<p>triand Identical to wand. Used for readability for nets driven by multiple sources.
</p>
<p>tri1 Pulls up to logic one when tri-stated.
</p>
<p>tri0 Pulls down to logic zero when tri-stated.
</p>
<p>trireg Holds last value when tri-stated (capacitance strength inherent).
</p>
<p>Each of these net types can also have an associated drive strength. The strength is used in
</p>
<p>determining the final value of the net when it is connected to multiple drivers.
</p>
<p>5.4.1.3 Variable Data Types
</p>
<p>Verilog also contains data types that model storage. These are called variable data types. A variable
</p>
<p>data type can take on the values 0, 1, X, and Z but does not have an associated strength. Variable data
</p>
<p>types will hold the value assigned to them until their next assignment. The syntax and description for the
</p>
<p>Verilog variable data types are given below.
</p>
<p>Type Description
</p>
<p>reg A variable that models logic storage. Can take on values 0, 1, X, and Z.
</p>
<p>integer A 32-bit, 2&rsquo;s complement variable representing whole numbers between
</p>
<p>�2,147,483,64810 and +2,147,483,647.
</p>
<p>real A 64-bit, floating point variable representing real numbers between
</p>
<p>&ndash;(2.2 � 10�308)10 and +(2.2 � 10
308)10.
</p>
<p>time An unsigned, 64-bit variable taking on values from 010 to +(9.2 � 10
18).
</p>
<p>realtime Same as time. Just used for readability.
</p>
<p>5.4.1.4 Vectors
</p>
<p>In Verilog, a vector is a one-dimensional array of elements. All of the net data types, in addition to the
</p>
<p>variable type reg, can be used to form vectors. The syntax for defining a vector is as follows:
</p>
<p>&lt;type&gt; [&lt;MSB_index&gt;:&lt;LSB_index&gt;] vector_name
</p>
<p>While any range of indices can be used, it is common practice to have the LSB index start at zero.
</p>
<p>Example:
</p>
<p>wire [7:0] Sum; // This defines an 8-bit vector called &ldquo;Sum&rdquo; of type wire. The
// MSB is given the index 7 while the LSB is given the index 0.
</p>
<p>reg [15:0] Q; // This defines a 16-bit vector called &ldquo;Q&rdquo; of type reg.
</p>
<p>Individual bits within the vector can be addressed using their index. Groups of bits can be accessed
</p>
<p>using an index range.
</p>
<p>Sum[0]; // This is the least significant bit of the vector &ldquo;Sum&rdquo; defined
above.
Q[15:8]; //Thisisthe upper 8-bitsofthe 16-bitvector&ldquo;Q&rdquo; defined above.
</p>
<p>166 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4.1.5 Arrays
</p>
<p>An array is a multidimensional array of elements. This can also be thought of as a &ldquo;vector of vectors.&rdquo;
</p>
<p>Vectors within the array all have the same dimensions. To declare an array, the element type and
</p>
<p>dimensions are defined first followed by the array name and its dimensions. It is common practice to
</p>
<p>place the start index of the array on the left side of the &ldquo;:&rdquo;when defining its dimensions. The syntax for the
</p>
<p>creation of an array is shown below.
</p>
<p>&lt;element_type&gt; [&lt;MSB_index&gt;:&lt;LSB_index&gt;] array_name
[&lt;array_start_index&gt;:&lt;array_end_index&gt;];
</p>
<p>Example:
</p>
<p>reg[7:0] Mem[0:4095]; // Defines an array of 4096, 8-bit vectors of type reg.
integer A[1:100]; // Defines an array of 100 integers.
</p>
<p>When accessing an array, the name of the array is given first, followed by the index of the element. It
</p>
<p>is also possible to access an individual bit within an array by adding appending the index of element.
</p>
<p>Example:
</p>
<p>Mem[2]; // This is the 3rd element within the array named &ldquo;Mem&rdquo;.
// This syntax represents an 8-bit vector of type reg.
</p>
<p>Mem[2][7]; // This is the MSB of the 3rd element within the array named &ldquo;Mem&rdquo;.
// This syntax represents a single bit of type reg.
</p>
<p>A[2]; // This is the 2nd element within the array named &ldquo;A&rdquo;. Recall
// that A was declared with a starting index of 1.
// This syntax represents a 32-bit, signed integer.
</p>
<p>5.4.1.6 Expressing Numbers Using Different Bases
</p>
<p>If a number is simply entered into Verilog without identifying syntax, it is treated as an integer.
</p>
<p>However, Verilog supports defining numbers in other bases. Verilog also supports an optional bit size
</p>
<p>and sign of a number. When defining the value of arrays, the &ldquo;_&rdquo; can be inserted between numerals to
</p>
<p>improve readability. The &ldquo;_&rdquo; is ignored by the Verilog compiler. Values of numbers can be entered in
</p>
<p>either upper or lower case (i.e., z or Z, f or F, etc.). The syntax for specifying the base of a number is as
</p>
<p>follows:
</p>
<p>&lt;size_in_bits&gt;&rsquo;&lt;base&gt;&lt;value&gt;
</p>
<p>Note that specifying the size is optional. If it is omitted, the number will default to a 32-bit vector with
</p>
<p>leading zeros added as necessary. The supported bases are as follows:
</p>
<p>Syntax Description
</p>
<p>&lsquo;b Unsigned binary
</p>
<p>&lsquo;o Unsigned octal
</p>
<p>&lsquo;d Unsigned decimal
</p>
<p>&lsquo;h Unsigned hexadecimal
</p>
<p>&lsquo;sb Signed binary
</p>
<p>&lsquo;so Signed octal
</p>
<p>&lsquo;sd Signed decimal
</p>
<p>&lsquo;sh Signed hexadecimal
</p>
<p>5.4 Verilog Constructs &bull; 167</p>
<p/>
</div>
<div class="page"><p/>
<p>Example:
</p>
<p>10 // This is treated as decimal 10, which is a 32-bit signed vector.
4&rsquo;b1111 // A 4-bit number with the value 11112.
8&rsquo;b1011_0000 // An 8-bit number with the value 101100002.
8&rsquo;hFF // An 8-bit number with the value 111111112.
8&rsquo;hff // An 8-bit number with the value 111111112.
6&rsquo;hA // A 6-bit number with the value 0010102. Note that leading zeros
</p>
<p>// were added to make the value 6-bits.
8&rsquo;d7 // An 8-bit number with the value 000001112.
32&rsquo;d0 // A 32-bit number with the value 0000_000016.
&rsquo;b1111 // A 32-bit number with the value 0000_000F16.
8&rsquo;bZ // An 8-bit number with the value ZZZZ_ZZZZ.
</p>
<p>5.4.1.7 Assigning Between Different Types
</p>
<p>Verilog is said to be a weakly typed (or loosely typed) language, meaning that it permits assignments
</p>
<p>between different data types. This is as opposed to a strongly typed language (such as VHDL) where
</p>
<p>signal assignments are only permitted between like types. The reason Verilog permits assignment
</p>
<p>between different types is because it treats all of its types as just group of bits. When assigning between
</p>
<p>different types, Verilog will automatically truncate or add leading bits as necessary to make the assign-
</p>
<p>ment work. The following examples illustrate how Verilog handles a few assignments between different
</p>
<p>types. Assume that a variable called ABC_TB has been declared as type reg[2:0].
</p>
<p>Example:
</p>
<p>ABC_TB&frac14;2&rsquo;b00; //ABC_TBwillbeassigned3&rsquo;b000. Aleadingbitisautomaticallyadded.
ABC_TB&frac14; 5; //ABC_TBwillbeassigned3&rsquo;b101. The integer istruncated to3-bits.
ABC_TB&frac14; 8; //ABC_TBwillbeassigned3&rsquo;b000. The integer istruncated to3-bits.
</p>
<p>5.4.2 The Module
</p>
<p>All systems in Verilog are encapsulated inside of a module. Modules can include instantiations of
</p>
<p>lower-level modules in order to support hierarchical designs. The keywords module and endmodule
</p>
<p>signify the beginning and end of the system description. When working on large designs, it is common
</p>
<p>practice to place each module in its own file with the same name.
</p>
<p>module module_name (port_list); // Pre Verilog-2001
// port_definitions
// module_items
</p>
<p>endmodule
</p>
<p>or
</p>
<p>module module_name (port_list and port_definitions); // Verilog-2001 and after
// module_items
</p>
<p>endmodule
</p>
<p>5.4.2.1 Port Definitions
</p>
<p>The first item within a module is its definition of the inputs and outputs, or ports. Each port needs to
</p>
<p>have a user-defined name, a direction, and a type. The user-defined port names are case sensitive and
</p>
<p>must begin an alphabetic character. The port directions are declared to be one of the three types: input,
</p>
<p>output, and inout. A port can take on any of the previously described data types, but only wires,
</p>
<p>registers, and integers are synthesizable. Port names with the same type and direction can be listed
</p>
<p>on the same line separated by commas.
</p>
<p>168 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>There are two different port definition styles supported in Verilog. Prior to the Verilog-2001 release,
</p>
<p>the port names were listed within parentheses after the module name. Then within the module, the
</p>
<p>directionality and type of the ports were listed. Starting with the Verilog-2001 release, the port directions
</p>
<p>and types could be included alongside the port names within the parenthesis after the module name.
</p>
<p>This approach mimicked more of an ANSCI-C approach to passing inputs/outputs to a system. In this
</p>
<p>text, the newer approach to port definition will be used. Example 5.1 shows multiple approaches for
</p>
<p>defining a module and its ports.
</p>
<p>5.4.2.2 Signal Declarations
</p>
<p>A signal that is used for internal connections within a system is declared within the module before its
</p>
<p>first use. Each signal must be declared by listing its type followed by a user-defined name. Signal names
</p>
<p>of like type can be declared on the same line separated with a comma. All of the legal data types
</p>
<p>described above can be used for signals; however, only types net, reg, and integer will synthesize
</p>
<p>directly. The syntax for a signal declaration is as follows:
</p>
<p>&lt;type&gt; name;
</p>
<p>Example:
</p>
<p>wire node1; // declare a signal named &ldquo;node1&rdquo; of type wire
reg Q2, Q1, Q0; // declare three signals named &ldquo;Q2&rdquo;, &ldquo;Q1&rdquo;, and &ldquo;Q0&rdquo;, all of type
reg
</p>
<p>wire [63:0] bus1; //declarea 64-bitvectornamed&ldquo;bus1&rdquo;withallbitsoftypewire
integer i,j; // declare two integers called &ldquo;i&rdquo; and &ldquo;j&rdquo;
</p>
<p>Example 5.1
Declaring Verilog module ports
</p>
<p>5.4 Verilog Constructs &bull; 169</p>
<p/>
</div>
<div class="page"><p/>
<p>Verilog supports a hierarchical design approach; thus, signal names can be the same within a
</p>
<p>sub-system as those at a higher level without conflict. Figure 5.9 shows an example of legal signal
</p>
<p>naming in a hierarchical design.
</p>
<p>5.4.2.3 Parameter Declarations
</p>
<p>A parameter, or constant, is useful for representing a quantity that will be used multiple times in the
</p>
<p>architecture. The syntax for declaring a parameter is as follows:
</p>
<p>parameter &lt;type&gt; constant_name = &lt;value&gt;;
</p>
<p>Note that the type is optional and can only be integer, time, real, or realtime. If a type is provided,
</p>
<p>the parameter will have the same properties as a variable of the same time. If the type is excluded, the
</p>
<p>parameter will take on the type of the value assigned to it.
</p>
<p>Example:
</p>
<p>parameter BUS_WIDTH = 64;
parameter NICKEL = 8&rsquo;b0000_0101;
</p>
<p>Once declared, the constant name can be used throughout the module. The following example
</p>
<p>illustrates how we can use a constant to define the size of a vector. Notice that since we defined the
</p>
<p>constant to be the actual width of the vector (i.e., 32-bits), we need to subtract one from its value when
</p>
<p>defining the indices (i.e., [31:0]).
</p>
<p>Example:
</p>
<p>wire [BUS_WIDTH-1:0] BUS_A; // It is acceptable to add a &ldquo;space&rdquo; for
readability
</p>
<p>Fig. 5.9
Verilog signals and systems
</p>
<p>170 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4.2.4 Compiler Directives
</p>
<p>A compiler directive provides additional information to the simulation tool on how to interpret the
</p>
<p>Verilog model. A compiler directive is placed before the module definition and is preceded with a backtick
</p>
<p>(i.e., `). Note that this is not an apostrophe. A few of the most commonly used compiler directives are as
</p>
<p>follows:
</p>
<p>Syntax Description
</p>
<p>`timescale &lt;unit&gt;,&lt;precision&gt; Defines the timescale of the delay unit and its smallest precision.
</p>
<p>`include &lt;filename&gt; Includes additional files in the compilation.
</p>
<p>`define &lt;macroname&gt; &lt;value&gt; Declares a global constant.
</p>
<p>Example:
</p>
<p>&lsquo;timescale 1ns/1ps // Declares the unit of time is 1 ns with a precision of 1ps.
// The precision is the smallest amount that the time can
// take on. For example, with this directive the number
// 0.001 would be interpreted as 0.001 ns, or 1 ps.
// However, the number 0.0001 would be interpreted as 0 since
// it is smaller than the minimum precision value.
</p>
<p>5.4.3 Verilog Operators
</p>
<p>There are a variety of pre-defined operators in the Verilog standard. It is important to note that
</p>
<p>operators are defined to work on specific data types and that not all operators are synthesizable.
</p>
<p>5.4.3.1 Assignment Operator
</p>
<p>Verilog uses the equal sign (=) to denote an assignment. The left-hand side (LHS) of the assignment
</p>
<p>is the target signal. The right-hand side (RHS) contains the input arguments and can contain both
</p>
<p>signals, constants, and operators.
</p>
<p>Example:
</p>
<p>F1 = A; // F1 is assigned the signal A
F2 = 8&rsquo;hAA; // F2 is an 8-bit vector and is assigned the value 101010102
</p>
<p>5.4.3.2 Bitwise Logical Operators
</p>
<p>Bitwise operators perform logic functions on individual bits. The inputs to the operation are single
</p>
<p>bits and the output is a single bit. In the case where the inputs are vectors, each bit in the first vector is
</p>
<p>operated on by the bit in the same position from the second vector. If the vectors are not the same length,
</p>
<p>the shorter vector is padded with leading zeros to make both lengths equal. Verilog contains the following
</p>
<p>bitwise operators:
</p>
<p>Syntax Operation
</p>
<p>~ Negation
</p>
<p>&amp; AND
</p>
<p>| OR
</p>
<p>^ XOR
</p>
<p>~^ or ^~ XNOR
</p>
<p>&lt;&lt; Logical shift left (fill empty LSB location with zero)
</p>
<p>&gt;&gt; Logical shift right (fill empty MSB location with zero)
</p>
<p>5.4 Verilog Constructs &bull; 171</p>
<p/>
</div>
<div class="page"><p/>
<p>Example:
</p>
<p>~X // invert each bit in X
X &amp; Y // AND each bit of X with each bit of Y
X | Y // OR each bit of X with each bit of Y
X ^ Y // XOR each bit of X with each bit of Y
X ~^ Y // XNOR each bit of X with each bit of Y
X &lt;&lt; 3 // Shift X left 3 times and fill with zeros
Y &gt;&gt; 2 // Shift Y right 2 times and fill with zeros
</p>
<p>5.4.3.3 Reduction Logic Operators
</p>
<p>A reduction operator is one that uses each bit of a vector as individual inputs into a logic operation
</p>
<p>and produces a single bit output. Verilog contains the following reduction logic operators.
</p>
<p>Syntax Operation
</p>
<p>&amp; AND all bits in the vector together (1-bit result)
</p>
<p>~&amp; NAND all bits in the vector together (1-bit result)
</p>
<p>| OR all bits in the vector together (1-bit result)
</p>
<p>~| NOR all bits in the vector together (1-bit result)
</p>
<p>^ XOR all bits in the vector together (1-bit result)
</p>
<p>~^ or ^~ XNOR all bits in the vector together (1-bit result)
</p>
<p>Example:
</p>
<p>&amp;X // AND all bits in vector X together
~&amp;X // NAND all bits in vector X together
|X // OR all bits in vector X together
~|X // NOR all bits in vector X together
^X // XOR all bits in vector X together
~^X // XNOR all bits in vector X together
</p>
<p>5.4.3.4 Boolean Logic Operators
</p>
<p>A Boolean logic operator is one that returns a value of TRUE (1) or FALSE (0) based on a logic
</p>
<p>operation of the input operations. These operations are used in decision statements.
</p>
<p>Syntax Operation
</p>
<p>! Negation
</p>
<p>&amp;&amp; AND
</p>
<p>|| OR
</p>
<p>Example:
</p>
<p>!X // TRUE if all values in X are 0, FALSE otherwise
X &amp;&amp; Y // TRUE if the bitwise AND of X and Y results in all ones, FALSE otherwise
X || Y // TRUE if the bitwise OR of X and Y results in all ones, FALSE otherwise
</p>
<p>5.4.3.5 Relational Operators
</p>
<p>A relational operator is one that returns a value of TRUE (1) or FALSE (0) based on a comparison of
</p>
<p>two inputs.
</p>
<p>Syntax Description
</p>
<p>== Equality
</p>
<p>!= Inequality
</p>
<p>&lt; Less than
</p>
<p>&gt; Greater than
</p>
<p>&lt;= Less than or equal
</p>
<p>&gt;= Greater than or equal
</p>
<p>172 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>Example:
</p>
<p>X == Y // TRUE if X is equal to Y, FALSE otherwise
X != Y // TRUE if X is not equal to Y, FALSE otherwise
X &lt; Y // TRUE if X is less than Y, FALSE otherwise
X &gt; Y // TRUE if X is greater than Y, FALSE otherwise
X &lt;= Y // TRUE if X is less than or equal to Y, FALSE otherwise
X &gt;= Y // TRUE if X is greater than or equal to Y, FALSE otherwise
</p>
<p>5.4.3.6 Conditional Operators
</p>
<p>Verilog contains a conditional operator that can be used to provide a more intuitive approach to
</p>
<p>modeling logic statements. The keyword for the conditional operator is ? with the following syntax:
</p>
<p>&lt;target_net&gt; = &lt;Boolean_condition&gt; ? &lt;true_assignment&gt; : &lt;false_assignment&gt;;
</p>
<p>This operator specifies a Boolean condition in which if evaluated TRUE, the true_assignment will be
</p>
<p>assigned to the target. If the Boolean condition is evaluated FALSE, the false_assignment portion of the
</p>
<p>operator will be assigned to the target. The values in this assignment can be signals or logic values. The
</p>
<p>Boolean condition can be any combination of the Boolean operators described above. Nested condi-
</p>
<p>tional operators can also be implemented by inserting subsequent conditional operators in place of the
</p>
<p>false_value.
</p>
<p>Example:
</p>
<p>F = (A == 1&rsquo;b0) ? 1&rsquo;b1 : 1&rsquo;b0; // If A is a zero, F=1, otherwise F=0.
This models an inverter.
</p>
<p>F = (sel == 1&rsquo;b0) ? A : B; // If sel is a zero, F=A, otherwise F=B.
This models a selectable switch.
</p>
<p>F = ((A == 1&rsquo;b0) &amp;&amp; (B == 1&rsquo;b0)) ? 1&rsquo;b&rsquo;0 : // Nested conditional statements.
((A == 1&rsquo;b0) &amp;&amp; (B == 1&rsquo;b1)) ? 1&rsquo;b&rsquo;1 : // This models an XOR gate.
((A == 1&rsquo;b1) &amp;&amp; (B == 1&rsquo;b0)) ? 1&rsquo;b&rsquo;1 :
((A == 1&rsquo;b1) &amp;&amp; (B == 1&rsquo;b1)) ? 1&rsquo;b&rsquo;0;
</p>
<p>F = ( !C &amp;&amp; (!A || B) ) ? 1&rsquo;b1 : 1&rsquo;b0; // This models the logic expression
// F = C&rsquo;�(A&rsquo;+B).
</p>
<p>5.4.3.7 Concatenation Operator
</p>
<p>In Verilog, the curly brackets (i.e., {}) are used to concatenate multiple signals. The target of this
</p>
<p>operation must be the same size of the sum of the sizes of the input arguments.
</p>
<p>Example:
</p>
<p>Bus1[7:0]&frac14; {Bus2[7:4],Bus3[3:0]};//AssumingBus1,Bus2,andBus3areall8-bit
// vectors,thisoperationtakestheupper4-bits
</p>
<p>of
// Bus2,concatenatesthemwiththelower4-bitsof
// Bus3,andassignsthe8-bitcombinationtoBus1.
</p>
<p>BusC &frac14; {BusA, BusB}; // If BusA and BusB are 4-bits, then BusC
// must be 8-bits.
</p>
<p>BusC[7:0]&frac14; {4&rsquo;b0000, BusA}; // This pads the 4-bit vector BusA with 4x leading
// zeros and assigns to the 8-bit vector BusC.
</p>
<p>5.4 Verilog Constructs &bull; 173</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4.3.8 Replication Operator
</p>
<p>Verilog provides the ability to concatenate a vector with itself through the replication operator. This
</p>
<p>operator uses double curly brackets (i.e., {{}}) and an integer indicating the number of replications to be
</p>
<p>performed. The replication syntax is as follows:
</p>
<p>{&lt;number_of_replications&gt;{&lt;vector_name_to_be_replicated&gt;}}
</p>
<p>Example:
</p>
<p>BusX&frac14; {4{Bus1}}; //Thisisequivalentto: BusX&frac14; {Bus1,Bus1, Bus1, Bus1};
BusY&frac14; {2{A,B}}; // This is equivalent to: BusY&frac14; {A, B, A, B};
BusZ&frac14; {Bus1, {2{Bus2}}}; // This is equivalent to: BusZ&frac14; {Bus1, Bus2, Bus2};
</p>
<p>5.4.3.9 Numerical Operators
</p>
<p>Verilog also provides a set of numerical operators as follows:
</p>
<p>Syntax Operation
</p>
<p>+ Addition
</p>
<p>� Subtraction (when placed between arguments)
</p>
<p>� 2&rsquo;s complement negation (when placed in front of an argument)
</p>
<p>* Multiplication
</p>
<p>/ Division
</p>
<p>% Modulus
</p>
<p>** Raise to the power
</p>
<p>&lt;&lt;&lt; Shift to the left, fill with zeros
</p>
<p>&lt;&lt;&lt; Shift to the right, fill with sign bit
</p>
<p>Example:
</p>
<p>X + Y // Add X to Y
X - Y // Subtract Y from X
-X // Take the two&rsquo;s complement negation of X
X * Y // Multiply X by Y
X / Y // Divide X by Y
X % Y // Modulus X/Y
X ** Y // Raise X to the power of Y
X &lt;&lt;&lt; 3 // Shift X left 3 times, fill with zeros
X &gt;&gt;&gt; 2 // Shift X right 2 times, fill with sign bit
</p>
<p>Verilog will allow the use of these operators on arguments of different sizes, types, and signs. The
</p>
<p>rules of the operations are as follows:
</p>
<p>&bull; If two vectors are of different sizes, the smaller vector is expanded to the size of the larger
vector.
</p>
<p>○ If the smaller vector is unsigned, it is padded with zeros.
</p>
<p>○ If the smaller vector is signed, it is padded with the sign bit.
</p>
<p>&bull; If one of the arguments is real, then the arithmetic will take place using real numbers.
</p>
<p>&bull; If one of the arguments is unsigned, then all arguments will be treated as unsigned.
</p>
<p>174 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.4.3.10 Operator Precedence
</p>
<p>The following is the order of precedence of the Verilog operators:
</p>
<p>Operators Precedence Notes
</p>
<p>! ~ + - Highest Bitwise/unary
</p>
<p>{} {{}} Concatenation/replication
</p>
<p>() # No operation, just parenthesis
</p>
<p>** Power
</p>
<p>* / % Binary multiply/divide/modulo
</p>
<p>+ - # Binary addition/subtraction
</p>
<p>&lt;&lt; &gt;&gt; &lt;&lt;&lt; &gt;&gt;&gt; Shift operators
</p>
<p>&lt; &lt;&frac14; &gt; &gt;&frac14; Greater/less than comparisons
</p>
<p>&frac14;&frac14; !&frac14; # Equality/inequality comparisons
</p>
<p>&amp; ~&amp; AND/NAND operators
</p>
<p>^ ~^ XOR/XNOR operators
</p>
<p>| ~| # OR/NOR operators
</p>
<p>&amp;&amp; Boolean AND
</p>
<p>|| Boolean OR
</p>
<p>?: Lowest Conditional operator
</p>
<p>CONCEPT CHECK
</p>
<p>CC5.4(a) What revision of Verilog added the ability to list the port names, types, and directions
just once after the module name?
</p>
<p>A) Verilog-1995.
</p>
<p>B) Verilog-2001.
</p>
<p>C) Verilog-2005.
</p>
<p>D) SystemVerilog.
</p>
<p>CC5.4(b) What is the difference between types wire and reg?
</p>
<p>A) They are the same.
</p>
<p>B) The type wire is a simple interconnection while reg will hold the value of its
last assignment.
</p>
<p>C) The type wire is for scalars while the type reg is for vectors.
</p>
<p>D) Only wire is synthesizable.
</p>
<p>5.5 Modeling Concurrent Functionality in Verilog
</p>
<p>It is important to remember that Verilog is a hardware description language, not a programming
</p>
<p>language. In a programming language, the lines of code are executed sequentially as they appear in the
</p>
<p>source file. In Verilog, the lines of code represent the behavior of real hardware. Thus, the assignments
</p>
<p>are executed concurrently unless specifically noted otherwise.
</p>
<p>5.5 Modeling Concurrent Functionality in Verilog &bull; 175</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5.1 Continuous Assignment
</p>
<p>Verilog uses the keyword assign to denote a continuous signal assignment. After this keyword, an
</p>
<p>assignment is made using the &frac14; symbol. The left-hand side (LHS) of the assignment is the target signal
</p>
<p>and must be a net type. The right-hand side (RHS) contains the input arguments and can contain nets,
</p>
<p>regs, constants, and operators. A continuous assignment models combinational logic. Any change to the
</p>
<p>RHS of the expression will result in an update to the LHS target net. The net being assigned to must be
</p>
<p>declared prior to the first continuous assignment. Multiple continuous assignments can be made to the
</p>
<p>same net. When this happens, the assignment containing signals with the highest drive strength will take
</p>
<p>priority.
</p>
<p>Example:
</p>
<p>assign F1 &frac14; A; // F1 is updated anytime A changes, where A is a signal
assign F2 &frac14; 1&rsquo;b0; // F2 is assigned the value 0
assign F3 &frac14; 4&rsquo;hAA; // F3 is an 8-bit vector and is assigned the value 101010102
</p>
<p>Each individual assignment will be executed concurrently and synthesized as separate logic
</p>
<p>circuits. Consider the following example.
</p>
<p>Example:
</p>
<p>assign X &frac14; A;
assign Y &frac14; B;
assign Z &frac14; C;
</p>
<p>When simulated, these three lines of Verilog will make three separate signal assignments at the
</p>
<p>exact same time. This is different from a programming language that will first assign A to X, then B to Y,
</p>
<p>and finally C to Z. In Verilog this functionality is identical to three separate wires. This description will be
</p>
<p>directly synthesized into three separate wires.
</p>
<p>Below is another example of how continuous signal assignments in Verilog differ from a sequentially
</p>
<p>executed programming language.
</p>
<p>Example:
</p>
<p>assign A &frac14; B;
assign B &frac14; C;
</p>
<p>In a Verilog simulation, the signal assignments of C to B and B to A will take place at the same time.
</p>
<p>This means during synthesis, the signal B will be eliminated from the design since this functionality
</p>
<p>describes two wires in series. Automated synthesis tools will eliminate this unnecessary signal name.
</p>
<p>This is not the same functionality that would result if this example was implemented as a sequentially
</p>
<p>executed computer program. A computer program would execute the assignment of B to A first and then
</p>
<p>assign the value of C to B second. In this way, B represents a storage element that is passed to A before
</p>
<p>it is updated with C.
</p>
<p>5.5.2 Continuous Assignment with Logical Operators
</p>
<p>Each of the logical operators described in Sect. 5.4.3.2 can be used in conjunction with concurrent
</p>
<p>signal assignments to create individual combinational logic circuits. Example 5.2 shows how to design a
</p>
<p>Verilog model of a combinational logic circuit using this approach.
</p>
<p>176 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5.3 Continuous Assignment with Conditional Operators
</p>
<p>Logical operators are good for describing the behavior of small circuits; however, in the prior
</p>
<p>example, we still needed to create the canonical sum of products logic expression by hand before
</p>
<p>describing the functionality in Verilog. The true power of an HDL is when the behavior of the system can
</p>
<p>be described fully without requiring any hand design. The conditional operator allows us to describe a
</p>
<p>continuous assignment using Boolean conditions that affect the values of the result. In this approach, we
</p>
<p>use the conditional operator (?) in conjunction with the continuous assignment keyword assign. Exam-
</p>
<p>ple 5.3 shows how to design a Verilog model of a combinational logic circuit using continuous assign-
</p>
<p>ment with conditional operators. Note that this example uses the same truth table as in Example 5.2 to
</p>
<p>illustrate a comparison between approaches.
</p>
<p>Example 5.2
Modeling combinational logic using continuous assignment with logical operators
</p>
<p>5.5 Modeling Concurrent Functionality in Verilog &bull; 177</p>
<p/>
</div>
<div class="page"><p/>
<p>In the prior example, the conditional operator was based on a truth table. Conditional operators can
</p>
<p>also be used to model logic expressions. Example 5.4 shows how to design a Verilog model of a
</p>
<p>combinational logic circuit when the logic expression is already known. Note that this example again
</p>
<p>uses the same truth table as in Examples 5.2 and 5.3 to illustrate a comparison between approaches.
</p>
<p>Example 5.3
Modeling combinational logic using continuous assignment with conditional operators (1)
</p>
<p>178 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5.4 Continuous Assignment with Delay
</p>
<p>Verilog provides the ability to model gate delays when using a continuous assignment. The # is used
</p>
<p>to indicate a delayed assignment. For combinational logic circuits, the delay can be specified for all
</p>
<p>transitions, for rising and falling transitions separately, and for rising, falling, and transitions to the value
</p>
<p>off separately. A transition to off refers to a transition to Z. If only one delay parameter is specified, it is
</p>
<p>used to model all delays. If two delay parameters are specified, the first parameter is used for the rise
</p>
<p>time delay, while the second is used to model the fall time delay. If three parameters are specified, the
</p>
<p>third parameter is used to model the transition to off. Parentheses are optional but recommended when
</p>
<p>using multiple delay parameters.
</p>
<p>assign#(&lt;del_all&gt;) &lt;target_net&gt;&frac14;&lt;RHS_nets,operators,etc. . .&gt;;
assign#(&lt;del_rise,del_fall&gt;) &lt;target_net&gt;&frac14;&lt;RHS_nets,operators,etc. . .&gt;;
assign#(&lt;del_rise,del_fall,del_off&gt;)&lt;target_net&gt;&frac14;&lt;RHS_nets,operators,etc. . .&gt;;
</p>
<p>Example:
</p>
<p>assign #1 F &frac14; A; // Delay of 1 on all transitions.
assign #(2,3) F &frac14; A; // Delay of 2 for rising transitions and 3 for falling.
assign #(2,3,4) F &frac14; A; // Delay of 2 for rising, 3 for falling, and 4 for off
transitions.
</p>
<p>When using delay, it is typical to include the `timescale directive to provide the units of the delay
</p>
<p>being specified. Example 5.5 shows a graphical depiction of using delay with continuous assignments
</p>
<p>when modeling combinational logic circuits.
</p>
<p>Example 5.4
Modeling combinational logic using continuous assignment with conditional operators (2)
</p>
<p>5.5 Modeling Concurrent Functionality in Verilog &bull; 179</p>
<p/>
</div>
<div class="page"><p/>
<p>Verilog also provides a mechanism to model a range of delays that are selected by a switch set in
</p>
<p>the CAD compiler. There are three delays categories that can be specified: minimum, typical, and
</p>
<p>maximum. The delays are separated by a &ldquo;:&rdquo;. The following is the syntax of how to use the delay
</p>
<p>range capability.
</p>
<p>assign #(&lt;min&gt;:&lt;typ&gt;:&lt;max&gt;) &lt;target_net&gt; &frac14; &lt;RHS_nets, operators, etc. . .&gt;;
</p>
<p>Example 5.5
Modeling delay in continuous assignments
</p>
<p>180 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>Example:
</p>
<p>assign#(1:2:3) F&frac14;A;//Specifyingarangeofdelaysforalltransitions.
assign#(1:1:2,2:2:3) F&frac14;A;//Specifyingarangeofdelaysforrising/falling.
assign#(1:1:2,2:2:3,4:4:5)F&frac14;A;//Specifyingarangeofdelaysforeachtransition.
</p>
<p>The delay modeling capability in continuous assignment is designed to model the behavior of real
</p>
<p>combinational logic with respect to short duration pulses. When a pulse is shorter than the delay of the
</p>
<p>combinational logic gate, the pulse is ignored. Ignoring brief input pulses on the input accurately models
</p>
<p>the behavior of on-chip gates. When the input pulse is faster than the delay of the gate, the output of the
</p>
<p>gate does not have time to respond. As a result, there will not be a logic change on the output. This is
</p>
<p>called inertial delay modeling and is the default behavior when using continuous assignments. Example
</p>
<p>5.6 shows a graphical depiction of inertial delay behavior in Verilog.
</p>
<p>Example 5.6
Inertial delay modeling when using continuous assignment
</p>
<p>5.5 Modeling Concurrent Functionality in Verilog &bull; 181</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC5.5(a) Why is concurrency such an important concept in HDLs?
</p>
<p>A) Concurrency is a feature of HDLs that can&rsquo;t be modeled using schematics.
</p>
<p>B) Concurrency allows automated synthesis to be performed.
</p>
<p>C) Concurrency allows logic simulators to display useful system information.
</p>
<p>D) Concurrency is necessary to model real systems that operate in parallel.
</p>
<p>CC5.5(b) Why does modeling combinational logic in its canonical form with continuous assign-
ment with logical operators defeat the purpose of the modern digital design flow?
</p>
<p>A) It requires the designer to first create the circuit using the classical digital
design approach and then enter it into the HDL in a form that is essentially a
text-based netlist. This doesn&rsquo;t take advantage of the abstraction
capabilities and automated synthesis in the modern flow.
</p>
<p>B) It cannot be synthesized because the order of precedence of the logical
operators in Verilog doesn&rsquo;t match the precedence defined in Boolean
algebra.
</p>
<p>C) The circuit is in its simplest form so there is no work for the synthesizer
to do.
</p>
<p>D) It doesn&rsquo;t allow an else clause to cover the outputs for any remaining input
codes not explicitly listed.
</p>
<p>5.6 Structural Design and Hierarchy
</p>
<p>Structural design in Verilog refers to including lower-level sub-systems within a higher-level module
</p>
<p>in order to produce the desired functionality. This is called hierarchy and is a good design practice
</p>
<p>because it enables design partitioning. A purely structural design will not contain any behavioral
</p>
<p>constructs in the module such as signal assignments but instead just contain the instantiation and
</p>
<p>interconnections of other sub-systems. A sub-system in Verilog is simply another module that is called
</p>
<p>by a higher-level module. Each lower-level module that is called is executed concurrently by the calling
</p>
<p>module.
</p>
<p>5.6.1 Lower-Level Module Instantiation
</p>
<p>The term instantiation refers to the use or inclusion of a lower-level module within a system. In
</p>
<p>Verilog, the syntax for instantiating a lower-level module is as follows.
</p>
<p>module_name &lt;instance_identifier&gt; (port mapping. . .);
</p>
<p>The first portion of the instantiation is the module name that is being called. This must match the
</p>
<p>lower-level module name exactly, including case. The second portion of the instantiation is an optional
</p>
<p>instance identifier. An instance identifier is useful when instantiating multiple instances of the same
</p>
<p>lower-level module. The final portion of the instantiation is the port mapping. There are two techniques to
</p>
<p>connect signals to the ports of the lower-level module, explicit and positional.
</p>
<p>182 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.6.1.1 Explicit Port Mapping
</p>
<p>In explicit port mapping, the names of the ports of the lower-level sub-system are provided along
</p>
<p>with the signals they are being connected to. The lower-level port name is preceded with a period (.),
</p>
<p>while the signal it is being connected is enclosed within parentheses. The port connections can be listed
</p>
<p>in any order since the details of the connection (i.e., port name to signal name) are explicit. Each
</p>
<p>connection is separated by a comma. The syntax for explicit port mapping is as follows:
</p>
<p>module_name&lt;instanceidentifier&gt;(.port_name1(signal1),.port_name2(signal2),etc.);
</p>
<p>Example 5.7 shows how to design a Verilog model of a hierarchical system that consists of two
</p>
<p>lower-level modules.
</p>
<p>5.6.1.2 Positional Port Mapping
</p>
<p>In positional port mapping, the names of the ports of the lower-level modules are not explicitly listed.
</p>
<p>Instead, the signals to be connected to the lower-level system are listed in the same order in which the
</p>
<p>ports were defined in the sub-system. Each signal name is separated by a comma. This approach
</p>
<p>requires less text to describe the connection but can also lead to misconnections due to inadvertent
</p>
<p>mistakes in the signal order. The syntax for positional port mapping is as follows:
</p>
<p>module_name : &lt;instance_identifier&gt; (signal1, signal2, etc.);
</p>
<p>Example 5.7
Verilog structural design using explicit port mapping
</p>
<p>5.6 Structural Design and Hierarchy &bull; 183</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 5.8 shows how to create the same structural Verilog model as in Example 5.7, but using
</p>
<p>positional port mapping instead.
</p>
<p>5.6.2 Gate-Level Primitives
</p>
<p>Verilog provides the ability to model basic logic functionality through the use of primitives. A primitive
</p>
<p>is a logic operation that is simple enough that it doesn&rsquo;t require explicit modeling. An example of this
</p>
<p>behavior can be a basic logic gate or even a truth table. Verilog provides a set of gate-level primitives to
</p>
<p>model simple logic operations. These gate-level primitives are not(), and(), nand(), or(), nor(), xor(), and
</p>
<p>xnor(). Each of these primitives is instantiated as lower-level sub-systems with positional port mapping.
</p>
<p>The port order for each primitive has the output listed first followed by the input(s). The output and each of
</p>
<p>the inputs are scalars. Gate-level primitives do not need to be explicitly created as they are provided as
</p>
<p>part of the Verilog standard. One of the benefits of using gate-level primitives is that the number of inputs
</p>
<p>is easily scaled as each primitive can accommodate an increasing number of inputs automatically.
</p>
<p>Furthermore, modeling using this approach essentially provides a gate-level netlist, so it represents a
</p>
<p>very low-level, detailed gate-level implementation that is ready for technology mapping. Example 5.9
</p>
<p>shows how to use gate-level primitives to model the behavior of a combinational logic circuit.
</p>
<p>Example 5.8
Verilog structural design using positional port mapping
</p>
<p>184 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>5.6.3 User-Defined Primitives
</p>
<p>A user-defined primitive (UDP) is a system that describes the behavior of a low-level component
</p>
<p>using a logic table. This is very useful for creating combinational logic functionality that will be used
</p>
<p>numerous times. UDPs are also useful for large truth tables where it is more convenient to list the
</p>
<p>functionality in table form. UDPs are lower-level sub-systems that are intended to be instantiated in
</p>
<p>higher-level modules just like gate-level primitives, with the exception that the UPD needs to be created
</p>
<p>in its own file. The syntax for a UDP is as follows:
</p>
<p>primitive primitive_name (output output_name,
input input_name1, input_name2, ...);
</p>
<p>table
</p>
<p>in1_val in2_val ... : out_val;
in1_val in2_val ... : out_val;
:
</p>
<p>endtable
</p>
<p>endprimitive
</p>
<p>A UDPmust list its output(s) first in the port definition. It also does not require types to be defined for
</p>
<p>the ports. For combinational logic UDPs, all ports are assumed to be of type wire. Example 5.10 shows
</p>
<p>how to design a user-defined primitive to implement a combinational logic circuit.
</p>
<p>Example 5.9
Modeling combinational logic circuits using gate-level primitives
</p>
<p>5.6 Structural Design and Hierarchy &bull; 185</p>
<p/>
</div>
<div class="page"><p/>
<p>5.6.4 Adding Delay to Primitives
</p>
<p>Delay can be added to primitives using the same approach as described in Sect. 5.5.4. The delay is
</p>
<p>inserted after the primitive name but before the instance name.
</p>
<p>Example:
</p>
<p>not #2 U0 (An, A); // Gate level primitive for an inverter with delay of 2.
and #3 U3 (m0, An, Bn, Cn); // Gate level primitive for an AND gate with delay of 3.
SystemX_UDP #1 U0 (F, A, B, C); // UDP with a delay of 1.
</p>
<p>Example 5.10
Modeling combinational logic circuits with a user-defined primitive
</p>
<p>186 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC5.6 Does the use of lower-level sub-modules model concurrent functionality? Why?
</p>
<p>A) No. Since the lower-level behavior of the module being instantiated may
contain nonconcurrent behavior, it is not known what functionality will be
modeled.
</p>
<p>B) Yes. The modules are treated like independent sub-systems whose behavior
runs in parallel just as if separate parts were placed in a design.
</p>
<p>5.7 Overview of Simulation Test Benches
</p>
<p>One of the essential components of the modern digital design flow is verifying functionality through
</p>
<p>simulation. This simulation takes place at many levels of abstraction. For a system to be tested, there
</p>
<p>needs to be a mechanism to generate input patterns to drive the system and then observe the outputs to
</p>
<p>verify correct operation. The mechanism to do this in Verilog is called a test bench. A test bench is a file in
</p>
<p>Verilog that has no inputs or outputs. The test bench instantiates the system to be tested as a lower-level
</p>
<p>module. The test bench generates the input conditions and drives them into the input ports of the system
</p>
<p>being tested. Verilog contains numerous methods to generate stimulus patterns. Since a test bench will
</p>
<p>not be synthesized, very abstract behavioral modeling can be used to generate the inputs. The output of
</p>
<p>the system can be viewed as a waveform in a simulation tool. Verilog also has the ability to check the
</p>
<p>outputs against expected results and notify the user if differences occur. Figure 5.10 gives an overview
</p>
<p>of how test benches are used in Verilog. The techniques to generate the stimulus patterns are covered in
</p>
<p>Chap. 8.
</p>
<p>5.7 Overview of Simulation Test Benches &bull; 187</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC5.7 How can the output of a DUT be verified when it is connected to a signal that does not go
anywhere?
</p>
<p>A) It can&rsquo;t. The output must be routed to an output port on the test bench.
</p>
<p>B) The values of any dangling signal are automatically written to a text file.
</p>
<p>C) It is viewed in the logic simulator as either a waveform or text listing.
</p>
<p>D) It can&rsquo;t. A signal that does not go anywhere will cause an error when the
Verilog file is compiled.
</p>
<p>Fig. 5.10
Overview of Verilog test benches
</p>
<p>188 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v Themodern digital design flow relies on com-
puter- aided engineering (CAE) and
computer-aided design (CAD) tools to man-
age the size and complexity of today&rsquo;s digital
designs.
</p>
<p>v Hardware description languages (HDLs)
allow the functionality of digital systems to
be entered using text. VHDL and Verilog are
the two most common HDLs in use today.
</p>
<p>v In the 1980s, two major HDLs emerged,
VHDL and Verilog. VHDL was sponsored by
the Department of Defense, while Verilog
was driven by the commercial industry. Both
were later standardized by IEEE.
</p>
<p>v The ability to automatically synthesize a logic
circuit from a Verilog behavioral description
became possible approximately 10 years
after the original definition of Verilog. As
such, only a subset of the behavioral
modeling techniques in Verilog can be auto-
matically synthesized.
</p>
<p>v HDLs can model digital systems at different
levels of design abstraction. These include
the system, algorithmic, RTL, gate, and cir-
cuit levels. Designing at a higher level of
abstraction allows more complex systems to
be modeled without worrying about the
details of the implementation.
</p>
<p>v In a Verilog source file, all functionality is
contained within a module. The first portion
of the module is the port definition. The sec-
ond portion contains declarations of internal
signals/constants/ parameters. The third por-
tion contains the description of the behavior.
</p>
<p>v A port is an input or output to a system that is
defined as part of the initial module state-
ment. A signal, or net, is an internal connec-
tion within the system that is declared inside
of the module. A signal is not visible outside
of the system.
</p>
<p>v Instantiating other modules from within a
higher-level module is how Verilog
implements hierarchy. A lower-level module
can be instantiated as many times as
desired. An instance identifier is useful in
keeping track of each instantiation. The
ports of the component can be connected
using either explicit or positional port
mapping.
</p>
<p>v Concurrency is the term that describes
operations being performed in parallel. This
allows real-world system behavior to be
modeled.
</p>
<p>v Verilog provides the continuous assignment
operator to support modeling concurrent
systems. Complex logic circuits can be
implemented by using continuous assign-
ment with logical operators or conditional
operators.
</p>
<p>v Verilog sub-systems are also treated as con-
current sub-systems.
</p>
<p>v Delay can be modeled in Verilog for all
transitions, or for individual transitions (rise,
fall, off). A range of delays can also be
provided (min:typ:max). Delay can be
added to continuous assignments and
sub-system instantiations.
</p>
<p>v Gate-level primitives are provided in Verilog
to implement basic logic functions (not, and,
nand, or, nor, xor, xnor). These primitives are
instantiated just like any other lower-level
sub-system.
</p>
<p>v User-defined primitives are supported in
Verilog that allow the functionality of a circuit
to be described in table form.
</p>
<p>v A simulation test bench is a Verilog file that
drives stimulus into a device under test
(DUT). Test benches do not have inputs or
outputs and are not synthesizable.
</p>
<p>Exercise Problems
</p>
<p>Section 5.1: History of HDLs
</p>
<p>5.1.1 What was the original purpose of Verilog?
</p>
<p>5.1.2 Can all of the functionality that can be
described in Verilog be simulated?
</p>
<p>5.1.3 Can all of the functionality that can be
described in Verilog be synthesized?
</p>
<p>Section 5.2: HDL Abstraction
</p>
<p>5.2.1 Give the level of design abstraction that the
following statement relates to: if there is ever
</p>
<p>an error in the system, it should return to the
reset state.
</p>
<p>5.2.2 Give the level of design abstraction that the
following statement relates to: once the design
is implemented in a sum of products form,
DeMorgan&rsquo;s Theorem will be used to convert
it to a NAND-gate only implementation.
</p>
<p>5.2.3 Give the level of design abstraction that the
following statement relates to: the design will
be broken down into two sub-systems, one that
will handle data collection and the other that
will control data flow.
</p>
<p>Exercise Problems &bull; 189</p>
<p/>
</div>
<div class="page"><p/>
<p>5.2.4 Give the level of design abstraction that the
following statement relates to: the interconnect
on the IC should be changed from aluminum to
copper to achieve the performance needed in
this design.
</p>
<p>5.2.5 Give the level of design abstraction that the
following statement relates to: the MOSFETs
need to be able to drive at least 8 other loads in
this design.
</p>
<p>5.2.6 Give the level of design abstraction that the
following statement relates to: this system will
contain 1 host computer and support up to
1000 client computers.
</p>
<p>5.2.7 Give the design domain that the following activ-
ity relates to: drawing the physical layout of the
CPU will require 6 months of engineering time.
</p>
<p>5.2.8 Give the design domain that the following activ-
ity relates to: the CPU will be connected to four
banks of memory.
</p>
<p>5.2.9 Give the design domain that the following activ-
ity relates to: the fan-in specifications for this
logic family require excessive logic circuitry to
be used.
</p>
<p>5.2.10 Give the design domain that the following activ-
ity relates to: the performance specifications
for this system require 1 TFLOP at &lt;5 W.
</p>
<p>Section 5.3: The Modern Digital
Design Flow
</p>
<p>5.3.1 Which step in the modern digital design flow
does the following statement relate to: a CAD
tool will convert the behavioral model into a
gate-level description of functionality.
</p>
<p>5.3.2 Which step in the modern digital design flow
does the following statement relate to: after
realistic gate and wiring delays are determined,
one last simulation should be performed to
make sure the design meets the original timing
requirements.
</p>
<p>5.3.3 Which step in the modern digital design flow
does the following statement relate to: if the
memory is distributed around the perimeter of
the CPU, the wiring density will be minimized.
</p>
<p>5.3.4 Which step in the modern digital design flow
does the following statement relate to: the
design meets all requirements so now I&rsquo;m
building the hardware that will be shipped.
</p>
<p>5.3.5 Which step in the modern digital design flow
does the following statement relate to: the sys-
tem will be broken down into three
sub-systems with the following behaviors.
</p>
<p>5.3.6 Which step in the modern digital design flow
does the following statement relate to: this sys-
tem needs to have 10 Gbytes of memory.
</p>
<p>5.3.7 Which step in the modern digital design flow
does the following statement relate to: to meet
the power requirements, the gates will be
implemented in the 74HC logic family.
</p>
<p>Section 5.4: Verilog Constructs
</p>
<p>5.4.1 What is the name of the main design unit in
Verilog?
</p>
<p>5.4.2 What portion of the Verilog module describes
the inputs and outputs.
</p>
<p>5.4.3 What step is necessary if a system requires
internal connections?
</p>
<p>5.4.4 What are all the possible values that a Verilog
net type can take on?
</p>
<p>5.4.5 What is the highest strength that a value can
take on in Verilog.
</p>
<p>5.4.6 What is the range of decimal numbers that can
be represented using the type integer in
Verilog?
</p>
<p>5.4.7 What is the width of the vector defined using
the type [63:0] wire?
</p>
<p>5.4.8 What is the syntax for indexing the most signif-
icant bit in the type [31:0] wire? Assume the
vector is named example.
</p>
<p>5.4.9 What is the syntax for indexing the least signif-
icant bit in the type [31:0] wire? Assume the
vector is named example.
</p>
<p>5.4.10 What is the difference between a wire and reg
type?
</p>
<p>5.4.11 How many bits is the type integer by default?
</p>
<p>5.4.12 How many bits is the type real by default?
</p>
<p>Section 5.5: Modeling Concurrent
Functionality in Verilog
</p>
<p>5.5.1 Design a Verilog model to implement the
behavior described by the 3-input minterm list
shown in Fig. 5.11. Use continuous assign-
ment with logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Fig. 5.11
System E functionality
</p>
<p>5.5.2 Design a Verilog model to implement the
behavior described by the 3-input minterm list
shown in Fig. 5.11. Use continuous assign-
ment with conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>5.5.3 Design a Verilog model to implement the
behavior described by the 3-input maxterm
list shown in Fig. 5.12. Use continuous assign-
ment with logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>190 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 5.12
System F functionality
</p>
<p>5.5.4 Design a Verilog model to implement the
behavior described by the 3-input maxterm
list shown in Fig. 5.12. Use continuous assign-
ment with conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>5.5.5 Design a Verilog model to implement the
behavior described by the 3-input truth table
shown in Fig. 5.13. Use continuous assign-
ment with logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Fig. 5.13
System G functionality
</p>
<p>5.5.6 Design a Verilog model to implement the
behavior described by the 3-input truth table
shown in Fig. 5.13. Use continuous assign-
ment with conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>5.5.7 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 5.14. Use continuous assign-
ment and logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Fig. 5.14
System I functionality
</p>
<p>5.5.8 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 5.14. Use continuous assign-
ment and conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>5.5.9 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 5.15. Use continuous assign-
ment and logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Fig. 5.15
System J functionality
</p>
<p>5.5.10 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 5.15. Use continuous assign-
ment and conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>5.5.11 Design a Verilog model to implement the
behavior described by the 4-input truth table
shown in Fig. 5.16. Use continuous assign-
ment and logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Fig. 5.16
System K functionality
</p>
<p>Exercise Problems &bull; 191</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5.12 Design a Verilog model to implement the
behavior described by the 4-input truth table
shown in Fig. 5.16. Use continuous assign-
ment and conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.
</p>
<p>Section 5.6: Structural Design in Verilog
</p>
<p>5.6.1 Design a Verilog model to implement the
behavior described by the 3-input minterm list
shown in Fig. 5.11. Use a structural design
approach based on gate- level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.2 Design a Verilog model to implement the
behavior described by the 3-input minterm list
shown in Fig. 5.11. Use a structural design
approach based on a user-defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>5.6.3 Design a Verilog model to implement the
behavior described by the 3-input maxterm
list shown in Fig. 5.12. Use a structural design
approach based on gate- level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.4 Design a Verilog model to implement the
behavior described by the 3-input maxterm
list shown in Fig. 5.12. Use a structural design
approach based on a user-defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
</p>
<p>ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>5.6.5 Design a Verilog model to implement the
behavior described by the 3-input truth table
shown in Fig. 5.13. Use a structural design
approach based on gate-level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.6 Design a Verilog model to implement the
behavior described by the 3-input truth table
shown in Fig. 5.13. Use a structural design
approach based on a user-defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>5.6.7 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 5.14. Use a structural design
approach based on gate- level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.8 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 5.14. Use a structural design
approach based on a user- defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>5.6.9 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 5.15. Use a structural design
approach based on gate- level primitives. This
is considered structural because you will need
</p>
<p>192 &bull; Chapter 5: Verilog (Part 1)</p>
<p/>
</div>
<div class="page"><p/>
<p>to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.10 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 5.15. Use a structural design
approach based on a user- defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>5.6.11 Design a Verilog model to implement the
behavior described by the 4-input truth table
shown in Fig. 5.16. Use a structural design
approach based on gate-level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a
traditional sub-system; however, you don&rsquo;t
</p>
<p>need to create the gate-level modules as they
are already built into the Verilog standard. You
will need to determine a logic expression for
the system prior to connecting the gate- level
primitives. You can use whatever approach
you prefer to create the logic expression (i.e.,
canonical SOP/POS, minimized SOP/POS,
etc.). Declare your module and ports to match
the block diagram provided. Use the type wire
for your ports.
</p>
<p>5.6.12 Design a Verilog model to implement the
behavior described by the 4-input truth table
shown in Fig. 5.16. Use a structural design
approach based on a user-defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional sub-system. You will need
to create both the upper-level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.
</p>
<p>Section 5.7: Overview of Simulation Test
Benches
</p>
<p>5.7.1 What is the purpose of a test bench?
</p>
<p>5.7.2 Does a test bench have input and output ports?
</p>
<p>5.7.3 Can a test bench be simulated?
</p>
<p>5.7.4 Can a test bench be synthesized?
</p>
<p>Exercise Problems &bull; 193</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 6: MSI Logic
This chapter introduces a group of combinational logic building blocks that are commonly used in
</p>
<p>digital design. As we move into systems that are larger than individual gates, there are naming
</p>
<p>conventions that are used to describe the size of the logic. Table 6.1 gives these naming conventions.
</p>
<p>In this chapter, we will look atmedium- scale integrated circuit (MSI) logic. Each of these building blocks
</p>
<p>can be implemented using the combinational logic design steps covered in Chaps. 4 and 5. The goal of
</p>
<p>this chapter is to provide an understanding of the basic principles of MSI logic.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>6.1 Design a decoder circuit using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>6.2 Design an encoder circuit using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>6.3 Design a multiplexer circuit using both the classical digital design approach and the
modern HDL-based approach.
</p>
<p>6.4 Design a demultiplexer circuit using both the classical digital design approach and the
modern HDL-based approach.
</p>
<p>6.1 Decoders
</p>
<p>A decoder is a circuit that takes in a binary code and has outputs that are asserted for specific values
</p>
<p>of that code. The code can be of any type or size (e.g., unsigned, two&rsquo;s complement, etc.). Each output
</p>
<p>will assert for only specific input codes. Since combinational logic circuits only produce a single output,
</p>
<p>this means that within a decoder, there will be a separate combinational logic circuit for each output.
</p>
<p>6.1.1 Example: One-Hot Decoder
</p>
<p>A one-hot decoder is a circuit that has n inputs and 2n outputs. Each output will assert for one and
</p>
<p>only one input code. Since there are 2n outputs, there will always be one and only one output asserted at
</p>
<p>Table 6.1
Naming convention for the size of digital systems
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_6
</p>
<p>195</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_6&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_6&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>any given time. Example 6.1 shows the process of designing a 2-to-4 one-hot decoder by hand (i.e.,
</p>
<p>using the classical digital design approach).
</p>
<p>As decoders get larger, it is necessary to use hardware description languages to model their
</p>
<p>behavior. Example 6.2 shows how to model a 3-to-8 one-hot decoder in Verilog with continuous
</p>
<p>assignment and logic operators.
</p>
<p>Example 6.1
2-to-4 one-hot decoder: logic synthesis by hand
</p>
<p>196 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>This description can be further simplified by using vector notation for the ports and describing the
</p>
<p>functionality using conditional operators. Example 6.3 shows how to model the 3-to-8 one-hot decoder in
</p>
<p>Verilog using continuous assignment with conditional operators.
</p>
<p>Example 6.2
3-to-8 one-hot decoder: Verilog modeling using logical operators
</p>
<p>6.1 Decoders &bull; 197</p>
<p/>
</div>
<div class="page"><p/>
<p>6.1.2 Example: 7-Segment Display Decoder
</p>
<p>A 7-segment display decoder is a circuit used to drive character displays that are commonly found in
</p>
<p>applications such as digital clocks and household appliances. A character display is made up of seven
</p>
<p>individual LEDs, typically labeled a&ndash;g. The input to the decoder is the binary equivalent of the decimal or
</p>
<p>Hex character that is to be displayed. The output of the decoder is the arrangement of LEDs that will form
</p>
<p>the character. Decoders with 2-inputs can drive characters &ldquo;0&rdquo; to &ldquo;3.&rdquo; Decoders with 3-inputs can drive
</p>
<p>characters &ldquo;0&rdquo; to &ldquo;7.&rdquo; Decoders with 4-inputs can drive characters &ldquo;0&rdquo; to &ldquo;F&rdquo; with the case of the Hex
</p>
<p>characters being &ldquo;A, b, c or C, d, E and F.&rdquo;
</p>
<p>Let&rsquo;s look at an example of how to design a 3-input, 7-segment decoder by hand. The first step in the
</p>
<p>process is to create the truth table for the outputs that will drive the LEDs in the display. We&rsquo;ll call these
</p>
<p>outputs Fa, Fb, . . ., Fg. Example 6.4 shows how to construct the truth table for the 7-segment display
</p>
<p>decoder. In this table, a logic 1 corresponds to the LED being ON.
</p>
<p>Example 6.3
3-to-8 one-hot decoder: Verilog modeling using conditional operators
</p>
<p>198 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>If we wish to design this decoder by hand, we need to create seven separate combinational logic
</p>
<p>circuits. Each of the outputs (Fa &ndash; Fg) can be put into a 3-input K-map to find the minimized logic
</p>
<p>expression. Example 6.5 shows the design of the decoder from the truth table in Example 6.4 by hand.
</p>
<p>Example 6.4
7-Segment display decoder: truth table
</p>
<p>6.1 Decoders &bull; 199</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 6.5
7-Segment display decoder: logic synthesis by hand
</p>
<p>200 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>This same functionality can be implemented in Verilog using concurrent modeling techniques.
</p>
<p>Example 6.6 shows how to model the 7-segment decoder in Verilog using continuous assignment with
</p>
<p>logic operators.
</p>
<p>Again, a more compact description of the decoder can be accomplished if the ports are described as
</p>
<p>vectors and a conditional operator is used. Example 6.7 shows how to model the 7-segment decoder in
</p>
<p>Verilog using continuous assignment with conditional operators.
</p>
<p>Example 6.6
7-Segment display decoder: Verilog modeling using logical operators
</p>
<p>6.1 Decoders &bull; 201</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC6.1 In a decoder, a logic expression is created for each output. Once all of the output logic
expressions are found, how can the decoder logic be further minimized?
</p>
<p>A) By using K-maps to find the output logic expressions.
</p>
<p>B) By buffering the inputs so that they can drive a large number of other gates.
</p>
<p>C) By identifying any logic terms that are used in multiple locations (inversions,
product terms, and sum terms) and sharing the interim results among multiple
circuits in the decoder.
</p>
<p>D) By ignoring fan-out.
</p>
<p>6.2 Encoders
</p>
<p>An encoder works in the opposite manner as a decoder. An assertion on a specific input port
</p>
<p>corresponds to a unique code on the output port.
</p>
<p>Example 6.7
7-Segment display decoder: Verilog modeling using conditional operators
</p>
<p>202 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>6.2.1 Example: One-Hot Binary Encoder
</p>
<p>A one-hot binary encoder has n outputs and 2n inputs. The output will be an n-bit, binary code which
</p>
<p>corresponds to an assertion on one and only one of the inputs. Example 6.8 shows the process of
</p>
<p>designing a 4-to-2 binary encoder by hand (i.e., using the classical digital design approach).
</p>
<p>In Verilog, an encoder can be implemented using continuous assignment with either logical or
</p>
<p>conditional operators. Example 6.9 shows how to model the encoder in Verilog using these techniques.
</p>
<p>Example 6.8
4-to-2 binary encoder: logic synthesis by hand
</p>
<p>6.2 Encoders &bull; 203</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC6.2 If it is desired to have the outputs of an encoder produce 0&rsquo;s for all input codes not
defined in the truth table, can &ldquo;don&rsquo;t cares&rdquo; be used when deriving the minimized logic
expressions? Why?
</p>
<p>A) No. Don&rsquo;t cares aren&rsquo;t used in encoders.
</p>
<p>B) Yes. Don&rsquo;t cares can always be used in K-maps.
</p>
<p>C) Yes. All that needs to be done is to treat each X as a 0 when forming the most
minimal prime implicant.
</p>
<p>D) No. Each cell in the K-map corresponding to an undefined input code needs to
contain a 0 so don&rsquo;t cares are not applicable.
</p>
<p>6.3 Multiplexers
</p>
<p>A multiplexer is a circuit that passes one of its multiple inputs to a single output based on a select
</p>
<p>input. This can be thought of as a digital switch. The multiplexer has n select lines, 2n inputs, and one
</p>
<p>output. Example 6.10 shows the process of designing a 2-to-1 multiplexer by hand (i.e., using the
</p>
<p>classical digital design approach).
</p>
<p>Example 6.9
4-to-2 binary encoder: Verilog modeling using logical and conditional operators
</p>
<p>204 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>In Verilog, a multiplexer can be implemented using continuous assignment with either logical or
</p>
<p>conditional operators. Example 6.11 shows how to model the multiplexer in Verilog using these
</p>
<p>techniques.
</p>
<p>Example 6.10
2-to-1 multiplexer: logic synthesis by hand
</p>
<p>6.3 Multiplexers &bull; 205</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC6.3 How are the product terms in a multiplexer based on the identity theorem?
</p>
<p>A) Only the select product term will pass its input to the final sum term. Since all of
the unselected product terms output 0, the input will be passed through the
sum term because anything OR&rsquo;d with a 0 is itself.
</p>
<p>B) The select lines are complemented such that they activate only one OR gate.
</p>
<p>C) The select line inputs will produce 1&rsquo;s on the inputs of the selected product
term. This allows the input signal to pass through the selected AND gate
because anything AND&rsquo;d with a 1 is itself.
</p>
<p>D) The select line inputs will produce 0&rsquo;s on the inputs of the selected sum term.
This allows the input signal to pass through the selected OR gate because
anything OR&rsquo;d with a 0 is itself.
</p>
<p>Example 6.11
4-to-1 multiplexer: Verilog modeling using logical and conditional operators
</p>
<p>206 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>6.4 Demultiplexers
</p>
<p>A demultiplexer works in a complementary fashion to a multiplexer. A demultiplexer has one input
</p>
<p>that is routed to one of its multiple outputs. The output that is active is dictated by a select input. A demux
</p>
<p>has n select lines that chooses to route the input to one of its 2n outputs. When an output is not selected,
</p>
<p>it outputs a logic 0. Example 6.12 shows the process of designing a 1-to-2 demultiplexer by hand (i.e.,
</p>
<p>using the classical digital design approach).
</p>
<p>In Verilog, a demultiplexer can be implemented using continuous assignment with either logical or
</p>
<p>conditional operators. Example 6.13 shows how to model the demultiplexer in Verilog using these
</p>
<p>techniques.
</p>
<p>Example 6.12
1-to-2 demultiplexer: logic synthesis by hand
</p>
<p>6.4 Demultiplexers &bull; 207</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC6.4 How many select lines are needed in a 1-to-64 demultiplexer?
</p>
<p>A) 1 B) 4 C) 6 D) 64
</p>
<p>Summary
</p>
<p>v The term medium-scale integrated circuit
(MSI) logic refers to a set of basic combina-
tional logic circuits that implement simple,
commonly used functions such as decoders,
encoders, multiplexers, and demultiplexers.
MSI logic can also include operations such
as comparators and simple arithmetic
circuits.
</p>
<p>v While an MSI logic circuit may have multiple
outputs, each output requires its own unique
logic expression that is based on the system
inputs.
</p>
<p>v A decoder is a system that has a greater
number of outputs than inputs. The behavior
of each output is based on each unique
input code.
</p>
<p>Example 6.13
1-to-4 demultiplexer: Verilog modeling using logical and conditional operators
</p>
<p>208 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>v An encoder is a system that has a greater
number of inputs than outputs. A com-
pressed output code is produced based on
which input(s) lines are asserted.
</p>
<p>v A multiplexer is a system that has one output
andmultiple inputs. At any given time, one and
only one input is routed to the output based on
the value on a set of select lines. For n select
lines, a multiplexer can support 2n inputs.
</p>
<p>v A demultiplexer is a system that has one
input and multiple outputs. The input is
</p>
<p>routed to one of the outputs depending on
the value on a set of select lines. For n select
lines, a demultiplexer can support 2n outputs.
</p>
<p>v HDLs are particularly useful for describing
MSI logic due to their abstract modeling
capability. Through the use of Boolean
conditions and vector assignments, the
behavior of MSI logic can be modeled in a
compact and intuitive manner.
</p>
<p>Exercise Problems
</p>
<p>Section 6.1: Decoders
</p>
<p>6.1.1 Design a 4-to-16 one-hot decoder by hand.
The block diagram and truth table for the
decoder are given in Fig. 6.1. Give the
minimized logic expressions for each output
(i.e., F0, F1, . . ., F15) and the full logic diagram
for the system.
</p>
<p>Fig. 6.1
4-to-16 one-hot decoder functionality
</p>
<p>6.1.2 Design a Verilog model for a 4-to-16 one-hot
decoder using continuous assignment and
gate-level primitives. Use the module port defi-
nition given in Fig. 6.2.
</p>
<p>Fig. 6.2
4-to-16 one-hot decoder module definition
</p>
<p>6.1.3 Design a Verilog model for a 4-to-16 one-hot
decoder using continuous assignment and log-
ical operators. Use the module port definition
given in Fig. 6.2.
</p>
<p>6.1.4 Design a Verilog model for a 4-to-16 one-hot
decoder using continuous assignment and
conditional operators. Use the module port def-
inition given in Fig. 6.2.
</p>
<p>6.1.5 Design a 4-input, 7-segment HEX character
decoder by hand. The system has four inputs
called A, B, C, and D. The system has seven
outputs called Fa, Fb, Fc, Fd, Fe, Ff, and Fg.
These outputs drive the individual LEDs within
the display. A logic 1 on an output corresponds
to the LED being ON. The display will show the
HEX characters 0&ndash;9, A, b, c, d, E, and F
corresponding to the 4-bit input code on A. A
template for creating the truth tables for this
system is provided in Fig. 6.3. Provide the
minimized logic expressions for each of the
seven outputs and the overall logic diagram
for the decoder.
</p>
<p>Exercise Problems &bull; 209</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 6.3
7-segment display decoder truth table
</p>
<p>210 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>6.1.6 Design a Verilog model for a 4-input, 7-seg-
ment HEX character decoder using continuous
assignment and logical operators. Use the
module port definition given in Fig. 6.4 for
your design. The system has a 4-bit input vec-
tor called ABCD and a 7-bit output vector
called F. The individual scalars within the out-
put vector (i.e., F[6:0]) correspond to the char-
acter display segments a, b, c, d, e, f, and g,
respectively. A logic 1 on an output
corresponds to the LED being ON. The display
will show the HEX characters 0&ndash;9, A, b, c, d, E,
and F corresponding to the 4-bit input code on
A. A template for creating the truth table is
provided in. The signals in this table corre-
spond to the ports in this problem as follows:
Fa &frac14; F(6), Fb &frac14; F(5), Fc &frac14; F(4), Fd &frac14; F(3),
Fe &frac14; F(2), Ff &frac14; F(1), and Fg &frac14; F(0).
</p>
<p>Fig. 6.4
7-segment display decoder module definition
</p>
<p>6.1.7 Design a Verilog model for a 4-input, 7-seg-
ment HEX character decoder using continuous
assignment and conditional operators. Use the
module port definition given in Fig. 6.4 for your
design. The system has a 4-bit input vector
called ABCD and a 7-bit output vector called
F. The individual scalars within the output vec-
tor (i.e., F[6:0]) correspond to the character
display segments a, b, c, d, e, f, and g, respec-
tively. A logic 1 on an output corresponds to the
LED being ON. The display will show the HEX
characters 0&ndash;9, A, b, c, d, E, and F
corresponding to the 4-bit input code on A. A
template for creating the truth table is provided
in. The signals in this table correspond to the
ports in this problem as follows: Fa &frac14; F(6),
Fb &frac14; F(5), Fc &frac14; F(4), Fd &frac14; F(3), Fe &frac14; F(2),
Ff &frac14; F(1), and Fg &frac14; F(0).
</p>
<p>Section 6.2: Encoders
</p>
<p>6.2.1 Design an 8-to-3 binary encoder by hand. The
block diagram and truth table for the encoder
are given in Fig. 6.5. Give the logic expressions
for each output and the full logic diagram for
the system.
</p>
<p>Fig. 6.5
8-to-3 one-hot encoder functionality
</p>
<p>6.2.2 Design a Verilog model for an 8-to-3 binary
encoder using continuous assignment and
gate-level primitives. Use the module port defi-
nition given in Fig. 6.6.
</p>
<p>Fig. 6.6
8-to-3 one-hot encoder module functionality
</p>
<p>6.2.3 Design a Verilog model for an 8-to-3 binary
encoder using continuous assignment and log-
ical operators. Use the module port definition
given in Fig. 6.6.
</p>
<p>6.2.4 Design a Verilog model for an 8-to-3 binary
encoder using continuous assignment and
conditional operators. Use the module port def-
inition given in Fig. 6.6.
</p>
<p>Section 6.3: Multiplexers
</p>
<p>6.3.1 Design an 8-to-1 multiplexer by hand. The
block diagram and truth table for the multi-
plexer are given in Fig. 6.7. Give the minimized
logic expressions for the output and the full
logic diagram for the system.
</p>
<p>Exercise Problems &bull; 211</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 6.7
8-to-1 multiplexer functionality
</p>
<p>6.3.2 Design a Verilog model for an 8-to-1 multi-
plexer using continuous assignment and
gate-level primitives. Use the module port defi-
nition given in Fig. 6.8.
</p>
<p>Fig. 6.8
8-to-1 multiplexer module definition
</p>
<p>6.3.3 Design a Verilog model for an 8-to-1 multi-
plexer using continuous assignment and logi-
cal operators. Use the module port definition
given in Fig. 6.8.
</p>
<p>6.3.4 Design a Verilog model for an 8-to-1 multi-
plexer using continuous assignment and con-
ditional operators. Use the module port
definition given in Fig. 6.8.
</p>
<p>Section 6.4: Demultiplexers
</p>
<p>6.4.1 Design a 1-to-8 demultiplexer by hand. The
block diagram and truth table for the demulti-
plexer are given in Fig. 6.9. Give the minimized
logic expressions for each output and the full
logic diagram for the system.
</p>
<p>Fig. 6.9
1-to-8 demultiplexer functionality
</p>
<p>6.4.2 Design a Verilog model for a 1-to-8 demulti-
plexer using continuous assignment and
gate-level primitives. Use the module port defi-
nition given in Fig. 6.10 for your design.
</p>
<p>Fig. 6.10
1-to-8 demultiplexer module definition
</p>
<p>6.4.3 Design a Verilog model for a 1-to-8 demulti-
plexer using continuous assignment and logi-
cal operators. Use the module port definition
given in Fig. 6.10 for your design.
</p>
<p>6.4.4 Design a Verilog model for a 1-to-8 demulti-
plexer using continuous assignment and con-
ditional operators. Use the module port
definition given in Fig. 6.10 for your design.
</p>
<p>212 &bull; Chapter 6: MSI Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 7: Sequential Logic Design
In this chapter we begin looking at sequential logic design. Sequential logic design differs from
</p>
<p>combinational logic design in that the outputs of the circuit depend not only on the current values of the
</p>
<p>inputs but also on the past values of the inputs. This is different from the combinational logic design
</p>
<p>where the output of the circuitry depends only on the current values of the inputs. The ability of a
</p>
<p>sequential logic circuit to base its outputs on both the current and past inputs allows more sophisticated
</p>
<p>and intelligent systems to be created. We begin by looking at sequential logic storage devices, which are
</p>
<p>used to hold the past values of a system. This is followed by an investigation of timing considerations of
</p>
<p>sequential logic circuits. We then look at some useful circuits that can be created using only sequential
</p>
<p>logic storage devices. Finally, we look at one of the most important logic circuits in digital systems, the
</p>
<p>finite-state machine. The goal of this chapter is to provide an understanding of the basic operation of
</p>
<p>sequential logic circuits.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>7.1 Describe the operation of a sequential logic storage device.
7.2 Describe sequential logic timing considerations.
7.3 Design a variety of common circuits based on sequential storage devices (toggle flops,
</p>
<p>ripple counters, switch debouncers, and shift registers).
7.4 Design a finite-state machine using the classical digital design approach.
7.5 Design a counter using the classical digital design approach and using an HDL-based,
</p>
<p>structural approach.
7.6 Describe the finite-state machine reset condition.
7.7 Analyze a finite-state machine to determine its functional operation and maximum clock
</p>
<p>frequency.
</p>
<p>7.1 Sequential Logic Storage Devices
</p>
<p>7.1.1 The Cross-Coupled Inverter Pair
</p>
<p>The first thing that is needed in sequential logic is a storage device. The fundamental storage device
</p>
<p>in sequential logic is based on a positive feedback configuration. Consider the circuit in Fig. 7.1. This
</p>
<p>circuit configuration is called the cross-coupled inverter pair. In this circuit if the input of U1 starts with a
</p>
<p>value of 1, it will produce an output of Q&frac14; 0. This output is fed back to the input of U2, thus producing an
</p>
<p>output of Qn &frac14; 1. Qn is fed back to the original input of U1, thus reinforcing the initial condition. This
</p>
<p>circuit will hold, or store, a logic 0 without being driven by any other inputs. This circuit operates in a
</p>
<p>complementary manner when the initial value of U1 is a 0. With this input condition, the circuit will store a
</p>
<p>logic 1 without being driven by any other inputs.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_7
</p>
<p>213</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_7&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_7&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>7.1.2 Metastability
</p>
<p>The cross-coupled inverter pair in Fig. 7.1 exhibits what is called metastable behavior due to its
</p>
<p>positive feedback configuration. Metastability refers to when a system can exist in a state of equilibrium
</p>
<p>when undisturbed but can be moved to a different, more stable state of equilibrium when sufficiently
</p>
<p>disturbed. Systems that exhibit high levels of metastability have an equilibrium state that is highly
</p>
<p>unstable, meaning that if disturbed even slightly the system will move rapidly to a more stable point of
</p>
<p>equilibrium. The cross-coupled inverter pair is a highly metastable system. This system actually contains
</p>
<p>three equilibrium states. The first is when the input of U1 is exactly between a logic 0 and logic 1 (i.e.,
</p>
<p>VCC/2). In this state, the output of U1 is also exactly VCC/2. This voltage is fed back to the input of U2, thus
</p>
<p>producing an output of exactly VCC/2 on U2. This in turn is fed back to the original input on U1 reinforcing
</p>
<p>the initial state. Despite this system being at equilibrium in this condition, this state is highly unstable.
</p>
<p>With minimal disturbance to any of the nodes within the system, it will move rapidly to one of the twomore
</p>
<p>stable states. The two stable states for this system are when Q &frac14; 0 or when Q &frac14; 1 (see Fig. 7.1). Once
</p>
<p>the transition begins between the unstable equilibrium state toward one of the twomore stable states, the
</p>
<p>positive feedback in the system continually reinforces the transition until the system reaches its final
</p>
<p>state. In electrical systems, this initial disturbance is caused by the presence of noise, or unwanted
</p>
<p>voltage in the system. Noise can come from many sources including random thermal motion of charge
</p>
<p>carriers in the semiconductor materials, electromagnetic energy, or naturally occurring ionizing particles.
</p>
<p>Noise is present in every electrical system so the cross-coupled inverter pair will never be able to stay in
</p>
<p>the unstable equilibrium state where all nodes are at VCC/2.
</p>
<p>The cross-coupled inverter pair has two stable states; thus it is called a bistable element. In order to
</p>
<p>understand the bistable behavior of this circuit, let&rsquo;s look at its behavior when the initial input value on U1
</p>
<p>is set directly between a logic 0 and logic 1 (i.e., VCC/2) and how a small amount of noise will cause the
</p>
<p>system to move toward a stable state. Recall that an inverter is designed to have an output that quickly
</p>
<p>transitions between a logic LOW and HIGH in order to minimize the time spent in the uncertainty region.
</p>
<p>This is accomplished by designing the inverter to have what is called gain. Gain can be thought of as a
</p>
<p>multiplying factor that is applied to the input of the circuit when producing the output (i.e., Vout &frac14; gain∙Vin).
</p>
<p>The gain for an inverter will be negative since the output moves in the opposite direction of the input. The
</p>
<p>inverter is designed to have a very high gain such that even the smallest change on the input when in the
</p>
<p>transition region will result in a large change on the output. Consider the behavior of this circuit shown in
</p>
<p>Fig. 7.2. In this example, let&rsquo;s represent the gain of the inverter as &ndash;g and see how the system responds
</p>
<p>when a small positive voltage noise (Vn) is added to the VCC/2 input on U1.
</p>
<p>Fig. 7.1
Storage using a cross-coupled inverter pair
</p>
<p>214 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 7.2
Examining metastability moving toward the state Q &frac14; 0
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 215</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 7.3 shows how the system responds when a small negative voltage noise (�Vn) is added to
</p>
<p>the VCC/2 input on U1.
</p>
<p>7.1.3 The SR Latch
</p>
<p>While the cross-coupled inverter pair is the fundamental storage concept for sequential logic, there
</p>
<p>is no mechanism to set the initial value of Q. All that is guaranteed is that the circuit will store a value in
</p>
<p>one of the two stable states (Q&frac14; 0 or Q&frac14; 1). The SR Latch provides a means to control the initial values
</p>
<p>Fig. 7.3
Examining metastability moving toward the state Q &frac14; 1
</p>
<p>216 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>in this positive feedback configuration by replacing the inverters with NOR gates. In this circuit, S stands
</p>
<p>for set and indicates when the output is forced to a logic 1 (Q &frac14; 1), and R stands for reset and indicates
</p>
<p>when the output is forced to a logic 0 (Q&frac14; 0). When both S&frac14; 0 and R&frac14; 0, the SR Latch is put into a store
</p>
<p>mode, and it will hold the last value of Q. In all of these input conditions, Qn is the complement of
</p>
<p>Q. Consider the behavior of the SR Latch during its store state shown in Fig. 7.4.
</p>
<p>The SR Latch has two input conditions that will force the outputs to known values. The first condition
</p>
<p>is called the set state. In this state, the inputs are configured as S &frac14; 1 and R&frac14; 0. This input condition will
</p>
<p>force the outputs to Q &frac14; 1 (e.g., setting Q) and Qn &frac14; 0. The second input condition is called the reset
</p>
<p>state. In this state the inputs are configured as S&frac14; 0 and R&frac14; 1. This input condition will force the outputs
</p>
<p>to Q &frac14; 0 (i.e., resetting Q) and Qn &frac14; 1. Consider the behavior of the SR Latch during its set and reset
</p>
<p>states shown in Fig. 7.5.
</p>
<p>Fig. 7.4
SR Latch behavior: store state (S &frac14; 0, R &frac14; 0)
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 217</p>
<p/>
</div>
<div class="page"><p/>
<p>The final input condition for the SR Latch leads to potential metastability and should be avoided.
</p>
<p>When S&frac14; 1 and R&frac14; 1, the outputs of the SR Latch will both go to logic 0&rsquo;s. The problem with this state is
</p>
<p>that if the inputs subsequently change to the store state (S&frac14; 0, R&frac14; 0), the outputs will go metastable and
</p>
<p>then settle in one of the two stable states (Q &frac14; 0 or Q &frac14; 1). The reason this state is avoided is because
</p>
<p>the final resting state of the SR Latch is random and unknown. Consider this operation shown in Fig. 7.6.
</p>
<p>Fig. 7.5
SR Latch behavior: set (S &frac14; 1, R &frac14; 0) and reset (S &frac14; 0, R &frac14; 1) states
</p>
<p>Fig. 7.6
SR Latch behavior: don&rsquo;t use state (S &frac14; 1 and R &frac14; 1)
</p>
<p>218 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 7.7 shows the final truth table for the SR Latch.
</p>
<p>The SR Latch has some drawbacks when it comes to implementation with real circuitry. First, it takes
</p>
<p>two independent inputs to control the outputs. Second, the state where S &frac14; 1 and R &frac14; 1 causes
</p>
<p>problems when real propagation delays are considered through the gates. Since it is impossible to
</p>
<p>match the delays exactly between U1 and U2, the SR Latch may occasionally enter this state and
</p>
<p>experience momentary metastable behavior. In order to address these issues, a number of
</p>
<p>improvements can be made to this circuit to create two of the most commonly used storage devices in
</p>
<p>sequential logic, the D-Latch and the D-flip-flop. In order to understand the operation of these storage
</p>
<p>devices, two incremental modifications are made to the SR Latch. The first is called the S&rsquo;R&rsquo; Latch, and
</p>
<p>the second is the SR Latch with enable. These two circuits are rarely implemented and are only
</p>
<p>explained to understand how the SR Latch is modified to create a D-Latch and ultimately a D-flip-flop.
</p>
<p>7.1.4 The S&rsquo;R&rsquo; Latch
</p>
<p>The S&rsquo;R&rsquo; Latch operates in a similar manner as the SR Latch with the exception that the input codes
</p>
<p>corresponding to the store, set, and reset states are complemented. To accomplish this complementary
</p>
<p>behavior, the S&rsquo;R&rsquo; Latch is implemented with NAND gates configured in a positive feedback configura-
</p>
<p>tion. In this configuration, the S&rsquo;R&rsquo; Latch will store the last output when S&rsquo;&frac14; 1, R&rsquo;&frac14; 1. It will set the output
</p>
<p>(Q &frac14; 1) when S&rsquo; &frac14; 0, R&rsquo; &frac14; 1. Finally, it will reset the output (Q &frac14; 0) when S&rsquo; &frac14; 1, R&rsquo; &frac14; 0. Consider the
</p>
<p>behavior of the S&rsquo;R&rsquo; Latch during its store state shown in Fig. 7.8.
</p>
<p>Fig. 7.7
SR Latch truth table
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 219</p>
<p/>
</div>
<div class="page"><p/>
<p>Just as with the SR Latch, the S&rsquo;R&rsquo; Latch has two input configurations to control the values of the
</p>
<p>outputs. Consider the behavior of the S&rsquo;R&rsquo; Latch during its set and reset states shown in Fig. 7.9.
</p>
<p>Fig. 7.8
S&rsquo;R&rsquo; Latch behavior: store state (S0 &frac14; 1, R&rsquo; &frac14; 1)
</p>
<p>220 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>And finally, just as with the SR Latch, the S&rsquo;R&rsquo; Latch has a state that leads to potential metastability
</p>
<p>and should be avoided. Consider the operation of the S&rsquo;R&rsquo; Latch when the inputs are configured as S&rsquo;&frac14; 0
</p>
<p>and R&rsquo; &frac14; 0 shown in Fig. 7.10.
</p>
<p>The final truth table for the S&rsquo;R&rsquo; Latch is given in Fig. 7.11.
</p>
<p>Fig. 7.10
S&rsquo;R&rsquo; Latch behavior: don&rsquo;t use state (S&rsquo; &frac14; 0 and R&rsquo; &frac14; 0)
</p>
<p>Fig. 7.9
S&rsquo;R&rsquo; Latch behavior: set (S' &frac14; 0, R&rsquo; &frac14; 1) and reset (S&rsquo; &frac14; 1, R&rsquo; &frac14; 0) states
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 221</p>
<p/>
</div>
<div class="page"><p/>
<p>7.1.5 SR Latch with Enable
</p>
<p>The next modification that is made in order to move toward a D-Latch and ultimately a D-flip-flop is to
</p>
<p>add an enable line to the S&rsquo;R&rsquo; Latch. The enable is implemented by adding two NAND gates on the input
</p>
<p>stage of the S&rsquo;R&rsquo; Latch. The SR Latch with enable is shown in Fig. 7.12. In this topology, the use of NAND
</p>
<p>gates changes the polarity of the inputs, so this circuit once again has a set state where S&frac14; 1, R&frac14; 0 and
</p>
<p>a reset state of S &frac14; 0, R &frac14; 1. The enable line is labeled C, which stands for clock. The rationale for this
</p>
<p>will be demonstrated upon moving through the explanation of the D-Latch.
</p>
<p>Recall that any time a 0 is present on one of the inputs to a NAND gate, the output will always be a
</p>
<p>1 regardless of the value of the other inputs. In the SR Latch with enable configuration, any time C &frac14; 0,
</p>
<p>the outputs of U3 and U4 will be 1&rsquo;s and will be fed into the inputs of the cross-coupled NAND gate
</p>
<p>configuration (U1 and U2). Recall that the cross-coupled configuration of U1 and U2 is an S&rsquo;R&rsquo; Latch and
</p>
<p>will be put into a store state when S&rsquo;&frac14; 1 and R&rsquo;&frac14; 1. This is the store state (C&frac14; 0). When C&frac14; 1, it has the
</p>
<p>effect of inverting the values of the S and R inputs before they reach U1 and U2. This condition allows the
</p>
<p>set state to be entered when S &frac14; 1, R &frac14; 0, C &frac14; 1 and the reset state to be entered when S &frac14; 0, R &frac14; 1,
</p>
<p>C &frac14; 1. Consider this operation in Fig. 7.13.
</p>
<p>Fig. 7.11
S&rsquo;R&rsquo; Latch truth table
</p>
<p>Fig. 7.12
SR Latch with enable schematic
</p>
<p>222 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Again, there is a potential metastable state when S &frac14; 1, R &frac14; 1 and C &frac14; 1 that should be avoided.
</p>
<p>There is also a second store state when S&frac14; 0, R&frac14; 0, and C&frac14; 1 that is not used because storage is to be
</p>
<p>dictated by the C input.
</p>
<p>7.1.6 The D-Latch
</p>
<p>The SR Latch with enable can be modified to create a new storage device called a D-Latch. Instead
</p>
<p>of having two separate input lines to control the outputs of the latch, the R input of the latch is instead
</p>
<p>Fig. 7.13
SR Latch with enable behavior: store, set, and reset
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 223</p>
<p/>
</div>
<div class="page"><p/>
<p>driven with an inverted version of the S input. This prevents the S and R inputs from ever being the same
</p>
<p>value and removes the two &ldquo;Don&rsquo;t Use&rdquo; states in the truth table shown in Fig. 7.12. The new, single input
</p>
<p>is renamed D to stand for data. This new circuit still has the behavior that it will store the last value of Q
</p>
<p>and Qn when C&frac14; 0. When C&frac14; 1, the output will be Q&frac14; 1 when D&frac14; 1 and will be Q&frac14; 0 when D&frac14; 0. The
</p>
<p>behavior of the output when C&frac14; 1 is called tracking the input. The D-Latch schematic, symbol, and truth
</p>
<p>table are given in Fig. 7.14.
</p>
<p>The timing diagram for the D-Latch is shown in Fig. 7.15.
</p>
<p>Fig. 7.14
D-Latch schematic, symbol, and truth table
</p>
<p>Fig. 7.15
D-Latch timing diagram
</p>
<p>224 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.1.7 The D-Flip-Flop
</p>
<p>The final and most widely used storage device in sequential logic is the D-flip-flop. The D-flip-flop is
</p>
<p>similar in behavior to the D-Latch with the exception that the store mode is triggered by a transition, or
</p>
<p>edge on the clock signal instead of a level. This allows the D-flip-flop to implement higher frequency
</p>
<p>systems since the outputs are updated in a shorter amount of time. The schematic, symbol, and truth
</p>
<p>table are given in Fig. 7.16 for a rising edge-triggered D-flip-flop. To indicate that the device is edge
</p>
<p>sensitive, the input for the clock is designated with a &ldquo;&gt;.&rdquo; The U3 inverter in this schematic creates the
</p>
<p>rising edge behavior. If U3 is omitted, this circuit would be a negative edge-triggered D-flip-flop.
</p>
<p>The D-flip-flop schematic shown above is called a master/slave configuration because of how the
</p>
<p>data is passed through the two D-Latches (U1 and U2). Due to the U4 inverter, the two D-Latches will
</p>
<p>always be in complementary modes. When U1 is in hold mode, U2 will be in track mode and vice versa.
</p>
<p>When the clock signal transitions HIGH, U1 will store the last value of data. During the time when the
</p>
<p>clock is HIGH, U2 will enter track mode and pass this value to Q. In this way, the data is latched into the
</p>
<p>storage device on the rising edge of the clock and is present on Q. This is the master operation of the
</p>
<p>device because U1, or the first D-Latch, is holding the value, and the second D-Latch (the slave) is simply
</p>
<p>passing this value to the output Q. When the clock transitions LOW, U2 will store the output of U1. Since
</p>
<p>there is a finite delay through U1, the U2 D-Latch is able to store the value before U1 fully enters track
</p>
<p>mode. U2 will drive Q for the duration of the time that the clock is LOW. This is the slave operation of the
</p>
<p>device because U2, or the second D-Latch, is holding the value. During the time the clock is LOW, U1 is
</p>
<p>in track mode, which passes the input data to the middle of the D-flip-flop preparing for the next rising
</p>
<p>edge of the clock. The master/slave configuration creates a behavior where the Q output of the D-flip-flop
</p>
<p>is only updated with the value of D on a rising edge of the clock. At all other times, Q holds the last value
</p>
<p>of D. An example timing diagram for the operation of a rising edge D-flip-flop is given in Fig. 7.17.
</p>
<p>Fig. 7.16
D-flip-flop (rising edge triggered) schematic, symbol, and truth table
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 225</p>
<p/>
</div>
<div class="page"><p/>
<p>D-flip-flops often have additional signals that will set the initial conditions of the outputs that are
</p>
<p>separate from the clock. A reset input is used to force the outputs to Q&frac14; 0, Qn&frac14; 1. A preset input is used
</p>
<p>to force the outputs to Q&frac14; 1, Qn&frac14; 0. In most modern D-flip-flops, these inputs are active LOW, meaning
</p>
<p>that the line is asserted when the input is a 0. Active LOW inputs are indicated by placing an inversion
</p>
<p>bubble on the input pin of the symbol. These lines are typically asynchronous, meaning that when they
</p>
<p>are asserted, action is immediately taken to alter the outputs. This is different from a synchronous input in
</p>
<p>which action is only taken on the edge of the clock. Figure 7.18 shows the symbols and truth tables for
</p>
<p>two D-flip-flop variants, one with an active LOW reset and another with both an active LOW reset and
</p>
<p>active LOW preset.
</p>
<p>Fig. 7.17
D-flip-flop (rising edge triggered) timing diagram
</p>
<p>226 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>D-flip-flops can also be created with an enable line. An enable line controls whether or not the output
</p>
<p>is updated. Enable lines are synchronous, meaning that when they are asserted, the outputs will be
</p>
<p>updated on the rising edge of the clock. When de-asserted, the outputs are not updated. This behavior in
</p>
<p>effect ignores the clock input when de-asserted. Figure 7.19 shows the symbol and truth table for a D-flip-
</p>
<p>flop with a synchronous enable.
</p>
<p>The behavior of the D-flip-flop allows us to design systems that are synchronous to a clock signal. A
</p>
<p>clock signal is a periodic square wave that dictates when events occur in a digital system. A synchronous
</p>
<p>system based on D-flip-flops will allow the outputs of its storage devices to be updated upon a rising edge
</p>
<p>of the clock. This is advantageous because when the Q outputs are storing values, they can be used as
</p>
<p>inputs for combinational logic circuits. Since combinational logic circuits contain a certain amount of
</p>
<p>propagation delay before the final output is calculated, the D-flip-flop can hold the inputs at a steady
</p>
<p>Fig. 7.18
D-flip-flop with asynchronous reset and preset
</p>
<p>Fig. 7.19
D-flip-flop with synchronous enable
</p>
<p>7.1 Sequential Logic Storage Devices &bull; 227</p>
<p/>
</div>
<div class="page"><p/>
<p>value while the output is generated. Since the input on a D-flip-flop is ignored during all other times, the
</p>
<p>output of a combinational logic circuit can be fed back as an input to a D-flip-flop. This gives a system the
</p>
<p>ability to generate outputs based on the current values of inputs in addition to past values of the inputs
</p>
<p>that are being held on the outputs of D-flip-flops. This is the definition of sequential logic. An example
</p>
<p>synchronous, sequential system is shown in Fig. 7.20.
</p>
<p>CONCEPT CHECK
</p>
<p>CC7.1(a) What will always cause a digital storage device to come out of metastability and settle
in one of its two stable states? Why?
</p>
<p>A) The power supply. The power supply provides the necessary current for the
device to overcome metastability.
</p>
<p>B) Electrical noise. Noise will always push the storage device toward one state
or another. Once the storage device starts moving toward one of its stable
states, the positive feedback of the storage device will reinforce the transi-
tion until the output eventually comes to rest in a stable state.
</p>
<p>C) A reset. A reset will put the device into a known stable state.
</p>
<p>D) A rising edge of clock. The clock also puts the device into a known stable
state.
</p>
<p>CC7.1(b) What was the purpose of replacing the inverters in the cross-coupled inverter pair
with NOR gates to form the SR Latch?
</p>
<p>A) NOR gates are easier to implement in CMOS.
</p>
<p>B) To provide the additional output Qn.
</p>
<p>C) To provide more drive strength for storing.
</p>
<p>D) To provide inputs to explicitly set the value being stored.
</p>
<p>Fig. 7.20
An example synchronous system based on a D-flip-flop
</p>
<p>228 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.2 Sequential Logic Timing Considerations
</p>
<p>There are a variety of timing specifications that need to be met in order to successfully design
</p>
<p>circuits using sequential storage devices. The first specification is called the setup time (tsetup or ts). The
</p>
<p>setup time specifies how long the data input needs to be at a steady state before the clock event. The
</p>
<p>second specification is called the hold time (thold or th). The hold time specifies how long the data input
</p>
<p>needs to be at a steady state after the clock event. If these specifications are violated (i.e., the input
</p>
<p>transitions too close to the clock transition), the storage device will not be able to determine whether the
</p>
<p>input was a 1 or 0 and will go metastable. The time a storage device will remain metastable is a
</p>
<p>deterministic value and is specified by the part manufacturer (tmeta). In general, metastability should be
</p>
<p>avoided; however, knowing the maximum duration of metastability for a storage device allows us to
</p>
<p>design circuits to overcome potential metastable conditions. During the time the device is metastable,
</p>
<p>the output will have random behavior. It may go to a steady state 1, a steady state 0, or toggle between a
</p>
<p>0 and 1 uncontrollably. Once the device comes out of metastability, it will come to rest in one of its two
</p>
<p>stable states (Q &frac14; 0 or Q &frac14; 1). The final resting state is random and unknown. Another specification for
</p>
<p>sequential storage devices is the delay from the time a clock transition occurs to the point that the data is
</p>
<p>present on the Q output. This specification is called the clock-to-Q delay and is given the notation tCQ.
</p>
<p>These specifications are shown in Fig. 7.21.
</p>
<p>Fig. 7.21
Sequential storage device timing specifications
</p>
<p>7.2 Sequential Logic Timing Considerations &bull; 229</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC7.2 Which D-flop-flop timing specification requires all of combinational logic circuits in the
system to settle on their final output before a triggering clock edge can occur?
</p>
<p>A) tsetup B) thold C) tCQ D) tmeta
</p>
<p>7.3 Common Circuits Based on Sequential Storage Devices
</p>
<p>Sequential logic storage devices give us the ability to create sophisticated circuits that can make
</p>
<p>decisions based on the current and past values of the inputs; however, there are a variety of simple yet
</p>
<p>useful circuits that can be created with only these storage devices. This section will introduce a few of
</p>
<p>these circuits.
</p>
<p>7.3.1 Toggle Flop Clock Divider
</p>
<p>A toggle flop is a circuit that contains a D-flip-flop configured with its Qn output wired back to its D
</p>
<p>input. This configuration is also commonly referred to as a T-flip-flop or T-flop. In this circuit, the only input
</p>
<p>is the clock signal. Let&rsquo;s examine the behavior of this circuit when its outputs are initialized to Q &frac14; 0,
</p>
<p>Qn&frac14; 1. Since Qn is wired to the D input, a logic 1 is present on the input before the first clock edge. Upon
</p>
<p>a rising edge of the clock, Q is updated with the value of D. This puts the outputs at Q &frac14; 1, Qn &frac14; 0. With
</p>
<p>these outputs, now a logic 0 is present on the input before the next clock edge. Upon the next rising edge
</p>
<p>of the clock, Q is updated with the value of D. This time the outputs go to Q &frac14; 0, Qn &frac14; 1. This behavior
</p>
<p>continues indefinitely. The circuit is called a toggle flop because the outputs simply toggle between a
</p>
<p>0 and 1 every time there is a rising edge of the clock. This configuration produces outputs that are square
</p>
<p>waves with exactly half the frequency of the incoming clock. As a result, this circuit is also called a clock
</p>
<p>divider. This circuit can be given its own symbol with a label of &ldquo;T&rdquo; indicating it is a toggle flop. The
</p>
<p>configuration of a toggle flop (T-flop) and timing diagram are shown in Fig. 7.22.
</p>
<p>230 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.3.2 Ripple Counter
</p>
<p>The toggle flop configuration can be used to create a simple binary counter called a ripple counter. In
</p>
<p>this configuration, the Qn output of a toggle flop is used as the clock for a subsequent toggle flop. Since
</p>
<p>the output of the first toggle flop is a square wave that is 1/2 the frequency of the incoming clock, this
</p>
<p>configuration will produce an output on the second toggle flop that is 1/4 the frequency of the incoming
</p>
<p>clock. This is by nature the behavior of a binary counter. The output of this counter is present on the Q
</p>
<p>pins of each toggle flop. Toggle flops are added until the desired width of the counter is achieved with
</p>
<p>each toggle flop representing one bit of the counter. Since each toggle flop produces the clock for the
</p>
<p>subsequent latch, the clock is said to ripple through the circuit, hence the name ripple counter. A 3-bit
</p>
<p>ripple counter is shown in Fig. 7.23.
</p>
<p>Fig. 7.22
Toggle flop clock frequency divider
</p>
<p>7.3 Common Circuits Based on Sequential Storage Devices &bull; 231</p>
<p/>
</div>
<div class="page"><p/>
<p>7.3.3 Switch Debouncing
</p>
<p>Another useful circuit based on sequential storage devices is a switch debouncer. Mechanical
</p>
<p>switches have a well-known issue of not producing clean logic transitions on their outputs when pressed.
</p>
<p>This becomes problematic when using a switch to create an input for a digital device because it will
</p>
<p>cause unwanted logic level transitions on the output of the gate. In the case of a clock input, this
</p>
<p>unwanted transition can cause a storage device to unintentionally latch incorrect data.
</p>
<p>The primary cause of these unclean logic transitions is due to the physical vibrations of the metal
</p>
<p>contacts when they collide with each other during a button press or switch actuation. Within a mechanical
</p>
<p>switch, there is typically one contact that is fixed and another that is designed to move when the button is
</p>
<p>pressed. The contact that is designed to move can be thought of as a beam that is fixed on one side and
</p>
<p>free on the other. As the free side of the beammoves toward the fixed contact in order to close the circuit,
</p>
<p>it will collide and then vibrate just as a tuning fork does when struck. The vibration will eventually
</p>
<p>diminish, and the contact will come to rest, thus making a clean electrical connection; however, during
</p>
<p>the vibration period, the moving contact will bounce up and down on the destination contact. This
</p>
<p>bouncing causes the switch to open and close multiple times before coming to rest in the closed position.
</p>
<p>This phenomenon is accurately referred to as switch bounce. Switch bounce is present in all mechanical
</p>
<p>switches and gets progressively worse as the switches are used more and more.
</p>
<p>Fig. 7.23
3-Bit ripple counter
</p>
<p>232 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 7.24 shows some of the common types of switches found in digital systems. The term pole is
</p>
<p>used to describe the number of separate circuits controlled by the switch. The term throw is used to
</p>
<p>describe the number of separate closed positions the switch can be in.
</p>
<p>Let&rsquo;s look at switch bounce when using a SPST switch to provide an input to a logic gate. A SPST
</p>
<p>requires a resistor and can be configured to provide either a logic HIGH or LOW when in the open
</p>
<p>position and the opposite logic level when in the closed position. The example configuration in Fig. 7.25
</p>
<p>provides a logic LOW when in the open position and a logic HIGH when in the closed position. In the
</p>
<p>open position, the input to the gate (SW) is pulled to GND to create a logic LOW. In the closed position,
</p>
<p>the input to the gate is pulled to VCC to create a logic HIGH. A resistor is necessary to prevent a short
</p>
<p>circuit between VCC and GND when the switch is closed. Since the input current specification for a logic
</p>
<p>gate is very small, the voltage developed across the resistor due to the gate input current is negligible.
</p>
<p>This means that the resistor can be inserted in the pull-down network without developing a noticeable
</p>
<p>voltage. When the switch closes, the free-moving contact will bounce off of the destination contact
</p>
<p>numerous times before settling in the closed position. During the time while the switch is bouncing, the
</p>
<p>switch will repeatedly toggle between the open (HIGH) and closed (LOW) positions.
</p>
<p>Fig. 7.24
Common types of mechanical switches
</p>
<p>7.3 Common Circuits Based on Sequential Storage Devices &bull; 233</p>
<p/>
</div>
<div class="page"><p/>
<p>A possible solution to eliminate this switch bounce is to instead use a SPDT switch in conjunction
</p>
<p>with a sequential storage device. Before looking at this solution, we need to examine an additional
</p>
<p>condition introduced by the SPDT switch. The SPDT switch has what is known as break-before-make
</p>
<p>behavior. The term break is used to describe when a switch is open, while the term make is used to
</p>
<p>describe when the switch is closed. When a SPDTswitch is pressed, the input will be floating during the
</p>
<p>time when the free-moving contact is transitioning toward the destination contact. During this time, the
</p>
<p>output of the switch is unknown and can cause unwanted logic transitions if it is being used to drive the
</p>
<p>input of a logic gate.
</p>
<p>Let&rsquo;s look at switch bounce when using a SPDT switch without additional circuitry to handle
</p>
<p>bouncing. A SPDT has two positions that the free-moving contact can make a connection to (i.e., double
</p>
<p>throw). When using this switch to drive a logic level into a gate, one position is configured as a logic HIGH
</p>
<p>and the other a logic LOW. Consider the SPDTswitch configuration in Fig. 7.26. Position 1 of the SPDT
</p>
<p>switch is connected to GND, while position 2 is connected to VCC. When unpressed the switch is in
</p>
<p>position 1. When pressed, the free-moving contact will transition from position 1 to 2. During the
</p>
<p>transition, the free-moving contact is floating. This creates a condition where the input to the gate
</p>
<p>(SW) is unknown. This floating input will cause unpredictable behavior on the output of the gate. Upon
</p>
<p>reaching position 2, the free-moving contact will bounce off of the destination contact. This will cause the
</p>
<p>input of the logic gate to toggle between a logic HIGH and floating repeatedly until the free-moving
</p>
<p>contact comes to rest in position 2.
</p>
<p>Fig. 7.25
Switch bouncing in a single pole, single throw switch
</p>
<p>234 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>The SPDTswitch is ideal for use with an S&rsquo;R&rsquo; Latch in order to produce a clean logic transition. This
</p>
<p>is because during the break portion of the transition, an S&rsquo;R&rsquo; Latch can be used to hold the last value of
</p>
<p>the switch. This is unique to the SPDTconfiguration. The SPSTswitch in comparison does not have the
</p>
<p>break characteristic; rather it always drives a logic level in both of its possible positions. Consider the
</p>
<p>debounce circuit for a SPDT switch in Fig. 7.27. This circuit is based on an S&rsquo;R&rsquo; Latch with two pull-up
</p>
<p>resistors. Since the S&rsquo;R&rsquo; Latch is created using NAND gates, this circuit is commonly called a NAND-
</p>
<p>debounce circuit. In the unpressed configuration, the switch drives S&rsquo; &frac14; 0, and the R2 pull-up resistor
</p>
<p>drives R&rsquo; &frac14; 1. This creates a logic 0 on the output of the circuit (Qn &frac14; 0). During a switch press, the free-
</p>
<p>moving contact is floating; thus it is not driving in a logic level into the S&rsquo;R&rsquo; Latch. Instead, both pull-up
</p>
<p>resistors pull S&rsquo; and R&rsquo; to 1&rsquo;s. This puts the latch into its hold mode, and the output will remain at a logic
</p>
<p>0 (Qn &frac14; 0). Once the free-moving contact reaches the destination contact, the switch will drive R&rsquo; &frac14; 0.
</p>
<p>Since at this point the R1 pull-up is driving S&rsquo; &frac14; 1, the latch outputs a logic 1 (Qn &frac14; 1). When the free-
</p>
<p>moving contact bounces off of the destination contact, it will put the latch back into the hold mode;
</p>
<p>however, this time the last value that will be held is Qn &frac14; 1. As the switch continues to bounce, the latch
</p>
<p>will move between the Qn &frac14; 1 and Qn &frac14; &ldquo;Last Qn&rdquo; states, both of which produce an output of 1. In this
</p>
<p>way, the SPDT switch in conjunction with the S&rsquo;R&rsquo; Latch produces a clean 0 to 1 logic transition despite
</p>
<p>the break-before-make behavior of the switch and the contact bounce.
</p>
<p>Fig. 7.26
Switch bouncing in a single pole, double throw switch
</p>
<p>7.3 Common Circuits Based on Sequential Storage Devices &bull; 235</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 7.27
NAND-debounce circuit for a SPDT switch
</p>
<p>236 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.3.4 Shift Registers
</p>
<p>A shift register is a chain of D-flip-flops that each is connected to a common clock. The output of the
</p>
<p>first D-flip-flop is connected to the input of the second D-flip-flop. The output of the second D-flip-flop is
</p>
<p>connected to the input of the third D-flip-flop and so on. When data is present on the input to the first
</p>
<p>D-flip-flop, it will be latched upon the first rising edge of the clock. On the second rising edge of the clock,
</p>
<p>the same data will be latched into the second D-flip-flop. This continues on each rising edge of the clock
</p>
<p>until the data has been shifted entirely through the chain of D-flip-flops. Shift registers are commonly
</p>
<p>used to convert a serial string of data into a parallel format. If an n-bit, serial sequence of information is
</p>
<p>clocked into the shift register, after n clocks the data will be held on each of the D-flip-flop outputs. At this
</p>
<p>moment, the n-bits can be read as a parallel value. Consider the shift register configuration shown in
</p>
<p>Fig. 7.28.
</p>
<p>Fig. 7.28
4-Bit shift register
</p>
<p>7.3 Common Circuits Based on Sequential Storage Devices &bull; 237</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC7.3 Which D-flip-flop timing specification is most responsible for the ripple delay in a ripple
counter?
</p>
<p>A) tsetup B) thold C) tCQ D) tmeta
</p>
<p>7.4 Finite-State Machines
</p>
<p>Now we turn our attention to one of the most powerful sequential logic circuits, the finite-state
</p>
<p>machine (FSM). A FSM, or state machine, is a circuit that contains a predefined number of states (i.e., a
</p>
<p>finite number of states). The machine can exist in one and only one state at a time. The circuit transitions
</p>
<p>between states based on a triggering event, most commonly the edge of a clock, in addition to the values
</p>
<p>of any inputs of the machine. The number of states and all possible transitions is predefined. Through the
</p>
<p>use of states and a predefined sequence of transitions, the circuit is able to make decisions on the next
</p>
<p>state to transition based on a history of past states. This allows the circuit to create outputs that are more
</p>
<p>intelligent compared to a simple combinational logic circuit that has outputs based only on the current
</p>
<p>values of the inputs.
</p>
<p>7.4.1 Describing the Functionality of a FSM
</p>
<p>The design of a state machine begins with an abstract word description of the desired circuit
</p>
<p>behavior. We will use a design example of a push-button motor controller to describe all of the steps
</p>
<p>involved in creating a finite-state machine. Example 7.1 starts the FSM design process by stating the
</p>
<p>word description of the system.
</p>
<p>Example 7.1
Push-button window controller: word description
</p>
<p>238 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.1.1 State Diagrams
</p>
<p>A state diagram is a graphical way to describe the functionality of a finite-state machine. A state
</p>
<p>diagram is a form of a directed graph, in which each state (or vertex) within the system is denoted as a
</p>
<p>circle and given a descriptive name. The names are written inside of the circles. The transitions between
</p>
<p>states are denoted using arrows with the input conditions causing the transitions written next to them.
</p>
<p>Transitions (or edges) can move to different states upon particular input conditions or remain in the same
</p>
<p>state. For a state machine implemented using sequential logic storage, an evaluation of when to
</p>
<p>transition states is triggered every time the storage devices update their outputs. For example, if the
</p>
<p>system was implemented using rising edge-triggered D-flip-flops, then an evaluation would occur on
</p>
<p>every rising edge of the clock.
</p>
<p>There are two different types of output conditions for a state machine. The first is when the output
</p>
<p>only depends on the current state of the machine. This type of system is called aMoore machine. In this
</p>
<p>case, the outputs of the system are written inside of the state circles. This indicates the output value that
</p>
<p>will be generated for each specific state. The second output condition is when the outputs depend on
</p>
<p>both the current state and the system inputs. This type of system is called aMealy machine. In this case,
</p>
<p>the outputs of the system are written next to the state transitions corresponding to the appropriate input
</p>
<p>values. Outputs in a state diagram are typically written inside of parentheses. Example 7.2 shows the
</p>
<p>construction of the state diagram for our push-button window controller design.
</p>
<p>7.4 Finite-State Machines &bull; 239</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.1.2 State Transition Tables
</p>
<p>The state diagram can now be described in a table format that is similar to a truth table. This puts the
</p>
<p>state machine behavior in a form that makes logic synthesis straightforward. The table contains the
</p>
<p>same information as in the state diagram. The state that the machine exists in is called the current state.
</p>
<p>For each current state that the machine can reside in, every possible input condition is listed along with
</p>
<p>the destination state of each transition. The destination state for a transition is called the next state. Also
</p>
<p>listed in the table are the outputs corresponding to each current state and, in the case of a Mealy
</p>
<p>machine, the output corresponding to each input condition. Example 7.3 shows the construction of the
</p>
<p>state transition table for the push-button window controller design. This information is identical to the
</p>
<p>state diagram given in Example 7.2.
</p>
<p>Example 7.2
Push-button window controller: state diagram
</p>
<p>240 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.2 Logic Synthesis for a FSM
</p>
<p>Once the behavior of the state machine has been described, it can be directly synthesized. There
</p>
<p>are three main components of a state machine: the state memory, the next state logic, and the output
</p>
<p>logic. Figure 7.29 shows a block diagram of a state machine highlighting these three components. The
</p>
<p>next state logic block is a group of combinational logic that produces the next state signals based on the
</p>
<p>current state and any system inputs. The state memory holds the current state of the system. The current
</p>
<p>state is updated with next state on every rising edge of the clock, which is indicated with the &ldquo;&gt;&rdquo; symbol
</p>
<p>within the block. This behavior is created using D-flip-flops where the current state is held on the Q
</p>
<p>outputs of the D-flip-flops, while the next state is present on the D inputs of the D-flip-flops. In this way,
</p>
<p>every rising edge of the clock will trigger an evaluation of which state to move to next. This decision is
</p>
<p>based on the current state and the current inputs. The output logic block is a group of combinational logic
</p>
<p>that creates the outputs of the system. This block always uses the current state as an input and,
</p>
<p>depending on the type of machine (Mealy vs. Moore), uses the system inputs. It is useful to keep this
</p>
<p>block diagram in mind when synthesizing finite-state machines as it will aid in keeping the individual
</p>
<p>design steps separate and clear.
</p>
<p>Example 7.3
Push-button window controller: state transition table
</p>
<p>7.4 Finite-State Machines &bull; 241</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.2.1 State Memory
</p>
<p>The state memory is the circuitry that will hold the current state of the machine. Upon a rising edge of
</p>
<p>a clock, it will update the current state with the next state. At all other times, the next state input is ignored.
</p>
<p>This gives time for the next state logic circuitry to compute the results for the next state. This behavior is
</p>
<p>identical to that of a D-flip-flop; thus the state memory is simply one or more D-flip-flops. The number of
</p>
<p>D-flip-flops required depends on how the states are encoded. State encoding is the process of assigning
</p>
<p>a binary value to the descriptive names of the states from the state diagram and state transition tables.
</p>
<p>Once the descriptive names have been converted into representative codes using 1&rsquo;s and 0&rsquo;s, the states
</p>
<p>can be implemented in real circuitry. The assignment of codes is arbitrary and can be selected in order to
</p>
<p>minimize the circuitry needed in the machine.
</p>
<p>There are three main styles of state encoding. The first is straight binary encoding. In this approach
</p>
<p>the state codes are simply a set of binary counts (i.e., 00, 01, 10, 11. . .). The binary counts are assigned
</p>
<p>starting at the beginning of the state diagram and incrementally assigned toward the end. This type of
</p>
<p>encoding has the advantage that it is very efficient in minimizing the number of D-flip-flops needed for the
</p>
<p>state memory. With nD-flip-flops, 2n states can be encoded. When a large number of states are required,
</p>
<p>the number of D-flip-flops can be calculated using the rules of logarithmic math. Example 7.4 shows how
</p>
<p>to solve for the number of bits needed in the binary state code based on the number of states in the
</p>
<p>machine.
</p>
<p>Fig. 7.29
Main components of a finite-state machine
</p>
<p>242 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>The second type of state encoding is called gray code encoding. A gray code is one in which the
</p>
<p>value of a code differs by only one bit from any of its neighbors, (i.e., 00, 01, 11, 10. . .). A gray code is
</p>
<p>useful for reducing the number of bit transitions on the state codes when the machine has a transition
</p>
<p>sequence that is linear. Reducing the number of bit transitions can reduce the amount of power
</p>
<p>consumption and noise generated by the circuit. When the state transitions of a machine are highly
</p>
<p>nonlinear, a gray code encoding approach does not provide any benefit. Gray code is also an efficient
</p>
<p>coding approach. With n D-flip-flops, 2n states can be encoded just as in binary encoding. Figure 7.30
</p>
<p>shows the process of creating n-bit, gray code patterns.
</p>
<p>Example 7.4
Solving for the number of bits needed for binary state encoding
</p>
<p>7.4 Finite-State Machines &bull; 243</p>
<p/>
</div>
<div class="page"><p/>
<p>The third common technique to encode states is using one-hot encoding. In this approach, a
</p>
<p>separate D-flip-flop is asserted for each state in the machine. For an n-state machine, this encoding
</p>
<p>approach requires n D-flip-flops. For example, if a machine had three states, the one-hot state codes
</p>
<p>would be &ldquo;001&rdquo;, &ldquo;010,&rdquo; and &ldquo;100.&rdquo; This approach has the advantage that the next state logic circuitry is
</p>
<p>very simple; further, there is less chance that the different propagation delays through the next state logic
</p>
<p>will cause an inadvertent state to be entered. This approach is not as efficient as binary and gray code in
</p>
<p>terms of minimizing the number of D-flip-flops because it requires one D-flip-flop for each state; however,
</p>
<p>in modern digital integrated circuits that have abundant D-flip-flops, one-hot encoding is commonly used.
</p>
<p>Figure 7.31 shows the differences between these three state encoding approaches.
</p>
<p>Once the codes have been assigned to the state names, each of the bits within the code must be
</p>
<p>given a unique signal name. The signal names are necessary because the individual bits within the state
</p>
<p>code are going to be implemented with real circuitry, so each signal name will correspond to an actual
</p>
<p>Fig. 7.30
Creating an n-bit gray code pattern
</p>
<p>Fig. 7.31
Comparison of different state encoding approaches
</p>
<p>244 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>node in the logic diagram. These individual signal names are called state variables. Unique variable
</p>
<p>names are needed for both the current state and next state signals. The current state variables are driven
</p>
<p>by the Q outputs of the D-flip-flops holding the state codes. The next state variables are driven by the
</p>
<p>next state logic circuitry and are connected to the D inputs of the D-flip-flops. State variable names are
</p>
<p>commonly chosen that are descriptive both in terms of their purpose and connection location. For
</p>
<p>example, current state variables are often given the names Q, Q_cur, or Q_current to indicate that
</p>
<p>they come from the Q outputs of the D-flip-flops. Next state variables are given names such as Q*,
</p>
<p>Q_nxt, or Q_next to indicate that they are the next value of Q and are connected to the D input of the
</p>
<p>D-flip-flops. Once state codes and state variable names are assigned, the state transition table is
</p>
<p>updated with the detailed information.
</p>
<p>Returning to our push-button window controller example, let&rsquo;s encode our states in straight binary
</p>
<p>and use the state variable names of Q_cur and Q_nxt. Example 7.5 shows the process of state encoding
</p>
<p>and the new state transition table.
</p>
<p>7.4.2.2 Next State Logic
</p>
<p>The next step in the statemachine design is to synthesize the next state logic. The next state logic will
</p>
<p>compute the values of the next state variables based on the current state and the system inputs. Recall
</p>
<p>that a combinational logic function drives one and only one output bit. This means that every bit within the
</p>
<p>next state code needs to have a dedicated combinational logic circuit. The state transition table contains
</p>
<p>all of the necessary information to synthesize the next state logic including the exact output values of each
</p>
<p>next state variable for each and every input combination of state code and system input(s).
</p>
<p>Example 7.5
Push-button window controller: state encoding
</p>
<p>7.4 Finite-State Machines &bull; 245</p>
<p/>
</div>
<div class="page"><p/>
<p>In our push-button window controller example, we only need to create one combinational logic
</p>
<p>circuit because there is only one next state variable (Q_nxt). The inputs to the combinational logic circuit
</p>
<p>are Q_cur and Press. Notice that the state transition table was created such that the order of the input
</p>
<p>values are listed in a binary count just as in a formal truth table formation. This makes synthesizing the
</p>
<p>combinational logic circuit straightforward. Example 7.6 shows the steps to synthesize the next state
</p>
<p>logic for this the push-button window controller.
</p>
<p>7.4.2.3 Output Logic
</p>
<p>The next step in the state machine design is to synthesize the output logic. The output logic will
</p>
<p>compute the values of the system outputs based on the current state and, in the case of a Mealy
</p>
<p>machine, the system inputs. Each of the output signals will require a dedicated combinational logic
</p>
<p>circuit. Again, the state transition table contains all of the necessary information to synthesize the output
</p>
<p>logic.
</p>
<p>In our push-button window controller example, we need to create one circuit to compute the output
</p>
<p>&ldquo;Open_CW&rdquo; and one circuit to compute the output &ldquo;Close_CCW.&rdquo; In this example, the inputs to these
</p>
<p>circuits are the current state (Q_cur) and the system input (Press). Example 7.7 shows the steps to
</p>
<p>synthesize the output logic for the push-button window controller.
</p>
<p>Example 7.6
Push-button window controller: next state logic
</p>
<p>246 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.2.4 The Final Logic Diagram
</p>
<p>The final step of the design of the state machine is to create the logic diagram. It is useful to recall the
</p>
<p>block diagram for a state machine from Fig. 7.29. A logic diagram begins by entering the state memory.
</p>
<p>Recall that the state memory consists of D-flip-flops that hold the current state code. One D-flip-flop is
</p>
<p>needed for every current state variable. When entering the D-flip-flops, it is useful to label them with the
</p>
<p>current state variable they will be holding. The next part of the logic diagram is the next state logic. Each
</p>
<p>of the combinational logic circuits that compute the next state variables should be drawn to the left of D-
</p>
<p>flip-flop holding the corresponding current state variable. The output of each next state logic circuit is
</p>
<p>connected to the D input of the corresponding D-flip-flop. Finally, the output logic is entered with the
</p>
<p>inputs to the logic coming from the current state and potentially from the system inputs.
</p>
<p>Example 7.8 shows the process for creating the final logic diagram for our push-button window
</p>
<p>controller. Notice that the state memory is implemented with one D-flip-flop since there is only 1-bit in the
</p>
<p>current state code (Q_cur). The next state logic is a combinational logic circuit that computes Q_nxt
</p>
<p>based on the values of Q_cur and Press. Finally, the output logic consists of two separate combinational
</p>
<p>logic circuits to compute the system outputs Open_CW and Close_CCW based on Q_cur and Press. In
</p>
<p>this diagram the Qn output of the D-flip-flop could have been used for the inverted versions of Q_cur;
</p>
<p>however, inversion bubbles were used instead in order to make the diagram more readable.
</p>
<p>Example 7.7
Push-button window controller: output logic
</p>
<p>7.4 Finite-State Machines &bull; 247</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.3 FSM Design Process Overview
</p>
<p>The entire finite-state machine design process is given in Fig. 7.32.
</p>
<p>Fig. 7.32
Finite-state machine design flow
</p>
<p>Example 7.8
Push-button window controller: logic diagram
</p>
<p>248 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.4 FSM Design Examples
</p>
<p>7.4.4.1 Serial Bit Sequence Detector
</p>
<p>Let&rsquo;s consider the design of a 3-bit serial sequence detector. Example 7.9 provides the word
</p>
<p>description, state diagram, and state transition table for this finite-state machine.
</p>
<p>Example 7.10 provides the state encoding and next state logic synthesis for the 3-bit serial bit
</p>
<p>sequence detector.
</p>
<p>Example 7.9
Serial bit sequence detector (part 1)
</p>
<p>7.4 Finite-State Machines &bull; 249</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.11 shows the output logic synthesis and final logic diagram for the 3-bit serial bit
</p>
<p>sequence detector.
</p>
<p>Example 7.10
Serial bit sequence detector (part 2)
</p>
<p>250 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.4.2 Vending Machine Controller
</p>
<p>Let&rsquo;s now look at the design of a simple vending machine controller. Example 7.12 provides the word
</p>
<p>description, state diagram, and state transition table for this finite-state machine.
</p>
<p>Example 7.11
Serial bit sequence detector (part 3)
</p>
<p>7.4 Finite-State Machines &bull; 251</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.13 provides the state encoding and next state logic synthesis for the simple vending
</p>
<p>machine controller.
</p>
<p>Example 7.12
Vending machine controller (part 1)
</p>
<p>252 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.14 shows the output logic synthesis and final logic diagram for the vending machine
</p>
<p>controller.
</p>
<p>Example 7.13
Vending machine controller (part 2)
</p>
<p>7.4 Finite-State Machines &bull; 253</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.14
Vending machine controller (part 3)
</p>
<p>254 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC7.4(a) What allows a finite-state machine to make more intelligent decisions about the
system outputs compared to combinational logic alone?
</p>
<p>A) A finite-state machine has knowledge about the past inputs.
</p>
<p>B) The D-flip-flops allow the outputs to be generated more rapidly.
</p>
<p>C) The next state and output logic allows the finite-state machine to be more
complex and implement larger truth tables.
</p>
<p>D) A synchronous system is always more intelligent.
</p>
<p>CC7.4(b) When designing a finite-state machine, many of the details of the implementation can
be abstracted. At what design step do the details of the implementation start being
considered?
</p>
<p>A) The state diagram step.
</p>
<p>B) The state transition table step.
</p>
<p>C) The state memory synthesis step.
</p>
<p>D) The word description.
</p>
<p>CC7.4(c) What impact does adding an additional state have on the implementation of the state
memory logic in a finite-state machine?
</p>
<p>A) It adds an additional D-flip-flop.
</p>
<p>B) It adds a new state code that must be supported.
</p>
<p>C) It adds more combinational logic to the logic diagram.
</p>
<p>D) It reduces the speed that the machine can run at.
</p>
<p>CC7.4(d) Which of the following statements about the next state logic is FALSE?
</p>
<p>A) It is always combinational logic.
</p>
<p>B) It always uses the current state as one of its inputs.
</p>
<p>C) Its outputs are connected to the D inputs of the D-flip-flops in the state
memory.
</p>
<p>D) It uses the results of the output logic as part of its inputs.
</p>
<p>CC7.4(e) Why does the output logic stage of a finite-state machine always use the current
state as one of its inputs?
</p>
<p>A) If it didn&rsquo;t, it would simply be a separate combinational logic circuit and not
be part of the finite-state machine.
</p>
<p>B) To make better decisions about what the system outputs should be.
</p>
<p>C) Because the next state logic is located too far away.
</p>
<p>D) Because the current state is produced on every triggering clock edge.
</p>
<p>CC7.4(f) What impact does asserting a reset have on a finite-state machine?
</p>
<p>A) It will cause the output logic to produce all zeros.
</p>
<p>B) It will cause the next state logic to produce all zeros.
</p>
<p>C) It will set the current state code to all zeros.
</p>
<p>D) It will start the system clock.
</p>
<p>7.4 Finite-State Machines &bull; 255</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5 Counters
</p>
<p>A counter is a special type of finite-state machine. A counter will traverse the states within a state
</p>
<p>diagram in a linear fashion continually circling around all states. This behavior allows a special type of
</p>
<p>output topology called state-encoded outputs. Since each state in the counter represents a unique
</p>
<p>counter output, the states can be encoded with the associated counter output value. In this way, the
</p>
<p>current state code of the machine can be used as the output of the entire system.
</p>
<p>7.5.1 2-Bit Binary Up Counter
</p>
<p>Let&rsquo;s consider the design of a 2-bit binary up counter. Example 7.15 provides the word description,
</p>
<p>state diagram, state transition table, and state encoding for this counter.
</p>
<p>Example 7.15
2-Bit binary up counter (part 1)
</p>
<p>256 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.16 shows the next state and output logic synthesis, the final logic diagram, and resultant
</p>
<p>representative timing diagram for the 2-bit binary up counter.
</p>
<p>7.5.2 2-Bit Binary Up/Down Counter
</p>
<p>Let&rsquo;s now consider a 2-bit binary up/down counter. In this type of counter, there is an input that
</p>
<p>dictates whether the counter increments or decrements. This counter can still be implemented as a
</p>
<p>Moore machine and use state-encoded outputs. Example 7.17 provides the word description, state
</p>
<p>diagram, state transition table, and state encoding for this counter.
</p>
<p>Example 7.16
2-Bit binary up counter (part 2)
</p>
<p>7.5 Counters &bull; 257</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.18 shows the next state and output logic synthesis, the final logic diagram, and resultant
</p>
<p>representative timing diagram for the 2-bit binary up/down counter.
</p>
<p>Example 7.17
2-Bit binary up/down counter (part 1)
</p>
<p>258 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5.3 2-Bit Gray Code Up Counter
</p>
<p>A gray code counter is one in which the output only differs by one bit from its prior value. This type of
</p>
<p>counter can be implemented using state-encoded outputs by simply encoding the states in gray code.
</p>
<p>Let&rsquo;s consider the design of a 2-bit gray code up counter. Example 7.19 provides the word description,
</p>
<p>state diagram, state transition table, and state encoding for this counter.
</p>
<p>Example 7.18
2-Bit binary up/down counter (part 2)
</p>
<p>7.5 Counters &bull; 259</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.20 shows the next state and output logic synthesis, the final logic diagram, and resultant
</p>
<p>representative timing diagram for the 2-bit gray code up counter.
</p>
<p>Example 7.19
2-Bit gray code up counter (part 1)
</p>
<p>260 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5.4 2-Bit Gray Code Up/Down Counter
</p>
<p>Let&rsquo;s now consider a 2-bit gray code up/down counter. In this type of counter, there is an input that
</p>
<p>dictates whether the counter increments or decrements. This counter can still be implemented as a
</p>
<p>Moore machine and use state-encoded outputs. Example 7.21 provides the word description, state
</p>
<p>diagram, state transition table, and state encoding for this counter.
</p>
<p>Example 7.20
2-Bit gray code up counter (part 2)
</p>
<p>7.5 Counters &bull; 261</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.22 shows the next state and output logic synthesis, the final logic diagram, and resultant
</p>
<p>representative timing diagram for the 2-bit gray code up/down counter.
</p>
<p>Example 7.21
2-Bit gray code up/down counter (part 1)
</p>
<p>262 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5.5 3-Bit One-Hot Up Counter
</p>
<p>A one-hot counter creates an output in which one and only one bit is asserted at a time. In an up
</p>
<p>counter configuration, the assertion is made on the least significant bit first, followed by the next higher
</p>
<p>significant bit, and so on (i.e., 001, 010, 100, 001. . .). A one-hot counter can be created using state-
</p>
<p>Example 7.22
2-Bit gray code up/down counter (part 2)
</p>
<p>7.5 Counters &bull; 263</p>
<p/>
</div>
<div class="page"><p/>
<p>encoded outputs. For a n-bit counter, the machine will require nD-flip-flops. Let&rsquo;s consider a 3-bit one-hot
</p>
<p>up counter. Example 7.23 provides the word description, state diagram, state transition table, and state
</p>
<p>encoding for this counter.
</p>
<p>Example 7.24 shows the next state and output logic synthesis, the final logic diagram, and resultant
</p>
<p>representative timing diagram for the 3-bit one-hot up counter.
</p>
<p>Example 7.23
3-Bit one-hot up counter (part 1)
</p>
<p>264 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5.6 3-Bit One-Hot Up/Down Counter
</p>
<p>Let&rsquo;s now consider a 3-bit one-hot up/down counter. In this type of counter, there is an input that
</p>
<p>dictates whether the counter increments or decrements. This counter can still be implemented as a
</p>
<p>Moore machine and use state-encoded outputs. Example 7.25 provides the word description, state
</p>
<p>diagram, state transition table, and state encoding for this counter.
</p>
<p>Example 7.24
3-Bit one-hot up counter (part 2)
</p>
<p>7.5 Counters &bull; 265</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 7.26 shows the next state and output logic synthesis for the 3-bit one-hot up/down counter.
</p>
<p>Example 7.25
3-Bit one-hot up/down counter (part 1)
</p>
<p>266 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Finally, Example 7.27 shows the logic diagram and resultant representative timing diagram for the
</p>
<p>counter.
</p>
<p>Example 7.26
3-Bit one-hot up/down counter (part 2)
</p>
<p>7.5 Counters &bull; 267</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC7.5 What characteristic of a counter makes it a special case of a finite-state machine?
</p>
<p>A) The state transitions are mostly linear, which reduces the implementation
complexity.
</p>
<p>B) The outputs are always a gray code.
</p>
<p>C) The next state logic circuitry is typically just sum terms.
</p>
<p>D) There is never a situation where a counter could be a Mealy machine.
</p>
<p>Example 7.27
3-Bit one-hot up/down counter (part 3)
</p>
<p>268 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.6 Finite-State Machine&rsquo;s Reset Condition
</p>
<p>The one-hot counter designs in Examples 7.23 and 7.25 where the first FSM examples that had an
</p>
<p>initial state that was not encoded with all 0&rsquo;s. Notice that all of the other FSM examples had initial states
</p>
<p>with state codes comprised of all 0&rsquo;s (e.g., w_closed&frac14; 0, S0&frac14; &ldquo;00&rdquo;, C0&frac14; &ldquo;00&rdquo;, GC_0&frac14; &ldquo;00&rdquo;, etc.). When
</p>
<p>the initial state is encoded with all 0&rsquo;s, the FSM can be put into this state by asserting the reset line of all of
</p>
<p>the D-flip-flops in the state memory. By asserting the reset line, the Q outputs of all of the D-flip-flops are
</p>
<p>forced to 0&rsquo;s. This sets the initial current state value to whatever state is encoded with all 0&rsquo;s. The initial
</p>
<p>state of a machine is often referred to as the reset state. The circuitry to initialize state machines is often
</p>
<p>omitted from the logic diagram as it is assumed that the necessary circuitry will exist in order to put the
</p>
<p>state machine into the reset state. If the reset state is encoded with all 0&rsquo;s, then the reset line can be used
</p>
<p>alone; however, if the reset state code contains 1&rsquo;s, then both the reset and preset lines must be used to
</p>
<p>put the machine into the reset state upon start up. Let&rsquo;s look at the behavior of the one-hot up counter
</p>
<p>again. Figure 7.33 shows how using the reset lines of the D-flip-flops alone will cause the circuit to
</p>
<p>operate incorrectly. Instead, a combination of the reset and preset lines must be used to get the one-hot
</p>
<p>counter into its initial state of Hot_0 &frac14; &ldquo;001&rdquo;.
</p>
<p>Fig. 7.33
Finite-state machine reset state
</p>
<p>7.6 Finite-State Machine&rsquo;s Reset Condition &bull; 269</p>
<p/>
</div>
<div class="page"><p/>
<p>Resets are most often asynchronous so that they can immediately alter the state of the FSM. If a
</p>
<p>reset was implemented in a synchronous manner and there was a clock failure, the system could not be
</p>
<p>reset since there would be no more subsequent clock edges that would recognize that the reset line was
</p>
<p>asserted. An asynchronous reset allows the system to be fully restarted even in the event of a clock
</p>
<p>failure.
</p>
<p>CONCEPT CHECK
</p>
<p>CC7.6 What is the downside of using D-flip-flops that do not have preset capability in a finite-
state machine?
</p>
<p>A) The finite-state machine will run slower.
</p>
<p>B) The next state logic will be more complex.
</p>
<p>C) The output logic will not be able to support both Mealy- and Moore-type
machine architectures.
</p>
<p>D) The start-up state can never have a 1 in its state code.
</p>
<p>7.7 Sequential Logic Analysis
</p>
<p>Sequential logic analysis refers to the act of deciphering the operation of a circuit from its final logic
</p>
<p>diagram. This is similar to combinational logic analysis with the exception that the storage capability of
</p>
<p>the D-flip-flops must be considered. This analysis is also used to understand the timing of a sequential
</p>
<p>logic circuit and can be used to predict the maximum clock rate that can be used.
</p>
<p>7.7.1 Finding the State Equations and Output Logic Expressions of a FSM
</p>
<p>When given the logic diagram for a finite-state machine and it is desired to reverse-engineer
</p>
<p>its behavior, the first step is to determine the next state logic and output logic expressions. This can
</p>
<p>be accomplished by first labeling the current and next state variables on the inputs and outputs of the
</p>
<p>D-flip-flops that are implementing the state memory of the FSM. The outputs of the D-flip-flops are
</p>
<p>labeled with arbitrary current state variable names (e.g., Q1_cur, Q0_cur, etc.) and the inputs are labeled
</p>
<p>with arbitrary next state variable names (e.g., Q1_nxt, Q0_nxt, etc.). The numbering of the state
</p>
<p>variables can be assigned to the D-flip-flops arbitrarily as long as the current and next state bit numbering
</p>
<p>is matched. For example, if a D-flip-flop is labeled to hold bit 0 of the state code, its output should be
</p>
<p>labeled Q0_cur and its input should be labeled Q0_nxt.
</p>
<p>Once the current state variable nets are labeled in the logic diagram, the expressions for the next
</p>
<p>state logic can be found by analyzing the combinational logic circuity driving the next state variables
</p>
<p>(e.g., Q1_nxt, Q0_nxt). The next state logic expressions will be in terms of the current state variables
</p>
<p>(e.g., Q1_cur, Q0_cur) and any inputs to the FSM.
</p>
<p>The output logic expressions can also be found by analyzing the combinational logic driving the
</p>
<p>outputs of the FSM. Again, these will be in terms of the current state variables and potentially the inputs
</p>
<p>to the FSM. When analyzing the output logic, the type of machine can be determined. If the output logic
</p>
<p>only depends on combinational logic that is driven by the current state variables, the FSM is a Moore
</p>
<p>machine. If the output logic depends on both the current state variables and the FSM inputs, the FSM is a
</p>
<p>Mealy machine. An example of this analysis approach is given in Example 7.28.
</p>
<p>270 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.7.2 Finding the State Transition Table of a FSM
</p>
<p>Once the next state logic and output logic expressions are known, the state transition table can be
</p>
<p>created. It is useful to assign more descriptive names to all possible state codes in the FSM. The number
</p>
<p>of unique states possible depends on how many D-flip-flops are used in the state memory of the FSM.
</p>
<p>For example, if the FSM uses two D-flip-flops, there are four unique state codes (i.e., 00, 01, 10, 11). We
</p>
<p>can assign descriptive names such as S0 &frac14; 00, S1 &frac14; 01, S2 &frac14; 10, and S3 &frac14; 11. When first creating the
</p>
<p>transition table, we assign labels and list each possible state code. If a particular code is not used, it can
</p>
<p>be removed from the transition table at the end of the analysis. The state code that the machine will start
</p>
<p>in can be found by analyzing its reset and preset connections. This code is typically listed first in the
</p>
<p>table. The transition table is then populated with all possible combinations of current states and inputs.
</p>
<p>Example 7.28
Determining the next state logic and output logic expression of a FSM
</p>
<p>7.7 Sequential Logic Analysis &bull; 271</p>
<p/>
</div>
<div class="page"><p/>
<p>The next state codes and output logic values can then be populated by evaluating the next state logic
</p>
<p>and output logic expressions found earlier. An example of this analysis is shown in Example 7.29.
</p>
<p>7.7.3 Finding the State Diagram of a FSM
</p>
<p>Once the state transition table is found, creating the state diagram becomes possible. We start the
</p>
<p>diagram with the state corresponding to the reset state. We then draw how the FSM transitions between
</p>
<p>each of its possible states based on the inputs to the machine and list the corresponding outputs. An
</p>
<p>example of this analysis is shown in Example 7.30.
</p>
<p>Example 7.29
Determining the state transition table of a FSM
</p>
<p>272 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.7.4 Determining the Maximum Clock Frequency of a FSM
</p>
<p>The maximum clock frequency is often one of the banner specifications for a digital system. The
</p>
<p>clock frequency of a FSM depends on a variety of timing specifications within the sequential circuit
</p>
<p>including the setup and hold time of the D-flip-flop, the clock-to-Q delay of the D-flip-flop, the combina-
</p>
<p>tional logic delay driving the input of the D-flip-flop, the delay of the interconnect that wires the circuit
</p>
<p>together, and the desired margin for the circuit. The basic concept of analyzing the timing of FSM is to
</p>
<p>determine how long we must wait after a rising (assuming a rising edge-triggered D-flip-flop) clock edge
</p>
<p>occurs until the subsequent rising clock edge can occur. The amount of time that must be allowed
</p>
<p>Example 7.30
Determining the state diagram of a FSM
</p>
<p>7.7 Sequential Logic Analysis &bull; 273</p>
<p/>
</div>
<div class="page"><p/>
<p>between rising clock edges depends on howmuch delay exists in the system. A sufficient amount of time
</p>
<p>must exist between clock edges to allow the logic computations to settle so that on the next clock edge,
</p>
<p>the D-flip-flops can latch in a new value on their inputs.
</p>
<p>Let&rsquo;s examine all of the sources of delay in a FSM. Let&rsquo;s begin by assuming that all logic values are
</p>
<p>at a stable value and we experience a rising clock edge. The value present on the D input of the D-flip-
</p>
<p>flop is latched into the storage device and will appear on the Q output after one clock-to-Q delay of the
</p>
<p>device (tCQ). Once the new value is produced on the output of the D-flip-flop, it is then used by a variety of
</p>
<p>combinational logic circuits to produce the next state codes and the outputs of the FSM. The next state
</p>
<p>code computation is typically longer than the output computation so let&rsquo;s examine that path. The new
</p>
<p>value on Q propagates through the combinational logic circuitry and produces the next state code at the
</p>
<p>D input of the D-flip-flop. The delay to produce this next state code includes wiring delay in addition to
</p>
<p>gate delay. When analyzing the delay of the combinational logic circuitry (tcmb) and the delay of the
</p>
<p>interconnect (tint), the worst-case path is always considered. Once the new logic value is produced by the
</p>
<p>next state logic circuitry, it must remain stable for a certain amount of time in order to meet the D-flip-flop&rsquo;s
</p>
<p>setup specification (tsetup). Once this specification is met, the D-flip-flop could be clocked with the next
</p>
<p>clock edge; however, this represents a scenario without any margin in the timing. This means that if
</p>
<p>anything in the system caused the delay to increase even slightly, the D-flip-flop could go metastable. To
</p>
<p>avoid this situation, margin is included in the delay (tmargin). This provides some padding so that the
</p>
<p>system can reliably operate. A margin of 10% is typical in digital systems. The time that must exist
</p>
<p>between rising clock edges is then simply the sum of all of these sources of delay
</p>
<p>(tCQ + tcmb + tint + tsetup + tmargin). Since the time between rising clock edges is defined as the period of
</p>
<p>the signal (T), this value is also the definition of the period of the fastest clock. Since the frequency of a
</p>
<p>signal is simply f &frac14; 1/T, the maximum clock frequency for the FSM is the reciprocal of the sum of the
</p>
<p>delay.
</p>
<p>One specification that is not discussed in the above description is the hold time of the D-flip-flop
</p>
<p>(thold). The hold specification is the amount of time that the input to the D-flip-flop must remain constant
</p>
<p>after the clock edge. In modern storage devices, this time is typically very small and considerably less
</p>
<p>than the tCQ specification. If the hold specification is less than tCQ, it can be ignored because the output of
</p>
<p>the D-flip-flop will not change until after one tCQ anyway. This means that the hold requirements are
</p>
<p>inherently met. This is the situation with the majority of modern D-flip-flops. In the rare case that the hold
</p>
<p>time is greater than tCQ, then it is used in place of tCQ in the summation of delays. Figure 7.34 gives the
</p>
<p>summary of the maximum clock frequency calculation when analyzing a FSM.
</p>
<p>274 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s take a look at an example of how to use this analysis. Example 7.31 shows this analysis for the
</p>
<p>FSM analyzed in prior sections but this time considering the delay specifications of each device.
</p>
<p>Fig. 7.34
Timing analysis of a finite-state machine
</p>
<p>7.7 Sequential Logic Analysis &bull; 275</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC7.7 What is the risk of running the clock above its maximum allowable frequency in a finite-
state machine?
</p>
<p>A) The power consumption may drop below the recommended level.
</p>
<p>B) The setup and hold specifications of the D-flip-flops may be violated, which
may put the machine into an unwanted state.
</p>
<p>C) The states may transition too quickly to be usable.
</p>
<p>D) The crystal generating the clock may become unstable.
</p>
<p>Example 7.31
Determining the maximum clock frequency of a FSM
</p>
<p>276 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v Sequential logic refers to a circuit that bases
its outputs on both the present and past
values of the inputs. Past values are held in
sequential logic storage device.
</p>
<p>v All sequential logic storage devices are
based on a cross-coupled feedback loop.
The positive feedback loop formed in this
configuration will hold either a 1 or a 0. This
is known as a bistable device.
</p>
<p>v If the inputs of the feedback loop in a sequen-
tial logic storage device are driven to exactly
between a 1 and a 0 (i.e., Vcc/2) and then
released, the device will go metastable.
Metastability refers to the behavior where
the device will ultimately be pushed toward
one of the two stable states in the system,
typically by electrical noise. Once the device
begins moving toward one of the stable
states, the positive feedback will reinforce
the transition until it reaches the stable
state. The stable state that the device will
move toward is random and unknown.
</p>
<p>v Cross-coupled inverters are the most basic
form of the positive feedback loop configura-
tion. To give the ability to drive the outputs of
the storage device to known values, the
inverters are replaced with NOR gates to
form the SR Latch. A variety of other
modifications can be made to the loop con-
figuration to ultimately produce a D-Latch
and D-flip-flop.
</p>
<p>v A D-flip-flop will update its Q output with the
value on its D input on every triggering edge
of a clock. The amount of time that it takes for
the Q output to update after a triggering clock
edge is called the &ldquo;t-clock-to-Q&rdquo; (tCQ)
specification.
</p>
<p>v The setup and hold times of a D-flip-flop
describe how long before (tsetup) and after
(thold) the triggering clock edge that the data
on the D input of the device must be stable. If
the D input transitions too close to the trigger-
ing clock edge (i.e., violating a setup or hold
specification), then the device will go meta-
stable, and the ultimate value on Q is
unknown.
</p>
<p>v A synchronous system is one in which all
logic transitions occur based on a single
timing event. The timing event is typically
the triggering edge of a clock.
</p>
<p>v There are a variety of common circuits that
can be accomplished using just sequential
storage devices. Examples of these circuits
include switch debouncing, toggle flops, rip-
ple counters, and shift registers.
</p>
<p>v A finite-state machine (FSM) is a system that
produces outputs based on the current value
of the inputs and a history of past inputs. The
history of inputs is recorded as states that the
machine has been in. As the machine
responds to new inputs, it transitions
between states. This allows a finite-state
machine to make more sophisticated
decisions about what outputs to produce by
knowing its history.
</p>
<p>v A state diagram is a graphical way to
describe the behavior of a FSM. States are
represented using circles, and transitions are
represented using arrows. Outputs are listed
either inside of the state circle or next to the
transition arrow.
</p>
<p>v A state transition table contains the same
information as a state diagram but in tabular
format. This allows the system to be more
easily synthesized because the information
is in a form similar to a truth table.
</p>
<p>v The first step in FSM synthesis is creating the
state memory. The state memory consists of
a set of D-flip-flops that hold the current state
of the FSM. Each state in the FSM must be
assigned a binary code. The type of
encoding is arbitrary; however, there are cer-
tain encoding types that are commonly used
such as binary, gray code, and one-hot.
Once the codes are assigned, state variables
need to be defined for each bit position for
both the current state and the next state
codes. The state variables for the current
state represent the Q outputs of the D-flip-
flops, which hold the current state code. The
state variables for the next state code repre-
sent the D inputs of the D-flip-flops. A D-flip-
flop is needed for each bit in the state code.
On the triggering edge of a clock, the current
state will be updated with the next state code.
</p>
<p>v The second step in FSM synthesis is creating
the next state logic. The next state logic is
combinational logic circuitry that produces
the next state codes based on the current
state variables and any system inputs. The
next state logic drives the D inputs of the D-
flip-flops in the state memory.
</p>
<p>v The third step in FSM synthesis is creating
the output logic. The output logic is combina-
tional logic circuitry that produces the system
outputs based on the current state and,
potentially, the system inputs.
</p>
<p>v The output logic always depends on the cur-
rent state of a FSM. If the output logic also
depends on the system inputs, the machine
</p>
<p>Summary &bull; 277</p>
<p/>
</div>
<div class="page"><p/>
<p>is a Mealy machine. If the output logic does
not depend on the system inputs, the
machine is a Moore machine.
</p>
<p>v A counter is a special type of finite-state
machine in which the states are traversed
linearly. The linear progression of states
allows the next state logic to be simplified.
The complexity of the output logic in a
counter can also be reduced by encoding
the states with the desired counter output
for that state. This technique, known as
state-encoded outputs, allows the system
outputs to simply be the current state of
the FSM.
</p>
<p>v The reset state of a FSM is the state that the
machine will go to when it begins operation.
The state code for the reset state must be
configured using the reset and/or preset lines
of the D-flip-flops. If only reset lines are used
on the D-flip-flops, the reset state must be
encoded using only zeros.
</p>
<p>v Given the logic diagram for a state machine,
the logic expression for the next state mem-
ory and the output logic can be determined
by analyzing the combinational logic driving
the D inputs of the state memory (i.e., the
next state logic) and the combinational logic
driving the system outputs (i.e., the output
logic).
</p>
<p>v Given the logic diagram for a state diagram,
the state diagram can be determined by first
finding the logic expressions for the next
state and output logic. The number of D-flip-
</p>
<p>flops in the logic diagram can then be used to
calculate the possible number of state codes
that the machine has. The state codes are
then used to calculate the next state logic
and output values. From this information, a
state transition table can be created and, in
turn, the state diagram.
</p>
<p>v The maximum frequency of a FSM is found
by summing all sources of time delay that
must be accounted for before the next trig-
gering edge of the clock can occur. These
sources include tCQ, the worst-case combi-
national logic path, the worst-case intercon-
nect delay path, the setup/hold time of the
D-flip-flops, and any margin that is to be
included. The sum of these timing delays
represents the smallest period (T) that the
clock can have. This is then converted to
frequency.
</p>
<p>v If the tCQ time is greater than or equal to the
hold time, the hold time can be ignored in the
maximum frequency calculation. This is
because the outputs of the D-flip-flops are
inherently held while the D-flip-flops are pro-
ducing the next output value. The time it
takes to change the outputs after a triggering
clock edge is defined as tCQ. This means as
long as tCQ � thold, the hold time specification
is inherently met since the logic driving the
next state codes uses the Q outputs of the
D-flip-flops.
</p>
<p>Exercise Problems
</p>
<p>For some of the following exercise problems,
</p>
<p>you will be asked to design a Verilog model
</p>
<p>and perform a functional simulation. You will
</p>
<p>be provided with a test bench for each of
</p>
<p>these problems. The details of how to create
</p>
<p>your own Verilog test bench are provided
</p>
<p>later in Chap. 8. For some of the following
</p>
<p>exercise problems, you will be asked to use
</p>
<p>D-flip-flops as part of a Verilog design. You
</p>
<p>will be provided with the model of the D-flip-
</p>
<p>flop and can declare it as a sub-system in
</p>
<p>your design. The Verilog module definition
</p>
<p>for a D-flip-flop is given in Fig. 7.35. Keep in
</p>
<p>mind that this D-flip-flop has an active LOW
</p>
<p>reset. This means that when the reset line is
</p>
<p>pulled to a 0, the outputs will go to Q &frac14; 0,
</p>
<p>Qn &frac14; 1. When the reset line is LOW, the
</p>
<p>incoming clock is ignored. Once the reset
</p>
<p>line goes HIGH, the D-flip-flop resumes nor-
</p>
<p>mal behavior. The details of how to create
</p>
<p>your own model of a D-flip-flop are provided
</p>
<p>later in Chap. 8.
</p>
<p>278 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 7.1: Sequential Logic Storage
Devices
</p>
<p>7.1.1 What does the term metastability refer to in a
sequential storage device?
</p>
<p>7.1.2 What does the term bistable refer to in a
sequential storage device?
</p>
<p>7.1.3 You are given a cross-coupled inverter pair in
which all nodes are set to Vcc/2. Why will this
configuration always move to a more stable
state?
</p>
<p>7.1.4 An SR Latch essentially implements the same
cross-coupled feedback loop to store informa-
tion as in a cross-coupled inverter pair. What is
the purpose of using NOR gates instead of
inverters in the SR Latch configuration?
</p>
<p>7.1.5 Why isn&rsquo;t the input condition S &frac14; R &frac14; 1 used in
an SR Latch?
</p>
<p>7.1.6 How will the output Q behave in an SR Latch if
the inputs continuously switch between S &frac14; 0,
R &frac14; 1 and S &frac14; 1, R &frac14; 1 every 10 ns?
</p>
<p>7.1.7 How do D-flip-flops enable synchronous
systems?
</p>
<p>7.1.8 What signal in the D-flip-flop in Fig. 7.35 has
the highest priority?
</p>
<p>7.1.9 For the timing diagram shown in Fig. 7.36,
draw the outputs Q and Qn for a rising edge-
triggered D-flip-flop with active LOW.
</p>
<p>Fig. 7.36
D-flip-flop timing exercise 1
</p>
<p>7.1.10 For the timing diagram shown in Fig. 7.37,
draw the outputs Q and Qn for a rising edge
triggered D-flip-flop with active LOW.
</p>
<p>Fig. 7.37
D-flip-flop timing exercise 2
</p>
<p>7.1.11 For the timing diagram shown in Fig. 7.38,
draw the outputs Q and Qn for a rising edge
triggered D-flip-flop with active LOW.
</p>
<p>Fig. 7.38
D-flip-flop timing exercise 3
</p>
<p>Section 7.2: Sequential Logic Timing
Considerations
</p>
<p>7.2.1 What timing specification is violated in a D-flip-
flop when the data is not held long enough
before the triggering clock edge occurs?
</p>
<p>7.2.2 What timing specification is violated in a D-flip-
flop when the data is not held long enough after
the triggering clock edge occurs?
</p>
<p>7.2.3 What is the timing specification for a D-flip-flop
that describes how long after the triggering
clock edge occurs that the new data will be
present on the Q output?
</p>
<p>7.2.4 What is the timing specification for a D-flip-flop
that describes how long after the device goes
metastable that the outputs will settle to known
states.
</p>
<p>7.2.5 If the Q output of a D-flip-flop is driving the D
input of another D-flip-flop from the same logic
family, can the hold time be ignored if it is less
than the clock-to-Q delay? Provide an expla-
nation as to why or why not.
</p>
<p>Fig. 7.35
D-flip-flop module definition
</p>
<p>Exercise Problems &bull; 279</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 7.3: Common Circuits Based
on Sequential Storage Devices
</p>
<p>7.3.1 In a toggle flop (T-flop) configuration, the Qn
output of the D-flip-flop is routed back to the D
input. This can lead to a hold time violation if
the output arrives on the input too quickly.
Under what condition(s) is a hold time violate
not an issue?
</p>
<p>7.3.2 In a toggle flop (T-flop) configuration, what
timing specifications dictate how quickly the
next edge of the incoming clock can occur?
</p>
<p>7.3.3 One drawback of a ripple counter is that the
delay through the cascade of D-flip-flops can
become considerable for large counters. At
what point does the delay of a ripple counter
prevent it from being useful?
</p>
<p>7.3.4 A common use of a ripple counter is in the
creation of a 2n programmable clock divider.
In a ripple counter, bit(0) has a frequency that
is exactly 1/2 of the incoming clock, bit(1) has a
frequency that is exactly 1/4 of the incoming
clock, bit(2) has a frequency that is exactly 1/8
of the incoming clock, etc. This behavior can
be exploited to create a divided down output
clock that is divided by multiples of 2n by
selecting a particular bit of the counter. The
typical configuration of this programmable
clock divider is to route each bit of the counter
to an input of a multiplexer. The select lines
going to the multiplexer choose which bit of
the counter are used as the divided down
clock output. This architecture is shown in
Fig. 7.39. Design a Verilog model to implement
the programmable clock divider shown in this
figure. Use the module port definition provided
in this figure for your design. Use a 4-bit ripple
counter to produce four divided versions of the
clock (1/2, 1/4, 1/8, and 1/16). Your system will
take in two select lines that will choose which
version of the clock is to be routed to the out-
put. Instantiate the D-flip-flop model provided
to implement the ripple counter. Implement the
4-to-1 multiplexer using continuous assign-
ment. The multiplexer does not need to be its
own sub-system.
</p>
<p>Fig. 7.39
Programmable clock module description
</p>
<p>7.3.5 What phenomenon causes switch bounce in a
SPST switch?
</p>
<p>7.3.6 What two phenomena causes switch bounce in
a SPDT switch?
</p>
<p>Section 7.4: Finite-State Machines
</p>
<p>7.4.1 For the state diagram in Fig. 7.40, how many
D-Flip-Flops will this machine take if the states
are encoded in binary?
</p>
<p>Fig. 7.40
FSM 0 state diagram
</p>
<p>280 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.2 For the state diagram in Fig. 7.40, how many
D-flip-flops will this machine take if the states
are encoded in gray code?
</p>
<p>7.4.3 For the state diagram in Fig. 7.40, how many
D-flip-flops will this machine take if the states
are encoded in one-hot?
</p>
<p>7.4.4 For the state diagram in Fig. 7.40, is this a
Mealy or Moore machine?
</p>
<p>The next set of questions are about the design of a
finite-state machine by hand to implement the behavior
described by the state diagram in Fig. 7.40. For this
design, you will name the current state variable
Q0_cur and name the next state variable Q0_nxt. You
will also use the following state codes:
</p>
<p>OFF &frac14; &lsquo;0&rsquo;
ON &frac14; &lsquo;1&rsquo;
</p>
<p>7.4.5 For the state diagram in Fig. 7.40, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.4.6 For the state diagram in Fig. 7.40, what is the
output logic expression for Assert?
</p>
<p>7.4.7 For the state diagram in Fig. 7.40, provide the
final logic diagram for this machine.
</p>
<p>7.4.8 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.40. Use the module port definition
provided in Fig. 7.41 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with logical
operators for the implementation of your next
state and output logic.
</p>
<p>Fig. 7.41
FSM 0 module definition
</p>
<p>7.4.9 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.40. Use the module port definition
provided in Fig. 7.41 for your design. Name
the current state variables Q1_cur and
Q0_cur and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with condi-
tional operators for the implementation of your
next state and output logic.
</p>
<p>7.4.10 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.40. Use the module port definition
provided in Fig. 7.41 for your design. Name
</p>
<p>the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use user-defined primitives for the imple-
mentation of your next state and output logic.
</p>
<p>7.4.11 For the state diagram in Fig. 7.42, how many
D-flip-flops will this machine take if the states
are encoded in binary?
</p>
<p>Fig. 7.42
FSM 1 state diagram
</p>
<p>7.4.12 For the state diagram in Fig. 7.42, how many
D-flip-flops will this machine take if the states
are encoded in gray code?
</p>
<p>7.4.13 For the state diagram in Fig. 7.42, how many
D-flip-flops will this machine take if the states
are encoded in one-hot?
</p>
<p>7.4.14 For the state diagram in Fig. 7.42, is this a
Mealy or Moore machine?
</p>
<p>The next set of questions are about the design of a
finite-state machine by hand to implement the behavior
described by the state diagram in Fig. 7.42. For this
design, you will name the current state variables
Q1_cur and Q0_cur and name the next state variables
Q1_nxt and Q0_nxt. You will also use the following state
codes:
</p>
<p>Start &frac14; &ldquo;00&rdquo;
Midway &frac14; &ldquo;01&rdquo;
</p>
<p>Done &frac14; &ldquo;10&rdquo;
</p>
<p>7.4.15 For the state diagram in Fig. 7.42, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.4.16 For the state diagram in Fig. 7.42, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.4.17 For the state diagram in Fig. 7.42, what is the
output logic expression for Dout?
</p>
<p>7.4.18 For the state diagram in Fig. 7.42, provide the
final logic diagram for this machine.
</p>
<p>7.4.19 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.42. Use the module port definition
provided in Fig. 7.43 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
</p>
<p>Exercise Problems &bull; 281</p>
<p/>
</div>
<div class="page"><p/>
<p>Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with logical
operators for the implementation of your next
state and output logic.
</p>
<p>Fig. 7.43
FSM 1 module description
</p>
<p>7.4.20 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.42. Use the module port definition
provided in Fig. 7.43 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with condi-
tional operators for the implementation of your
next state and output logic.
</p>
<p>7.4.21 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.42. Use the module port definition
provided in Fig. 7.43 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use user-defined primitives for the imple-
mentation of your next state and output logic.
</p>
<p>7.4.22 For the state diagram in Fig. 7.44, how many
D-flip-flops will this machine take if the states
are encoded in binary?
</p>
<p>Fig. 7.44
FSM 2 state diagram
</p>
<p>7.4.23 For the state diagram in Fig. 7.44, how many
D-flip-flops will this machine take if the states
are encoded in gray code?
</p>
<p>7.4.24 For the state diagram in Fig. 7.44, how many
D-flip-flops will this machine take if the states
are encoded in one-hot?
</p>
<p>7.4.25 For the state diagram in Fig. 7.44, is this a
Mealy or Moore machine?
</p>
<p>The next set of questions are about the design of a
finite-state machine by hand to implement the behavior
described by the state diagram in Fig. 7.44. For this
design, you will name the current state variables
Q1_cur and Q0_cur and name the next state variables
Q1_nxt and Q0_nxt. You will also use the following state
codes:
</p>
<p>S0 &frac14; &ldquo;00&rdquo;
S1 &frac14; &ldquo;01&rdquo;
S2 &frac14; &ldquo;10&rdquo;
S3 &frac14; &ldquo;11&rdquo;
</p>
<p>7.4.26 For the state diagram in Fig. 7.44, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.4.27 For the state diagram in Fig. 7.44, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.4.28 For the state diagram in Fig. 7.44, what is the
output logic expression for Dout?
</p>
<p>7.4.29 For the state diagram in Fig. 7.44, provide the
final logic diagram for this machine.
</p>
<p>7.4.30 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.44. Use the module port definition
provided in Fig. 7.45 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with logical
operators for the implementation of your next
state and output logic.
</p>
<p>Fig. 7.45
FSM 2 module description
</p>
<p>7.4.31 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.44. Use the module port definition
provided in Fig. 7.45 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use continuous assignment with logical
operators for the implementation of your next
state and output logic.
</p>
<p>282 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.32 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.44. Use the module port definition
provided in Fig. 7.45 for your design. Name
the current state variables Q1_cur and
Q0_cur, and name the next state variables
Q1_nxt and Q0_nxt. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use user-defined primitives for the imple-
mentation of your next state and output logic.
</p>
<p>7.4.33 For the state diagram in Fig. 7.46, how many
D-flip-flops will this machine take if the states
are encoded in binary?
</p>
<p>Fig. 7.46
FSM 3 state diagram
</p>
<p>7.4.34 For the state diagram in Fig. 7.46, how many
D-flip-flops will this machine take if the states
are encoded in gray code?
</p>
<p>7.4.35 For the state diagram in Fig. 7.46, how many
D-flip-flops will this machine take if the states
are encoded in one-hot?
</p>
<p>7.4.36 For the state diagram in Fig. 7.46, is this a
Mealy or Moore machine?
</p>
<p>The next set of questions are about the design of a
finite-state machine by hand to implement the behavior
described by the state diagram in Fig. 7.46. For this
design, you will name the current state variables
Q2_cur, Q1_cur, and Q0_cur and name the next state
variables Q2_nxt, Q1_nxt, and Q0_nxt. You will also use
the following state codes:
</p>
<p>Start &frac14; &ldquo;000&rdquo;
Boot &frac14; &ldquo;001&rdquo;
Halt &frac14; &ldquo;010&rdquo;
Ack &frac14; &ldquo;011&rdquo;
Run &frac14; &ldquo;100&rdquo;
</p>
<p>7.4.37 For the state diagram in Fig. 7.46, what is the
next state logic expression for Q2_nxt?
</p>
<p>7.4.38 For the state diagram in Fig. 7.46, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.4.39 For the state diagram in Fig. 7.46, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.4.40 For the state diagram in Fig. 7.46, what is the
output logic expression for Up?
</p>
<p>7.4.41 For the state diagram in Fig. 7.46, provide the
final logic diagram for this machine.
</p>
<p>7.4.42 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.46. Use the module port definition
provided in Fig. 7.47 for your design. Name
the current state variables Q2_cur, Q1_cur,
and Q0_cur, and name the next state variables
Q2_nxt, Q1_nxt, andQ0_nxt. Instantiate the D-
flip-flop model provided to implement your
state memory. Use continuous assignment
with logical operators for the implementation
of your next state and output logic.
</p>
<p>Fig. 7.47
FSM 3 module description
</p>
<p>7.4.43 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.46. Use the module port definition
provided in Fig. 7.47 for your design. Name
the current state variables Q2_cur, Q1_cur,
and Q0_cur, and name the next state variables
Q2_nxt, Q1_nxt, andQ0_nxt. Instantiate the D-
flip-flop model provided to implement your
state memory. Use continuous assignment
with logical operators for the implementation
of your next state and output logic.
</p>
<p>7.4.44 Design a Verilog model to implement the
behavior described by the state diagram in
Fig. 7.46. Use the module port definition
provided in Fig. 7.47 for your design. Name
the current state variables Q2_cur, Q1_cur,
and Q0_cur, and name the next state variables
Q2_nxt, Q1_nxt, andQ0_nxt. Instantiate the D-
flip-flop model provided to implement your
state memory. Use user-defined primitives for
the implementation of your next state and out-
put logic.
</p>
<p>The next set of questions are about the design of a 4-bit
serial bit sequence detector by hand similar to the one
described in Example 7.9. The input to your state detec-
tor is called DIN, and the output is called FOUND. Your
detector will assert FOUND anytime there is a 4-bit
sequence of &ldquo;0101.&rdquo; For all other input sequences, the
output is not asserted.
</p>
<p>7.4.45 For your 4-bit serial bit sequence detector, pro-
vide the state diagram for this FSM.
</p>
<p>Exercise Problems &bull; 283</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4.46 For your 4-bit serial bit sequence detector, how
many D-flip-flops does it take to implement the
state memory for this FSM if you encode your
states in binary?
</p>
<p>7.4.47 For your 4-bit serial bit sequence detector, pro-
vide the state transition table for this FSM.
</p>
<p>7.4.48 For your 4-bit serial bit sequence detector, syn-
thesize and provide the combinational logic
expressions for the next state logic.
</p>
<p>7.4.49 For your 4-bit serial bit sequence detector, syn-
thesize and provide the combinational logic
expression for the output logic for FOUND.
</p>
<p>7.4.50 For your 4-bit serial bit sequence detector, is
this FSM a Mealy or Moore machine?
</p>
<p>7.4.51 For your 4-bit serial bit sequence detector, pro-
vide the logic diagram for this FSM.
</p>
<p>The next set of questions are about the design of a
20-cent vending machine controller by hand similar to
the one described in Example 7.12. Your controller will
take in nickels and dimes and dispense a product any-
time the customer has entered 20 cents. Your FSM has
two inputs, Nin and Din. Nin is asserted whenever the
customer enters a nickel, while Din is asserted anytime
the customer enters a dime. Your FSM has two outputs,
dispense and change. Dispense is asserted anytime the
customer has entered at least 20 cents and change is
asserted anytime the customer has entered more than
20 cents and needs a nickel in change.
</p>
<p>7.4.52 For your 20-cent vending machine controller,
provide the state diagram for this FSM.
</p>
<p>7.4.53 For your 20-cent vending machine controller,
how many D-flip-flops does it take to imple-
ment the state memory for this FSM if you
encode your states in binary?
</p>
<p>7.4.54 For your 20-cent vending machine controller,
provide the state transition table for this FSM.
</p>
<p>7.4.55 For your 20-cent vending machine controller,
synthesize and provide the combinational logic
expressions for the next state logic.
</p>
<p>7.4.56 For your 20-cent vending machine controller,
synthesize and provide the combinational logic
expression for the output logic for Dispense
and Change.
</p>
<p>7.4.57 For your 20-cent vending machine controller, is
this FSM a Mealy or Moore machine?
</p>
<p>7.4.58 For your 20-cent vending machine controller,
provide the logic diagram for this FSM.
</p>
<p>The next set of questions are about the design of a
finite-state machine by hand that controls a traffic light
at the intersection of a busy highway and a seldom used
side road. You will be designing the control signals for
just the red, yellow, and green lights facing the highway.
Under normal conditions, the highway has a green light.
The side road has a car detector that indicates when a
car pulls up by asserting a signal called CAR. When
CAR is asserted, you will change the highway traffic
light from green to yellow. Once yellow, you will always
go to red. Once in the red position, a built-in timer will
</p>
<p>begin a countdown and provide your controller a signal
called TIMEOUT when 15 seconds has passed. Once
TIMEOUT is asserted, you will change the highway
traffic light back to green. Your system will have three
outputs GRN, YLW, and RED that control when the
highway facing traffic lights are on (1 &frac14; ON, 0 &frac14; OFF).
</p>
<p>7.4.59 For your traffic light controller, provide the state
diagram for this FSM.
</p>
<p>7.4.60 For your traffic light controller, howmany D-flip-
flops does it take to implement the state mem-
ory for this FSM if you encode your states in
binary?
</p>
<p>7.4.61 For your traffic light controller, provide the state
transition table for this FSM.
</p>
<p>7.4.62 For your traffic light controller, synthesize and
provide the combinational logic expressions for
the next state logic.
</p>
<p>7.4.63 For your traffic light controller, synthesize and
provide the combinational logic expression for
the output logic for GRN, YLW, and RED.
</p>
<p>7.4.64 For your traffic light controller, is this FSM a
Mealy or Moore machine?
</p>
<p>7.4.65 For your traffic light controller, provide the logic
diagram for this FSM.
</p>
<p>Section 7.5: Counters
</p>
<p>The next set of questions are about the design a 3-bit
binary up counter by hand. This state machine will need
eight states and require three bits for the state variable
codes. Name the current state variables Q2_cur,
Q1_cur, and Q0_cur and the next state variables
Q2_nxt, Q1_nxt, andQ0_nxt. The output of your counter
will be a 3-bit vector called Count.
</p>
<p>7.5.1 For your 3-bit binary up counter, what is the
next state logic expression for Q2_nxt?
</p>
<p>7.5.2 For your 3-bit binary up counter, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.5.3 For your 3-bit binary up counter, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.5.4 For your 3-bit binary up counter, what is the
output logic expression for Count(2)?
</p>
<p>7.5.5 For your 3-bit binary up counter, what is the
output logic expression for Count(1)?
</p>
<p>7.5.6 For your 3-bit binary up counter, what is the
output logic expression for Count(0)?
</p>
<p>7.5.7 For your 3-bit binary up counter, provide the
logic diagram.
</p>
<p>7.5.8 Design a Verilog model for a 3-bit binary up
counter. Instantiate the D-flip-flop model
provided to implement your state memory.
Use whatever concurrent modeling approach
you wish to model the next state and output
logic. Use the module port definition provided
in Fig. 7.48 for your design.
</p>
<p>284 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 7.48
3-Bit binary up counter module definition
</p>
<p>The next set of questions are about the design a 3-bit
binary up/down counter by hand. The counter will have
an input called Up that will dictate the direction of the
counter. When Up &frac14; 1, the counter should increment
and when Up &frac14; 0 it should decrement. This state
machine will need eight states and require three bits
for the state variable codes. Name the current state
variables Q2_cur, Q1_cur, and Q0_cur and the next
state variables Q2_nxt, Q1_nxt, and Q0_nxt. The output
of your counter will be a 3-bit vector called Count.
</p>
<p>7.5.9 For your 3-bit binary up/down counter, what is
the next state logic expression for Q2_nxt?
</p>
<p>7.5.10 For your 3-bit binary up/down counter, what is
the next state logic expression for Q1_nxt?
</p>
<p>7.5.11 For your 3-bit binary up/down counter, what is
the next state logic expression for Q0_nxt?
</p>
<p>7.5.12 For your 3-bit binary up/down counter, what is
the output logic expression for Count(2)?
</p>
<p>7.5.13 For your 3-bit binary up/down counter, what is
the output logic expression for Count(1)?
</p>
<p>7.5.14 For your 3-bit binary up/down counter, what is
the output logic expression for Count(0)?
</p>
<p>7.5.15 For your 3-bit binary up/down counter, provide
the logic diagram.
</p>
<p>7.5.16 Design a Verilog model for a 3-bit binary
up/down counter. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use whatever concurrent modeling
approach you wish to model the next state
and output logic. Use the module port definition
provided in Fig. 7.49 for your design.
</p>
<p>Fig. 7.49
3-Bit binary up/down counter module definition
</p>
<p>The next set of questions are about the design a 3-bit
gray code up counter by hand. This counter will create a
pattern of 000!001!011!010!110!111!101!100
and then repeat. This state machine will need eight
states and require three bits for the state variable
codes. Name the current state variables Q2_cur,
Q1_cur, and Q0_cur and the next state variables
Q2_nxt, Q1_nxt, and Q0_nxt. The output of your
counter will be a 3-bit vector called Count.
</p>
<p>7.5.17 For your 3-bit gray code up counter, what is the
next state logic expression for Q2_nxt?
</p>
<p>7.5.18 For your 3-bit gray code up counter, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.5.19 For your 3-bit gray code up counter, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.5.20 For your 3-bit gray code up counter, what is the
output logic expression for Count(2)?
</p>
<p>7.5.21 For your 3-bit gray code up counter, what is the
output logic expression for Count(1)?
</p>
<p>7.5.22 For your 3-bit gray code up counter, what is the
output logic expression for Count(0)?
</p>
<p>7.5.23 For your 3-bit gray code up counter, provide
the logic diagram.
</p>
<p>7.5.24 Design a Verilog model for a 3-bit gray code up
counter. Instantiate the D-flip-flop model
provided to implement your state memory.
Use whatever concurrent modeling approach
you wish to model the next state and output
logic. Use the module port definition provided
in Fig. 7.50 for your design.
</p>
<p>Fig. 7.50
3-Bit gray code up counter module definition
</p>
<p>The next set of questions are about the design a 3-bit
gray code up/down counter by hand. The counter will
have an input called Up that will dictate the direction of
the counter. When Up &frac14; 1, the counter should incre-
ment, and when Up &frac14; 0, it should decrement. When
incrementing up, the counter will create the pattern
000!001!011!010!110!111!101!100 and then
repeat. This state machine will need eight states and
require three bits for the state variable codes. Name the
current state variables Q2_cur, Q1_cur, and Q0_cur and
the next state variables Q2_nxt, Q1_nxt, and Q0_nxt.
The output of your counter will be a 3-bit vector called
Count.
</p>
<p>7.5.25 For your 3-bit gray code up/down counter, what
is the next state logic expression for Q2_nxt?
</p>
<p>7.5.26 For your 3-bit gray code up/down counter, what
is the next state logic expression for Q1_nxt?
</p>
<p>7.5.27 For your 3-bit gray code up/down counter, what
is the next state logic expression for Q0_nxt?
</p>
<p>7.5.28 For your 3-bit gray code up/down counter, what
is the output logic expression for Count(2)?
</p>
<p>7.5.29 For your 3-bit gray code up/down counter, what
is the output logic expression for Count(1)?
</p>
<p>7.5.30 For your 3-bit gray code up/down counter, what
is the output logic expression for Count(0)?
</p>
<p>7.5.31 For your 3-bit gray code up/down counter, pro-
vide the logic diagram.
</p>
<p>Exercise Problems &bull; 285</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5.32 Design a Verilog model for a 3-bit gray code
up/down counter. Instantiate the D-flip-flop
model provided to implement your state mem-
ory. Use whatever concurrent modeling
approach you wish to model the next state
and output logic. Use the module port definition
provided in Fig. 7.51 for your design.
</p>
<p>Fig. 7.51
3-Bit gray code up/down counter module
definition
</p>
<p>The next set of questions are about the design a 4-bit
one-hot up counter by hand. This counter will create a
pattern of 0001!0010!0100!1000 and then repeat.
This FSM should use state-encoded outputs to simplify
the output logic. This state machine will need four states
and require four bits for the state variable codes. Name
the current state variables Q3_cur, Q2_cur, Q1_cur, and
Q0_cur and the next state variables Q3_nxt, Q2_nxt,
Q1_nxt, andQ0_nxt. The output of your counter will be a
4-bit vector called Count.
</p>
<p>7.5.33 For your 4-bit one-hot up counter, what is the
next state logic expression for Q3_nxt?
</p>
<p>7.5.34 For your 4-bit one-hot up counter, what is the
next state logic expression for Q2_nxt?
</p>
<p>7.5.35 For your 4-bit one-hot up counter, what is the
next state logic expression for Q1_nxt?
</p>
<p>7.5.36 For your 4-bit one-hot up counter, what is the
next state logic expression for Q0_nxt?
</p>
<p>7.5.37 For your 4-bit one-hot up counter, what is the
output logic expression for Count(3)?
</p>
<p>7.5.38 For your 4-bit one-hot up counter, what is the
output logic expression for Count(2)?
</p>
<p>7.5.39 For your 4-bit one-hot up counter, what is the
output logic expression for Count(1)?
</p>
<p>7.5.40 For your 4-bit one-hot up counter, what is the
output logic expression for Count(0)?
</p>
<p>7.5.41 For your 4-bit one-hot up counter, provide the
logic diagram.
</p>
<p>7.5.42 Design a Verilog model for a 4-bit one-hot up
counter. Instantiate the D-flip-flop model
provided to implement your state memory.
Use whatever concurrent signal assignment
modeling approach you wish to model the
next state and output logic. Use the Verilog
module definition provided in Fig. 7.52 for
your design.
</p>
<p>Fig. 7.52
4-Bit one-hot up counter module description
</p>
<p>The next set of questions are about the design of a
binary counter that goes from 00002 (010) to 10012
(910) by hand. This counter will create a pattern of
0000!0001!0010!
0011!0100!0101!0110!0111!1000!1001 and
then repeat. This type of counter is known as a binary-
coded decimal (BCD) counter. This FSM should use
state-encoded outputs to simplify the output logic. This
state machine will need ten states and require four bits
for the state variable codes. Name the current state
variables Q3_cur, Q2_cur, Q1_cur, and Q0_cur and
the next state variables Q3_nxt, Q2_nxt, Q1_nxt, and
Q0_nxt. The output of your counter will be a 4-bit vector
called Count.
</p>
<p>7.5.43 For your BCD counter, what is the next state
logic expression for Q3_nxt?
</p>
<p>7.5.44 For your BCD counter, what is the next state
logic expression for Q2_nxt?
</p>
<p>7.5.45 For your BCD counter, what is the next state
logic expression for Q1_nxt?
</p>
<p>7.5.46 For your BCD counter, what is the next state
logic expression for Q0_nxt?
</p>
<p>7.5.47 For your BCD counter, what is the output logic
expression for Count(3)?
</p>
<p>7.5.48 For your BCD counter, what is the output logic
expression for Count(2)?
</p>
<p>7.5.49 For your BCD counter, what is the output logic
expression for Count(1)?
</p>
<p>7.5.50 For your BCD counter, what is the output logic
expression for Count(0)?
</p>
<p>7.5.51 For your BCD counter, provide the logic
diagram.
</p>
<p>Section 7.6: Finite-State Machine&rsquo;s Reset
Condition
</p>
<p>7.6.1 Are resets typically synchronous or
asynchronous?
</p>
<p>7.6.2 Why is it necessary to have a reset/preset
condition in a finite-state machine?
</p>
<p>7.6.3 How does the reset/preset condition corre-
spond to the behavior described in the state
diagram?
</p>
<p>7.6.4 When is it necessary to also use the preset line
(s) of a D-flip-flop instead of just the reset line
(s) when implementing the state memory of a
finite-state machine?
</p>
<p>286 &bull; Chapter 7: Sequential Logic Design</p>
<p/>
</div>
<div class="page"><p/>
<p>7.6.5 If a finite-state machine has eight unique states
that are encoded in binary and all D-flip-flops
used for the state memory use their reset lines,
what is the state code that the machine will go
to upon reset?
</p>
<p>Section 7.7: Sequential Logic Analysis
</p>
<p>7.7.1 For the finite state machine logic diagram in
Fig. 7.53, give the next state logic expression
for Q_nxt.
</p>
<p>Fig. 7.53
Sequential logic analysis 1
</p>
<p>7.7.2 For the finite-state machine logic diagram in
Fig. 7.53, give the output logic expression
for Tout.
</p>
<p>7.7.3 For the finite-state machine logic diagram in
Fig. 7.53, give the state transition table.
</p>
<p>7.7.4 For the finite-state machine logic diagram in
Fig. 7.53, give the state diagram.
</p>
<p>7.7.5 For the finite-state machine logic diagram in
Fig. 7.53, give the maximum clock frequency.
</p>
<p>7.7.6 For the finite-state machine logic diagram in
Fig. 7.54, give the next state logic expression
for Q_nxt.
</p>
<p>Fig. 7.54
Sequential logic analysis 2
</p>
<p>7.7.7 For the finite-state machine logic diagram in
Fig. 7.54, give the output logic expression for F.
</p>
<p>7.7.8 For the finite-state machine logic diagram in
Fig. 7.54, give the state transition table.
</p>
<p>7.7.9 For the finite-state machine logic diagram in
Fig. 7.54, give the state diagram.
</p>
<p>7.7.10 For the finite-state machine logic diagram in
Fig. 7.54, give the maximum clock frequency.
</p>
<p>7.7.11 For the finite-state machine logic diagram in
Fig. 7.55, give the next state logic expressions
for Q1_nxt and Q0_nxt.
</p>
<p>Fig. 7.55
Sequential logic analysis 3
</p>
<p>7.7.12 For the finite-state machine logic diagram in
Fig. 7.55, give the output logic expression for
Return.
</p>
<p>7.7.13 For the finite-state machine logic diagram in
Fig. 7.55, give the state transition table.
</p>
<p>7.7.14 For the finite-state machine logic diagram in
Fig. 7.55, give the state diagram.
</p>
<p>7.7.15 For the finite-state machine logic diagram in
Fig. 7.55, give the maximum clock frequency.
</p>
<p>Exercise Problems &bull; 287</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 8: Verilog (Part 2)
In Chap. 5, Verilog was presented as a way to describe the behavior of concurrent systems. The
</p>
<p>modeling techniques presented were appropriate for combinational logic because these types of circuits
</p>
<p>have outputs dependent only on the current values of their inputs. This means a model that continuously
</p>
<p>performs signal assignments provides an accurate model of this circuit behavior. In Chap. 7, sequential
</p>
<p>logic storage devices were presented that did not continuously update their outputs based on the
</p>
<p>instantaneous values of their inputs. Instead, sequential storage devices only update their outputs
</p>
<p>based upon an event, most often the edge of a clock signal. The modeling techniques presented in
</p>
<p>Chap. 5 are unable to accurately describe this type of behavior. In this chapter, we describe the Verilog
</p>
<p>constructs to model signal assignments that are triggered by an event in order to accurately model
</p>
<p>sequential logic. We can then use these techniques to describe more complex sequential logic circuits
</p>
<p>such as finite state machines and register transfer level systems. This chapter will also present how to
</p>
<p>create test benches and look at more advanced features that are commonly used in Verilog to model
</p>
<p>modern systems. The goal of this chapter is to give an understanding of the full capability of hardware
</p>
<p>description languages.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>8.1 Describe the behavior of Verilog procedural assignment and how they are used to model
sequential logic circuits.
</p>
<p>8.2 Model combinational logic circuits using a Verilog procedural assignment and conditional
programming constructs.
</p>
<p>8.3 Describe the functionality of common Verilog system tasks.
8.4 Design a Verilog test bench to verify the functional operation of a system.
</p>
<p>8.1 Procedural Assignment
</p>
<p>Verilog uses procedural assignment to model signal assignments that are based on an event. An
</p>
<p>event is most commonly a transition of a signal. This provides the ability to model sequential logic circuits
</p>
<p>such as D-flip-flops and finite state machines by triggering assignments off of a clock edge. Procedural
</p>
<p>assignments can only drive variable data types (i.e., reg, integer, real, and time); thus, they are ideal for
</p>
<p>modeling storage devices. Procedural signal assignments can be evaluated in the order they are listed;
</p>
<p>thus, they are able to model sequential assignments.
</p>
<p>A procedural assignment can also be used to model combinational logic circuits by making signal
</p>
<p>assignments when any of the inputs to the model change. Despite the left-hand side of the assignment
</p>
<p>not being able to be of type wire in procedural assignment, modern synthesizers will recognize properly
</p>
<p>designed combinational logic models and produce the correct circuit implementation. Procedural assign-
</p>
<p>ment also supports standard programming constructs such as if-else decisions, case statements, and
</p>
<p>loops. This makes procedural assignment a powerful modeling approach in Verilog and is the most
</p>
<p>common technique for designing digital systems and creating test benches.
</p>
<p>8.1.1 Procedural Blocks
</p>
<p>All procedural signal assignments must be enclosed within a procedural block. Verilog has two types
</p>
<p>of procedural blocks, initial and always.
</p>
<p># Springer Nature Switzerland AG 2019
B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
https://doi.org/10.1007/978-3-030-13605-5_8
</p>
<p>289</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_8&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_8&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>8.1.1.1 Initial Blocks
</p>
<p>An initial block will execute all of the statements embedded within it one time at the beginning of the
</p>
<p>simulation. An initial block is not used to model synthesizable behavior. It is instead used within test
</p>
<p>benches to either set the initial values of repetitive signals or to model the behavior of a signal that only
</p>
<p>has a single set of transitions. The following is the syntax for an initial block.
</p>
<p>initial
</p>
<p>begin // an optional &ldquo;: name&rdquo; can be added after the begin keyword
</p>
<p>signal_assignment_1
</p>
<p>signal_assignment_2
</p>
<p>:
</p>
<p>end
</p>
<p>Let&rsquo;s look at a simple model of how an initial block is used to model the reset line in a test bench. In
</p>
<p>the following example, the signal &ldquo;Reset_TB&rdquo; is being driven into a DUT. At the beginning of the
</p>
<p>simulation, the initial value of Reset_TB is set to a logic zero. The second assignment will take place
</p>
<p>after a delay of 15 time units. The second assignment statement sets Reset_TB to a logic one. The
</p>
<p>assignments in this example are evaluated in sequence in the order they are listed due to the delay
</p>
<p>operator. Since the initial block executes only once, Reset_TB will stay at the value of its last assignment
</p>
<p>for the remainder of the simulation.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>Reset_TB &frac14; 1&rsquo;b0;
</p>
<p>#15 Reset_TB &frac14; 1&rsquo;b1;
</p>
<p>end
</p>
<p>8.1.1.2 Always Blocks
</p>
<p>An always block will execute forever or for the duration of the simulation. An always block can be
</p>
<p>used to model synthesizable circuits in addition to non-synthesizable behavior in test benches. The
</p>
<p>following is the syntax for an always block.
</p>
<p>always
</p>
<p>begin
</p>
<p>signal_assignment_1
</p>
<p>signal_assignment_2
</p>
<p>:
</p>
<p>end
</p>
<p>Let&rsquo;s look at a simple model of how an always block can be used to model a clock line in a test
</p>
<p>bench. In the following example, the value of the signal Clock_TB will continuously change its logic value
</p>
<p>every 10 time units.
</p>
<p>Example:
</p>
<p>always
</p>
<p>begin
</p>
<p>#10 Clock_TB &frac14; ~Clock_TB;
</p>
<p>end
</p>
<p>By itself, the above always block will not work because when the simulation begins, Clock_TB does
</p>
<p>not have an initial value so the simulator will not know what the value of Clock_TB is at time zero. It will
</p>
<p>also not know what the output of the negation operation (~) will be at time unit 10. The following example
</p>
<p>290 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>shows the correct way of modeling a clock signal using a combination of initial and always blocks. Verilog
</p>
<p>allows assignments to the same variable from multiple procedural blocks, so the following example is
</p>
<p>valid. Note that when the simulation begins, Clock_TB is assigned a logic zero. This provides a known
</p>
<p>value for the signal at time zero and also allows the always block negation to have a deterministic value.
</p>
<p>The example below will create a clock signal that will toggle every 10 time units.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>Clock_TB &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>always
</p>
<p>begin
</p>
<p>#10 Clock_TB &frac14; ~Clock_TB;
</p>
<p>end
</p>
<p>8.1.1.3 Sensitivity Lists
</p>
<p>A sensitivity list is used in conjunction with a procedural block to trigger when the assignments within
</p>
<p>the block are executed. The symbol @ is used to indicate a sensitivity list. Signals can then be listed
</p>
<p>within parenthesis after the @ symbol that will trigger the procedural block. The following is the base
</p>
<p>syntax for a sensitivity list.
</p>
<p>always @ (signal1, signal2)
</p>
<p>begin
</p>
<p>signal_assignment_1
</p>
<p>signal_assignment_2
</p>
<p>:
</p>
<p>end
</p>
<p>In this syntax, any transition on any of the signals listed within the parenthesis will cause the always
</p>
<p>block to trigger and all of its assignments to take place one time. After the always block ends, it will await
</p>
<p>the next signal transition in the sensitivity list to trigger again. The following example shows how to model
</p>
<p>a simple 3-input AND gate. In this example, any transition on inputs A, B, or C will cause the block to
</p>
<p>trigger and the assignment to F to occur.
</p>
<p>Example:
</p>
<p>always @ (A, B, C)
</p>
<p>begin
</p>
<p>F &frac14; A &amp; B &amp; C;
</p>
<p>end
</p>
<p>Verilog also supports keywords to limit triggering of the block to only rising edge or falling edge
</p>
<p>transitions. The keywords are posedge and negedge. The following is the base syntax for an edge
</p>
<p>sensitive block. In this syntax, only rising edge transitions on signal1 or falling edge transitions on signal2
</p>
<p>will cause the block to trigger.
</p>
<p>always @ (posedge signal1, negedge signal2)
</p>
<p>begin
</p>
<p>signal_assignment_1
</p>
<p>signal_assignment_2
</p>
<p>:
</p>
<p>end
</p>
<p>Sensitivity lists can also contain Boolean operators to more explicitly describe behavior. The
</p>
<p>following syntax is identical to the syntax above.
</p>
<p>8.1 Procedural Assignment &bull; 291</p>
<p/>
</div>
<div class="page"><p/>
<p>always @ (posedge signal1 or negedge signal2)
</p>
<p>begin
</p>
<p>signal_assignment_1
</p>
<p>signal_assignment_2
</p>
<p>:
</p>
<p>end
</p>
<p>The ability to model edge sensitivity allows us to model sequential circuits. The following example
</p>
<p>shows how to model a simple D-flip-flop.
</p>
<p>Example:
</p>
<p>always @ (posedge Clock)
</p>
<p>begin
</p>
<p>Q &frac14; D; // Note: This model does not include a reset.
</p>
<p>end
</p>
<p>In Verilog-2001, the syntax to support sensitivity lists that will trigger based on any signal listed on
</p>
<p>the right-hand side of any assignment within the block was added. This syntax is @*. The following
</p>
<p>example how to use this modeling approach to model a 3-input AND gate.
</p>
<p>Example:
</p>
<p>always @*
</p>
<p>begin
</p>
<p>F &frac14; A &amp; B &amp; C;
</p>
<p>end
</p>
<p>8.1.2 Procedural Statements
</p>
<p>There are two kinds of signal assignments that can be used within a procedural block, blocking and
</p>
<p>non-blocking.
</p>
<p>8.1.2.1 Blocking Assignments
</p>
<p>A blocking assignment is denoted with the &frac14; symbol, and the evaluation and assignment of each
</p>
<p>statement take place immediately. Each assignment within the block is executed in parallel. When this
</p>
<p>behavior is coupled with a sensitivity list that contains all of the inputs to the system, this approach can
</p>
<p>model synthesizable combinational logic circuits. This approach provides the same functionality as
</p>
<p>continuous assignments outside of a procedural block. The reason that designers use blocking
</p>
<p>assignments instead of continuous assignment is that more advanced programming constructs are
</p>
<p>supported within Verilog procedural blocks. These will be covered in the next section. Example 8.1
</p>
<p>shows how to use blocking assignments within a procedural block to model a combinational logic circuit.
</p>
<p>292 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>8.1.2.2 Non-blocking Assignments
</p>
<p>A non-blocking assignment is denoted with the &lt;&frac14; symbol. When using non-blocking assignments,
</p>
<p>the assignment to the target signal is deferred until the end of the procedural block. This allows the
</p>
<p>assignments to be executed in the order they are listed in the block without cascading interim
</p>
<p>assignments through the list. When this behavior is coupled with triggering the block off of a clock signal,
</p>
<p>this approach canmodel synthesizable sequential logic circuits. Example 8.2 shows an example of using
</p>
<p>non-blocking assignments to model a sequential logic circuit.
</p>
<p>The difference between blocking and non-blocking assignments is subtle and is often one of the
</p>
<p>most difficult concepts to grasp when first learning Verilog. One source of confusion comes from the fact
</p>
<p>that blocking and non-blocking assignments can produce the same results when they either contains a
</p>
<p>single assignment or a list of assignments that don&rsquo;t have any signal interdependencies. A signal
</p>
<p>interdependency refers to when a signal that is the target of an assignment (i.e., on the LHS of an
</p>
<p>Example 8.2
Using non-blocking assignments to model sequential logic
</p>
<p>Example 8.1
Using blocking assignments to model combinational logic
</p>
<p>8.1 Procedural Assignment &bull; 293</p>
<p/>
</div>
<div class="page"><p/>
<p>assignment) is used as an argument (i.e., on the RHS of an assignment) in subsequent statements.
</p>
<p>Example 8.3 shows two models that produce the same results regardless of whether a blocking or
</p>
<p>non-blocking assignment is used.
</p>
<p>When a list of statements within a procedural block does have signal interdependencies, blocking
</p>
<p>and non-blocking assignments will have different behavior. Example 8.4 shows how signal
</p>
<p>interdependencies will cause different behavior between blocking and non-blocking assignments. In
</p>
<p>this example, all inputs are listed in the sensitivity list with the intent of modeling combinational logic.
</p>
<p>Example 8.3
Identical behavior when using blocking vs. non-blocking assignments
</p>
<p>294 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 8.4
Different behavior when using blocking vs. non-blocking assignments (1)
</p>
<p>8.1 Procedural Assignment &bull; 295</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 8.5 shows another case where signal interdependencies will cause different behavior
</p>
<p>between blocking and non-blocking assignments. In this example, the procedural block is triggered by
</p>
<p>the rising edge of a clock signal with the intent of modeling two stages of sequential logic.
</p>
<p>Example 8.5
Different behavior when using blocking vs. non-blocking assignments (2)
</p>
<p>296 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>While the behavior of these procedural assignments can be confusing, there are two design
</p>
<p>guidelines that can make creating accurate, synthesizable models straightforward. They are:
</p>
<p>1. When modeling combinational logic, use blocking assignments and list every input in the
sensitivity list.
</p>
<p>2. When modeling sequential logic, use non-blocking assignments and only list the clock and
reset lines (if applicable) in the sensitivity list.
</p>
<p>8.1.3 Statement Groups
</p>
<p>A statement group refers to how the statements in a block are processed. Verilog supports two types
</p>
<p>of statement groups: begin/end and fork/join. When using begin/end, all statements enclosed within the
</p>
<p>group will be evaluated in the order they are listed. When using a fork/join, all statements enclosed within
</p>
<p>the group will be evaluated in parallel. When there is only one statement within procedural block, a
</p>
<p>statement group is not needed. For multiple statements in a procedural block, a statement group is
</p>
<p>required. Statement groups can contain an optional name that is appended after the first keyword
</p>
<p>preceded by a &ldquo;:.&rdquo; Example 8.6 shows a graphical depiction of the difference between begin/end and
</p>
<p>fork/join groups. Note that this example also shows the syntax for naming the statement groups.
</p>
<p>Example 8.6
Behavior of statement groups begin/end vs. fork/join
</p>
<p>8.1 Procedural Assignment &bull; 297</p>
<p/>
</div>
<div class="page"><p/>
<p>8.1.4 Local Variables
</p>
<p>Local variables can be declared within a procedural block. The statement group must be named,
</p>
<p>and the variables will not be visible outside of the block. Variables can only be of variable type.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin:stim_block //itisrequiredtonametheblockwhendeclaringlocalvariables
</p>
<p>integer i; // local variables can only be of variable type
</p>
<p>i&frac14;2;
</p>
<p>end
</p>
<p>CONCEPT CHECK
</p>
<p>CC8.1 If a model of a combinational logic circuit excludes one of its inputs from the sensitivity
list, what is the implied behavior?
</p>
<p>A) A storage element because the output will be held at its last value when the
unlisted input transitions.
</p>
<p>B) An infinite loop.
</p>
<p>C) A don&rsquo;t care will be used to form the minimal logic expression.
</p>
<p>D) Not applicable because this syntax will not compile.
</p>
<p>8.2 Conditional Programming Constructs
</p>
<p>One of the more powerful features that procedural blocks provide in Verilog is the ability to use
</p>
<p>conditional programming constructs such as if-else decisions, case statements, and loops. These
</p>
<p>constructs are only available within a procedural block and can be used to model both combinational
</p>
<p>and sequential logic.
</p>
<p>8.2.1 if-else Statements
</p>
<p>An if-else statement provides a way to make conditional signal assignments based on Boolean
</p>
<p>conditions. The if portion of statement is followed by a Boolean condition that if evaluated TRUE will
</p>
<p>cause the signal assignment listed after it to be performed. If the Boolean condition is evaluated FALSE,
</p>
<p>the statements listed after the else portion are executed. If multiple statements are to be executed in
</p>
<p>either the if or else portion, then the statement group keywords begin/end need to be used. If only one
</p>
<p>statement is to be executed, then the statement group keywords are not needed. The else portion of the
</p>
<p>statement is not required, and if omitted, no assignment will take place when the Boolean condition is
</p>
<p>evaluated FALSE. The syntax for an if-else statement is as follows:
</p>
<p>if (&lt;boolean_condition&gt;)
</p>
<p>true_statement
</p>
<p>else
</p>
<p>false_statement
</p>
<p>298 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>The syntax for an if-else statement with multiple true/false statements is as follows:
</p>
<p>if (&lt;boolean_condition&gt;)
</p>
<p>begin
</p>
<p>true_statement_1
</p>
<p>true_statement_2
</p>
<p>end
</p>
<p>else
</p>
<p>begin
</p>
<p>false_statement_1
</p>
<p>false_statement_2
</p>
<p>end
</p>
<p>If more than one Boolean condition is required, additional if-else statements can be embedded
</p>
<p>within the else clause of the preceding if statement. The following shows an example of if-else
</p>
<p>statements implementing two Boolean conditions.
</p>
<p>if (&lt;boolean_condition_1&gt;)
</p>
<p>true_statement_1
</p>
<p>else if (&lt;boolean_condition_2&gt;)
</p>
<p>true_statement_2
</p>
<p>else
</p>
<p>false_statement
</p>
<p>Let&rsquo;s look at using an if-else statement to describe the behavior of a combinational logic circuit.
</p>
<p>Recall that a combinational logic circuit is one in which the output depends on the instantaneous values
</p>
<p>of the inputs. This behavior can bemodeled by placing all of the inputs to the circuit in the sensitivity list of
</p>
<p>an always block and using blocking assignments. Using this approach, a change on any of the inputs in
</p>
<p>the sensitivity list will trigger the block, and the assignments will take place immediately. Example 8.7
</p>
<p>shows how to model a 3-input combinational logic circuit using if-else statements within a procedural
</p>
<p>always block.
</p>
<p>Example 8.7
Using if-else statements to model combinational logic
</p>
<p>8.2 Conditional Programming Constructs &bull; 299</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2.2 case Statements
</p>
<p>A case statement is another technique to model signal assignments based on Boolean conditions.
</p>
<p>As with the if-else statement, a case statement can only be used inside of a procedural block. The
</p>
<p>statement begins with the keyword case followed by the input signal name that assignments will be
</p>
<p>based off of enclosed within parenthesis. The case statement can be based on multiple input signal
</p>
<p>names by concatenating the signals within the parenthesis. Then a series of input codes followed by the
</p>
<p>corresponding assignment is listed. The keyword default can be used to provide the desired signal
</p>
<p>assignment for any input codes not explicitly listed. When multiple input conditions have the same
</p>
<p>assignment statement, they can be listed on the same line comma-delimited to save space. The keyword
</p>
<p>endcase is used to denote the end of the case statement. The following is the syntax for a case
</p>
<p>statement.
</p>
<p>case (&lt;input_name&gt;)
</p>
<p>input_val_1 : statement_1
</p>
<p>input_val_2 : statement_2
</p>
<p>:
</p>
<p>input_val_n : statement_n
</p>
<p>default : default_statement
</p>
<p>endcase
</p>
<p>Example 8.8 shows how to model a 3-input combinational logic circuit using a case statement within
</p>
<p>a procedural block. Note in this example the inputs are scalars, so they must be concatenated so that the
</p>
<p>input values can be listed as 3-bit vectors. In this example, there are three versions of the model
</p>
<p>provided. The first explicitly lists out all binary input codes. This approach is more readable because it
</p>
<p>mirrors a truth table form. The second approach only lists the input codes corresponding to an output of
</p>
<p>one and uses the default clause to handle all other input codes. The third approach shows how to list
</p>
<p>multiple input codes with the same assignment on the same line using a comma-delimited series.
</p>
<p>300 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>If-else statements can be embedded within a case statement, and, conversely, case statements can
</p>
<p>be embedded within an if-else statement.
</p>
<p>8.2.3 casez and casex Statements
</p>
<p>Verilog provides two additional case statements that support don&rsquo;t cares in the input conditions. The
</p>
<p>casez statement allows the symbols ? and Z to represent a don&rsquo;t care. The casex statement extends the
</p>
<p>casez statement by also interpreting X as a don&rsquo;t care. Care should be taken when using the casez and
</p>
<p>casex statement as it is easy to create unintended logic when using don&rsquo;t cares in the input codes.
</p>
<p>8.2.4 forever Loops
</p>
<p>A loop within Verilog provides a mechanism to perform repetitive assignments infinitely. This is
</p>
<p>useful in test benches for creating stimulus such as clocks or other periodic signals. We have already
</p>
<p>covered a looping construct in the form of an always block. An always block provides a loop with a
</p>
<p>starting condition. Verilog provides additional looping constructs to model more sophisticated behavior.
</p>
<p>All looping constructs must reside with a procedural block.
</p>
<p>Example 8.8
Using case statements to model combinational logic
</p>
<p>8.2 Conditional Programming Constructs &bull; 301</p>
<p/>
</div>
<div class="page"><p/>
<p>The simplest looping construct is the forever loop. As with other conditional programming
</p>
<p>constructs, if multiple statements are associated with the forever loop, they must be enclosed within a
</p>
<p>statement group. If only one statement is used, the statement group is not needed. A forever loop within
</p>
<p>an initial block provides identical behavior as an always loop without a sensitivity loop. It is important to
</p>
<p>provide a time step event or delay within a forever loop or it will cause a simulation to hang. The following
</p>
<p>is the syntax for a forever loop in Verilog.
</p>
<p>forever
</p>
<p>begin
</p>
<p>statement_1
</p>
<p>statement_2
</p>
<p>:
</p>
<p>statement_n
</p>
<p>end
</p>
<p>Consider the following example of a forever loop that generates a clock signal (CLK) with a period of
</p>
<p>10 time units. In this example, the forever loop is embedded within an initial block. This allows the initial
</p>
<p>value of CLK to be set to zero upon the beginning of the simulation. Once the forever loop is entered, it
</p>
<p>will execute indefinitely. Notice that since there is only one statement after the forever keyword, a
</p>
<p>statement group (i.e., begin/end) is not needed.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>CLK &frac14; 0;
</p>
<p>forever
</p>
<p>#10 CLK &frac14; ~CLK;
</p>
<p>end
</p>
<p>8.2.5 while Loops
</p>
<p>A while loop provides a looping structure with a Boolean condition that controls its execution. The
</p>
<p>loop will only execute as long as the Boolean condition is evaluated true. The following is the syntax for a
</p>
<p>Verilog while loop.
</p>
<p>while (&lt;boolean_condition&gt;)
</p>
<p>begin
</p>
<p>statement_1
</p>
<p>statement_2
</p>
<p>:
</p>
<p>statement_n
</p>
<p>end
</p>
<p>Let&rsquo;s implement the previous example of a loop that generates a clock signal (CLK) with a period of
</p>
<p>10 time units as long as EN&frac14; 1. The TRUE Boolean condition for the while loop is EN&frac14; 1. When EN&frac14; 0,
</p>
<p>the while loop will be skipped. When the loop becomes inactive, CLK will hold its last assigned value.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>CLK &frac14; 0;
</p>
<p>while (EN &frac14;&frac14; 1)
</p>
<p>#10 CLK &frac14; ~CLK;
</p>
<p>end
</p>
<p>302 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2.6 repeat Loops
</p>
<p>A repeat loop provides a looping structure that will execute a fixed number of times. The following is
</p>
<p>the syntax for a Verilog repeat loop.
</p>
<p>repeat (&lt;number_of_loops&gt;)
</p>
<p>begin
</p>
<p>statement_1
</p>
<p>statement_2
</p>
<p>:
</p>
<p>statement_n
</p>
<p>end
</p>
<p>Let&rsquo;s implement the previous example of a loop that generates a clock signal (CLK) with a period of
</p>
<p>10 time units, except this time we&rsquo;ll use a repeat loop to only produce ten clock transitions, or five full
</p>
<p>periods of CLK.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>CLK &frac14; 0;
</p>
<p>repeat (10)
</p>
<p>#10 CLK &frac14; ~CLK;
</p>
<p>end
</p>
<p>8.2.7 for loops
</p>
<p>A for loop provides the ability to create a loop that can automatically update an internal variable. A
</p>
<p>loop variable within a for loop is altered each time through the loop according to a step assignment. The
</p>
<p>starting value of the loop variable is provided using an initial assignment. The loop will execute as long as
</p>
<p>a Boolean condition associated with the loop variable is TRUE. The following is the syntax for a Verilog
</p>
<p>for loop:
</p>
<p>for (&lt;initial_assignment&gt;; &lt;Boolean_condition&gt;; &lt;step_assignment&gt;)
</p>
<p>begin
</p>
<p>statement_1
</p>
<p>statement_2
</p>
<p>:
</p>
<p>statement_n
</p>
<p>end
</p>
<p>The following is an example of creating a simple counter using the loop variable. The loop variable
</p>
<p>i was declared as an integer prior to this block. The signal count is also of type integer. The loop variable
</p>
<p>will start at 0 and increment by 1 each time through the loop. The loop will execute as long as i &lt; 15 or
</p>
<p>16 times total. For loops allow the loop variable to be used in signal assignments within the block.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>for (i&frac14;0; i&lt;15; i&frac14;i+1)
</p>
<p>#10 Count &frac14; i;
</p>
<p>end
</p>
<p>8.2.8 disable
</p>
<p>Verilog provides the ability to stop a loop using the keyword disable. The disable function only works
</p>
<p>on named statement groups. The disable function is typically used after a certain fixed amount of time or
</p>
<p>within a conditional construct such as an if-else or case statement that is triggered by a control signal.
</p>
<p>8.2 Conditional Programming Constructs &bull; 303</p>
<p/>
</div>
<div class="page"><p/>
<p>Consider the following forever loop example that will generate a clock signal (CLK) but only when an
</p>
<p>enable (EN) is asserted. When EN &frac14; 0, the loop will disable, and the simulation will end.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>CLK &frac14; 0;
</p>
<p>forever
</p>
<p>begin: loop_ex
</p>
<p>if (EN &frac14;&frac14; 1)
</p>
<p>#10 CLK &frac14; ~CLK;
</p>
<p>else
</p>
<p>disable loop_ex; // The group name to be disabled comes after the keyword
</p>
<p>end
</p>
<p>end
</p>
<p>CONCEPT CHECK
</p>
<p>CC8.2 When using an if-else statement to model a combinational logic circuit, is using the else
clause the same as using don&rsquo;t careswhenminimizing a logic expression with a K-map?
</p>
<p>A) Yes. The else clause allows the synthesizer to assign whatever output values
are necessary in order to create the most minimal circuit.
</p>
<p>B) No. The else clause explicitly states the output values for all input codes not
listed in the if portion of the statement. This is the same as filling in the truth
table with specific values for all input codes covered by the else clause, and
the synthesizer will create the logic expression accordingly.
</p>
<p>8.3 System Tasks
</p>
<p>A system task in Verilog is one that is used to insert additional functionality into a model that is not
</p>
<p>associated with real circuitry. There are three main groups of system tasks in Verilog: (1) text output,
</p>
<p>(2) file input/output, and (3) simulation control. All system tasks begin with a $ and are only used during
</p>
<p>simulation. These tasks are ignored by synthesizers, so they can be included in real circuit models. All
</p>
<p>system tasks must reside within procedural blocks.
</p>
<p>8.3.1 Text Output
</p>
<p>Text output system tasks are used to print strings and variable values to the console or transcript of a
</p>
<p>simulation tool. The syntax follows ANSI C where double quotes (&ldquo;&rdquo;) are used to denote the text string to
</p>
<p>be printed. Standard text can be entered within the string in addition to variables. Variable can be printed
</p>
<p>in two ways. The first is to simply list the variable in the system task function outside of the double quotes.
</p>
<p>In this usage, the default format to be printed will be decimal unless a task is used with a different default
</p>
<p>format. The second way to print a variable is within a text string. In this usage, a unique code is inserted
</p>
<p>into the string indicating the format of how to print the value. After the string, a comma-separated list of
</p>
<p>the variable name(s) is listed that corresponds positionally to the codes within the string. The following
</p>
<p>are the most commonly used text output system tasks:
</p>
<p>304 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>Task Description
</p>
<p>$display() Print text string when statement is encountered and append a newline.
</p>
<p>$displayb() Same as $display, but default format of any arguments is binary.
</p>
<p>$displayo() Same as $display, but default format of any arguments is octal.
</p>
<p>$displayh() Same as $display, but default format of any arguments is hexadecimal.
</p>
<p>$write() Same as $display, but the string is printed without a newline.
</p>
<p>$writeb() Same as $write, but default format of any arguments is binary.
</p>
<p>$writeo() Same as $write, but default format of any arguments is octal.
</p>
<p>$writeh() Same as $write, but default format of any arguments is hexadecimal.
</p>
<p>$strobe() Same as $display, but printing occurs after all simulation events are executed.
</p>
<p>$strobeb() Same as $strobe, but default format of any arguments is binary.
</p>
<p>$strobeo() Same as $strobe, but default format of any arguments is octal.
</p>
<p>$strobeh() Same as $strobe, but default format of any arguments is hexadecimal.
</p>
<p>$monitor() Same as $display, but printing occurs when the value of an argument changes.
</p>
<p>$monitorb() Same as $monitor, but default format of any arguments is binary.
</p>
<p>$monitoro() Same as $monitor, but default format of any arguments is octal.
</p>
<p>$monitorh() Same as $monitor, but default format of any arguments is hexadecimal.
</p>
<p>$monitoron Begin tracking argument changes in subsequent $monitor tasks.
</p>
<p>$monitoroff Stop tracking argument changes in subsequent $monitor tasks.
</p>
<p>The following is a list of the most common text formatting codes for printing variables within a string.
</p>
<p>Code Format
</p>
<p>%b Binary values
</p>
<p>%o Octal values
</p>
<p>%d Decimal values
</p>
<p>%h Hexadecimal values
</p>
<p>%f Real values using decimal form
</p>
<p>%e Real values using exponential form
</p>
<p>%t Time values
</p>
<p>%s Character strings
</p>
<p>%m Hierarchical name of scope (no argument required when printing)
</p>
<p>%l Configuration library binding (no argument required when printing)
</p>
<p>The format letters in these codes are not case sensitive (i.e., %d and %D are equivalent). Each of
</p>
<p>these formatting codes can also contain information about truncation of leading and trailing digits.
</p>
<p>Rounding will take place when numbers are truncated. The formatting syntax is as follows:
</p>
<p>%&lt;number_of_leading_digits&gt;.&lt;number_of_trailing_digits&gt;&lt;format_code_letter&gt;
</p>
<p>There are also a set of string formatting and character escapes that are supported for use with the
</p>
<p>text output system tasks.
</p>
<p>Code Description
</p>
<p>\n Print a new line.
</p>
<p>\t Print a tab.
</p>
<p>\&rdquo; Print a quote (&ldquo;).
</p>
<p>\cr Print a backslash (\).
</p>
<p>%% Print a percent sign (%).
</p>
<p>The following is a set of examples using common text output system tasks. For these examples,
</p>
<p>assume two variables have been declared and initialized as follows: A &frac14; 3 (integer) and B &frac14; 45.6789
</p>
<p>(real). Recall that Verilog uses 32-bit codes to represent type integer and real.
</p>
<p>8.3 System Tasks &bull; 305</p>
<p/>
</div>
<div class="page"><p/>
<p>Example:
</p>
<p>$display("Hello World"); // Will print: Hello World
</p>
<p>$display("A&frac14; %b",A); //Thiswillprint:A&frac14; 00000000000000000000000000000011
</p>
<p>$display("A&frac14; %o", A); // This will print: A &frac14; 00000000003
</p>
<p>$display("A&frac14; %d", A); // This will print: A &frac14; 3
</p>
<p>$display("A&frac14; %h", A); // This will print: A &frac14; 00000003
</p>
<p>$display("A&frac14; %4.0b", A); // This will print: A &frac14; 0011
</p>
<p>$display("B &frac14; %f", B); // This will print: B &frac14; 45.678900
</p>
<p>$display("B &frac14; %2.0f", B); // This will print: B &frac14; 46
</p>
<p>$display("B &frac14; %2.1f", B); // This will print: B &frac14; 45.7
</p>
<p>$display("B &frac14; %2.2f", B); // This will print: B &frac14; 45.68
</p>
<p>$display("B &frac14; %e", B); // This will print: B &frac14; 4.567890e+001
</p>
<p>$display("B &frac14; %1.0e", B); // This will print: B &frac14; 5e+001
</p>
<p>$display("B &frac14; %1.1e", B); // This will print: B &frac14; 4.6e+001
</p>
<p>$display("B &frac14; %2.2e", B); // This will print: B &frac14; 4.57e+001
</p>
<p>$write("A is ", A, "\n"); // This will print: A is 3
</p>
<p>$writeb("Ais",A,"\n"); //Thiswillprint:Ais00000000000000000000000000000011
</p>
<p>$writeo("Ais ", A,"\n"); // Willprint: A is 00000000003
</p>
<p>$writeh("Ais ", A,"\n"); // Willprint: A is 00000003
</p>
<p>8.3.2 File Input/Output
</p>
<p>File I/O system tasks allow a Verilog module to create and/or access data files is the same way files
</p>
<p>are handled in ANSI C. This is useful when the results of a simulation are large and need to be stored in a
</p>
<p>file as opposed to viewing in a waveform or transcript window. This is also useful when complex stimulus
</p>
<p>vectors are to be read from an external file and driven into a device under test. Verilog supports the
</p>
<p>following file I/O system task functions:
</p>
<p>Task Description
</p>
<p>$fopen() Opens a file and returns a unique file descriptor.
</p>
<p>$fclose() Closes the file associated with the descriptor.
</p>
<p>$fdisplay() Same as $display but statements are directed to the file descriptor.
</p>
<p>$fwrite() Same as $write but statements are directed to the file descriptor.
</p>
<p>$fstrobe() Same as $strobe but statements are directed to the file descriptor.
</p>
<p>$fmonitor() Same as $monitor but statements are directed to the file descriptor.
</p>
<p>$readmemb() Read binary data from file and insert into previously defined memory array.
</p>
<p>$readmemh() Read hexadecimal data from file and insert into previously defined memory
array
</p>
<p>The $fopen() function will either create and open or open an existing file. Each file that is opened is
</p>
<p>given a unique integer called a file descriptor that is used to identify the file in other I/O functions. The
</p>
<p>integer must be declared prior to the first use of $fopen. A file name argument is required and provided
</p>
<p>within double quotes. By default, the file is opened for writing. If the file name doesn&rsquo;t exist, it will be
</p>
<p>created. If the file name does exist, it will be overwritten. An optional file_type can be provided that gives
</p>
<p>specific action for the file opening including opening an existing file and appending to a file. The following
</p>
<p>are the supported codes for $fopen():
</p>
<p>306 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>$fopen types Description
</p>
<p>&ldquo;r&rdquo; or &ldquo;rb&rdquo; Open file for reading.
</p>
<p>&ldquo;w&rdquo; or &ldquo;wb&rdquo; Create for writing.
</p>
<p>&ldquo;a&rdquo; or &ldquo;ab&rdquo; Open for writing and append to the end of file.
</p>
<p>&ldquo;r+&rdquo; or &ldquo;r + b&rdquo; or &ldquo;rb+&rdquo; Open for update, reading or writing file.
</p>
<p>&ldquo;w+&rdquo; or &ldquo;w + b&rdquo; or &ldquo;wb+&rdquo; Create for update.
</p>
<p>&ldquo;a+&rdquo; or &ldquo;a + b&rdquo; or &ldquo;ab+&rdquo; Open or create for update, append to the end of file.
</p>
<p>Once a file is open, data can be written to it using the $fdisplay(), $fwrite(), $fstrobe(), and
</p>
<p>$fmonitor() tasks. These functions require two arguments. The first argument is the file descriptor and
</p>
<p>the second is the information to be written. The information follows the same syntax as the I/O system
</p>
<p>tasks. The following example shows how to create a file and write data to it. This example will create a
</p>
<p>new file called &ldquo;Data_out.txt&rdquo; and write two lines of text to it with the values of variables A and B.
</p>
<p>Example:
</p>
<p>integer A &frac14; 3;
</p>
<p>real B &frac14; 45.6789;
</p>
<p>integer FILE_1;
</p>
<p>initial
</p>
<p>begin
</p>
<p>FILE_1 &frac14; $fopen("Data_out.txt", "w");
</p>
<p>$fdisplay(FILE_1, "A is %d", A);
</p>
<p>$fdisplay(FILE_1, "B is %f", B);
</p>
<p>$fclose(FILE_1);
</p>
<p>end
</p>
<p>When reading data from a file, the functions $readmemb() and $readmemh() can be used. These
</p>
<p>tasks require that a storage array be declared that the contents of the file can be read into. These tasks
</p>
<p>have two arguments, the first being the name of the file and the second being the name of the storage
</p>
<p>array to store the file contents into. The following example shows how to read the contents of a file into a
</p>
<p>storage array called &ldquo;memory.&rdquo; Assume the file contains eight lines, each containing a 3-bit vector. The
</p>
<p>vectors start at 000 and increment to 111, and each symbol will be interpreted as binary using the
</p>
<p>$readmemb() task. The storage array &ldquo;memory&rdquo; is declared to be an 8x3 array of type reg. The
</p>
<p>$readmemb() task will insert each line of the file into each 3-bit vector location within &ldquo;memory.&rdquo; To
</p>
<p>illustrate how the data is stored, this example also contains a second procedural block that will print the
</p>
<p>contents of the storage element to the transcript.
</p>
<p>Example:
</p>
<p>reg[2:0] memory[7:0];
</p>
<p>initial
</p>
<p>begin: Read_Block
</p>
<p>$readmemb("Data_in.txt", memory);
</p>
<p>end
</p>
<p>initial
</p>
<p>begin: Print_Block
</p>
<p>$display("printing memory %b", memory[0]); // This will print &ldquo;000&rdquo;
</p>
<p>$display("printing memory %b", memory[1]); // This will print &ldquo;001&rdquo;
</p>
<p>$display("printing memory %b", memory[2]); // This will print &ldquo;010&rdquo;
</p>
<p>$display("printing memory %b", memory[3]); // This will print &ldquo;011&rdquo;
</p>
<p>$display("printing memory %b", memory[4]); // This will print &ldquo;100&rdquo;
</p>
<p>$display("printing memory %b", memory[5]); // This will print &ldquo;101&rdquo;
</p>
<p>$display("printing memory %b", memory[6]); // This will print &ldquo;110&rdquo;
</p>
<p>$display("printing memory %b", memory[7]); // This will print &ldquo;111&rdquo;
</p>
<p>end
</p>
<p>8.3 System Tasks &bull; 307</p>
<p/>
</div>
<div class="page"><p/>
<p>8.3.3 Simulation Control and Monitoring
</p>
<p>Verilog also provides a set of simulation control and monitoring tasks. The following are the most
</p>
<p>commonly used tasks in this group.
</p>
<p>Task Description
</p>
<p>$finish() Finishes simulation and exits.
</p>
<p>$stop() Halts the simulation and enters an interactive debug mode.
</p>
<p>$time() Returns the current simulation time as a 64-bit vector.
</p>
<p>$stime() Returns the current simulation time as a 32-bit integer.
</p>
<p>$realtime() Returns the current simulation time as a 32-bit real number.
</p>
<p>$timeformat() Controls the format used by the %t code in print statements.
</p>
<p>The arguments are: (&lt;unit&gt;, &lt;precision&gt;, &lt;suffix&gt;, &lt;min_field_width&gt;)
</p>
<p>where:
</p>
<p>&lt;unit&gt; 0 &frac14; 1 s
</p>
<p>�1 &frac14; 100 ms
</p>
<p>�2 &frac14; 10 ms
</p>
<p>�3 &frac14; 1 ms
</p>
<p>�4 &frac14; 100 us
</p>
<p>�5 &frac14; 10 us
</p>
<p>�6 &frac14; 1 us
</p>
<p>�7 &frac14; 100 ns
</p>
<p>�8 &frac14; 10 ns
</p>
<p>�9 &frac14; 1 ns
</p>
<p>�10 &frac14; 100 ps
</p>
<p>�11 &frac14; 10 ps
</p>
<p>�12 &frac14; 1 ps
</p>
<p>�13 &frac14; 100 fs
</p>
<p>�14 &frac14; 10 fs
</p>
<p>�15 &frac14; 1 fs
</p>
<p>&lt;precision&gt; &frac14; The number of decimal points to display.
</p>
<p>&lt;suffix&gt; &frac14; A string to be appended to time to indicate units.
</p>
<p>&lt;min_field_width&gt; &frac14; The minimum number of characters to display.
</p>
<p>The following shows an example of how these tasks can be used.
</p>
<p>Example:
</p>
<p>initial
</p>
<p>begin
</p>
<p>$timeformat (-9, 2, "ns", 10);
</p>
<p>$display("Stimulus starting at time: %t", $time);
</p>
<p>#10 A_TB&frac14;0; B_TB&frac14;0; C_TB&frac14;0;
</p>
<p>#10 A_TB&frac14;0; B_TB&frac14;0; C_TB&frac14;1;
</p>
<p>#10 A_TB&frac14;0; B_TB&frac14;1; C_TB&frac14;0;
</p>
<p>#10 A_TB&frac14;0; B_TB&frac14;1; C_TB&frac14;1;
</p>
<p>#10 A_TB&frac14;1; B_TB&frac14;0; C_TB&frac14;0;
</p>
<p>#10 A_TB&frac14;1; B_TB&frac14;0; C_TB&frac14;1;
</p>
<p>#10 A_TB&frac14;1; B_TB&frac14;1; C_TB&frac14;0;
</p>
<p>#10 A_TB&frac14;1; B_TB&frac14;1; C_TB&frac14;1;
</p>
<p>$display("Simulation stopping at time: %t", $time);
</p>
<p>end
</p>
<p>308 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>This example will result in the following statements printed to the simulator transcript:
</p>
<p>Stimulus starting at time: 0.00ns
</p>
<p>Simulation stopping at time: 80.00ns
</p>
<p>CONCEPT CHECK
</p>
<p>CC8.3 How can Verilog system tasks be included in synthesizable circuit models when they
provide inherently unsynthesizable functionality?
</p>
<p>A) They can&rsquo;t. System tasks can only be used in test benches.
</p>
<p>B) The &ldquo;$&rdquo; symbol tells the CAD tool that the task can be ignored during synthesis.
</p>
<p>C) The designer must only use system tasks that model sequential logic.
</p>
<p>D) The designer must only use system tasks that model combinational logic.
</p>
<p>8.4 Test Benches
</p>
<p>The functional verification of Verilog designs is accomplished through simulation using a test bench.
</p>
<p>A test bench is a Verilog model that instantiates the system to be tested as a sub-system, generates the
</p>
<p>input patterns to drive into the sub-system, and observes the outputs. The system being tested is often
</p>
<p>called a device under test (DUT) or unit under test (UUT). Test benches are only used for simulation, so
</p>
<p>they can use abstract modeling techniques that are unsynthesizable to generate the stimulus patterns.
</p>
<p>Verilog conditional programming constructions and system tasks can also be used to report on the status
</p>
<p>of a test and also automatically check that the outputs are correct.
</p>
<p>8.4.1 Common Stimulus Generation Techniques
</p>
<p>When creating stimulus for combinational logic circuits, it is common to use a procedural block to
</p>
<p>generate all possible input patterns to drive the DUTand especially any transitions that may cause timing
</p>
<p>errors. Example 8.9 shows a test bench for a combinational logic circuit where an initial block contains a
</p>
<p>series of delayed assignments to provide the stimulus to the DUT. This block creates every possible input
</p>
<p>pattern, delayed by a fixed amount. Note that the initial block will only execute once. If the patterns were
</p>
<p>desired to repeat indefinitely, an always block without a sensitivity list could be used instead.
</p>
<p>8.4 Test Benches &bull; 309</p>
<p/>
</div>
<div class="page"><p/>
<p>Multiple procedural blocks can be used within a Verilog module to provide parallel functionality.
</p>
<p>Using both initial and always blocks allows the test bench to drive both repetitive and aperiodic signals.
</p>
<p>Initial and always blocks can also be used to drive the same signal in order to provide a starting value and
</p>
<p>a repetitive pattern. Example 8.10 shows a test bench for a rising edge triggered D-flip-flop with an
</p>
<p>asynchronous, active LOW reset in which multiple procedural blocks are used to generate the stimulus
</p>
<p>patterns for the DUT.
</p>
<p>Example 8.9
Test bench for a combinational logic circuit
</p>
<p>310 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>8.4.2 Printing Results to the Simulator Transcript
</p>
<p>In the past test bench examples, the input and output values are observed using either the
</p>
<p>waveform or listing tool within the simulator tool. It is also useful to print the values of the simulation to
</p>
<p>a transcript window to track the simulation as each statement is processed. Messages can be printed
</p>
<p>that show the status of the simulation in addition to the inputs and outputs of the DUT using the text
</p>
<p>output system tasks. Example 8.11 shows a test bench that prints the inputs and output to the transcript
</p>
<p>of the simulation tool. Note that the test bench must wait some amount of delay before evaluating the
</p>
<p>output, even if the DUT does not contain any delay.
</p>
<p>Example 8.10
Test bench for a sequential logic circuit
</p>
<p>8.4 Test Benches &bull; 311</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 8.11
Printing test bench results to the transcript
</p>
<p>312 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>8.4.3 Automatic Result Checking
</p>
<p>Test benches can also perform automated checking of the results using the conditional program-
</p>
<p>ming constructs described earlier in this chapter. Example 8.12 shows an example of a test bench that
</p>
<p>uses if-else statements to check the output of the DUTand print a PASS/FAIL message to the transcript.
</p>
<p>Example 8.12
Test bench with automatic output checking
</p>
<p>8.4 Test Benches &bull; 313</p>
<p/>
</div>
<div class="page"><p/>
<p>8.4.4 Using Loops to Generate Stimulus
</p>
<p>When creating stimulus that follow regular patterns such as counting, loops can be an effective way
</p>
<p>to produce the input vectors. A for loop is especially useful for generating exhaustive stimulus patterns
</p>
<p>for combinational logic circuits. An integer loop variable can increment within the for loop and then be
</p>
<p>assigned to the DUT inputs as type reg. Recall that in Verilog, when an integer is assigned to a variable of
</p>
<p>type reg, it is truncated to matched the size of the reg. This allows a binary count to be created for an
</p>
<p>input stimulus pattern by using an integer loop variable that increments within a for loop. Example 8.13
</p>
<p>shows how the stimulus for a combinational logic circuit can be produced with a for loop.
</p>
<p>314 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>8.4.5 Using External Files in Test Benches
</p>
<p>There are often cases where the results of a test bench need to be written to an external file, either
</p>
<p>because they are too verbose or because there needs to be a stored record. Verilog allows writing to
</p>
<p>external files via the file I/O system tasks (i.e., $fdisplay(), $fwrite(), $fstrong(), and $fmonitor()). Example
</p>
<p>8.14 shows a test bench in which the input vectors and the output of the DUTare written to an external file
</p>
<p>using the $fdisplay() system task.
</p>
<p>Example 8.13
Using a loop to generate stimulus in a test bench
</p>
<p>8.4 Test Benches &bull; 315</p>
<p/>
</div>
<div class="page"><p/>
<p>It is often the case that the input vectors are either too large to enter manually or were created by a
</p>
<p>separate program. In either case, a useful technique in test benches is to read input vectors from an
</p>
<p>external file. Example 8.15 shows an example where the input stimulus vectors for a DUTare read from
</p>
<p>an external file using the $readmemb() system task.
</p>
<p>Example 8.14
Printing test bench results to an external file
</p>
<p>316 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 8.15
Reading test bench stimulus vectors from an external file
</p>
<p>8.4 Test Benches &bull; 317</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC8.4 Could a test bench ever use always blocks and sensitivity lists exclusively to create its
stimulus? Why or why not?
</p>
<p>A) Yes. The signal assignments will simply be made when the block ends.
</p>
<p>B) No. Since a sensitivity list triggers when there is a change on one or more of
the signals listed, the blocks in the test bench would never trigger because
there is no method to make the initial signal transition.
</p>
<p>Summary
</p>
<p>v To model sequential logic, an HDL needs to
be able to trigger signal assignments based
on an event. This is accomplished in Verilog
using procedural assignment.
</p>
<p>v There are two types of procedural blocks in
Verilog, initial and always. An initial block
executes one time. An always block runs
continually.
</p>
<p>v A sensitivity list is a way to control when a
Verilog procedural block is triggered. A sen-
sitivity list contains a list of signals. If any of
the signals in the sensitivity list transitions, it
will cause the block to trigger. If a sensitivity
list is omitted, the block will trigger immedi-
ately. Sensitivity lists are most commonly
used with always blocks.
</p>
<p>v Sensitivity lists and always blocks are used
to model synthesizable logic. Initial blocks
are typically only used in test benches.
Always blocks are also used in test benches.
</p>
<p>v There are two types of signal assignments
that can be used within a procedural block,
blocking, and non-blocking.
</p>
<p>v A blocking assignment is denoted with the &frac14;
symbol. All blocking assignments are made
immediately within the procedural block.
Blocking assignments are used to model
combinational logic. Combinational logic
models list all input to the circuit in the
sensitivity list.
</p>
<p>v A non-blocking assignment is denoted with
the &lt;&frac14; symbol. All non-blocking assignments
are made when the procedural block ends
and are evaluated in the order they appeared
in the block. Blocking assignments are used
to model sequential logic. Sequential logic
models list only the clock and reset in the
sensitivity list.
</p>
<p>v Variables can be defined within a procedural
block as long as the block is named.
</p>
<p>v Procedural blocks allow more advanced
modeling constructs in Verilog. These
include if-else statements, case statements,
and loops.
</p>
<p>v Verilog provides numerous looping
constructs including forever, while, repeat,
and for. Loops can be terminated using the
disable keyword.
</p>
<p>v System tasks provide additional functionality
to Verilog models. Tasks begin with the $
symbol and are omitted from synthesis. Sys-
tem tasks can be included in synthesizable
logic models.
</p>
<p>v There are three groups of system tasks: text
output, file input/output, and simulation con-
trol and monitoring.
</p>
<p>v System tasks that perform printing functions
can output strings in addition to variable
values. Verilog provides a mechanism to
print the variable values in a variety of format.
</p>
<p>v A test bench is a way to simulate a device
under test (DUT) by instantiating it as a
sub-system, driving in stimulus, and observ-
ing the outputs. Test benches do not have
inputs or outputs and are unsynthesizable.
</p>
<p>v Test benches for combinational logic typically
exercise the DUT under an exhaustive set of
stimulus vectors. These include all possible
logic inputs in addition to critical transitions
that could cause timing errors.
</p>
<p>v Text I/O system tasks provide a way to print
the results of a test bench to the simulation
tool transcript.
</p>
<p>v File I/O system tasks provide a way to print
the results of a test bench to an external file
and also to read in stimulus vectors from an
external file.
</p>
<p>v Conditional programming constructs can be
used within a test bench to perform automatic
checking of the outputs of a DUT within a test
bench.
</p>
<p>318 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>v Loops can be used in test benches to auto-
matically generate stimulus patterns. A for
loop is a convenient technique to produce a
counting pattern.
</p>
<p>v Assignment from an integer to a reg in a for
loop is allowed. The binary value of the inte-
ger is truncated to fit the size of the reg
vector.
</p>
<p>Exercise Problems
</p>
<p>Section 8.1: Procedural Assignment
</p>
<p>8.1.1 When using a sensitivity list with a procedural
block, what will cause the block to trigger?
</p>
<p>8.1.2 When a sensitivity list is not used with a proce-
dural block, when will the block trigger?
</p>
<p>8.1.3 When are statements executed when using
blocking assignments?
</p>
<p>8.1.4 When are statements executed when using
non-blocking assignments?
</p>
<p>8.1.5 When is it possible to exclude statement
groups from a procedural block?
</p>
<p>8.1.6 What is the difference between a begin/end
and fork/join group when each contain multiple
statements?
</p>
<p>8.1.7 What is the difference between a begin/end
and fork/join group when each contain only a
single statement?
</p>
<p>8.1.8 What type of procedural assignment is used
when modeling combinational logic?
</p>
<p>8.1.9 What type of procedural assignment is used
when modeling sequential logic?
</p>
<p>8.1.10 What signals should be listed in the sensitivity
list when modeling combinational logic?
</p>
<p>8.1.11 What signals should be listed in the sensitivity
list when modeling sequential logic?
</p>
<p>Section 8.2: Conditional Programming
Constructs
</p>
<p>8.2.1 Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 8.1. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-
ducing F &frac14; 0 than producing F &frac14; 1. Can you
use this to your advantage to make your if-else
statement simpler?
</p>
<p>Fig. 8.1
System I functionality
</p>
<p>8.2.2 Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 8.1. Use procedural assignment and a
case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
</p>
<p>8.2.3 Design a Verilog model to implement the
behavior described by the 4-input minterm list
in Fig. 8.2. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
</p>
<p>Fig. 8.2
System J functionality
</p>
<p>Exercise Problems &bull; 319</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2.4 Design a Verilog model to implement the
behavior described by the 4-input minterm list
in Fig. 8.2. Use procedural assignment and a
case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
</p>
<p>8.2.5 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list in Fig. 8.3. Use procedural assignment
and an if-then statement. Declare the module
to match the block diagram provided. Use the
type wire for the inputs and type reg for the
output.
</p>
<p>Fig. 8.3
System K functionality
</p>
<p>8.2.6 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list in Fig. 8.3. Use procedural assignment
and a case statement. Declare the module to
match the block diagram provided. Use the
type wire for the inputs and type reg for the
output.
</p>
<p>8.2.7 Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 8.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-
ducing F &frac14; 1 than producing F &frac14; 0. Can you
use this to your advantage to make your if-else
statement simpler?
</p>
<p>Fig. 8.4
System L functionality
</p>
<p>8.2.8 Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 8.4. Use procedural assignment and a
case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.
</p>
<p>8.2.9 Figure 8.5 shows the topology of a 4-bit shift
register when implemented structurally using
D-Flip-Flops. Design a Verilog model to
describe this functionality using a single proce-
dural block and non-blocking assignments
instead of instantiating D-Flip-Flops. The figure
also provides the block diagram for the module
port definition. Use the type wire for the inputs
and type reg for the outputs.
</p>
<p>Fig. 8.5
4-bit shift register functionality
</p>
<p>8.2.10 Design a Verilog model for a counter using a
for loop with an output type of integer. Fig-
ure 8.6 shows the block diagram for the mod-
ule definition. The counter should increment
from 0 to 31 and then start over. Use delay in
your loop to update the counter value every
10 ns. Consider using the loop variable of the
for loop to generate your counter value.
</p>
<p>Fig. 8.6
Integer counter block diagram
</p>
<p>8.2.11 Design a Verilog model for a counter using a
for loop with an output type of reg[4:0]. Fig-
ure 8.7 shows the block diagram for the mod-
ule definition. The counter should increment
from 000002 to 111112 and then start over.
Use delay in your loop to update the counter
value every 10 ns. Consider using the loop
variable of the for loop to generate an integer
version of your count value and then assign it
to the output variable of type reg[4:0].
</p>
<p>320 &bull; Chapter 8: Verilog (Part 2)</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 8.7
5-Bit binary counter block diagram
</p>
<p>Section 8.3: System Tasks
</p>
<p>8.3.1 Are system tasks synthesizable? Why or why
not?
</p>
<p>8.3.2 What is the difference between the tasks $dis-
play() and $write()?
</p>
<p>8.3.3 What is the difference between the tasks $dis-
play() and $monitor()?
</p>
<p>8.3.4 What is the data type returned by the task
$fopen()?
</p>
<p>Section 8.4: Test Benches
</p>
<p>8.4.1 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.1. Your
test bench should drive in every possible input
code for the vector ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;,
&ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;). Have your test bench
change the input pattern every 10 ns using
delay within your procedural block.
</p>
<p>8.4.2 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.1 with
automatic checking. Your test bench should
drive in every possible input code for the vector
ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;, &ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;).
Have your test bench change the input pattern
every 10 ns using delay within your procedural
block. Use conditional statements to check
whether the output of the DUT is correct. For
each input vector, print a message using $dis-
play() that indicates the current input vector
being tested, the resulting output of your DUT,
and whether the DUToutput is correct.
</p>
<p>8.4.3 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.2. Your
test bench should drive in every possible input
code for the vector ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;,
&ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;). Have your test bench
change the input pattern every 10 ns using
delay within your procedural block.
</p>
<p>8.4.4 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.2 with
automatic checking. Your test bench should
drive in every possible input code for the vector
ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;, &ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;).
Have your test bench change the input pattern
every 10 ns using delay within your procedural
block. Use conditional statements to check
whether the output of the DUT is correct. For
each input vector, print a message using $dis-
play() that indicates the current input vector
being tested, the resulting output of your DUT,
and whether the DUToutput is correct.
</p>
<p>8.4.5 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.3. Your
test bench should drive in every possible input
code for the vector ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;,
&ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;). Have your test bench
change the input pattern every 10 ns using
delay within your procedural block.
</p>
<p>8.4.6 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.3 with
automatic checking. Your test bench should
drive in every possible input code for the vector
ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;, &ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;).
Have your test bench change the input pattern
every 10 ns using delay within your procedural
block. Use conditional statements to check
whether the output of the DUT is correct. For
each input vector, print a message using $dis-
play() that indicates the current input vector
being tested, the resulting output of your DUT,
and whether the DUToutput is correct.
</p>
<p>8.4.7 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.4. Your
test bench should drive in every possible input
code for the vector ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;,
&ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;). Have your test bench
change the input pattern every 10 ns using
delay within your procedural block.
</p>
<p>8.4.8 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.4 with
automatic checking. Your test bench should
drive in every possible input code for the vector
ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;, &ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;).
Have your test bench change the input pattern
every 10 ns using delay within your procedural
block. Use conditional statements to check
whether the output of the DUT is correct. For
each input vector, print a message using $dis-
play() that indicates the current input vector
being tested, the resulting output of your DUT,
and whether the DUToutput is correct.
</p>
<p>8.4.9 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 8.4. Your
test bench should drive in every possible input
code for the vector ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;,
&ldquo;0010&rdquo;, . . ., &ldquo;1111&rdquo;). Have your test bench
change the input pattern every 10 ns using
delay within your procedural block. Print the
results to an external file named
&ldquo;output_vectors.txt&rdquo; using $fdisplay().
</p>
<p>8.4.10 Design a Verilog test bench that reads in test
vectors from an external file to verify the func-
tional operation of the system in Fig. 8.4. Cre-
ate an input text file called &ldquo;input_vectors.txt&rdquo;
that contains each input code for the vector
ABCD (i.e., &ldquo;0000&rdquo;, &ldquo;0001&rdquo;, &ldquo;0010&rdquo;, . . .,
&ldquo;1111&rdquo;), each on a separate line in the file.
Your test bench should read in the vectors
using $readmemb(), drive each code into the
DUT, and print the results to the transcript
using $display().
</p>
<p>Exercise Problems &bull; 321</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 9: Behavioral Modeling
</p>
<p>of Sequential Logic
In this chapter, we will look at modeling sequential logic using the more sophisticated behavioral
</p>
<p>modeling techniques presented in Chap. 8. We will begin by looking at modeling sequential storage
</p>
<p>devices. Next, we will look at the behavioral modeling of finite-state machines. Finally, we will look at
</p>
<p>register transfer level, or RTL modeling. The goal of this chapter is to provide an understanding of how
</p>
<p>hardware description languages can be used to create behavioral models of synchronous digital
</p>
<p>systems.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>9.1 Design a Verilog behavioral model for a sequential logic storage device.
9.2 Describe the process for creating a Verilog behavioral model for a finite-state machine.
9.3 Design a Verilog behavioral model for a finite-state machine.
9.4 Design a Verilog behavioral model for a counter.
9.5 Design a Verilog register transfer level (RTL) model of a synchronous digital system.
</p>
<p>9.1 Modeling Sequential Storage Devices in Verilog
</p>
<p>9.1.1 D-Latch
</p>
<p>Let&rsquo;s begin with the model of a simple D-Latch. Since the outputs of this sequential storage device
</p>
<p>are not updated continuously, its behavior is modeled using a procedural assignment. Since we want to
</p>
<p>create a synthesizable model of sequential logic, non-blocking assignments are used. In the sensitivity
</p>
<p>list, we need to include the C input since it controls when the D-Latch is in track or store mode. We also
</p>
<p>need to include the D input in the sensitivity list because during the track mode, the output Q will be
</p>
<p>assigned the value of D, so any change on D needs to trigger the procedural assignments. The use of an
</p>
<p>if-else statement is used to model the behavior during track mode (C &frac14; 1). Since the behavior is not
</p>
<p>explicitly stated for when C &frac14; 0, the outputs will hold their last value, which allows us to simply omit the
</p>
<p>else portion of the if statement to complete the model. Example 9.1 shows the behavioral model for a
</p>
<p>D-Latch.
</p>
<p>Example 9.1
Behavioral model of a D-latch in verilog
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_9
</p>
<p>323</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_9&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_9&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>9.1.2 D-Flip-Flop
</p>
<p>The rising edge behavior of a D-flip-flop is modeled using a (posedge Clock) Boolean condition in
</p>
<p>the sensitivity list of a procedural block. Example 9.2 shows the behavioral model for a rising edge-
</p>
<p>triggered D-flip-flop with both Q and Qn outputs.
</p>
<p>9.1.3 D-Flip-Flop with Asynchronous Reset
</p>
<p>D-flip-flops typically have a reset line to initialize their outputs to known states (e.g., Q &frac14; 0, Qn &frac14; 1).
</p>
<p>Resets are asynchronous, meaning whenever they are asserted, assignments to the outputs take place
</p>
<p>immediately. If a reset was synchronous, the outputs would only update on the next rising edge of the
</p>
<p>clock. This behavior is undesirable because if there is a system failure, there is no guarantee that a clock
</p>
<p>edge will ever occur. Thus, the reset may never take place. Asynchronous resets are more desirable not
</p>
<p>only to put the D-flip-flops into a known state at start-up, but also to recover from a system failure that
</p>
<p>may have impacted the clock signal. In order to model this asynchronous behavior, the reset signal is
</p>
<p>included in the sensitivity list. This allows both clock and the reset transitions to trigger the procedural
</p>
<p>block. The edge sensitivity of the reset can be specified using posedge (active HIGH) or negedge (active
</p>
<p>LOW). Within the block an if-else statement is used to determine whether the reset has been asserted or
</p>
<p>a rising edge of the clock has occurred. The if-else statement first checks whether the reset input has
</p>
<p>been asserted since it has the highest priority. If it has, it makes the appropriate assignments to the
</p>
<p>outputs (Q &frac14; 0, Qn &frac14; 1). If the reset has not been asserted, the else clause is executed, which
</p>
<p>corresponds to a rising edge of clock (Q &lt;&frac14; D, Qn &lt;&frac14; ~D). No other assignments are listed in the
</p>
<p>block; thus, the outputs are only updated on a transition of the reset or clock. At all other times, the
</p>
<p>outputs remain at their current value, thus modeling the store behavior of the D-flip-flop. Example 9.3
</p>
<p>shows the behavioral model for a rising edge-triggered D-flip-flop with an asynchronous, active LOW
</p>
<p>reset.
</p>
<p>Example 9.2
Behavioral model of a D-flip-flop in verilog
</p>
<p>324 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>9.1.4 D-Flip-Flop with Asynchronous Reset and Preset
</p>
<p>A D-flip-flop with both an asynchronous reset and asynchronous preset is handled in a similar
</p>
<p>manner as the D-flip-flop in the prior section. The preset input is included in the sensitivity list in order to
</p>
<p>trigger the block whenever a transition occurs on either the clock, reset, or preset inputs. The edge
</p>
<p>sensitivity keywords are used to dictated whether the preset is active HIGH or LOW. Nested if-else
</p>
<p>statements are used to first check whether a reset has occurred; then whether a preset has occurred;
</p>
<p>and finally, whether a rising edge of the clock has occurred. Example 9.4 shows the model for a rising
</p>
<p>edge-triggered D-flip-flop with asynchronous, active LOW reset and preset.
</p>
<p>Example 9.3
Behavioral model of a D-flip-flop with asynchronous reset in verilog
</p>
<p>9.1 Modeling Sequential Storage Devices in Verilog &bull; 325</p>
<p/>
</div>
<div class="page"><p/>
<p>9.1.5 D-Flip-Flop with Synchronous Enable
</p>
<p>An enable input is also a common feature of modern D-flip-flops. Enable inputs are synchronous,
</p>
<p>meaning that when they are asserted, action is only taken on the rising edge of the clock. This means
</p>
<p>that the enable input is not included in the sensitivity list of the always block. Since enable is only
</p>
<p>considered when there is a rising edge of the clock, the logic for the enable is handled in a nested if-else
</p>
<p>statement that is included in the section that models the behavior for when a rising edge of clock is
</p>
<p>detected. Example 9.5 shows the model for a D-flip-flop with a synchronous enable (EN) input. When
</p>
<p>EN&frac14; 1, the D-flip-flop is enabled, and assignments are made to the outputs only on the rising edge of the
</p>
<p>clock. When EN &frac14; 0, the D-flip-flop is disabled and assignments to the outputs are not made. When
</p>
<p>disabled, the D-flip-flop effectively ignores rising edges on the clock and the outputs remain at their last
</p>
<p>values.
</p>
<p>Example 9.4
Behavioral model of a D-flip-flop with asynchronous reset and preset in verilog
</p>
<p>326 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC9.1 Why is the D input not listed in the sensitivity list of a D-flip-flop?
</p>
<p>A) To simplify the behavioral model.
</p>
<p>B) To avoid a setup time violation if D transitions too closely to the clock.
</p>
<p>C) Because a rising edge of clock is needed to make the assignment.
</p>
<p>D) Because the outputs of the D-flip-flop are not updated when D changes.
</p>
<p>9.2 Modeling Finite-State Machines in Verilog
</p>
<p>Finite-state machines can be easily modeled using the behavioral constructs from Chap. 8. The
</p>
<p>most common modeling practice for FSMs is to declare two signals of type reg that are called
</p>
<p>current_state and next_state. Then a parameter is declared for each descriptive state name in the
</p>
<p>state diagram. A parameter also requires a value, so the state encoding can be accomplished during the
</p>
<p>parameter declaration. Once the signals and parameters are created, all of the procedural assignments
</p>
<p>Example 9.5
Behavioral model of a D-flip-flop with synchronous enable in verilog
</p>
<p>9.2 Modeling Finite-State Machines in Verilog &bull; 327</p>
<p/>
</div>
<div class="page"><p/>
<p>in the state machine model can use the descriptive state names in their signal assignments. Within the
</p>
<p>Verilog state machine model, three separate procedural blocks are used to describe each of the
</p>
<p>functional blocks, state memory, next state logic, and output logic. In order to examine how to model a
</p>
<p>finite-state machine using this approach, let&rsquo;s use the push-button window controller example from
</p>
<p>Chap. 7. Example 9.6 gives the overview of the design objectives for this example and the state diagram
</p>
<p>describing the behavior to be modeled in Verilog.
</p>
<p>Let&rsquo;s begin by defining the ports of the module. The system has an input called Press and two
</p>
<p>outputs called Open_CW and Close_CCW. The system also has clock and reset inputs. We will design
</p>
<p>the system to update on the rising edge of the clock and have an asynchronous, active LOW, reset.
</p>
<p>Example 9.7 shows the port definitions for this example. Note that outputs are declared as type reg, while
</p>
<p>inputs are declared as type wire.
</p>
<p>Example 9.6
Push-button window controller in verilog: design description
</p>
<p>Example 9.7
Push-button window controller in verilog: port definition
</p>
<p>328 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>9.2.1 Modeling the States
</p>
<p>Now we begin designing the finite-state machine in Verilog using behavioral modeling constructs.
</p>
<p>The first step is to create two signals that will be used for the state variables. In this text we will always
</p>
<p>name these signals current_state and next_state. The signal current_state will represent the outputs of
</p>
<p>the D-flip-flops forming the state memory and will hold the current state code. The signal next_state will
</p>
<p>represent the D inputs to the D-flip-flops forming the state memory and will receive the value from the
</p>
<p>next state logic circuitry. Since the FSM will be modeled using procedural assignment, both of these
</p>
<p>signals will be declared of type reg. The width of the reg vector depends on the number of states in the
</p>
<p>machine and the encoding technique chosen. The next step is to declare parameters for each of the
</p>
<p>descriptive state names in the state diagram. The state encoding must be decided at this point. The
</p>
<p>following syntax shows how to declare the current_state and next_state signals and the parameters.
</p>
<p>Note that since this machine only has two states, the width of these signals is only 1-bit.
</p>
<p>reg current_state, next_state;
</p>
<p>parameter w_closed &frac14; 1&rsquo;b0,
</p>
<p>w_open &frac14; 1&rsquo;b1;
</p>
<p>9.2.2 The State Memory Block
</p>
<p>Now that we have variables and parameters for the states of the FSM, we can create the model for
</p>
<p>the state memory. State memory is modeled using its own procedural block. This block models the
</p>
<p>behavior of the D-flip-flops in the FSM that are holding the current state on their Q outputs. Each time
</p>
<p>there is a rising edge of the clock, the current state is updated with the next state value present on the D
</p>
<p>inputs of the D-flip-flops. This block must also model the reset condition. For this example, we will have
</p>
<p>the state machine go to the w_closed state when Reset is asserted. At all other times, the block will
</p>
<p>simply update current_state with next_state on every rising edge of the clock. The block model is very
</p>
<p>similar to the model of a D-flip-flop. This is as expected since this block will synthesize into one or more
</p>
<p>D-flip-flops to hold the current state. The sensitivity list contains only Clock and Reset and assignments
</p>
<p>are only made to the signal current_state. The following syntax shows how to model the state memory of
</p>
<p>this FSM example.
</p>
<p>always @ (posedge Clock or negedge Reset)
</p>
<p>begin: STATE_MEMORY
</p>
<p>if (!Reset)
</p>
<p>current_state &lt;&frac14; w_closed;
</p>
<p>else
</p>
<p>current_state &lt;&frac14; next_state;
</p>
<p>end
</p>
<p>9.2.3 The Next State Logic Block
</p>
<p>Now we model the next state logic of the FSM using a second procedural block. Recall that the next
</p>
<p>state logic is combinational logic; thus, we need to include all of the input signals that the circuit considers
</p>
<p>in the next state calculation in the sensitivity list. The current_state signal will always be included in the
</p>
<p>sensitivity list of the next state logic block in addition to any inputs to the system. For this example, the
</p>
<p>system has one other input called Press. This block makes assignments to the next_state signal. It is
</p>
<p>common to use a case statement to separate out the assignments that occur at each state. At each state
</p>
<p>within the case statement, an if-else statement is used to model the assignments for different input
</p>
<p>conditions on Press. The following syntax shows how to model the next state logic of this FSM example.
</p>
<p>Notice that we include a default clause in the case statement to ensure that the state machine has a path
</p>
<p>back to the reset state in the case of an unexpected fault.
</p>
<p>9.2 Modeling Finite-State Machines in Verilog &bull; 329</p>
<p/>
</div>
<div class="page"><p/>
<p>always @ (current_state or Press)
</p>
<p>begin: NEXT_STATE_LOGIC
</p>
<p>case (current_state)
</p>
<p>w_closed:if(Press&frac14;&frac14; 1&rsquo;b1)next_state&frac14; w_open; elsenext_state&frac14; w_closed;
</p>
<p>w_open : if (Press&frac14;&frac14; 1&rsquo;b1) next_state&frac14; w_closed; else next_state&frac14; w_open;
</p>
<p>default : next_state&frac14; w_closed;
</p>
<p>endcase
</p>
<p>end
</p>
<p>9.2.4 The Output Logic Block
</p>
<p>Now we model the output logic of the FSM using a third procedural block. Recall that output logic is
</p>
<p>combinational logic; thus, we need to include all of the input signals that this circuit considers in the
</p>
<p>output assignments. The current_state will always be included in the sensitivity list. If the FSM is a Mealy
</p>
<p>machine, then the system inputs will also be included in the sensitivity list. If the machine is a Moore
</p>
<p>machine, then only the current_state will be present in the sensitivity list. For this example, the FSM is a
</p>
<p>Mealy machine, so the input Press needs to be included in the sensitivity list. Note that this block only
</p>
<p>makes assignments to the outputs of the machine (Open_CW and Close_CCW). The following syntax
</p>
<p>shows how to model the output logic of this FSM example. Again, we include a default clause to ensure
</p>
<p>that the state machine has explicit output behavior in the case of a fault.
</p>
<p>always @ (current_state or Press)
</p>
<p>begin: OUTPUT_LOGIC
</p>
<p>case (current_state)
</p>
<p>w_closed : if (Press &frac14;&frac14; 1&rsquo;b1)
</p>
<p>begin
</p>
<p>Open_CW &frac14; 1&rsquo;b1;
</p>
<p>Close_CCW &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>else
</p>
<p>begin
</p>
<p>Open_CW &frac14; 1&rsquo;b0;
</p>
<p>Close_CCW &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>w_open : if (Press &frac14;&frac14; 1&rsquo;b1)
</p>
<p>begin
</p>
<p>Open_CW &frac14; 1&rsquo;b0;
</p>
<p>Close_CCW &frac14; 1&rsquo;b1;
</p>
<p>end
</p>
<p>else
</p>
<p>begin
</p>
<p>Open_CW &frac14; 1&rsquo;b0;
</p>
<p>Close_CCW &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>default : begin
</p>
<p>Open_CW &frac14; 1&rsquo;b0;
</p>
<p>Close_CCW &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>endcase
</p>
<p>end
</p>
<p>Putting this all together yields a behavioral model for the FSM that can be simulated and
</p>
<p>synthesized. Example 9.8 shows the entire model for this example.
</p>
<p>330 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.8
Push-button window controller in verilog: full model
</p>
<p>9.2 Modeling Finite-State Machines in Verilog &bull; 331</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.9 shows the simulation waveform for this state machine. This functional simulation was
</p>
<p>performed using ModelSim-Altera Starter Edition 10.1d. A macro file was used to display the current and
</p>
<p>next state variables using their parameter names instead of their state codes. This allows the functional-
</p>
<p>ity of the FSM to be more easily observed. This approach will be used for the rest of the FSM examples in
</p>
<p>this book.
</p>
<p>9.2.5 Changing the State Encoding Approach
</p>
<p>In the prior example, we only had two states and they were encoded as w_closed &frac14; 1&rsquo;b0;
</p>
<p>w_open_1&rsquo;b1. This encoding technique is considered binary; however, a gray code approach would
</p>
<p>yield the same codes since the width of the variables were only one bit. The way that state variables and
</p>
<p>state codes are assigned in Verilog makes is straightforward to change the state codes. The only
</p>
<p>consideration that must be made is expanding the size of the current_state and next_state variables
</p>
<p>to accommodate the new state codes. The following example shows how the state encoding would look
</p>
<p>if a one-hot approach was used (w_closed &frac14; 2&rsquo;b01; w_open_2&rsquo;b10). Note that the state variables now
</p>
<p>must be two bits wide. This means the state variables need to be declared as type reg[1:0]. Example 9.10
</p>
<p>shows the resulting simulation waveforms. The simulation waveform shows the value of the state codes
</p>
<p>instead of the state names.
</p>
<p>reg [1:0] current_state, next_state;
</p>
<p>parameter w_closed &frac14; 2&rsquo;b01,
</p>
<p>w_open &frac14; 2&rsquo;b10;
</p>
<p>Example 9.9
Push-button window controller in verilog: simulation waveform
</p>
<p>332 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC9.2 Why is it always a good design approach to model a generic finite-state machine using
three processes?
</p>
<p>A) For readability.
</p>
<p>B) So that it is easy to identify whether the machine is a Mealy or Moore.
</p>
<p>C) So that the state memory process can be reused in other FSMs.
</p>
<p>D) Because each of the three sub-systems of a FSM has unique inputs and
outputs that should be handled using dedicated processes.
</p>
<p>9.3 FSM Design Examples in Verilog
</p>
<p>This section presents a set of example finite-state machine designs using the behavioral modeling
</p>
<p>constructs of Verilog. These examples are the same state machines that were presented in Chap. 7.
</p>
<p>9.3.1 Serial Bit Sequence Detector in Verilog
</p>
<p>Let&rsquo;s look at the design of the serial bit sequence detector finite-state machine from Chap. 7 using
</p>
<p>the behavioral modeling constructs of Verilog. Example 9.11 shows the design description and port
</p>
<p>definition for this state machine.
</p>
<p>Example 9.10
Push-button window controller in verilog: changing state codes
</p>
<p>9.3 FSM Design Examples in Verilog &bull; 333</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.12 shows the full model for the serial bit sequence detector. Notice that the states are
</p>
<p>encoded in binary, which requires three bits for the variables current_state and next_state.
</p>
<p>Example 9.11
Serial bit sequence detector in verilog: design description and port definition
</p>
<p>334 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.13 shows the functional simulation waveform for this design.
</p>
<p>Example 9.12
Serial bit sequence detector in verilog: full model
</p>
<p>9.3 FSM Design Examples in Verilog &bull; 335</p>
<p/>
</div>
<div class="page"><p/>
<p>9.3.2 Vending Machine Controller in Verilog
</p>
<p>Let&rsquo;s now look at the design of the vending machine controller from Chap. 7 using the behavioral
</p>
<p>modeling constructs of Verilog. Example 9.14 shows the design description and port definition.
</p>
<p>Example 9.15 shows the full model for the vending machine controller. In this model, the descriptive
</p>
<p>state names Wait, 25&cent;, and 50&cent; cannot be used directly. This is because Verilog user-defined names
</p>
<p>cannot begin with a number. Instead, the letter &ldquo;s&rdquo; is placed in front of the state names in order to make
</p>
<p>them legal Verilog names (i.e., sWait, s25, s50).
</p>
<p>Example 9.13
Serial bit sequence detector in verilog: simulation waveform
</p>
<p>Example 9.14
Vending machine controller in verilog: design description and port definition
</p>
<p>336 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.16 shows the resulting simulation waveform for this design.
</p>
<p>Example 9.15
Vending machine controller in verilog: full model
</p>
<p>9.3 FSM Design Examples in Verilog &bull; 337</p>
<p/>
</div>
<div class="page"><p/>
<p>9.3.3 2-Bit, Binary Up/Down Counter in Verilog
</p>
<p>Let&rsquo;s now look at how a simple counter can be implemented using the three-block behavioral
</p>
<p>modeling approach in Verilog. Example 9.17 shows the design description and port definition for the
</p>
<p>2-bit, binary up/down counter FSM from Chap. 7.
</p>
<p>Example 9.18 shows the full model for the 2-bit up/down counter using the three-block modeling
</p>
<p>approach. Since a counter&rsquo;s outputs only depend on the current state, counters are Moore machines.
</p>
<p>This simplifies the output logic block since it only needs to contain the current state in its sensitivity list.
</p>
<p>Example 9.16
Vending machine controller in verilog: simulation waveform
</p>
<p>Example 9.17
2-bit up/down counter in verilog: design description and port definition
</p>
<p>338 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.19 shows the resulting simulation waveform for this counter finite-state machine.
</p>
<p>Example 9.18
2-bit up/down counter in verilog: full model (three-block approach)
</p>
<p>Example 9.19
2-bit up/down counter in verilog: simulation waveform
</p>
<p>9.3 FSM Design Examples in Verilog &bull; 339</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC9.3 The procedural block for the state memory is nearly identical for all finite-state machines
with one exception. What is it?
</p>
<p>A) The sensitivity list may need to include a preset signal.
</p>
<p>B) Sometimes it is modeled using an SR latch storage approach instead of with
D-flip-flop behavior.
</p>
<p>C) The name of the reset state will be different.
</p>
<p>D) The current_state and next_state signals are often swapped.
</p>
<p>9.4 Modeling Counters in Verilog
</p>
<p>Counters are a special case of finite-state machines because they move linearly through their
</p>
<p>discrete states (either forward or backward) and typically are implemented with state-encoded outputs.
</p>
<p>Due to this simplified structure and widespread use in digital systems, Verilog allows counters to be
</p>
<p>modeled using a single-procedural block with arithmetic operators (i.e., + and �). This enables a more
</p>
<p>compact model and allows much wider counters to be implemented in a practical manner.
</p>
<p>9.4.1 Counters in Verilog Using a Single-Procedural Block
</p>
<p>Let&rsquo;s look at how we can model a 4-bit, binary up counter with an output called CNT. We want to
</p>
<p>model this counter using the &ldquo;+&rdquo; operator to avoid having to explicitly define a state code for each state as
</p>
<p>in the three-block modeling approach to FSMs. The &ldquo;+&rdquo; operator works on the type reg, so the counting
</p>
<p>behavior can simply be modeled using CNT &lt;&frac14; CNT + 1. The procedural block also needs to handle the
</p>
<p>reset condition. Both the Clock and Reset signals are listed in the sensitivity list. Within the block, an
</p>
<p>if-else statement is used to handle both the reset and increment behaviors. Example 9.20 shows the
</p>
<p>Verilog model and simulation waveform for this counter. When the counter reaches its maximum value of
</p>
<p>&ldquo;1111,&rdquo; it rolls over to &ldquo;0000&rdquo; and continues counting because it is declared to only contain 4-bits.
</p>
<p>340 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>9.4.2 Counters with Range Checking
</p>
<p>When a counter needs to have a maximum range that is different from the maximum binary value of
</p>
<p>the count vector (i.e., &lt;2n-1), then the procedural block needs to contain range checking logic. This can
</p>
<p>be modeled by inserting a nested if-else statement beneath of the else clause that handles the behavior
</p>
<p>for when the counter receives a rising clock edge. This nested if-else first checks whether the count has
</p>
<p>reached its maximum value. If it has, it is reset back to it minimum value. If it hasn&rsquo;t, the counter is
</p>
<p>incremented as usual. Example 9.21 shows the Verilog model and simulation waveform for a counter
</p>
<p>with a minimum count value of 010 and amaximum count value of 1010. This counter still requires 4-bits to
</p>
<p>be able to encode 1010.
</p>
<p>Example 9.20
Binary counter using a single-procedural block in verilog
</p>
<p>9.4 Modeling Counters in Verilog &bull; 341</p>
<p/>
</div>
<div class="page"><p/>
<p>9.4.3 Counters with Enables in Verilog
</p>
<p>Including an enable in a counter is a common technique to prevent the counter from running
</p>
<p>continuously. When the enable is asserted, the counter will increment on the rising edge of the clock
</p>
<p>as usual. When the enable is de-asserted, the counter will simply hold its last value. Enable lines are
</p>
<p>synchronous, meaning that they are only evaluated on the rising edge of the clock. As such, they are
</p>
<p>modeled using a nested if-else statement within the main if-else statement checking for a rising edge of
</p>
<p>the clock. Example 9.22 shows an example model for a 4-bit counter with enable.
</p>
<p>Example 9.21
Binary counter with range checking in verilog
</p>
<p>342 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>9.4.4 Counters with Loads
</p>
<p>A counter with a load has the ability to set the counter to a specified value. The specified value is
</p>
<p>provided on an input port (i.e., CNT_in) with the same width as the counter output (CNT). A synchronous
</p>
<p>load input signal (i.e., Load) is used to indicate when the counter should set its value to the value present
</p>
<p>on CNT_in. Example 9.23 shows an example model for a 4-bit counter with load capability.
</p>
<p>Example 9.22
Binary counter with enable in verilog
</p>
<p>9.4 Modeling Counters in Verilog &bull; 343</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC9.4 If a counter is modeled using only one procedural block in Verilog, is it still a finite-state
machine? Why or why not?
</p>
<p>A) Yes. It is just a special case of a FSM that can easily be modeled using one
block. Synthesizers will recognize the single block model as a FSM.
</p>
<p>B) No. Using only one block will synthesize into combinational logic. Without the
ability to store a state, it is not a finite-state machine.
</p>
<p>9.5 RTL Modeling
</p>
<p>Register transfer level modeling refers to a level of design abstraction in which vector data is moved
</p>
<p>and operated on in a synchronous manner. This design methodology is widely used in data path
</p>
<p>modeling and computer system design.
</p>
<p>Example 9.23
Binary counter with load in verilog
</p>
<p>344 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>9.5.1 Modeling Registers in Verilog
</p>
<p>The term register describes a group of D-Flip-Flops running off of the same clock, reset, and enable
</p>
<p>inputs. Data is moved in and out of the bank of D-flip-flops as a vector. Logic operations can be made on
</p>
<p>the vectors and are latched into the register on a clock edge. A register is a higher level of abstraction that
</p>
<p>allows vector data to be stored without getting into the details of the lower-level implementation of the D-
</p>
<p>flip-flops and combinational logic. Example 9.24 shows an RTL model of an 8-bit, synchronous register.
</p>
<p>This circuit has an active LOW, asynchronous reset that will cause the 8-bit output Reg_Out to go to
</p>
<p>0 when it is asserted. When the reset is not asserted, the output will be updated with the 8-bit input
</p>
<p>Reg_In if the system is enabled (EN&frac14; 1), and there is a rising edge on the clock. If the register is disabled
</p>
<p>(EN &frac14; 0), the input clock is ignored. At all other times, the output holds its last value.
</p>
<p>Example 9.24
RTL model of an 8-bit register in verilog
</p>
<p>9.5 RTL Modeling &bull; 345</p>
<p/>
</div>
<div class="page"><p/>
<p>9.5.2 Registers as Agents on a Data Bus
</p>
<p>One of the powerful topologies that registers can easily model is a multi-drop bus. In this topology,
</p>
<p>multiple registers are connected to a data bus as receivers, or agents. Each agent has an enable line that
</p>
<p>controls when it latches information from the data bus into its storage elements. This topology is
</p>
<p>synchronous, meaning that each agent and the driver of the data bus is connected to the same clock
</p>
<p>signal. Each agent has a dedicated, synchronous enable line that is provided by a system controller
</p>
<p>elsewhere in the design. Example 9.25 shows this multi-drop bus topology. In this example system, three
</p>
<p>registers (A, B, and C) are connected to a data bus as receivers. Each register is connected to the same
</p>
<p>clock and reset signals. Each register has its own dedicated enable line (A_EN, B_EN, and C_EN).
</p>
<p>This topology can be modeled using RTL abstraction by treating each register as a separate
</p>
<p>procedural block. Example 9.26 shows how to describe this topology with an RTL model in Verilog.
</p>
<p>Notice that the three procedural blocks modeling the A, B, and C registers are nearly identical to each
</p>
<p>other except for the signal names they use.
</p>
<p>Example 9.25
Registers as agents on a data bus: system topology
</p>
<p>346 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 9.27 shows the resulting simulation waveform for this system. Each register is updated
</p>
<p>with the value on the data bus whenever its dedicated enable line is asserted.
</p>
<p>Example 9.26
Registers as agents on a data bus: RTL model in verilog
</p>
<p>Example 9.27
Registers as agents on a data bus: simulation waveform
</p>
<p>9.5 RTL Modeling &bull; 347</p>
<p/>
</div>
<div class="page"><p/>
<p>9.5.3 Shift Registers in Verilog
</p>
<p>A shift register is a circuit which consists of multiple registers connected in series. Data is shifted
</p>
<p>from one register to another on the rising edge of the clock. This type of circuit is often used in serial-to-
</p>
<p>parallel data converters. Example 9.28 shows an RTL model for a 4-stage, 8-bit shift register.
</p>
<p>Example 9.28
RTL model of a 4-stage, 8-bit shift register in verilog
</p>
<p>348 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC9.5 Does RTL modeling synthesize as combinational logic, sequential logic, or both? Why?
</p>
<p>A) Combinational logic. Since only one process is used for each register, it will be
synthesized using basic gates.
</p>
<p>B) Sequential logic. Since the sensitivity list contains clock and reset, it will
synthesize into only D-flip-flops.
</p>
<p>C) Both. The model has a sensitivity list containing clock and reset and uses an
if-else statement indicative of a D-flip-flop. This will synthesize a D-flip-flop to
hold the value for each bit in the register. In addition, the ability to manipulate
the inputs into the register (using either logical operators, arithmetic operators,
or choosing different signals to latch) will synthesize into combinational logic in
front of the D input to each D-flip-flop.
</p>
<p>Summary
</p>
<p>v A synchronous system is modeled with a
procedural block and a sensitivity list. The
clock and reset signals are always listed by
themselves in the sensitivity list. Within the
block is an if-else statement. The if clause of
the statement handles the asynchronous
reset condition, while the else clause handles
the synchronous signal assignments.
</p>
<p>v Edge sensitivity is modeled within a proce-
dural block using the (posedge Clock or
negedge reset) syntax in the sensitivity lists.
</p>
<p>v Most D-flip-flops and registers contain a syn-
chronous enable line. This is modeled using
a nested if-else statement within the main
procedural block&rsquo;s if-else statement. The
nested if-else goes beneath the clause for
the synchronous signal assignments.
</p>
<p>v Generic finite-state machines are modeled
using three separate procedural blocks that
describe the behavior of the next state logic,
the state memory, and the output logic. Sep-
arate blocks are used because each of the
three functions in a FSM is dependent on
different input signals.
</p>
<p>v In Verilog, descriptive state names can be
created for a FSM using parameters. Two
</p>
<p>signals are first declared called current_state
and next_state of type reg. Then a parameter
is defined for each unique state in the
machine with the state name and desired
state code. Throughout the rest of the
model, the unique state names can be used
as both assignments to current_state/
next_state and as inputs in case and if-else
statements. This approach allows the model
to be designed using readable syntax while
providing a synthesizable design.
</p>
<p>v Counters are a special type of finite-state
machine that can be modeled using a
single-procedural block. Only the clock and
reset signals are listed in the sensitivity list of
the counter block.
</p>
<p>v Registers are modeled in Verilog in a similar
manner to a D-flip-flop with a synchronous
enable. The only difference is that the inputs
and outputs are vectors.
</p>
<p>v Register transfer level, or RTL, modeling
provides a higher level of abstraction for
moving and manipulating vectors of data in
a synchronous manner.
</p>
<p>Summary &bull; 349</p>
<p/>
</div>
<div class="page"><p/>
<p>Exercise Problems
</p>
<p>Section 9.1: Modeling Sequential Storage
Devices in Verilog
</p>
<p>9.1.1 How does a Verilog model for a D-flip-flop han-
dle treating reset as the highest priority input?
</p>
<p>9.1.2 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), why isn&rsquo;t EN listed in
the sensitivity list?
</p>
<p>9.1.3 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), what is the impact of
listing EN in the sensitivity list?
</p>
<p>9.1.4 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), why is the behavior of
the enable modeled using a nested if-else
statement under the else clause handling the
logic for the clock edge input?
</p>
<p>Section 9.2: Modeling Finite-State
Machines in Verilog
</p>
<p>9.2.1 What is the advantage of using parameters for
the state when modeling a finite-state
machine?
</p>
<p>9.2.2 What is the advantage of having to assign the
state codes during the parameter declaration
for the state names when modeling a finite-
state machine?
</p>
<p>9.2.3 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, does the next state logic block
model combinational or sequential logic?
</p>
<p>9.2.4 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, does the state memory block
model combinational or sequential logic?
</p>
<p>9.2.5 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, does the output logic block model
combinational or sequential logic?
</p>
<p>9.2.6 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, what inputs are listed in the sensi-
tivity list of the next state logic block?
</p>
<p>9.2.7 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, what inputs are listed in the sensi-
tivity list of the state memory block?
</p>
<p>9.2.8 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, what inputs are listed in the sensi-
tivity list of the output logic block?
</p>
<p>9.2.9 When using the three-procedural block behav-
ioral modeling approach for finite-state
machines, how can the signals listed in the
sensitivity list of the output logic block immedi-
ately indicate whether the FSM is a Mealy or a
Moore machine?
</p>
<p>9.2.10 Why is it not a good design approach to com-
bine the next state logic and output logic
behavior into a single-procedural block?
</p>
<p>Section 9.3: FSM Design Examples
in Verilog
</p>
<p>9.3.1 Design a Verilog behavioral model to imple-
ment the finite-state machine described by
the state diagram in Fig. 9.1. Use the port
definition provided in this figure for your design.
Use the three-block approach to modeling
FSMs described in this chapter for your design.
Model the state variables using parameters
and encode the states in binary using the fol-
lowing state codes: Start&frac14; &ldquo;00,&rdquo;Midway&frac14; &ldquo;01,&rdquo;
Done &frac14; &ldquo;10.&rdquo;
</p>
<p>Fig. 9.1
FSM 1 state diagram and module definition
</p>
<p>9.3.2 Design a Verilog behavioral model to imple-
ment the finite-state machine described by
the state diagram in Fig. 9.1. Use the port
definition provided in this figure for your design.
Use the three-block approach to modeling
FSMs described in this chapter for your design.
Model the state variables using parameters,
and encode the states in one-hot using the
following state codes: Start &frac14; &ldquo;001,&rdquo; Mid-
way &frac14; &ldquo;010,&rdquo; Done &frac14; &ldquo;100.&rdquo;
</p>
<p>9.3.3 Design a Verilog behavioral model to imple-
ment the finite-state machine described by
the state diagram in Fig. 9.2. Use the port
definition provided in this figure for your design.
Use the three-block approach to modeling
FSMs described in this chapter for your design.
Model the state variables using parameters
and encode the states in binary using the fol-
lowing state codes: S0 &frac14; &ldquo;00,&rdquo; S1 &frac14; &ldquo;01,&rdquo;
S2 &frac14; &ldquo;10,&rdquo; and S3 &frac14; &ldquo;11.&rdquo;
</p>
<p>350 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 9.2
FSM 2 state diagram and module definition
</p>
<p>9.3.4 Design a Verilog behavioral model to imple-
ment the finite-state machine described by
the state diagram in Fig. 9.2. Use the port
definition provided in this figure for your design.
Use the three-block approach to modeling
FSMs described in this chapter for your design.
Model the state variables using parameters
and encode the states in one-hot using the
following state codes: S0 &frac14; &ldquo;0001,&rdquo;
S1 &frac14; &ldquo;0010,&rdquo; S2 &frac14; &ldquo;0100,&rdquo; and S3 &frac14; &ldquo;1000,&rdquo;
</p>
<p>9.3.5 Design a Verilog behavioral model for a 4-bit
serial bit sequence detector similar to Example
9.11. Use the port definition provided in
Fig. 9.3. Use the three-block approach to
modeling FSMs described in this chapter for
your design. The input to your sequence detec-
tor is called DIN and the output is called
FOUND. Your detector will assert FOUND any-
time there is a 4-bit sequence of &ldquo;0101.&rdquo; Model
the states in this machine with parameters.
Choose any state encoding approach
you wish.
</p>
<p>Fig. 9.3
Sequence detector module definition
</p>
<p>9.3.6 Design a Verilog behavioral model for a
20-cent vending machine controller similar to
Example 9.14. Use the port definition provided
in Fig. 9.4. Use the three-block approach to
modeling FSMs described in this chapter for
</p>
<p>your design. Your controller will take in nickels
and dimes and dispense a product anytime the
customer has entered 20 cents. Your FSM has
two inputs, Nin and Din. Nin is asserted when-
ever the customer enters a nickel, while Din is
asserted anytime the customer enters a dime.
Your FSM has two outputs, Dispense and
Change. Dispense is asserted anytime the
customer has entered at least 20 cents and
Change is asserted anytime the customer has
entered more than 20 cents and needs a nickel
in change. Model the states in this machine
with parameters. Choose any state encoding
approach you wish.
</p>
<p>Fig. 9.4
Vending machine module definition
</p>
<p>9.3.7 Design a Verilog behavioral model for a finite-
state machine for a traffic light controller. Use
the port definition provided in Fig. 9.5. This is
the same problem description as in exercise
7.4.15. This time, you will implement the func-
tionality using the behavioral modeling
techniques presented in this chapter. Your
FSMwill control a traffic light at the intersection
of a busy highway and a seldom used side
road. You will be designing the control signals
for just the red, yellow, and green lights facing
the highway. Under normal conditions, the
highway has a green light. The side road has
car detector that indicates when car pulls up by
asserting a signal called CAR. When CAR is
asserted, you will change the highway traffic
light from green to yellow and then from yellow
to red. Once in the red position, a built-in timer
will begin a countdown and provide your con-
troller a signal called TIMEOUT when
15 seconds has passed. Once TIMEOUT is
asserted, you will change the highway traffic
light back to green. Your system will have three
outputs GRN, YLW, and RED, which control
when the highway facing traffic lights are on
(1 &frac14; ON, 0 &frac14; OFF). Model the states in this
machine with parameters. Choose any state
encoding approach you wish.
</p>
<p>Fig. 9.5
Traffic light controller module definition
</p>
<p>Exercise Problems &bull; 351</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 9.4: Modeling Counters in Verilog
</p>
<p>9.4.1 Design a Verilog behavioral model for a 16-bit,
binary up counter using a single-procedural
block. The block diagram for the port definition
is shown in Fig. 9.6.
</p>
<p>Fig. 9.6
16-bit binary up counter block diagram
</p>
<p>9.4.2 Design a Verilog behavioral model for a 16-bit,
binary up counter with range checking using a
single-procedural block. The block diagram for
the port definition is shown in Fig. 9.6. Your
counter should count up to 60,000 and then
start over at 0.
</p>
<p>9.4.3 Design a Verilog behavioral model for a 16-bit,
binary up counter with enable using a single-
procedural block. The block diagram for the
port definition is shown in Fig. 9.7.
</p>
<p>Fig. 9.7
16-bit binary up counter with enable block
diagram
</p>
<p>9.4.4 Design a Verilog behavioral model for a 16-bit,
binary up counter with enable and load using a
single-procedural block. The block diagram for
the port definition is shown in Fig. 9.8.
</p>
<p>Fig. 9.8
16-bit binary up counter with load block diagram
</p>
<p>9.4.5 Design a Verilog behavioral model for a 16-bit,
binary up/down counter using a single-
procedural block. The block diagram for the
port definition is shown in Fig. 9.9. When
Up &frac14; 1, the counter will increment. When
Up &frac14; 0, the counter will decrement.
</p>
<p>Fig. 9.9
16-bit binary up/down counter block diagram
</p>
<p>Section 9.5: RTL Modeling
</p>
<p>9.5.1 In register transfer level modeling, how does
the width of the register relate to the number of
D-flip-flops that will be synthesized?
</p>
<p>9.5.2 In register transfer level modeling, how is the
synchronous data movement managed if all
registers are using the same clock?
</p>
<p>9.5.3 Design a Verilog RTL model of a 32-bit, syn-
chronous register. The block diagram for the
port definition is shown in Fig. 9.10. The regis-
ter has a synchronous enable. The register
should be modeled using a single-procedural
block.
</p>
<p>Fig. 9.10
32-bit register block diagram
</p>
<p>9.5.4 Design a Verilog RTL model of an 8-stage,
16-bit shift register. The block diagram for the
port definition is shown in Fig. 9.11. Each stage
of the shift register will be provided as an out-
put of the system (A, B, C, D, E, F, G, and H).
The shift register should be modeled using a
single-procedural block.
</p>
<p>352 &bull; Chapter 9: Behavioral Modeling of Sequential Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 9.11
16-bit shift register block diagram
</p>
<p>9.5.5 Design a Verilog RTL model of the multi-drop
bus topology in Fig. 9.12. Each of the 16-bit
registers (RegA, RegB, RegC, and RegD) will
latch the contents of the 16-bit data bus if their
enable line is asserted. Each register should
be modeled using an individual procedural
block.
</p>
<p>Fig. 9.12
Agents on a bus block diagram
</p>
<p>Exercise Problems &bull; 353</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 10: Memory
This chapter introduces the basic concepts, terminology, and roles of memory in digital systems.
</p>
<p>The material presented here will not delve into the details of the device physics or low-level theory of
</p>
<p>operation. Instead, the intent of this chapter is to give a general overview of memory technology and its
</p>
<p>use in computer systems in addition to how to model memory in Verilog. The goal of this chapter is to give
</p>
<p>an understanding of the basic principles of semiconductor-based memory systems.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>10.1 Describe the basic architecture and terminology for semiconductor-based memory
systems.
</p>
<p>10.2 Describe the basic architecture of non-volatile memory systems.
10.3 Describe the basic architecture of volatile memory systems.
10.4 Design a Verilog behavioral model of a memory system.
</p>
<p>10.1 Memory Architecture and Terminology
</p>
<p>The termmemory is used to describe a system with the ability to store digital information. The term
</p>
<p>semiconductor memory refers to systems that are implemented using integrated circuit technology.
</p>
<p>These types of systems store the digital information using transistors, fuses, and/or capacitors on a
</p>
<p>single semiconductor substrate. Memory can also be implemented using technology other than
</p>
<p>semiconductors. Disk drives store information by altering the polarity of magnetic fields on a circular
</p>
<p>substrate. The two magnetic polarities (north and south) are used to represent different logic values (i.e.,
</p>
<p>0 or 1). Optical disks use lasers to burn pits into reflective substrates. The binary information is
</p>
<p>represented by light either being reflected (no pit) or not reflected (pit present). Semiconductor memory
</p>
<p>does not have any moving parts, so it is called solid-state memory and can hold more information per unit
</p>
<p>area than disk memory. Regardless of the technology used to store the binary data, all memory has
</p>
<p>common attributes and terminology that are discussed in this chapter.
</p>
<p>10.1.1 Memory Map Model
</p>
<p>The information stored in memory is called the data. When information is placed into memory, it is
</p>
<p>called a write. When information is retrieved from memory, it is called a read. In order to access data in
</p>
<p>memory, an address is used. While data can be accessed as individual bits, in order to reduce the
</p>
<p>number of address locations needed, data is typically grouped into N-bit words. If a memory system has
</p>
<p>N &frac14; 8, this means that 8-bits of data are stored at each address. The number of address locations is
</p>
<p>described using the variable M. The overall size of the memory is typically stated by saying &ldquo;M�N.&rdquo; For
</p>
<p>example, if we had a 16�8 memory system, that means that there are 16 address locations, each
</p>
<p>capable of storing a byte of data. This memory would have a capacity of 16�8 &frac14; 128 bits. Since the
</p>
<p>address is implemented as a binary code, the number of lines in the address bus (n) will dictate the
</p>
<p>number of address locations that the memory system will have (M &frac14; 2n). Figure 10.1 shows a graphical
</p>
<p>depiction of how data resides in memory. This type of graphic is called a memory map model.
</p>
<p># Springer Nature Switzerland AG 2019
B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
https://doi.org/10.1007/978-3-030-13605-5_10
</p>
<p>355</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_10&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_10&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>10.1.2 Volatile Versus Non-volatile Memory
</p>
<p>Memory is classified into two categories depending on whether it can store information when power
</p>
<p>is removed or not. The term non-volatile is used to describe memory that holds information when the
</p>
<p>power is removed, while the term volatile is used to describe memory that loses its information when
</p>
<p>power is removed. Historically, volatile memory is able to run at faster speeds compared to non-volatile
</p>
<p>memory, so it is used as the primary storage mechanism while a digital system is running. Non-volatile
</p>
<p>memory is necessary in order to hold critical operation information for a digital system such as start-up
</p>
<p>instructions, operations systems, and applications.
</p>
<p>10.1.3 Read-Only Versus Read/Write Memory
</p>
<p>Memory can also be classified into two categories with respect to how data is accessed. Read-only
</p>
<p>memory (ROM) is a device that cannot be written to during normal operation. This type of memory is
</p>
<p>useful for holding critical system information or programs that should not be altered while the system is
</p>
<p>running. Read/write memory refers to memory that can be read and written to during normal operation
</p>
<p>and is used to hold temporary data and variables.
</p>
<p>10.1.4 Random Access Versus Sequential Access
</p>
<p>Random-access memory (RAM) describes memory in which any location in the system can be
</p>
<p>accessed at any time. The opposite of this is sequential access memory, in which not all address
</p>
<p>locations are immediately available. An example of a sequential access memory system is a tape drive.
</p>
<p>In order to access the desired address in this system, the tape spool must be spun until the address is in
</p>
<p>a position that can be observed. Most semiconductor memory in modern systems is random access. The
</p>
<p>terms RAM and ROM have been adopted, somewhat inaccurately, to also describe groups of memory
</p>
<p>with particular behavior. While the term ROM technically describes a system that cannot be written to, it
</p>
<p>has taken on the additional association of being the term to describe non-volatile memory. While the term
</p>
<p>RAM technically describes how data is accessed, it has taken on the additional association of being the
</p>
<p>term to describe volatile memory. When describing modern memory systems, the terms RAM and ROM
</p>
<p>are used most commonly to describe the characteristics of the memory being used; however, modern
</p>
<p>memory systems can be both read/write and non-volatile, and the majority of memory is random access.
</p>
<p>CONCEPT CHECK
</p>
<p>CC10.1 An 8-bit wide memory has eight address lines. What is its capacity in bits?
</p>
<p>A) 64 B) 256 C) 1024 D) 2048
</p>
<p>Fig. 10.1
Memory map model
</p>
<p>356 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2 Non-volatile Memory Technology
</p>
<p>10.2.1 ROM Architecture
</p>
<p>This section describes some of the most common non-volatile memory technologies used to store
</p>
<p>digital information. An address decoder is used to access individual data words within the memory
</p>
<p>system. The address decoder asserts one and only one word line (WL) for each unique binary address
</p>
<p>that is present on its input. This operation is identical to a binary-to-one-hot decoder. For an n-bit
</p>
<p>address, the decoder can access 2n, or M words in memory. The word lines historically run horizontally
</p>
<p>across the memory array; thus they are often called row lines, and the word line decoder is often called
</p>
<p>the row decoder.Bit lines (BL) run perpendicular to the word lines in order to provide individual bit storage
</p>
<p>access at the intersection of the bit and word lines. These lines typically run vertically through the
</p>
<p>memory array; thus they are often called column lines. The output of the memory system (i.e., Data_Out)
</p>
<p>is obtained by providing an address and then reading the word from buffered versions of the bit lines.
</p>
<p>When a system provides individual bit access to a row, or access to multiple data words sharing a row
</p>
<p>line, a column decoder is used to route the appropriate bit line(s) to the data out port.
</p>
<p>In a traditional ROM array, each bit line contains a pull-up network to VCC. This provides the ability to
</p>
<p>store a logic 1 at all locations within the array. If a logic 0 is desired at a particular location, an NMOS pull-
</p>
<p>down transistor is inserted. The gate of the NMOS is connected to the appropriate word line, and the
</p>
<p>drain of the NMOS is connected to the bit line. When reading, the word line is asserted and turns on the
</p>
<p>NMOS transistor. This pulls the bit line to GND and produces a logic 0 on the output. When the NMOS
</p>
<p>transistor is excluded, the bit line remains at a logic 1 due to the pull-up network. Figure 10.2 shows the
</p>
<p>basic architecture of a ROM.
</p>
<p>10.2 Non-volatile Memory Technology &bull; 357</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 10.3 shows the operation of a ROM when information is being read.
</p>
<p>Fig. 10.2
Basic architecture of read-only memory (ROM)
</p>
<p>358 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>Memory can be designed to be either asynchronous or synchronous. Asynchronous memory
</p>
<p>updates its data outputs immediately upon receiving an address. Synchronous memory only updates
</p>
<p>its data outputs on the rising edge of a clock. The term latency is used to describe the delay between
</p>
<p>when a signal is sent to the memory (either the address in an asynchronous system or the clock in a
</p>
<p>synchronous system) and when the data is available. Figure 10.4 shows a comparison of the timing
</p>
<p>diagrams between asynchronous and synchronous ROM systems during a read cycle.
</p>
<p>Fig. 10.3
ROM operation during a read
</p>
<p>10.2 Non-volatile Memory Technology &bull; 359</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2.2 Mask Read-Only Memory (MROM)
</p>
<p>A mask read-only memory (MROM) is a non-volatile device that is programmed during fabrication.
</p>
<p>The termmask refers to a transparent plate that contains patterns to create the features of the devices on
</p>
<p>an integrated circuit using a process called photolithography. An MROM is fabricated with all of the
</p>
<p>features necessary for the memory device with the exception of the final connections between the NMOS
</p>
<p>transistors and the word and bit lines. This allows the majority of the device to be created prior to knowing
</p>
<p>what the final information to be stored is. Once the desired information to be stored is provided by the
</p>
<p>customer, the fabrication process is completed by adding connections between certain NMOS
</p>
<p>transistors and the word/bit lines in order to create logic 0&rsquo;s. Figure 10.5 shows an overview of the
</p>
<p>MROM programming process.
</p>
<p>Fig. 10.4
Asynchronous vs. synchronous ROM operation during a read cycle
</p>
<p>360 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2.3 Programmable Read-Only Memory (PROM)
</p>
<p>A programmable read-only memory (PROM) is created in a similar manner as an MROM except that
</p>
<p>the programming is accomplished post-fabrication through the use of fuses or anti-fuses. A fuse is an
</p>
<p>electrical connection that is normally conductive. When a certain amount of current is passed through the
</p>
<p>fuse, it will melt, or blow, and create an open circuit. The amount of current necessary to open the fuse is
</p>
<p>much larger than the current the fuse would conduct during normal operation. An anti-fuse operates in
</p>
<p>the opposite manner as a fuse. An anti-fuse is normally an open circuit. When a certain amount of current
</p>
<p>is forced into the anti-fuse, the insulating material breaks down and creates a conduction path. This turns
</p>
<p>the anti-fuse from an open circuit into a wire. Again, the amount of current necessary to close the anti-
</p>
<p>fuse is much larger than the current the anti-fuse would experience during normal operation. A PROM
</p>
<p>uses fuses or anti-fuses in order to connect/disconnect the NMOS transistors in the ROM array to the
</p>
<p>word/bit lines. A PROM programmer is used to burn the fuses or anti-fuses. A PROM can only be
</p>
<p>programmed once in this manner; thus it is a read-only memory and non-volatile. A PROM has the
</p>
<p>advantage that programming can take place quickly as opposed to an MROM that must be programmed
</p>
<p>through device fabrication. Figure 10.6 shows an example PROM device based on fuses.
</p>
<p>Fig. 10.5
MROM overview
</p>
<p>10.2 Non-volatile Memory Technology &bull; 361</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2.4 Erasable Programmable Read-Only Memory (EPROM)
</p>
<p>As an improvement to the one-time programming characteristic of PROMs, an electrically program-
</p>
<p>mable ROM with the ability to be erased with ultraviolet (UV) light was created. The erasable program-
</p>
<p>mable read-only memory (EPROM) is based on a floating-gate transistor. In a floating-gate transistor,
</p>
<p>an additional metal-oxide structure is added to the gate of an NMOS. This has the effect of increasing the
</p>
<p>threshold voltage. The geometry of the second metal-oxide is designed such that the threshold voltage is
</p>
<p>high enough that normal CMOS logic levels are not able to turn the transistor on (i.e., VT1 � VCC). This
</p>
<p>threshold can be changed by applying a large electric field across the two metal structures in the gate.
</p>
<p>This causes charge to tunnel into the secondary oxide, ultimately changing it into a conductor. This
</p>
<p>phenomenon is called Fowler-Nordheim tunneling. The new threshold voltage is low enough that normal
</p>
<p>CMOS logic levels are not able to turn the transistors off (i.e., VT2 � GND). This process is how the
</p>
<p>device is programmed. This process is accomplished using a dedicated programmer; thus the EPROM
</p>
<p>must be removed from its system to program. Figure 10.7 shows an overview of a floating-gate transistor
</p>
<p>and how it is programmed.
</p>
<p>Fig. 10.6
PROM overview
</p>
<p>362 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>In order to change the floating-gate transistor back into its normal state, the device is exposed to a
</p>
<p>strong ultraviolet light source. When the UV light strikes the trapped charge in the secondary oxide, it
</p>
<p>transfers enough energy to the charge particles that they can move back into the metal plates in the gate.
</p>
<p>This, in effect, erases the device and restores it back to a state with a high threshold voltage. EPROMs
</p>
<p>contain a transparent window on the top of their package that allows the UV light to strike the devices.
</p>
<p>The EPROMmust be removed from its system to perform the erase procedure. When the UV light erase
</p>
<p>procedure is performed, every device in the memory array is erased. EPROMs are a significant
</p>
<p>improvement over PROMs because they can be programmed multiple times; however, the programming
</p>
<p>and erase procedures are manually intensive and require an external programmer and external eraser.
</p>
<p>Figure 10.8 shows the erase procedure for a floating-gate transistor using UV light.
</p>
<p>Fig. 10.7
Floating-gate transistor &ndash; Programming
</p>
<p>10.2 Non-volatile Memory Technology &bull; 363</p>
<p/>
</div>
<div class="page"><p/>
<p>An EPROM array is created in the exact same manner as in a PROM array with the exception that
</p>
<p>additional programming circuitry is placed on the IC and a transparent window is included on the
</p>
<p>package to facilitate erasing. An EPROM is non-volatile and read-only since the programming procedure
</p>
<p>takes place outside of its destination system.
</p>
<p>10.2.5 Electrically Erasable Programmable Read-Only Memory (EEPROM)
</p>
<p>In order to address the inconvenient programming and erasing procedures associated with
</p>
<p>EPROMs, the electrically erasable programmable ROM (EEPROM) was created. In this type of circuit,
</p>
<p>the floating-gate transistor is erased by applying a large electric field across the secondary oxide. This
</p>
<p>electric field provides the energy to move the trapped charge from the secondary oxide back into the
</p>
<p>metal plates of the gate. The advantage of this approach is that the circuitry to provide the large electric
</p>
<p>field can be generated using circuitry on the same substrate as the memory array, thus eliminating the
</p>
<p>need for an external UV light eraser. In addition, since the circuitry exists to generate large on-chip
</p>
<p>voltages, the device can also be programmed without the need for an external programmer. This allows
</p>
<p>an EEPROM to be programmed and erased while it resides in its target environment. Figure 10.9 shows
</p>
<p>the procedure for erasing a floating-gate transistor using an electric field.
</p>
<p>Fig. 10.9
Floating-gate transistor &ndash; Erasing with electricity
</p>
<p>Fig. 10.8
Floating-gate transistor &ndash; Erasing with UV light
</p>
<p>364 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>Early EEPROMs were very slow and had a limited number of program/erase cycles; thus they were
</p>
<p>classified into the category of non-volatile, read-only memory. Modern floating-gate transistors are now
</p>
<p>capable of access times on scale with other volatile memory systems; thus they have evolved into one of
</p>
<p>the few non-volatile, read/write memory technologies used in computer systems today.
</p>
<p>10.2.6 FLASH Memory
</p>
<p>One of the early drawbacks of EEPROM was that the circuitry that provided the capability to
</p>
<p>program and erase individual bits also added to the size of each individual storage element. FLASH
</p>
<p>EEPROM was a technology that attempted to improve the density of floating-gate memory by program-
</p>
<p>ming and erasing in large groups of data, known as blocks. This allowed the individual storage cells to
</p>
<p>shrink and provided higher-density memory parts. This new architecture was called NAND FLASH and
</p>
<p>provided faster write and erase times coupled with higher-density storage elements. The limitation of
</p>
<p>NAND FLASH was that reading and writing could only be accomplished in a block-by-block basis. This
</p>
<p>characteristic precluded the use of NAND FLASH for run-time variables and data storage but was well
</p>
<p>suited for streaming applications such as audio/video and program loading. As NAND FLASH technol-
</p>
<p>ogy advanced, the block size began to shrink, and software adapted to accommodate the block-by-block
</p>
<p>data access. This expanded the applications that NAND FLASH could be deployed in. Today, NAND
</p>
<p>FLASH memory is used in nearly all portable devices (e.g., smartphones, tablets, etc.), and its use in
</p>
<p>solid-state hard drives is on pace to replace hard disk drives and optical disks as the primary non-volatile
</p>
<p>storage medium in modern computers.
</p>
<p>In order to provide individual word access, NOR FLASH was introduced. In NOR FLASH, circuitry is
</p>
<p>added to provide individual access to data words. This architecture provided faster read times than
</p>
<p>NAND FLASH, but the additional circuitry causes the write and erase times to be slower and the
</p>
<p>individual storage cell size to be larger. Due to NAND FLASH having faster write times and higher
</p>
<p>density, it is seeing broader scale adoption compared to NOR FLASH despite only being able to access
</p>
<p>information in blocks. NOR FLASH is considered random-access memory, while NAND FLASH is
</p>
<p>typically not; however, as the block size of NAND FLASH is continually reduced, its use for variable
</p>
<p>storage is becoming more attractive. All FLASH memory is non-volatile and read/write.
</p>
<p>CONCEPT CHECK
</p>
<p>CC10.2 Which of the following is suitable for implementation in a read-only memory?
</p>
<p>A) Variables that a computer program needs to continuously update
</p>
<p>B) Information captured by a digital camera
</p>
<p>C) A computer program on a spacecraft
</p>
<p>D) Incoming digitized sound from a microphone
</p>
<p>10.3 Volatile Memory Technology
</p>
<p>This section describes some common volatile memory technologies used to store digital
</p>
<p>information.
</p>
<p>10.3 Volatile Memory Technology &bull; 365</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3.1 Static Random-Access Memory (SRAM)
</p>
<p>Static random-access memory (SRAM) is a semiconductor technology that stores information using
</p>
<p>a cross-coupled inverter feedback loop. Figure 10.10 shows the schematic for the basic SRAM storage
</p>
<p>cell. In this configuration, two access transistors (M1 and M2) are used to read and write from the storage
</p>
<p>cell. The cell has two complementary ports called bit line (BL) and bit line&rsquo; (BLn). Due to the inverting
</p>
<p>functionality of the feedback loop, these two ports will always be the complement of each other. This
</p>
<p>behavior is advantageous because the two lines can be compared to each other to determine the data
</p>
<p>value. This allows the voltage levels used in the cell to be lowered while still being able to detect the
</p>
<p>stored data value. Word lines are used to control the access transistors. This storage element takes six
</p>
<p>CMOS transistors to implement and is often called a 6Tconfiguration. The advantage of this memory cell
</p>
<p>is that it has very fast performance compared to other sub-systems because of its underlying technology
</p>
<p>being simple CMOS transistors. SRAM cells are commonly implemented on the same IC substrate as
</p>
<p>the rest of the system, thus allowing a fully integrated system to be realized. SRAM cells are used for
</p>
<p>cache memory in computer systems.
</p>
<p>To build an SRAMmemory system, cells are arranged in an array pattern. Figure 10.11 shows a 4�4
</p>
<p>SRAM array topology. In this configuration, word lines are shared horizontally across the array in order to
</p>
<p>provide addressing capability. An address decoder is used to convert the binary-encoded address into
</p>
<p>the appropriate word line assertions. N storage cells are attached to the word line to provide the desired
</p>
<p>data word width. Bit lines are shared vertically across the array in order to provide data access (either
</p>
<p>read or write). A data line controller handles whether data is read from or written to the cells based on an
</p>
<p>external write enable (WE) signal. When WE is asserted (WE&frac14; 1), data will be written to the cells. When
</p>
<p>WE is de-asserted (WE &frac14; 0), data will be read from the cells. The data line controller also handles
</p>
<p>determining the correct logic value read from the cells by comparing BL to BLn. As more cells are added
</p>
<p>to the bit lines, the signal magnitude being driven by the storage cells diminishes due to the additional
</p>
<p>loading of the other cells. This is where having complementary data signals (BL and BLn) is advanta-
</p>
<p>geous because this effectively doubles the magnitude of the storage cell outputs. The comparison of BL
</p>
<p>to BLn is handled using a differential amplifier that produces a full logic level output even when the
</p>
<p>incoming signals are very small.
</p>
<p>Fig. 10.10
SRAM storage element (6T)
</p>
<p>366 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>SRAM is volatile memory because when the power is removed, the cross-coupled inverters are not
</p>
<p>able to drive the feedback loop and the data is lost. SRAM is also read/write memory because the
</p>
<p>storage cells can be easily read from or written to during normal operation.
</p>
<p>Let&rsquo;s look at the operation of the SRAM array when writing the 4-bit word &ldquo;0111&rdquo; to address &ldquo;01.&rdquo;
</p>
<p>Figure 10.12 shows a graphical depiction of this operation. In this write cycle, the row address decoder
</p>
<p>observes the address input &ldquo;01&rdquo; and asserts WL1. Asserting this word line enables all of the access
</p>
<p>transistors (i.e., M1 and M2 in Fig. 10.10) of the storage cells in this row. The line drivers are designed to
</p>
<p>have a stronger drive strength than the inverters in the storage cells so that they can override their values
</p>
<p>during a write. The information &ldquo;0111&rdquo; is present on the Data_In bus, and the write enable control line is
</p>
<p>asserted (WE &frac14; 1) to indicate a write. The data line controller passes the information to be stored to the
</p>
<p>line drivers, which in turn converts each input into complementary signals and drives the bit lines. This
</p>
<p>Fig. 10.11
4�4 SRAM array topology
</p>
<p>10.3 Volatile Memory Technology &bull; 367</p>
<p/>
</div>
<div class="page"><p/>
<p>overrides the information in each storage cell connected to WL1. The address decoder then de-asserts
</p>
<p>WL1 and the information is stored.
</p>
<p>Now let&rsquo;s look at the operation of the SRAM array when reading a 4-bit word from address &ldquo;10.&rdquo; Let&rsquo;s
</p>
<p>assume that this row was storing the value &ldquo;1010.&rdquo; Figure 10.13 shows a graphical depiction of this
</p>
<p>operation. In this read cycle, the row address decoder asserts WL2, which allows the SRAM cells to drive
</p>
<p>their respective bit lines. Note that each cell drives a complementary version of its stored value. The input
</p>
<p>control line is de-asserted (WE &frac14; 0), which indicates that the sense amplifiers will read the BL and BLn
</p>
<p>lines in order to determine the full logic value stored in each cell. This logic value is then routed to the
</p>
<p>Data_Out port of the array. In an SRAM array, reading from the cell does not impact the contents of the
</p>
<p>cell. Once the read is complete, WL2 is de-asserted and the read cycle is complete.
</p>
<p>Fig. 10.12
SRAM operation during a write cycle &ndash; Storing &ldquo;0111&rdquo; to Address &ldquo;01&rdquo;
</p>
<p>368 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3.2 Dynamic Random-Access Memory (DRAM)
</p>
<p>Dynamic random-access memory (DRAM) is a semiconductor technology that stores information
</p>
<p>using a capacitor. A capacitor is a fundamental electrical device that stores charge. Figure 10.14 shows
</p>
<p>the schematic for the basic DRAM storage cell. The capacitor is accessed through a transistor (M1).
</p>
<p>Since this storage element takes one transistor and one capacitor, it is often referred to as a 1T1C
</p>
<p>configuration. Just as in SRAM memory, word lines are used to access the storage elements. The term
</p>
<p>digit line is used to describe the vertical connection to the storage cells. DRAM has an advantage over
</p>
<p>SRAM in that the storage element requires less area to implement. This allows DRAM memory to have
</p>
<p>much higher density compared to SRAM.
</p>
<p>Fig. 10.13
SRAM operation during a read cycle &ndash; Reading &ldquo;0101&rdquo; from Address &ldquo;10&rdquo;
</p>
<p>10.3 Volatile Memory Technology &bull; 369</p>
<p/>
</div>
<div class="page"><p/>
<p>There are a variety of considerations that must be accounted for when using DRAM. First, the
</p>
<p>charge in the capacitor will slowly dissipate over time due to the capacitors being non-ideal. If left
</p>
<p>unchecked, eventually the data held in the capacitor will be lost. In order to overcome this issue,
</p>
<p>DRAM has a dedicated circuit to refresh the contents of the storage cell. A refresh cycle involves
</p>
<p>periodically reading the value stored on the capacitor and then writing the same value back again at
</p>
<p>full signal strength. This behavior also means that that DRAM is volatile because when the power is
</p>
<p>removed, and the refresh cycle cannot be performed, the stored data is lost. DRAM is also considered
</p>
<p>read/write memory because the storage cells can be easily read from or written to during normal
</p>
<p>operation.
</p>
<p>Another consideration when using DRAM is that the voltage of the word line must be larger than VCC
in order to turn on the access transistor. In order to turn on an NMOS transistor, the gate terminal must be
</p>
<p>larger than the source terminal by at least a threshold voltage (VT). In traditional CMOS circuit design, the
</p>
<p>source terminal is typically connected to ground (0v). This means the transistor can be easily turned on
</p>
<p>by driving the gate with a logic 1 (i.e., VCC) since this creates a VGS voltage much larger than VT. This is
</p>
<p>not always the case in DRAM. In DRAM, the source terminal is not connected to ground but rather to the
</p>
<p>storage capacitor. In the worst-case situation, the capacitor could be storing a logic 1 (i.e., VCC). This
</p>
<p>means that in order for the word line to be able to turn on the access transistor, it must be equal to or
</p>
<p>larger than (VCC + VT). This is an issue because the highest voltage that the DRAM device has access to
</p>
<p>is VCC. In DRAM, a charge pump is used to create a voltage larger than VCC + VT that is driven on the
</p>
<p>word lines. Once this voltage is used, the charge is lost, so the line must be pumped up again before its
</p>
<p>next use. The process of &ldquo;pumping up&rdquo; takes time that must be considered when calculating the
</p>
<p>maximum speed of DRAM. Figure 10.15 shows a graphical depiction of this consideration.
</p>
<p>Fig. 10.14
DRAM storage element (1T 1C)
</p>
<p>Fig. 10.15
DRAM charge pumping of word lines
</p>
<p>370 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>Another consideration when using DRAM is how the charge in the capacitor develops into an actual
</p>
<p>voltage on the digital line when the access transistor is closed. Consider the simple 4�4 array of DRAM
</p>
<p>cells shown in Fig. 10.16. In this topology, the DRAM cells are accessed using the same approach as in
</p>
<p>the SRAM array from Fig. 10.11.
</p>
<p>One of the limitations of this simple configuration is that the charge stored in the capacitors cannot
</p>
<p>develop a full voltage level across the digit line when the access transistor is closed. This is because the
</p>
<p>digit line itself has capacitance that impacts how much voltage will be developed. In practice, the
</p>
<p>capacitance of the digit line (CDL) is much larger than the capacitance of the storage cell (CS) due to
</p>
<p>having significantly more area and being connected to numerous other storage cells. This becomes an
</p>
<p>issue because when the storage capacitor is connected to the digit line, the resulting voltage on the digit
</p>
<p>line (VDL) is much less than the original voltage on the storage cell (VS). This behavior is known as
</p>
<p>charge sharing because when the access transistor is closed, the charge on both capacitors is
</p>
<p>distributed across both devices and results in a final voltage that depends on the initial charge in the
</p>
<p>system and the values of the two capacitors. Example 10.1 shows an example of how to calculate the
</p>
<p>final digit line voltage when the storage cell is connected.
</p>
<p>Fig. 10.16
Simple 4�4 DRAM array topology
</p>
<p>10.3 Volatile Memory Technology &bull; 371</p>
<p/>
</div>
<div class="page"><p/>
<p>The issue with the charge sharing behavior of a DRAM cell is that the final voltage on the word line is
</p>
<p>not large enough to be detected by a standard logic gate or latch. In order to overcome this issue, modern
</p>
<p>DRAM arrays use complementary storage cells and sense amplifiers. The complementary cells store the
</p>
<p>Example 10.1
Calculating the final digit line voltage in a DRAM based on charge sharing
</p>
<p>372 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>original data and its complement. Two digit lines (DL and DLn) are used to read the contents of the
</p>
<p>storage cells. DL and DLn are initially pre-charged to exactly VCC/2. When the access transistors are
</p>
<p>closed, the storage cells will share their charge with the digit lines andmove them slightly away from VCC/
</p>
<p>2 in different directions. This allows twice the voltage difference to be developed during a read. A sense
</p>
<p>amplifier is then used to boost this small voltage difference into a full logic level that can be read by a
</p>
<p>standard logic gate or latch. Figure 10.17 shows the modern DRAM array topology based on comple-
</p>
<p>mentary storage cells.
</p>
<p>The sense amplifier is designed to boost small voltage deviations from VCC/2 on DL and DLn to full
</p>
<p>logic levels. The sense amplifier sits in-between DL and DLn and has two complementary networks, the
</p>
<p>N-sense amplifier and the P-sense amplifier. The N-sense amplifier is used to pull a signal that is below
</p>
<p>VCC/2 (either DL or DLn) down to GND. A control signal (N-Latch or NLATn) is used to turn on this
</p>
<p>network. The P-sense amplifier is used to pull a signal that is above VCC/2 (either DL or DLn) up to VCC. A
</p>
<p>control signal (Active Pull-Up or ACT) is used to turn on this network. The two networks are activated in a
</p>
<p>sequence with the N-sense network activating first. Figure 10.18 shows an overview of the operation of a
</p>
<p>DRAM sense amplifier.
</p>
<p>Fig. 10.17
Modern DRAM array topology based on complementary storage cells
</p>
<p>10.3 Volatile Memory Technology &bull; 373</p>
<p/>
</div>
<div class="page"><p/>
<p>Let&rsquo;s now put everything together and look at the operation of a DRAM system during a read
</p>
<p>operation. Figure 10.19 shows a simplified timing diagram of a DRAM read cycle. This diagram shows
</p>
<p>the critical signals and their values when reading a logic 1. Notice that there is a sequence of steps that
</p>
<p>must be accomplished before the information in the storage cells can be retrieved.
</p>
<p>Fig. 10.18
DRAM sense amplifier
</p>
<p>374 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>A DRAM write operation is accomplished by opening the access transistors to the complementary
</p>
<p>storage cells using WL, disabling the pre-charge drivers and then writing full logic level signals to the
</p>
<p>storage cells using the Data_In line driver.
</p>
<p>CONCEPT CHECK
</p>
<p>CC10.3 Which of the following is suitable for implementation in a read/write memory?
</p>
<p>A) A look up table containing the values of sine.
</p>
<p>B) Information captured by a digital camera.
</p>
<p>C) The boot up code for a computer.
</p>
<p>D) A computer program on a spacecraft.
</p>
<p>Fig. 10.19
DRAM operation during a read cycle &ndash; Reading a 1 from a storage cell
</p>
<p>10.3 Volatile Memory Technology &bull; 375</p>
<p/>
</div>
<div class="page"><p/>
<p>10.4 Modeling Memory with Verilog
</p>
<p>10.4.1 Read-Only Memory in Verilog
</p>
<p>A read-only memory in Verilog can be defined in two ways. The first is to simply use a case
</p>
<p>statement to define the contents of each location in memory based on the incoming address. A second
</p>
<p>approach is to declare an array and then initialize its contents. When using an array, a separate
</p>
<p>procedural block handles assigning the contents of the array to the output based on the incoming
</p>
<p>address. The array can be initialized using either an initial block or through the file I/O system tasks
</p>
<p>$readmemb() or $readmemh(). Example 10.2 shows two approaches for modeling a 4�4 ROMmemory.
</p>
<p>In this example the memory is asynchronous, meaning that as soon as the address changes, the data
</p>
<p>from the ROM will appear immediately. To model this asynchronous behavior, the procedural blocks are
</p>
<p>sensitive to the incoming address. In the simulation, each possible address is provided (i.e., &ldquo;00,&rdquo; &ldquo;01,&rdquo;
</p>
<p>&ldquo;10,&rdquo; and &ldquo;11) to verify that the ROM was initialized correctly.
</p>
<p>Example 10.2
Behavioral models of a 4�4 asynchronous read-only memory in Verilog
</p>
<p>376 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>A synchronous ROM can be created in a similar manner as in the asynchronous approach. The only
</p>
<p>difference is that in a synchronous ROM, a clock edge is used to trigger the procedural block that
</p>
<p>updates data_out. A sensitivity list is used that contains the clock to trigger the assignment. Example
</p>
<p>10.3 shows two Verilog models for a synchronous ROM. Notice that prior to the first clock edge, the
</p>
<p>simulator does not know what to assign to data_out, so it lists the value as unknown (X).
</p>
<p>10.4.2 Read/Write Memory in Verilog
</p>
<p>In a simple read/write memory model, there is an output port that provides data when reading
</p>
<p>(data_out) and an input port that receives data when writing (data_in). Within the module, an array signal
</p>
<p>is declared with elements of type reg. To write to the array, signal assignments are made from the data_in
</p>
<p>port to the element within the array corresponding to the incoming address. To read from the array, the
</p>
<p>Example 10.3
Behavioral models of a 4�4 synchronous read-only memory in Verilog
</p>
<p>10.4 Modeling Memory with Verilog &bull; 377</p>
<p/>
</div>
<div class="page"><p/>
<p>data_out port is assigned the element within the array corresponding to the incoming address. A write
</p>
<p>enable (WE) signal tells the system when to write to the array (WE &frac14; 1) or when to read from the array
</p>
<p>(WE &frac14; 0). In an asynchronous R/W memory, data is immediately written to the array when WE &frac14; 1 and
</p>
<p>data is immediately read from the array when WE &frac14; 0. This is modeled using a procedural block with a
</p>
<p>sensitivity list containing every input to the system. Example 10.4 shows an asynchronous R/W 4�4
</p>
<p>memory system and functional simulation results. In the simulation, each address is initially read from to
</p>
<p>verify that it does not contain data. The data_out port produces unknown (X) for the initial set of read
</p>
<p>operations. Each address in the array is then written to. Finally, the array is read from verifying that the
</p>
<p>data that was written can be successfully retrieved.
</p>
<p>A synchronous read/write memory is made in a similar manner with the exception that a clock is
</p>
<p>used to trigger the procedural block managing the signal assignments. In this case, the WE signal acts
</p>
<p>as a synchronous control signal indicating whether assignments are read from or written to the RWarray.
</p>
<p>Example 10.5 shows the Verilog model for a synchronous read/write memory and the simulation
</p>
<p>waveform showing both read and write cycles.
</p>
<p>Example 10.4
Behavioral model of a 4�4 asynchronous read/write memory in Verilog
</p>
<p>378 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC10.4 Explain the advantage of modeling memory in Verilog without going into the details of
the storage cell operation.
</p>
<p>A) It allows the details of the storage cell to be abstracted from the functional
operation of the memory system.
</p>
<p>B) It is too difficult to model the analog behavior of the storage cell.
</p>
<p>C) There are too many cells to model so the simulation would take too long.
</p>
<p>D) It lets both ROM and R/W memory to be modeled in a similar manner.
</p>
<p>Example 10.5
Behavioral model of a 4�4 synchronous read/write memory in Verilog
</p>
<p>10.4 Modeling Memory with Verilog &bull; 379</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v The term memory refers to large arrays of
digital storage. The technology used in mem-
ory is typically optimized for storage density
at the expense of control capability. This is
different from a D-flip-flop, which is optimized
for complete control at the bit level.
</p>
<p>v A memory device always contains an
address bus input. The number of bits in the
address bus dictates how many storage
locations can be accessed. An n-bit address
bus can access 2n (or M) storage locations.
</p>
<p>v The width of each storage location (N) allows
the density of the memory array to be
increased by reading and writing vectors of
data instead of individual bits.
</p>
<p>v A memory map is a graphical depiction of a
memory array. A memory map is useful to
give an overview of the capacity of the array
and how different address ranges of the array
are used.
</p>
<p>v A read is an operation in which data is
retrieved from memory. A write is an opera-
tion in which data is stored to memory.
</p>
<p>v An asynchronous memory array responds
immediately to its control inputs. A synchro-
nous memory array only responds on the
triggering edge of clock.
</p>
<p>v Volatile memory will lose its data when the
power is removed. Non-volatile memory will
retain its data when the power is removed.
</p>
<p>v Read-only memory (ROM) is a memory type
that cannot be written to during normal oper-
ation. Read/write (R/W) memory is a memory
type that can be written to during normal
operation. Both ROM and R/W memory can
be read from during normal operation.
</p>
<p>v Random-accessmemory (RAM) is a memory
type in which any location in memory can be
accessed at any time. In sequential access
memory, the data can only be retrieved in a
linear sequence. This means that in sequen-
tial memory the data cannot be accessed
arbitrarily.
</p>
<p>v The basic architecture of a ROM consists of
intersecting bit lines (vertical) and word lines
(horizontal) that contain storage cells at their
crossing points. The data is read out of the
ROM array using the bit lines. Each bit line
contains a pull-up resistor to initially store a
logic 1 at each location. If a logic 0 is desired
at a certain location, a pull-down transistor is
placed on a particular bit line with its gate
connected to the appropriate word line.
When the storage cell is addressed, the
word line will assert and turn on the pull-
down transistor producing a logic 0 on the
output.
</p>
<p>v There are a variety of technologies to imple-
ment the pull-down transistor in a ROM. Dif-
ferent ROM architectures include MROMs,
PROMs, EPROMs, and EEPROMs. These
memory types are non-volatile.
</p>
<p>v A R/W memory requires a storage cell that
can be both read from and written to during
normal operation. A DRAM (dynamic RAM)
cell is a storage element that uses a capaci-
tor to hold charge corresponding to a logic
value. An SRAM (static RAM) cell is a stor-
age element that uses a cross-coupled
inverter pair to hold the value being stored
in the positive feedback loop formed by the
inverters. Both DRAM and SRAM are volatile
and random access.
</p>
<p>v The floating-gate transistor enables memory
that is both non-volatile and R/W. Modern
memory systems based on floating-gate
transistor technology allow writing to take
place using the existing system power supply
levels. This type of R/W memory is called
FLASH. In FLASH memory, the information
is read out in blocks; thus it is not technically
random access.
</p>
<p>v Memory can be modeled in Verilog using an
array data type consisting of elements of
type reg.
</p>
<p>Exercise Problems
</p>
<p>Section 10.1: Memory Architecture
and Terminology
</p>
<p>10.1.1 For a 512k � 32 memory system, how many
unique address locations are there? Give the
exact number.
</p>
<p>10.1.2 For a 512k � 32 memory system, what is the
data width at each address location?
</p>
<p>10.1.3 For a 512k � 32 memory system, what is the
capacity in bits?
</p>
<p>10.1.4 For a 512k � 32-bit memory system, what is
the capacity in bytes?
</p>
<p>10.1.5 For a 512k � 32 memory system, how wide
does the incoming address bus need to be in
order to access every unique address
location?
</p>
<p>380 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>10.1.6 Name the type of memory with the following
characteristic: when power is removed, the
data is lost.
</p>
<p>10.1.7 Name the type of memory with the following
characteristic: when power is removed, the
memory still holds its information.
</p>
<p>10.1.8 Name the type of memory with the following
characteristic: it can only be read from during
normal operation.
</p>
<p>10.1.9 Name the type of memory with the following
characteristic: during normal operation, it can
be read and written to.
</p>
<p>10.1.10 Name the type of memory with the following
characteristic: data can be accessed from any
address location at any time.
</p>
<p>10.1.11 Name the type of memory with the following
characteristic: data can only be accessed in
consecutive order, thus not every location of
memory is available instantaneously.
</p>
<p>Section 10.2: Non-volatile Memory
Technology
</p>
<p>10.2.1 Name the type of memory with the following
characteristic: this memory is non-volatile,
read/write, and only provides data access in
blocks.
</p>
<p>10.2.2 Name the type of memory with the following
characteristic: this memory uses a floating-
gate transistor, can be erased with electricity,
and provides individual bit access.
</p>
<p>10.2.3 Name the type of memory with the following
characteristic: this memory is non-volatile,
read/write, and provides word-level data
access.
</p>
<p>10.2.4 Name the type of memory with the following
characteristic: this memory uses a floating-
gate transistor that is erased with UV light.
</p>
<p>10.2.5 Name the type of memory with the following
characteristic: this memory is programmed by
blowing fuses or anti-fuses.
</p>
<p>10.2.6 Name the type of memory with the following
characteristic: this memory is partially
fabricated prior to knowing the information to
be stored.
</p>
<p>Section 10.3: Volatile Memory
Technology
</p>
<p>10.3.1 How many transistors does it take to imple-
ment an SRAM cell?
</p>
<p>10.3.2 Why doesn&rsquo;t an SRAM cell require a refresh
cycle?
</p>
<p>10.3.3 Design a Verilog model for the SRAM system
shown in Fig. 10.20. Your storage cell should
be designed such that its contents can be
overwritten by the line driver. Consider using
signal strengths for this behavior (e.g., strong1
will overwrite a weak0). You will need to create
a system for the differential line driver with
enable. This driver will need to contain a high
impedance state when disabled. Both your line
</p>
<p>driver (Din) and receiver (Dout) are differential.
These systems can be modeled using simple
if-else statements. Create a test bench for your
system that will write a 0 to the cell, then read it
back to verify the 0 was stored, and then repeat
the write/read cycles for a 1.
</p>
<p>Fig. 10.20
SRAM cell block diagram
</p>
<p>10.3.4 Why is a DRAM cell referred to as a 1 T 1C
configuration?
</p>
<p>10.3.5 Why is a charge pump necessary on the word
lines of a DRAM array?
</p>
<p>10.3.6 Why does a DRAM cell require a refresh cycle?
</p>
<p>10.3.7 For the DRAM storage cell shown in Fig. 10.21,
solve for the final voltage on the digit line after
the access transistor (M1) closes if initially
VS &frac14; VCC (i.e., the cell is storing a 1). In this
system, CS &frac14; 5 pF, CDL &frac14; 10 pF, and
VCC &frac14; +3.4v. Prior to the access transistor
closing, the digit line is pre-charged to VCC/2.
</p>
<p>Fig. 10.21
DRAM charge sharing exercise
</p>
<p>10.3.8 For the DRAM storage cell shown in Fig. 10.21,
solve for the final voltage on the digit line after
the access transistor (M1) closes if initially
VS &frac14; GND (i.e., the cell is storing a 0). In
this system, CS &frac14; 5 pF, CDL &frac14; 10 pF, and
VCC &frac14; +3.4v. Prior to the access transistor
closing, the digit line is pre-charged to VCC/2.
</p>
<p>Exercise Problems &bull; 381</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 10.4: Modeling Memory
with Verilog
</p>
<p>10.4.1 Design a Verilog model for the 16�8, asyn-
chronous, read-only memory system shown
in Fig. 10.22. The system should contain the
information provided in the memory map. Cre-
ate a test bench to simulate your model by
reading from each of the 16 unique addresses
and observing data_out to verify it contains the
information in the memory map.
</p>
<p>Fig. 10.22
16�8 asynchronous ROM block diagram
</p>
<p>10.4.2 Design a Verilog model for the 16�8, synchro-
nous, read-only memory system shown in
Fig. 10.23. The system should contain the
information provided in the memory map. Cre-
ate a test bench to simulate your model by
reading from each of the 16 unique addresses
and observing data_out to verify it contains the
information in the memory map.
</p>
<p>Fig. 10.23
16�8 synchronous ROM block diagram
</p>
<p>10.4.3 Design a Verilog model for the 16�8, asyn-
chronous, read/write memory system shown
in Fig. 10.24. Create a test bench to simulate
your model. Your test bench should first read
from all of the address locations to verify they
are uninitialized. Next, your test bench should
write unique information to each of the address
locations. Finally, your test bench should read
from each address location to verify that the
information that was written was stored and
can be successfully retrieved.
</p>
<p>Fig. 10.24
16�8 asynchronous R/W memory block diagram
</p>
<p>10.4.4 Design a Verilog model for the 16�8, synchro-
nous, read/write memory system shown in
Fig. 10.25. Create a test bench to simulate
your model. Your test bench should first read
from all of the address locations to verify they
are uninitialized. Next, your test bench should
write unique information to each of the address
locations. Finally, your test bench should read
from each address location to verify that the
information that was written was stored and
can be successfully retrieved.
</p>
<p>Fig. 10.25
16�8 synchronous R/W memory block diagram
</p>
<p>382 &bull; Chapter 10: Memory</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 11: Programmable Logic
This chapter provides an overview of programmable logic devices (PLDs). The term PLD is used as
</p>
<p>a generic description for any circuit that can be programmed to implement digital logic. The technology
</p>
<p>and architectures of PLDs have advanced over time. A historical perspective is given on how the first
</p>
<p>programmable devices evolved into the programmable technologies that are prevalent today. The goal of
</p>
<p>this chapter is to provide a basic understanding of the principles of programmable logic devices.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>11.1 Describe the basic architecture and evolution of programmable logic devices.
11.2 Describe the basic architecture of field-programmable gate arrays (FPGAs).
</p>
<p>11.1 Programmable Arrays
</p>
<p>11.1.1 Programmable Logic Array (PLA)
</p>
<p>One of the first commercial PLDs developed using modern integrated circuit technology was the
</p>
<p>programmable logic array (PLA). In 1970, Texas Instrument introduced the PLA with an architecture
</p>
<p>that supported the implementation of arbitrary, sum of products logic expressions. The PLA was
</p>
<p>fabricated with a dense array of AND gates, called an AND plane, and a dense array of OR gates,
</p>
<p>called anOR plane. Inputs to the PLA each had an inverter in order to provide the original variable and its
</p>
<p>complement. Arbitrary SOP logic expressions could be implemented by creating connections between
</p>
<p>the inputs, the AND plane, and the OR plane. The original PLAs were fabricated with all of the necessary
</p>
<p>features except the final connections to implement the SOP functions. When a customer provided the
</p>
<p>desired SOP expression, the connections were added as the final step of fabrication. This configuration
</p>
<p>technique was similar to an MROM approach. Figure 11.1 shows the basic architecture of a PLA.
</p>
<p>Fig. 11.1
Programmable logic array (PLA) architecture
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_11
</p>
<p>383</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_11&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_11&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>A more compact schematic for the PLA is drawn by representing all of the inputs into the AND and
</p>
<p>OR gates with a single wire. Connections are indicated by inserting X&rsquo;s at the intersections of wires.
</p>
<p>Figure 11.2 shows this simplified PLA schematic implementing two different SOP logic expressions.
</p>
<p>11.1.2 Programmable Array Logic (PAL)
</p>
<p>One of the drawbacks of the original PLA was that the programmability of the OR plane caused
</p>
<p>significant propagation delays through the combinational logic circuits. In order to improve on the
</p>
<p>performance of PLAs, the programmable array logic (PAL) was introduced in 1978 by the company
</p>
<p>Monolithic Memories, Inc. The PAL contained a programmable AND plane and a fixed-OR plane. The
</p>
<p>fixed-OR plane improved the performance of this programmable architecture. While not having a
</p>
<p>programmable OR plane reduced the flexibility of the device, most SOP expressions could be
</p>
<p>manipulated to work with a PAL. Another contribution of the PAL was that the AND plane could be
</p>
<p>programmed using fuses. Initially, all connections were present in the AND plane. An external program-
</p>
<p>mer was used to blow fuses in order to disconnect the inputs from the AND gates. While the fuse
</p>
<p>approach provided one-time-only programming, the ability to configure the logic post-fabrication was a
</p>
<p>significant advancement over the PLA, which had to be programmed at the manufacturer. Figure 11.3
</p>
<p>shows the architecture of a PAL.
</p>
<p>Fig. 11.2
Simplified PLA schematic
</p>
<p>384 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>11.1.3 Generic Array Logic (GAL)
</p>
<p>As the popularity of the PAL grew, additional functionality was implemented to support more
</p>
<p>sophisticated designs. One of the most significant improvements was the addition of an output logic
</p>
<p>macrocell (OLMC). An OLMC provided a D-flip-flop and a selectable mux so that the output of the SOP
</p>
<p>circuit from the PAL could be used either as the system output or the input to a D-flip-flop. This enabled
</p>
<p>the implementation of sequential logic and finite-state machines. The OLMC also could be used to route
</p>
<p>the I/O pin back into the PAL to increase the number of inputs possible in the SOP expressions. Finally,
</p>
<p>the OLMC provided a multiplexer to allow feedback from either the PAL output or the output of the D-flip-
</p>
<p>flop. This architecture was named a generic array logic (GAL) to distinguish its features from a
</p>
<p>standard PAL. Figure 11.4 shows the architecture of a GAL consisting of a PAL and an OLMC.
</p>
<p>Fig. 11.3
Programmable array logic (PAL) architecture
</p>
<p>11.1 Programmable Arrays &bull; 385</p>
<p/>
</div>
<div class="page"><p/>
<p>11.1.4 Hard Array Logic (HAL)
</p>
<p>For mature designs, PALs and GALs could be implemented as a hard array logic (HAL) device. A
</p>
<p>HAL was a version of a PAL or GAL that had the AND plane connections implemented during fabrication
</p>
<p>instead of through blowing fuses. This architecture was more efficient for high-volume applications as it
</p>
<p>eliminated the programming step post-fabrication, and the device did not need to contain the additional
</p>
<p>programming circuitry.
</p>
<p>In 1983, Altera Inc. was founded as a programmable logic device company. In 1984, Altera released
</p>
<p>its first version of a PAL with a unique feature that it could be programmed and erased multiple times
</p>
<p>using a programmer and an UV light source similar to an EEPROM.
</p>
<p>11.1.5 Complex Programmable Logic Devices (CPLD)
</p>
<p>As the demand for larger programmable devices grew, the PAL&rsquo;s architecture was not able to scale
</p>
<p>efficiently due to a number of reasons: first, as the size of combinational logic circuits increased, the PAL
</p>
<p>encountered fan-in issues in its AND plane, and second, for each input that was added to the PAL, the
</p>
<p>amount of circuitry needed on the chip grew geometrically due to requiring a connection to each AND
</p>
<p>gate in addition to the area associated with the additional OLMC. This led to a new PLD architecture in
</p>
<p>which the on-chip interconnect was partitioned across multiple PALs on a single chip. This partitioning
</p>
<p>meant that not all inputs to the device could be used by each PAL so the design complexity increased;
</p>
<p>however, the additional programmable resources outweighed this drawback, and this architecture was
</p>
<p>broadly adopted. This new architecture was called a complex programmable logic device (CPLD).
</p>
<p>Fig. 11.4
Generic array logic (GAL) architecture
</p>
<p>386 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>The term simple programmable logic device (SPLD) was created to describe all of the previous PLD
</p>
<p>architectures (i.e., PLA, PAL, GAL, and HAL). Figure 11.5 shows the architecture of the CPLD.
</p>
<p>CONCEPT CHECK
</p>
<p>CC11.1 What is the only source of delay mismatch from the inputs to the outputs in a
programmable array?
</p>
<p>A) The AND gates will have different delays due to having different numbers of
inputs.
</p>
<p>B) The OR gates will have different delays due to having different numbers of
inputs.
</p>
<p>C) An input may or may not go through an inverter before reaching the AND
gates.
</p>
<p>D) None. All paths through the programmable array have identical delay.
</p>
<p>11.2 Field-Programmable Gate Arrays (FPGAs)
</p>
<p>To address the need for even more programmable resources, a new architecture was developed by
</p>
<p>Xilinx Inc. in 1985. This new architecture was called a field-programmable gate array (FPGA). An
</p>
<p>FPGA consists of an array of programmable logic blocks (or logic elements) and a network of program-
</p>
<p>mable interconnect that can be used to connect any logic element to any other logic element. Each logic
</p>
<p>Fig. 11.5
Complex PLD (CPLD) architecture
</p>
<p>11.2 Field-Programmable Gate Arrays (FPGAs) &bull; 387</p>
<p/>
</div>
<div class="page"><p/>
<p>block contained circuitry to implement arbitrary combinational logic circuits in addition to a D-flip-flop and
</p>
<p>a multiplexer for signal steering. This architecture effectively implemented an OLMC within each block,
</p>
<p>thus providing ultimate flexibility and providing significantly more resources for sequential logic. Today,
</p>
<p>FPGAs are the most commonly used programmable logic device with Altera Inc. and Xilinx Inc. being the
</p>
<p>two largest manufacturers. Figure 11.6 shows the generic architecture of an FPGA.
</p>
<p>11.2.1 Configurable Logic Block (or Logic Element)
</p>
<p>The primary reconfigurable structure in the FPGA is the configurable logic block (CLB) or logic
</p>
<p>element (LE). Xilinx Inc. uses the term CLB, while Altera uses LE. Combinational logic is implemented
</p>
<p>using a circuit called a look-up table (LUT), which can implement any arbitrary truth table. The details of
</p>
<p>Fig. 11.6
Field-programmable gate array (FPGA) architecture
</p>
<p>388 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>a LUTare given in the next section. The CLB/LE also contains a D-flip-flop for sequential logic. A signal
</p>
<p>steering multiplexer is used to select whether the output of the CLB/LE comes from the LUTor from the
</p>
<p>D-flip-flop. The LUT can be used to drive a combinational logic expression into the D input of the D-flip-
</p>
<p>flop, thus creating a highly efficient topology for finite-state machines. A global routing network is used to
</p>
<p>provide common signals to the CLB/LE such as clock, reset, and enable. This global routing network can
</p>
<p>provide these common signals to the entire FPGA or local groups of CLB/LEs. Figure 11.7 shows the
</p>
<p>topology of a simple CLB/LE.
</p>
<p>CLB/LEs have evolved to include numerous other features such as carry-in/carry-out signals so that
</p>
<p>arithmetic operations can be cascaded between multiple blocks in addition to signal feedback and D-flip-
</p>
<p>flop initialization.
</p>
<p>11.2.2 Look-Up Tables (LUTs)
</p>
<p>A look-up table is the primary circuit used to implement combinational logic in FPGAs. This topology
</p>
<p>has also been adopted in modern CPLDs. In a LUT, the desired outputs of a truth table are loaded into a
</p>
<p>local configuration SRAM memory. The SRAM memory provides these values to the inputs of a
</p>
<p>multiplexer. The inputs to the combinational logic circuit are then used as the select lines to the
</p>
<p>multiplexer. For an arbitrary input to the combinational logic circuit, the multiplexer selects the appropri-
</p>
<p>ate value held in the SRAM and routes it to the output of the circuit. In this way, the multiplexer looks up
</p>
<p>the appropriate output value based on the input code. This architecture has the advantage that any logic
</p>
<p>function can be created without creating a custom logic circuit. Also, the delay through the LUT is
</p>
<p>identical regardless of what logic function is being implemented. Figure 11.8 shows a 2-input combina-
</p>
<p>tional logic circuit implemented with a 4-input multiplexer.
</p>
<p>Fig. 11.7
Simple FPGA configurable logic block (or logic element)
</p>
<p>11.2 Field-Programmable Gate Arrays (FPGAs) &bull; 389</p>
<p/>
</div>
<div class="page"><p/>
<p>Fan-in limitations can be encountered quickly in LUTs as the number of inputs of the combinational
</p>
<p>logic circuit being implemented grows. Recall that multiplexers are implemented with an SOP topology in
</p>
<p>which each product term in the first level of logic has a number of inputs equal to the number of select
</p>
<p>lines plus one. Also recall that the sum term in the second level of logic in the SOP topology has a
</p>
<p>number of inputs equal to the total number of inputs to the multiplexer. In the example circuit shown in
</p>
<p>Fig. 11.8, each product term in the multiplexer will have three inputs, and the sum term will have four
</p>
<p>inputs. As an illustration of how quickly fan-in limitations are encountered, consider the implication of
</p>
<p>increasing the number of inputs in Fig. 11.8 from two to three. In this new configuration, the number of
</p>
<p>inputs in the product terms will increase from three to four and the number of inputs in the sum term will
</p>
<p>increase from four to eight. Eight inputs are often beyond the fan-in specifications of modern devices,
</p>
<p>meaning that even a 3-input combinational logic circuit will encounter fan-in issues when implemented
</p>
<p>using a LUT topology.
</p>
<p>To address this issue, multiplexer functionality in LUTs is typically implemented as a series of
</p>
<p>smaller, cascaded multiplexers. Each of the smaller multiplexers progressively choose which row of
</p>
<p>the truth table to route to the output of the LUT. This eliminates fan-in issues at the expense of adding
</p>
<p>additional levels of logic to the circuit. While cascading multiplexers increases the overall circuit delay,
</p>
<p>this approach achieves a highly consistent delay because regardless of the truth table output value, the
</p>
<p>number of levels of logic through the multiplexers is always the same. Figure 11.9 shows how the 2-input
</p>
<p>truth table from Fig. 11.8 can be implemented using a 2-level cascade of 2-input multiplexers.
</p>
<p>Fig. 11.8
2-input LUT implemented with a 4-input multiplexer
</p>
<p>390 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 11.9
2-input LUT implemented with a 2-level cascade of 2-input multiplexers
</p>
<p>11.2 Field-Programmable Gate Arrays (FPGAs) &bull; 391</p>
<p/>
</div>
<div class="page"><p/>
<p>If more inputs are needed in the LUT, additional MUX levels are added. Figure 11.10 shows the
</p>
<p>architecture for a 3-input LUT implemented with a 3-level cascade of 2-input multiplexers.
</p>
<p>Modern FPGAs can have LUTs with up to six inputs. If even more inputs are needed in a combina-
</p>
<p>tional logic expression, then multiple CLB/LEs are used that form even larger LUTs.
</p>
<p>11.2.3 Programmable Interconnect Points (PIPs)
</p>
<p>The configurable routing network on an FPGA is accomplished using programmable switches. A
</p>
<p>simple model for these switches is to use an NMOS transistor. A configuration SRAM bit stores whether
</p>
<p>the switch is opened or closed. On the FPGA, interconnect is routed vertically and horizontally between
</p>
<p>the CLB/LEs with switching points placed throughout the FPGA to facilitate any arbitrary routing
</p>
<p>configuration. Figure 11.11 shows how the routing can be configured into a full cross-point configuration
</p>
<p>using programmable switches.
</p>
<p>Fig. 11.10
3-input LUT implemented with a 3-level cascade of 2-input multiplexers
</p>
<p>392 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2.4 Input/Output Block (IOB)
</p>
<p>FPGAs also contain input/output blocks (IOBs) that provide programmable functionality for
</p>
<p>interfacing to external circuitry. The IOBs contain both driver and receiver circuitry so that they can be
</p>
<p>programmed to be either inputs or outputs. D-flip-flops are included in both the input and output circuitry
</p>
<p>to support synchronous logic. Figure 11.12 shows the architecture of an FPGA IOB.
</p>
<p>Fig. 11.11
FPGA programmable interconnect
</p>
<p>11.2 Field-Programmable Gate Arrays (FPGAs) &bull; 393</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2.5 Configuration Memory
</p>
<p>All of the programming information for an FPGA is contained within configuration SRAM that is
</p>
<p>distributed across the IC. Since this memory is volatile, the FPGA will lose its configuration when power
</p>
<p>is removed. Upon power-up, the FPGA must be programmed with its configuration data. This data is
</p>
<p>typically held in a nonvolatile memory such as FLASH. The &ldquo;FP&rdquo; in FPGA refers to the ability to program
</p>
<p>the device in the field, or post-fabrication. The &ldquo;GA&rdquo; in FPGA refers to the array topology of the
</p>
<p>programmable logic blocks or elements.
</p>
<p>CONCEPT CHECK
</p>
<p>CC11.2 What is the primary difference between an FPGA and a CPLD?
</p>
<p>A) The ability to create arbitrary SOP logic expressions.
</p>
<p>B) The abundance of configurable routing.
</p>
<p>C) The inclusion of D-flip-flops.
</p>
<p>D) The inclusion of programmable I/O pins.
</p>
<p>Fig. 11.12
FPGA input/output block (IOB)
</p>
<p>394 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v A programmable logic device (PLD) is a
generic term for a circuit that can be
configured to implement arbitrary logic
functions.
</p>
<p>v There are a variety of PLD architectures that
have been used to implement combinational
logic. These include the PLA and PAL. These
devices contain an AND plane and an OR
plane. The AND plane is configured to imple-
ment the product terms of a SOP expression.
The OR plane is configured to implement the
sum term of a SOP expression.
</p>
<p>v A GAL increases the complexity of logic
arrays by adding sequential logic storage
and programmable I/O capability.
</p>
<p>v A CPLD significantly increases the density of
PLDs by connecting an array of PALs
together and surrounding the logic with I/O
drivers.
</p>
<p>v FPGAs contain an array of programmable
logic elements that each consist of combina-
tional logic capability and sequential logic
storage. FPGAs also contain a programma-
ble interconnect network that provides the
highest level of flexibility in programmable
logic.
</p>
<p>v A look-up table (LUT) is a simple method to
create a programmable combinational logic
circuit. A LUT is simply a multiplexer with the
inputs to the circuit connected to the select
lines of the MUX. The desired outputs of the
truth table are connected to the MUX inputs.
As different input codes arrive on the select
lines of the MUX, they select the
corresponding logic value to be routed to
the system output.
</p>
<p>Exercise Problems
</p>
<p>Section 11.1: Programmable Arrays
</p>
<p>11.1.1 Name the type of programmable logic
described by the characteristic: this device
adds an output logic macrocell to a traditional
PAL.
</p>
<p>11.1.2 Name the type of programmable logic
described by the characteristic: this device
combines multiple PALs on a single chip with
a partitioned interconnect system.
</p>
<p>11.1.3 Name the type of programmable logic
described by the characteristic: this device
has a programmable AND plane and program-
mable OR plane.
</p>
<p>11.1.4 Name the type of programmable logic
described by the characteristic: this device
has a programmable AND plane and fixed-
OR plane.
</p>
<p>11.1.5 Name the type of programmable logic
described by the characteristic: this device is
a PAL or GAL that is programmed during
manufacturing.
</p>
<p>11.1.6 For the following unconfigured PAL schematic
in Fig. 11.13, draw in the connection points
(i.e., the X&rsquo;s) to implement the two SOP logic
expressions shown on the outputs.
</p>
<p>Fig. 11.13
Blank PAL schematic
</p>
<p>Exercise Problems &bull; 395</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 11.2: Field-Programmable Gate
Arrays (FPGAs)
</p>
<p>11.2.1 Give a general description of a field-
programmable gate array that differentiates it
from other programmable logic devices.
</p>
<p>11.2.2 Which part of an FPGA is described by the
following characteristic: this is used to interface
between the internal logic and external
circuitry.
</p>
<p>11.2.3 Which part of an FPGA is described by the
following characteristic: this is used to config-
ure the on-chip routing.
</p>
<p>11.2.4 Which part of an FPGA is described by the
following characteristic: this is the primary pro-
grammable element that makes up the array.
</p>
<p>11.2.5 Which part of an FPGA is described by the
following characteristic: this part is used to
implement the combinational logic within the
array.
</p>
<p>11.2.6 Draw the logic diagram of a 4-input look-up
table (LUT) to implement the truth table
provided in Fig. 11.14. Implement the LUT
with only 2-input multiplexers. Be sure to label
</p>
<p>the exact location of the inputs (A, B, C, and D),
the desired value for each row of the truth
table, and the output (F) in the diagram.
</p>
<p>Fig. 11.14
4-input LUT exercise
</p>
<p>396 &bull; Chapter 11: Programmable Logic</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 12: Arithmetic Circuits
This chapter presents the design and timing considerations of circuits to perform basic arithmetic
</p>
<p>operations including addition, subtraction, multiplication, and division. A discussion is also presented on
</p>
<p>how to model arithmetic circuits in Verilog. The goal of this chapter is to provide an understanding of the
</p>
<p>basic principles of binary arithmetic circuits.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>12.1 Design a binary adder using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>12.2 Design a binary subtractor using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>12.3 Design a binary multiplier using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>12.4 Design a binary divider using both the classical digital design approach and the modern
HDL-based approach.
</p>
<p>12.1 Addition
</p>
<p>Binary addition is performed in a similar manner to performing decimal addition by hand. The
</p>
<p>addition begins in the least significant position of the number ( p &frac14; 0). The addition produces the sum
</p>
<p>for this position. In the event that this positional sum cannot be represented by a single symbol, then the
</p>
<p>higher-order symbol is carried to the subsequent position (p&frac14; 1). The addition in the next higher position
</p>
<p>must include the number that was carried in from the lower positional sum. This process continues until
</p>
<p>all of the symbols in the number have been operated on. The final positional sum can also produce a
</p>
<p>carry, which needs to be accounted for in a separate system.
</p>
<p>Designing a binary adder involves creating a combinational logic circuit to perform the positional
</p>
<p>additions. Since a combinational logic circuit can only produce a scalar output, circuitry is needed to
</p>
<p>produce the sum and the carry at each position. The binary adder size is predetermined and fixed prior to
</p>
<p>implementing the logic (i.e., an n-bit adder). Both inputs to the adder must adhere to the fixed size,
</p>
<p>regardless of their value. Smaller numbers simply contain leading zeros in their higher-order positions.
</p>
<p>For an n-bit adder, the largest sum that can be produced will require n + 1 bits. To illustrate this, consider
</p>
<p>a 4-bit adder. The largest numbers that the adder will operate on are 11112 + 11112 (or 1510 + 1510). The
</p>
<p>result of this addition is 111102 (or 3010). Notice that the largest sum produced fits within 5 bits or n + 1.
</p>
<p>When constructing an adder circuit, the sum is always recorded using n-bits with a separate carry out bit.
</p>
<p>In our 4-bit example, the sum would be expressed as &ldquo;1110&rdquo; with a carry out. The carry out bit can be
</p>
<p>used in multiple word additions, used as part of the number when being decoded for a display, or simply
</p>
<p>discarded as in the case when using two&rsquo;s complement numbers.
</p>
<p>12.1.1 Half Adders
</p>
<p>When creating an adder, it is desirable to design incremental sub-systems that can be re-used. This
</p>
<p>reduces design effort and minimizes troubleshooting complexity. The most basic component in the adder
</p>
<p>is called a half adder. This circuit computes the sum and carry out on two input arguments. The reason it
</p>
<p>is called a half adder instead of a full adder is because it does not accommodate a carry in during the
</p>
<p>computation; thus it does not provide all of the necessary functionality required for the positional adder.
</p>
<p>Example 12.1 shows the design of a half adder. Notice that two combinational logic circuits are required
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_12
</p>
<p>397</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_12&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_12&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>in order to produce the sum (the XOR gate) and the carry out (the AND gate). These two gates are in
</p>
<p>parallel to each other; thus the delay through the half adder is due to only one level of logic.
</p>
<p>12.1.2 Full Adders
</p>
<p>A full adder is a circuit that still produces a sum and carry out but considers three inputs in the
</p>
<p>computations (A, B, and Cin). Example 12.2 shows the design of a full adder.
</p>
<p>Example 12.1
Design of a half adder
</p>
<p>Example 12.2
Design of a full adder
</p>
<p>398 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>As mentioned before, it is desirable to re-use design components as we construct more complex
</p>
<p>systems. One such design re-use approach is to create a full adder using two half adders. This is
</p>
<p>straightforward for thesumoutput since the logic is simply twocascadedXORgates (Sum&frac14;A
L
</p>
<p>B
L
</p>
<p>Cin).
</p>
<p>The carry out is not as straightforward. Notice that the expression for Cout derived in Example 12.2
</p>
<p>contains the term (A + B). If this term could be manipulated to use an XOR gate instead, it would allow the
</p>
<p>full adder to take advantage of existing circuitry in the system. Figure 12.1 shows a derivation of an
</p>
<p>equivalency that allows (A + B) to be replaced with (A
L
</p>
<p>B) in the Cout logic expression.
</p>
<p>The ability to implement the carry out logic using the expression Cout &frac14; A�B + (A
L
</p>
<p>B)�Cin allows us
</p>
<p>to implement a full adder with two half adders and the addition of a single OR gate. Example 12.3 shows
</p>
<p>this approach. In this new configuration, the sum is produced in two levels of logic, while the carry out is
</p>
<p>produced in three levels of logic.
</p>
<p>Fig. 12.1
A useful logic equivalency that can be exploited in arithmetic circuits
</p>
<p>12.1 Addition &bull; 399</p>
<p/>
</div>
<div class="page"><p/>
<p>12.1.3 Ripple Carry Adder (RCA)
</p>
<p>The full adder can now be used in the creation of multi-bit adders. The simplest topology exploiting
</p>
<p>the full adder is called a ripple carry adder (RCA). In this approach, full adders are used to create the sum
</p>
<p>and carry out of each bit position. The carry out of each full adder is used as the carry in for the next
</p>
<p>higher position. Since each subsequent full adder needs to wait for the carry to be produced by the
</p>
<p>preceding stage, the carry is said to ripple through the circuit, thus giving this approach its name.
</p>
<p>Example 12.4 shows how to design a 4-bit ripple carry adder using a chain of full adders. Notice that
</p>
<p>the carry in for the full adder in position 0 is tied to a logic 0. The 0 input has no impact on the result of the
</p>
<p>sum but enables a full adder to be used in the 0th position.
</p>
<p>Example 12.3
Design of a full adder out of half adders
</p>
<p>400 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>While the ripple carry adder provides a simple architecture based on design re-use, its delay can
</p>
<p>become considerable when scaling to larger input sizes (e.g., n &frac14; 32 or n &frac14; 64). A simple analysis of the
</p>
<p>timing can be stated such that if the time for a full adder to complete its positional sum is tFA, then the time
</p>
<p>for an n-bit ripple carry adder to complete its computation is tRCA &frac14; n�tFA.
</p>
<p>If we examine the RCA in more detail, we can break down the delay in terms of the levels of logic
</p>
<p>necessary for the computation. Example 12.5 shows the timing analysis of the 4-bit RCA. This analysis
</p>
<p>determines the number of logic levels in the adder. The actual gate delays can then be plugged in to find
</p>
<p>the final delay. The inputs to the adder are A, B, and Cin and are always assumed to update at the same
</p>
<p>time. The first full adder requires two levels of logic to produce its sum and three levels to produce its
</p>
<p>carry out. Since the timing of a circuit is always stated as its worst-case delay, we say that the first full
</p>
<p>adder takes three levels of logic. When the carry (C1) ripples to the next full adder (FA1), it must
</p>
<p>propagate through two additional levels of logic in order to produce C2. Notice that the first half adder
</p>
<p>in FA1 only depends on A1 and B1; thus it is able to perform this computation immediately. This half adder
</p>
<p>can be considered as first level logic. More importantly, it means that when the carry in arrives (C1), only
</p>
<p>two additional levels of logic are needed, not three. The levels of logic for the RCA can be expressed as
</p>
<p>3 + 2�(n�1). If each level of logic has a delay of tgate, then a more accurate expression for the RCA delay
</p>
<p>is tRCA &frac14; (3 + 2�(n�1))�tgate.
</p>
<p>Example 12.4
Design of a 4-bit ripple carry adder (RCA)
</p>
<p>12.1 Addition &bull; 401</p>
<p/>
</div>
<div class="page"><p/>
<p>12.1.4 Carry Look Ahead Adder (CLA)
</p>
<p>In order to address the potentially significant delay of a ripple carry adder, a carry look ahead (CLA)
</p>
<p>adder was created. In this approach, additional circuitry is included that produces the intermediate carry
</p>
<p>in signals immediately instead of waiting for them to be created by the preceding full adder stage. This
</p>
<p>allows the adder to complete in a fixed amount of time instead of one that scales with the number of bits in
</p>
<p>the adder. Example 12.6 shows an overview of the design approach for a CLA.
</p>
<p>Example 12.5
Timing analysis of a 4-bit ripple carry adder
</p>
<p>402 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>For the CLA architecture to be effective, the look ahead circuitry needs to be dependent only on the
</p>
<p>system inputs A, B, and Cin (i.e., C0). A secondary characteristic of the CLA is that it should exploit as
</p>
<p>much design re-use as possible. In order to examine the design re-use aspects of a multi-bit adder, the
</p>
<p>concepts of carry generation (g) and propagation (p) are used. A full adder is said to generate a carry if
</p>
<p>its inputs A and B result in Cout &frac14; 1 when Cin &frac14; 0. A full adder is said to propagate a carry if its inputs A
</p>
<p>and B result in Cout &frac14; 1 when Cin &frac14; 1. These simple statements can be used to derive logic expressions
</p>
<p>for each stage of the adder that can take advantage of existing logic terms from prior stages. Example
</p>
<p>12.7 shows the derivation of these terms and how algebraic substitutions can be exploited to create look
</p>
<p>ahead circuitry for each full adder that is only dependent on the system inputs. In these derivations, the
</p>
<p>variable i is used to represent position since p is used to represent the propagate term.
</p>
<p>Example 12.6
Design of a 4-bit carry look ahead adder (CLA) &ndash; Overview
</p>
<p>12.1 Addition &bull; 403</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 12.8 shows a timing analysis of the 4-bit carry look ahead adder. Notice that the full adders
</p>
<p>are modified to add the logic for the generate and propagate bits in addition to removing the unnecessary
</p>
<p>gates associated with creating the carry out.
</p>
<p>Example 12.7
Design of a 4-bit carry look ahead adder (CLA) &ndash; Algebraic formation
</p>
<p>404 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>The 4-bit CLA can produce the sum in four levels of logic as long as fan-in specifications are met. As
</p>
<p>the CLA width increases, the look ahead circuitry will become fan-in limited, and additional stages will be
</p>
<p>required to address the fan-in. Regardless, the CLA has considerably less delay than a RCA as the width
</p>
<p>of the adder is increased.
</p>
<p>12.1.5 Adders in Verilog
</p>
<p>12.1.5.1 Structural Model of a Ripple Carry Adder in Verilog
</p>
<p>A structural model of a ripple carry adder is useful to visualize the propagation delay of the circuit in
</p>
<p>addition to the impact of the carry rippling through the chain. Example 12.9 shows the structural model for
</p>
<p>a full adder in Verilog consisting of two half adders. The half adders are created using two gate-level
</p>
<p>primitives for the XOR and AND operations, each with a delay of 1 ns. The full adder is created by
</p>
<p>instantiating two versions of the half adder as sub-systems plus one additional gate-level primitive for the
</p>
<p>OR gate.
</p>
<p>Example 12.8
Timing analysis of a 4-bit carry look ahead adder
</p>
<p>12.1 Addition &bull; 405</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 12.10 shows the structural model of a 4-bit ripple carry adder in Verilog. The RCA is
</p>
<p>created by instantiating four full adders. Notice that a logic 1&rsquo;b0 can be directly inserted into the port map
</p>
<p>of the first full adder to model the behavior of C0 &frac14; 0.
</p>
<p>Example 12.9
Structural model of a full adder using two half adders in Verilog
</p>
<p>406 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>When creating arithmetic circuitry, testing under all input conditions is necessary to verify function-
</p>
<p>ality. Testing under each and every input condition can require a large number of input conditions. To test
</p>
<p>an n-bit adder under each and every numeric input condition will take (2n)2 test vectors. For our simple
</p>
<p>4-bit adder example, this equates to 256 input patterns. The large number of input patterns precludes the
</p>
<p>use of manual signal assignments in the test bench to stimulate the circuit. One approach to generating
</p>
<p>the input test patterns is to use nested for loops. Example 12.11 shows a test bench that uses two nested
</p>
<p>for loops to generate the 256 unique input conditions for the 4-bit ripple carry adder. Note that the loop
</p>
<p>variables i and j are declared as type integer and then automatically incremented within the for loops.
</p>
<p>Within the loops, the loop variables i and j are assigned to the DUT inputs A_TB and B_TB. The
</p>
<p>truncation to 4-bits is automatically handled in Verilog. The simulation waveform illustrates how the
</p>
<p>ripple carry adder has a noticeable delay before the output sum is produced. During the time the carry is
</p>
<p>rippling through the adder chain, glitches can appear on each of the sum bits in addition to the carry out
</p>
<p>signal. The values in this waveform are displayed as unsigned decimal symbols to make the results
</p>
<p>easier to interpret.
</p>
<p>Example 12.10
Structural model of a 4-bit ripple carry adder in Verilog
</p>
<p>12.1 Addition &bull; 407</p>
<p/>
</div>
<div class="page"><p/>
<p>12.1.5.2 Structural Model of a Carry Look Ahead Adder in Verilog
</p>
<p>A carry look ahead adder can also be modeled using procedural assignments and modified full
</p>
<p>adder sub-systems. Example 12.12 shows a structural model for a 4-bit CLA in Verilog. In this example,
</p>
<p>the gate delay is modeled at 1 ns. The delay due to multiple levels of logic is entered manually to simplify
</p>
<p>the model. The two cascaded XOR gates in the modified full adder are modeled using a single, 3-input
</p>
<p>gate primitive with 2 ns of delay.
</p>
<p>Example 12.11
Test bench for a 4-bit ripple carry adder using nested for loops in Verilog
</p>
<p>408 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 12.13 shows the simulation waveform for the 4-bit carry look ahead adder. The outputs still
</p>
<p>have intermediate transitions, while the combinational logic is computing the results; however, the overall
</p>
<p>delay of the adder is bound to �4*tgate.
</p>
<p>Example 12.12
Structural model of a 4-bit carry look ahead adder in Verilog
</p>
<p>Example 12.13
4-bit carry look ahead adder &ndash; Simulation waveform
</p>
<p>12.1 Addition &bull; 409</p>
<p/>
</div>
<div class="page"><p/>
<p>12.1.5.3 Behavior Model of an Adder Using Arithmetic Operators in Verilog
</p>
<p>Verilog also supports adder models at a higher level of abstraction using the &ldquo;+&rdquo; operator. Note that
</p>
<p>when adding two n-bit arguments, the sum produced will be n + 1 bits. This can be handled in Verilog by
</p>
<p>concatenating the Cout and Sum outputs on the LHS of the assignment. The entire add operation can be
</p>
<p>accomplished in a single continuous assignment that contains both the concatenation and addition
</p>
<p>operators. When using continuous assignment, the LHSmust be a net data type. This means the outputs
</p>
<p>Cout and Sum need to be declared as type wire. If it was desired to have the outputs declared of type reg,
</p>
<p>a procedural assignment could be used instead. Example 12.14 shows the behavioral model for a 4-bit
</p>
<p>adder in Verilog.
</p>
<p>CONCEPT CHECK
</p>
<p>CC12.1 Does a binary adder behave differently when it&rsquo;s operating on unsigned vs. two&rsquo;s
complement numbers? Why or why not?
</p>
<p>A) Yes. The adder needs to keep track of the sign bit; thus extra circuitry is
needed.
</p>
<p>B) No. The binary addition is identical. It is up to the designer to handle how the
two&rsquo;s complement codes are interpreted and whether two&rsquo;s complement
overflow occurred using a separate system.
</p>
<p>12.2 Subtraction
</p>
<p>Binary subtraction can be accomplished by building a dedicated circuit using a similar design
</p>
<p>approach as just described for adders. A more effective approach is to take advantage of two&rsquo;s
</p>
<p>complement representation in order to re-use existing adder circuitry. Recall that taking the two&rsquo;s
</p>
<p>Example 12.14
Behavioral model of a 4-bit adder in Verilog
</p>
<p>410 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>complement of a number will produce an equivalent magnitude number, but with the opposite sign (i.e.,
</p>
<p>positive to negative or negative to positive). This means that all that is required to create a subtractor
</p>
<p>from an adder is to first take the two&rsquo;s complement of the subtrahend input. Since the steps to take the
</p>
<p>two&rsquo;s complement of a number involve complementing each of the bits in the number and then adding
</p>
<p>1, the logic required is relatively simple. Example 12.15 shows a 4-bit subtractor using full adders. The
</p>
<p>subtrahend B is inverted prior to entering the full adders. Also, the carry in bit C0 is set to 1. This handles
</p>
<p>the &ldquo;adding 1&rdquo; step of the two&rsquo;s complement. All of the carries in the circuit are now treated as borrows,
</p>
<p>and the sum is now treated as the difference.
</p>
<p>A programmable adder/subtractor can be created with the use of a programmable inverter and a
</p>
<p>control signal. The control signal will selectively invert B and also change the C0 bit between a 0 (for
</p>
<p>adding) and a 1 (for subtracting). Example 12.16 shows how an XOR gate can be used to create a
</p>
<p>programmable inverter for use in a programmable adder/subtractor circuit.
</p>
<p>Example 12.15
Design of a 4-bit subtractor using full adders
</p>
<p>12.2 Subtraction &bull; 411</p>
<p/>
</div>
<div class="page"><p/>
<p>We can now define a control signal called (ADDn/SUB) that will control whether the circuit performs
</p>
<p>addition or subtraction. Example 12.17 shows the architecture of a 4-bit programmable adder/subtractor.
</p>
<p>It should be noted that this programmability adds another level of logic to the circuit, thus increasing its
</p>
<p>delay. The programmable architecture in Example 12.17 is shown for a ripple carry adder; however, this
</p>
<p>approach works equally well for a carry look ahead adder architecture.
</p>
<p>When using two&rsquo;s complement representation in arithmetic, care must be taken to monitor for two&rsquo;s
</p>
<p>complement overflow. Recall that when using two&rsquo;s complement representation, the number of bits of the
</p>
<p>numbers is fixed (e.g., 4-bits), and if a carry/borrow out is generated, it is ignored. This means that the
</p>
<p>Cout bit does not indicate whether two&rsquo;s complement overflow occurred. Instead, we must construct
</p>
<p>additional circuitry to monitor the arithmetic operations for overflow. Recall from Chap. 2 that two&rsquo;s
</p>
<p>complement overflow occurs in any of these situations:
</p>
<p>Example 12.16
Creating a programmable inverter using an XOR gate
</p>
<p>Example 12.17
Design of a 4-bit programmable adder/subtractor
</p>
<p>412 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>&bull; The sum of like signs results in an answer with opposite sign
(i.e., positive + positive &frac14; negative or negative + negative &frac14; positive).
</p>
<p>&bull; The subtraction of a positive number from a negative number results in a positive number
(i.e., negative &ndash; positive &frac14; positive).
</p>
<p>&bull; The subtraction of a negative number from a positive number results in a negative number
(i.e., positive &ndash; negative &frac14; negative).
</p>
<p>The construction of circuitry for these conditions is straightforward since the sign bit of all numbers
</p>
<p>involved in the operation indicates whether the number is positive or negative. The sign bits of the input
</p>
<p>arguments and the output are fed into combinational logic circuitry that will assert for any of the above
</p>
<p>conditions. These signals are then logically combined to create two&rsquo;s complement overflow signal.
</p>
<p>CONCEPT CHECK
</p>
<p>CC12.2 What modifications can be made to the programmable adder/subtractor architecture
so that it can be used to take the two&rsquo;s complement of a number?
</p>
<p>A) Remove the input A.
</p>
<p>B) Add an additional control signal that will cause the circuit to ignore A and just
perform a complement on B, and then add 1.
</p>
<p>C) Add an additional 1 to the original number using an OR gate on Cin.
</p>
<p>D) Set A to 0, put the number to be manipulated on B, and put the system into
subtraction mode. The system will then complement the bits on B, and then
add 1, thus performing two&rsquo;s complement negation.
</p>
<p>12.3 Multiplication
</p>
<p>12.3.1 Unsigned Multiplication
</p>
<p>Binary multiplication is performed in a similar manner to performing decimal multiplication by hand.
</p>
<p>Recall the process for long multiplication. First, the two numbers are placed vertically over one another
</p>
<p>with their least significant digits aligned. The upper number is called the multiplicand and the lower
</p>
<p>number is called the multiplier. Next, we multiply each individual digit within multiplier with the entire
</p>
<p>multiplicand, starting with the least position. The result of this interim multiplication is called the partial
</p>
<p>product. The partial product is recorded with its least significant digit aligned with the corresponding
</p>
<p>position of the multiplier digit. Finally, all partial products are summed to create the final product of the
</p>
<p>multiplication. This process is often called the shift and add approach. Example 12.18 shows the process
</p>
<p>for performing long multiplication on decimal numbers highlighting the individual steps.
</p>
<p>12.3 Multiplication &bull; 413</p>
<p/>
</div>
<div class="page"><p/>
<p>Binary multiplication follows this same process. Example 12.19 shows the process for performing
</p>
<p>long multiplication on binary numbers. Note that the inputs represent the largest unsigned numbers
</p>
<p>possible using 4-bits, thus producing the largest possible product. The largest product will require 8-bits
</p>
<p>to be represented. This means that for anymultiplication of n-bit inputs, the product will require 2�n bits for
</p>
<p>the result.
</p>
<p>The first step in designing a binary multiplier is to create circuitry that can compute the product on
</p>
<p>individual bits. Example 12.20 shows the design of a single-bit multiplier.
</p>
<p>Example 12.18
Performing long multiplication on decimal numbers
</p>
<p>Example 12.19
Performing long multiplication on binary numbers
</p>
<p>414 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>We can create all of the partial products in one level of logic by placing an AND gate between each
</p>
<p>bit pairing in the two input numbers. This will require n2 AND gates. The next step involves creating
</p>
<p>adders that can perform the sum of the columns of bits within the partial products. This step is not as
</p>
<p>straightforward. Notice that in our 4-bit example in Example 12.19 that the number of input bits in the
</p>
<p>column addition can reach up to 6 (in position 3). It would be desirable to re-use the full adders previously
</p>
<p>created; however, the existing full adders could only accommodate 3 inputs (A, B, Cin). We can take
</p>
<p>advantage of the associative property of addition to form the final sum incrementally. Example 12.21
</p>
<p>shows the architecture of this multiplier. This approach implements a shift and add process to compute
</p>
<p>the product and is known as a combinational multiplier because it is implemented using only combina-
</p>
<p>tional logic. Note that this multiplier only handles unsigned numbers.
</p>
<p>Example 12.20
Design of a single-bit multiplier
</p>
<p>Example 12.21
Design of a 4-bit unsigned multiplier
</p>
<p>12.3 Multiplication &bull; 415</p>
<p/>
</div>
<div class="page"><p/>
<p>This multiplier can have a significant delay, which is caused by the cascaded full adders. Example
</p>
<p>12.22 shows the timing analysis of the combinational multiplier highlighting the worst-case path through
</p>
<p>the circuit.
</p>
<p>12.3.2 A Simple Circuit to Multiply by Powers of Two
</p>
<p>In digital systems, a common operation is to multiply numbers by powers of two. For unsigned
</p>
<p>numbers, multiplying by two can be accomplished by performing a logical shift left. In this operation, all
</p>
<p>bits are moved to the next higher position (i.e., left) by one position and filling the 0th position with a zero.
</p>
<p>This has the effect of doubling the value of the number. This can be repeated to achieve higher powers of
</p>
<p>two. This process works as long as the resulting product fits within the number of bits available. Example
</p>
<p>12.23 shows this procedure.
</p>
<p>Example 12.22
Timing analysis of a 4-bit unsigned multiplier
</p>
<p>Example 12.23
Multiplying an unsigned binary number by two using a logical shift left
</p>
<p>416 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>12.3.3 Signed Multiplication
</p>
<p>When performing multiplication on signed numbers, it is desirable to re-use the unsigned multiplier
</p>
<p>in Example 12.21. Let&rsquo;s examine if this is possible. Recall in decimal multiplication that the inputs are
</p>
<p>multiplied together independent of their sign. The sign of the product is handled separately following
</p>
<p>these rules:
</p>
<p>&bull; A positive number times a positive number produces a positive number.
</p>
<p>&bull; A negative number times a negative number produces a positive number.
</p>
<p>&bull; A positive number times a negative number produces a negative number.
</p>
<p>This process does not work properly in binary due to the way that negative numbers are represented
</p>
<p>with two&rsquo;s complement. Example 12.24 illustrates how an unsigned multiplier incorrectly handles signed
</p>
<p>numbers.
</p>
<p>Instead of building a dedicated multiplier for signed numbers, we can add functionality to the
</p>
<p>unsigned multiplier previously presented to handle negative numbers. The process involves first
</p>
<p>identifying any negative numbers. If a negative number is present, the two&rsquo;s complement is taken on it
</p>
<p>to produce its equivalent magnitude, positive representation. The multiplication is then performed on the
</p>
<p>positive values. The final step is to apply the correct sign to the product. If the product should be negative
</p>
<p>due to one of the inputs being negative, the sign is applied by taking the two&rsquo;s complement on the final
</p>
<p>result. This creates a number that is now in 2�n two&rsquo;s complement format. Example 12.25 shows an
</p>
<p>illustration of the process to correctly handle signed numbers using an unsigned multiplier.
</p>
<p>Example 12.24
Illustrating how an unsigned multiplier incorrectly handles signed numbers
</p>
<p>12.3 Multiplication &bull; 417</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC12.3 Will the AND gates used to compute the partial products in a binary multiplier ever
experience an issue with fan-in as the size of the multiplier increases?
</p>
<p>A) Yes. When the number of bits of the multiplier arguments exceed the fan-in
specification of the AND gates used for the partial products, a fan-in issue
has occurred.
</p>
<p>B) No. The number of inputs of the AND gates performing the partial products
will always be two, regardless of the size of the input arguments to the
multiplier.
</p>
<p>Example 12.25
Process to correctly handle signed numbers using an unsigned multiplier
</p>
<p>418 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4 Division
</p>
<p>12.4.1 Unsigned Division
</p>
<p>There are a variety of methods to perform division, each with trade-offs between area, delay, and
</p>
<p>accuracy. To understand the general approach to building a divider circuit, let&rsquo;s focus on how a simple
</p>
<p>iterative divider can be built. Basic division yields a quotient and a remainder. The process begins by
</p>
<p>checking whether the divisor goes into the highest position digit in the dividend. The number of times this
</p>
<p>dividend digit can be divided is recorded as the highest position value of the quotient. Note that when
</p>
<p>performing division by hand, we typically skip over the condition when the result of these initial operations
</p>
<p>are zero, but when breaking down the process into steps that can be built with logic circuits, each step
</p>
<p>needs to be highlighted. The first quotient digit is then multiplied with the divisor and recorded below the
</p>
<p>original dividend. The next lower position digit of the dividend is brought down and joined with the product
</p>
<p>from the prior multiplication. This forms a new number to be divided by the divisor to create the next
</p>
<p>quotient value. This process is repeated until each of the quotient digits have been created. Any value
</p>
<p>that remains after the last subtraction is recorded as the remainder. Example 12.26 shows the long
</p>
<p>division process on decimal numbers highlight each incremental step.
</p>
<p>Long division in binary follows this same process. Example 12.27 shows the long division process
</p>
<p>on two 4-bit, unsigned numbers. This division results in a 4-bit quotient and a 4-bit remainder.
</p>
<p>Example 12.26
Performing long division on decimal numbers
</p>
<p>12.4 Division &bull; 419</p>
<p/>
</div>
<div class="page"><p/>
<p>When building a divider circuit using combinational logic, we can accomplish the computation using
</p>
<p>a series of iterative subtractors. Performing division is equivalent to subtracting the divisor from the
</p>
<p>interim dividend. If the subtraction is positive, then the divisor went into the dividend and the quotient is a
</p>
<p>1. If the subtraction yields a negative number, then the divisor did not go into the interim dividend, and the
</p>
<p>quotient is 0. We can use the borrow out of a subtraction chain to provide the quotient. This has the
</p>
<p>advantage that the difference has already been calculated for the next subtraction. A multiplexer is used
</p>
<p>to select whether the difference is used in the next subtraction (Q &frac14; 0) or if the interim divisor is simply
</p>
<p>brought down (Q&frac14; 1). This inherently provides the functionality of the multiplication step in long division.
</p>
<p>Example 12.28 shows the architecture of a 4-bit, unsigned divider based on the iterative subtraction
</p>
<p>approach. Notice that when the borrow out of the 4-bit subtractor chain is a 0, it indicates that the
</p>
<p>subtraction yielded a positive number. This means that the divisor went into the interim dividend once. In
</p>
<p>this case, the quotient for this position is a 1. An inverter is required to produce the correct polarity of the
</p>
<p>quotient. The borrow out is also fed into the multiplexer stage as the select line to pass the difference to
</p>
<p>the next stage of subtractors. If the borrow out of the 4-bit subtractor chain is a 1, it indicates that the
</p>
<p>subtraction yielded a negative number. In this case, the quotient is a 0. This also means that the
</p>
<p>difference calculated is garbage and should not be used. The multiplexer stage instead selects the
</p>
<p>interim dividend as the input to the next stage of subtractors.
</p>
<p>Example 12.27
Performing long multiplication on binary numbers
</p>
<p>420 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>To illustrate how this architecture works, Example 12.29 walks through each step in the process
</p>
<p>where 11112 (1510) is divided by 01112 (710). In this example, the calculations propagate through the logic
</p>
<p>stages from top to bottom in the diagram.
</p>
<p>Example 12.28
Design of a 4-bit unsigned divider using a series of iterative subtractors
</p>
<p>12.4 Division &bull; 421</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4.2 A Simple Circuit to Divide by Powers of Two
</p>
<p>For unsigned numbers, dividing by two can be accomplished by performing a logical shift right. In
</p>
<p>this operation, all bits are moved to the next lower position (i.e., right) by one position and then filling the
</p>
<p>highest position with a zero. This has the effect of halving the value of the number. This can be repeated
</p>
<p>to achieve higher powers of two. This process works until no more ones exist in the number, and the
</p>
<p>result is simply all zeros. Example 12.30 shows this process.
</p>
<p>Example 12.29
Dividing 11112 (1510) by 01112 (710) using the iterative subtraction architecture
</p>
<p>422 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4.3 Signed Division
</p>
<p>When performing division on signed numbers, a similar strategy as in signed multiplication is used.
</p>
<p>The process involves first identifying any negative numbers. If a negative number is present, the two&rsquo;s
</p>
<p>complement is taken on it to produce its equivalent magnitude, positive representation. The division is
</p>
<p>then performed on the positive values. The final step is to apply the correct sign to the divisor and
</p>
<p>quotient. This is accomplished by taking the two&rsquo;s complement if a negative number is required. The
</p>
<p>rules governing the polarities of the quotient and remainders are:
</p>
<p>&bull; The quotient will be negative if the input signs are different (i.e., pos/neg or neg/pos).
</p>
<p>&bull; The remainder has the same sign as the dividend.
</p>
<p>CONCEPT CHECK
</p>
<p>CC12.4 Could a shift register help reduce the complexity of a combinational divider circuit?
How?
</p>
<p>A) Yes. Instead of having redundant circuits holding the different shifted
versions of the divisor, a shift register could be used to hold and shift the
divisor after each subtraction.
</p>
<p>B) No. A state machine would then be needed to control the divisor shifting,
which would make the system even more complex.
</p>
<p>Summary
</p>
<p>v Binary arithmetic is accomplished using
combinational logic circuitry. These circuits
tend to be the largest circuits in a system
and have the longest delay. Arithmetic
circuits are often broken up into interim
calculations in order to reduce the overall
delay of the computation.
</p>
<p>v A ripple carry adder performs addition by
re-using lower level components that each
performs a small part of the computation. A
full adder is made from two half adders, and a
ripple carry adder is made from a chain of full
adders. This approach simplifies the design
of the adder, but leads to long delay times
</p>
<p>Example 12.30
Dividing an unsigned binary numbers by two using a logical shift right
</p>
<p>Summary &bull; 423</p>
<p/>
</div>
<div class="page"><p/>
<p>since the carry from each sum must ripple to
the next higher position&rsquo;s addition before it
can complete.
</p>
<p>v A carry look ahead adder attempts to elimi-
nate the linear dependence of delay on the
number of bits that exists in a ripple carry
adder. The carry look ahead adder contains
dedicated circuitry that calculates the carry
bits for each position of the addition. This
leads to a more constant delay as the width
of the adder increases.
</p>
<p>v A binary multiplier can be created in a similar
manner to the way multiplication is
</p>
<p>accomplished by hand using the shift and
add approach. The partial products of the
multiplication can be performed using
2-input AND gates. The sum of the partial
products can have more inputs than the typi-
cal ripple carry adder can accommodate. To
handle this, the additions are performed two
bits at a time using a series of adders.
</p>
<p>v Division can be accomplished using an itera-
tive subtractor architecture.
</p>
<p>Exercise Problems
</p>
<p>Section 12.1: Addition
</p>
<p>12.1.1 Give the total delay of the full adder shown in
Fig. 12.2 if all gates have a delay of 1 ns.
</p>
<p>Fig. 12.2
Full adder timing exercise
</p>
<p>12.1.2 Give the total delay of the full adder shown in
Fig. 12.2 if the XOR gates have delays of 5 ns
while the AND and OR gates have delays of
1 ns.
</p>
<p>12.1.3 Give the total delay of the 4-bit ripple carry
adder shown in Fig. 12.3 if all gates have a
delay of 2 ns.
</p>
<p>Fig. 12.3
4-bit RCA timing exercise
</p>
<p>12.1.4 Give the total delay of the 4-bit ripple carry
adder shown in Fig. 12.3 if the XOR gates
have delays of 10 ns while the AND and OR
gates have delays of 2 ns.
</p>
<p>12.1.5 Design a Verilog model for an 8-bit ripple carry
adder (RCA) using a structural design
approach. This involves creating a half adder
(half_adder.v), full adder (full_adder.v), and
then finally a top-level adder (rca.v) by
instantiating eight full adder sub-systems.
Model the logic operations using gate-level
primitives. Give each gate primitive a delay of
1 ns. The general topology and module defini-
tion for the design are shown in Fig. 12.4. Cre-
ate a test bench to exhaustively verify your
design under all input conditions. The test
bench should drive in different values every
30 ns in order to give sufficient time for the
results to ripple through the adder.
</p>
<p>Fig. 12.4
4-bit RCA module definition
</p>
<p>12.1.6 Give the total delay of the 4-bit carry look
ahead adder shown in Fig. 12.5 if all gates
have a delay of 2 ns.
</p>
<p>424 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>Fig. 12.5
4-bit CLA timing exercise
</p>
<p>12.1.7 Give the total delay of the 4-bit carry look
ahead adder shown in Fig. 12.5 if the XOR
gates have delays of 10 ns while the AND
and OR gates have delays of 2 ns.
</p>
<p>12.1.8 Design a Verilog model for an 8-bit carry look
ahead adder (cla.v). The model should instan-
tiate eight instances of a modified full adder
(mod_full_adder.v), which is implemented
with gate-level primitives. The carry look
ahead logic should be implemented using con-
tinuous assignment with logical operators
within the cla.v module. All logic operations
should have 1 ns of delay. The topology and
port definition for the design are shown in
Fig. 12.6. Create a test bench to exhaustively
verify this design under all input conditions.
The test bench should drive in different values
every 30 ns in order to give sufficient time for
the signals to propagate through the adder.
</p>
<p>Fig. 12.6
4-bit CLA module definition
</p>
<p>Section 12.2: Subtraction
</p>
<p>12.2.1 How is the programmable add/subtract topol-
ogy shown in Fig. 12.7 analogous to 2&rsquo;s com-
plement arithmetic?
</p>
<p>Fig. 12.7
Programmable adder/subtractor block diagram
</p>
<p>12.2.2 Will the programmable adder/subtractor archi-
tecture shown in Fig. 12.7 work for negative
numbers encoded using signed magnitude or
1&rsquo;s complement?
</p>
<p>12.2.3 When calculating the delay of the programma-
ble adder/subtractor architecture shown in
Fig. 12.7 does the delay of the XOR gate that
acts as the programmable inverter need to be
considered?
</p>
<p>12.2.4 Design a Verilog model for an 8-bit, program-
mable adder/subtractor. The design will have
an input called &ldquo;ADDn_SUB&rdquo; that will control
whether the system behaves as an adder (0) or
as a subtractor (1). The design should operate
on two&rsquo;s complement signed numbers. The
result of the operation(s) will appear on the
port called &ldquo;Sum_Diff.&rdquo; The model should
assert the output &ldquo;Cout_Bout&rdquo; when an addi-
tion creates a carry or when a subtraction
creates a borrow. The circuit will also assert
the output Vout when either operation results in
two&rsquo;s complement overflow. The port definition
and block diagram for the system is shown in
Fig. 12.8. Create a test bench to exhaustively
verify this design under all input conditions.
</p>
<p>Fig. 12.8
Programmable adder/subtractor module definition
</p>
<p>Exercise Problems &bull; 425</p>
<p/>
</div>
<div class="page"><p/>
<p>Section 12.3: Multiplication
</p>
<p>12.3.1 Give the total delay of the 4-bit unsigned multi-
plier shown in Fig. 12.9 if all gates have a delay
of 1 ns. The addition is performed using a ripple
carry adder.
</p>
<p>Fig. 12.9
4-bit unsigned multiplier block diagram
</p>
<p>12.3.2 For the 4-bit unsigned multiplier shown in
Fig. 12.9, how many levels of logic does it
take to compute all of the partial products?
</p>
<p>12.3.3 For the 4-bit unsigned multiplier shown in
Fig. 12.9, how many AND gates are needed
to compute the partial products?
</p>
<p>12.3.4 For the 4-bit unsigned multiplier shown in
Fig. 12.9, how many total AND gates are
used if the additions are implemented using
full adders made of half adders?
</p>
<p>12.3.5 Based on the architecture of an unsigned mul-
tiplier in Fig. 12.9, how many AND gates are
needed to compute the partial products if the
inputs are increased to 8 bits?
</p>
<p>12.3.6 For an 8-bit multiplier, how many bits are
needed to represent the product?
</p>
<p>12.3.7 For an 8-bit unsigned multiplier, what is the
largest value that the product can ever take
on? Give your answer in decimal.
</p>
<p>12.3.8 For an 8-bit signed multiplier, what is the larg-
est value that the product can ever take on?
Give your answer in decimal.
</p>
<p>12.3.9 For an 8-bit signed multiplier, what is the
smallest value that the product can ever take
on? Give your answer in decimal.
</p>
<p>12.3.10 What is the maximum number of times that a
4-bit unsigned multiplicand can be multiplied
by two using the logical shift left approach
before the product is too large to be
represented by an 8-bit product? Hint: The
maximum number of times this operation can
be performed corresponds to when the multi-
plicand starts at its lowest possible non-zero
value (i.e., 1).
</p>
<p>12.3.11 Design a Verilog model for an 8-bit unsigned
multiplier using whatever modeling approach
you wish. Create a test bench to exhaustively
verify this design under all input conditions.
The port definition for this multiplier is given in
Fig. 12.10.
</p>
<p>Fig. 12.10
4-bit unsigned multiplier module definition
</p>
<p>12.3.12 Design a Verilog model for an 8-bit signed
multiplier using whatever modeling approach
you wish. Create a test bench to exhaustively
verify this design under all input conditions.
The port definition for this multiplier is given in
Fig. 12.11.
</p>
<p>Fig. 12.11
4-bit signed multiplier module definition
</p>
<p>Section 12.4: Division
</p>
<p>12.4.1 For a 4-bit divider, how many bits are needed
for the quotient?
</p>
<p>12.4.2 For a 4-bit divider, how many bits are needed
for the remainder?
</p>
<p>12.4.3 Explain the basic concept of the iterative-
subtractor approach to division.
</p>
<p>12.4.4 For the 4-bit divider shown in Example 12.28,
estimate the total delay assuming all gates
have a delay of 1 ns.
</p>
<p>426 &bull; Chapter 12: Arithmetic Circuits</p>
<p/>
</div>
<div class="page"><p/>
<p>Chapter 13: Computer System Design
One of the most common digital systems in use today is the computer. A computer accomplishes
</p>
<p>tasks through an architecture that uses both hardware and software. The hardware in a computer
</p>
<p>consists of many of the elements that we have covered so far. These include registers, arithmetic and
</p>
<p>logic circuits, finite-state machines, and memory. What makes a computer so useful is that the hardware
</p>
<p>is designed to accomplish a predetermined set of instructions. These instructions are relatively simple,
</p>
<p>such as moving data between memory and a register or performing arithmetic on two numbers. The
</p>
<p>instructions are comprised of binary codes that are stored in a memory device and represent the
</p>
<p>sequence of operations that the hardware will perform to accomplish a task. This sequence of
</p>
<p>instructions is called a computer program. What makes this architecture so useful is that the preexisting
</p>
<p>hardware can be programmed to perform an almost unlimited number of tasks by simply defining the
</p>
<p>sequence of instructions to be executed. The process of designing the sequence of instructions, or
</p>
<p>program, is called software development or software engineering.
</p>
<p>The idea of a general-purpose computing machine dates back to the nineteenth century. The first
</p>
<p>computing machines were implemented with mechanical systems and were typically analog in nature.
</p>
<p>As technology advanced, computer hardware evolved from electromechanical switches to vacuum
</p>
<p>tubes and ultimately to integrated circuits. These newer technologies enabled switching circuits and
</p>
<p>provided the capability to build binary computers. Today&rsquo;s computers are built exclusively with semicon-
</p>
<p>ductor materials and integrated circuit technology. The term microcomputer is used to describe a
</p>
<p>computer that has its processing hardware implemented with integrated circuitry. Nearly all modern
</p>
<p>computers are binary. Binary computers are designed to operate on a fixed set of bits. For example, an
</p>
<p>8-bit computer would perform operations on 8 bits at a time. This means it moves data between registers
</p>
<p>and memory and performs arithmetic and logic operations in groups of 8 bits.
</p>
<p>This chapter will cover the basics of a simple computer system and present the design of an 8-bit
</p>
<p>system to illustrate the details of instruction execution. The goal of this chapter is to provide an
</p>
<p>understanding of the basic principles of computer systems.
</p>
<p>Learning Outcomes&mdash;After completing this chapter, you will be able to:
</p>
<p>13.1 Describe the basic components and operation of computer hardware.
13.2 Describe the basic components and operation of computer software.
13.3 Design a fully operational computer system using Verilog.
13.4 Describe the difference between the Von Neumann and Harvard computer architectures.
</p>
<p>13.1 Computer Hardware
</p>
<p>Computer hardware refers to all of the physical components within the system. This hardware
</p>
<p>includes all circuit components in a computer such as the memory devices, registers, and finite-state
</p>
<p>machines. Figure 13.1 shows a block diagram of the basic hardware components in a computer.
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5_13
</p>
<p>427</p>
<p/>
<div class="annotation"><a href="http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_13&amp;domain=pdf">http://crossmark.crossref.org/dialog/?doi=10.1007/978-3-030-13605-5_13&amp;domain=pdf</a></div>
</div>
<div class="page"><p/>
<p>13.1.1 Program Memory
</p>
<p>The instructions that are executed by a computer are held in program memory. Program memory is
</p>
<p>treated as read-only memory during execution in order to prevent the instructions from being overwritten
</p>
<p>by the computer. Some computer systems will implement the program memory on a true ROM device
</p>
<p>(MROM or PROM), while others will use a EEPROM that can be read from during normal operation but
</p>
<p>can only be written to using a dedicated write procedure. Programs are typically held in non-volatile
</p>
<p>memory so that the computer system does not lose its program when power is removed. Modern
</p>
<p>computers will often copy a program from non-volatile memory (e.g., a hard disk drive) to volatile memory
</p>
<p>after start-up in order to speed up instruction execution. In this case, care must be taken that the program
</p>
<p>does not overwrite itself.
</p>
<p>13.1.2 Data Memory
</p>
<p>Computers also require data memory, which can be written to and read from during normal
</p>
<p>operation. This memory is used to hold temporary variables that are created by the software program.
</p>
<p>This memory expands the capability of the computer system by allowing large amounts of information to
</p>
<p>be created and stored by the program. Additionally, computations can be performed that are larger than
</p>
<p>the width of the computer system by holding interim portions of the calculation (e.g., performing a 128-bit
</p>
<p>addition on a 32-bit computer). Data memory is implemented with R/W memory, most often SRAM or
</p>
<p>DRAM.
</p>
<p>13.1.3 Input/Output Ports
</p>
<p>The term port is used to describe the mechanism to get information from the output world into or out
</p>
<p>of the computer. Ports can be input, output, or bidirectional. I/O ports can be designed to pass information
</p>
<p>in a serial or parallel format.
</p>
<p>Fig. 13.1
Hardware components of a computer system
</p>
<p>428 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.1.4 Central Processing Unit
</p>
<p>The central processing unit (CPU) is considered the brains of the computer. The CPU handles
</p>
<p>reading instructions from memory, decoding them to understand which instruction is being performed,
</p>
<p>and executing the necessary steps to complete the instruction. The CPU also contains a set of registers
</p>
<p>that are used for general-purpose data storage, operational information, and system status. Finally, the
</p>
<p>CPU contains circuitry to perform arithmetic and logic operations on data.
</p>
<p>13.1.4.1 Control Unit
</p>
<p>The control unit is a finite-state machine that controls the operation of the computer. This FSM has
</p>
<p>states that perform fetching the instruction (i.e., reading it from program memory), decoding the instruc-
</p>
<p>tion, and executing the appropriate steps to accomplish the instruction. This process is known as fetch,
</p>
<p>decode, and execute and is repeated each time an instruction is performed by the CPU. As the control
</p>
<p>unit state machine traverses through its states, it asserts control signals that move and manipulate data
</p>
<p>in order to achieve the desired functionality of the instruction.
</p>
<p>13.1.4.2 Data Path: Registers
</p>
<p>The CPU groups its registers and ALU into a sub-system called the data path. The data path refers
</p>
<p>to the fast storage and data manipulations within the CPU. All of these operations are initiated and
</p>
<p>managed by the control unit state machine. The CPU contains a variety of registers that are necessary to
</p>
<p>execute instructions and hold status information about the system. Basic computers have the following
</p>
<p>registers in their CPU:
</p>
<p>&bull; Instruction Register (IR) &ndash; The instruction register holds the current binary code of the
instruction being executed. This code is read from program memory as the first part of
instruction execution. The IR is used by the control unit to decide which states in its FSM to
traverse in order to execute the instruction.
</p>
<p>&bull; Memory Address Register (MAR) &ndash; The memory address register is used to hold the current
address being used to access memory. The MAR can be loaded with addresses in order to
fetch instructions from program memory or with addresses to access data memory and/or I/O
ports.
</p>
<p>&bull; Program Counter (PC) &ndash; The program counter holds the address of the current instruction
being executed in program memory. The program counter will increment sequentially through
the program memory reading instructions until a dedicated instruction is used to set it to a new
location.
</p>
<p>&bull; General-Purpose Registers &ndash; These registers are available for temporary storage by the
program. Instructions exist to move information from memory into these registers and to move
information from these registers into memory. Instructions also exist to perform arithmetic and
logic operations on the information held in these registers.
</p>
<p>&bull; Condition Code Register (CCR) &ndash; The condition code register holds status flags that provide
information about the arithmetic and logic operations performed in the CPU. The most common
flags are negative (N), zero (Z), two&rsquo;s complement overflow (V), and carry (C). This register can
also contain flags that indicate the status of the computer, such as if an interrupt has occurred
or if the computer has been put into a low-power mode.
</p>
<p>13.1.4.3 Data Path: Arithmetic Logic Unit (ALU)
</p>
<p>The arithmetic logic unit is the system that performs all mathematical (i.e., addition, subtraction,
</p>
<p>multiplication, and division) and logic operations (i.e., and, or, not, shifts, etc.). This system operates on
</p>
<p>data being held in CPU registers. The ALU has a unique symbol associated with it to distinguish it from
</p>
<p>other functional units in the CPU.
</p>
<p>13.1 Computer Hardware &bull; 429</p>
<p/>
</div>
<div class="page"><p/>
<p>Figure 13.2 shows the typical organization of a CPU. The registers and ALU are grouped into the
</p>
<p>data path. In this example, the computer system has two general-purpose registers called A and B. This
</p>
<p>CPU organization will be used throughout this chapter to illustrate the detailed execution of instructions.
</p>
<p>13.1.5 A Memory-Mapped System
</p>
<p>A common way to simplify moving data in or out of the CPU is to assign a unique address to all
</p>
<p>hardware components in the memory system. Each input/output port and each location in both program
</p>
<p>and data memory are assigned a unique address. This allows the CPU to access everything in the
</p>
<p>memory system with a dedicated address. This reduces the number of lines that must pass into the CPU.
</p>
<p>A bus system facilitates transferring information within the computer system. An address bus is driven by
</p>
<p>the CPU to identify which location in the memory system is being accessed. A data bus is used to
</p>
<p>transfer information to/from the CPU and the memory system. Finally, a control bus is used to provide
</p>
<p>other required information about the transactions such as read or write lines. Figure 13.3 shows the
</p>
<p>computer hardware in a memory-mapped architecture.
</p>
<p>Fig. 13.2
Typical CPU organization
</p>
<p>430 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>To help visualize how the memory addresses are assigned, a memory map is used. This is a
</p>
<p>graphical depiction of the memory system. In the memory map, the ranges of addresses are provided for
</p>
<p>each of the main subsections of memory. This gives the programmer a quick overview of the available
</p>
<p>resources in the computer system. Example 13.1 shows a representative memory map for a computer
</p>
<p>system with an address bus with a width of 8 bits. This address bus can provide 256 unique locations.
</p>
<p>For this example, the memory system is also 8 bits wide; thus, the entire memory system is 256 � 8 in
</p>
<p>size. In this example 128 bytes are allocated for program memory; 96 bytes are allocated for data
</p>
<p>memory; 16 bytes are allocated for output ports; and 16 bytes are allocated for input ports.
</p>
<p>Fig. 13.3
Computer hardware in a memory-mapped configuration
</p>
<p>13.1 Computer Hardware &bull; 431</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC13.1 Is the hardware of a computer programmed in a similar way to a programmable logic
device?
</p>
<p>A) Yes. The control unit is reconfigured to produce the correct logic for each
unique instruction just like a logic element in an FPGA is reconfigured to
produce the desired logic expression.
</p>
<p>B) No. The instruction code from program memory simply tells the state
machine in the control unit which path to traverse in order to accomplish the
desired task.
</p>
<p>13.2 Computer Software
</p>
<p>Computer software refers to the instructions that the computer can execute and how they are
</p>
<p>designed to accomplish various tasks. The specific group of instructions that a computer can execute
</p>
<p>is known as its instruction set. The instruction set of a computer needs to be defined first before the
</p>
<p>computer hardware can be implemented. Some computer systems have a very small number of
</p>
<p>instructions in order to reduce the physical size of the circuitry needed in the CPU. This allows the
</p>
<p>CPU to execute the instructions very quickly but requires a large number of operations to accomplish a
</p>
<p>given task. This architectural approach is called a reduced instruction set computer (RISC).
</p>
<p>Example 13.1
Memory map for a 256 � 8 memory system
</p>
<p>432 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>The alternative to this approach is to make an instruction set with a large number of dedicated
</p>
<p>instructions that can accomplish a given task in fewer CPU operations. The drawback of this approach
</p>
<p>is that the physical size of the CPUmust be larger in order to accommodate the various instructions. This
</p>
<p>architectural approach is called a complex instruction set computer (CISC).
</p>
<p>13.2.1 Opcodes and Operands
</p>
<p>A computer instruction consists of two fields, an opcode and an operand. The opcode is a unique
</p>
<p>binary code given to each instruction in the set. The CPU decodes the opcode in order to know which
</p>
<p>instruction is being executed and then takes the appropriate steps to complete the instruction. Each
</p>
<p>opcode is assigned a mnemonic, which is a descriptive name for the opcode that can be used when
</p>
<p>discussing the instruction functionally. An operand is additional information for the instruction that may be
</p>
<p>required. An instruction may have any number of operands including zero. Figure 13.4 shows an
</p>
<p>example of how the instruction opcodes and operands are placed into program memory.
</p>
<p>13.2.2 Addressing Modes
</p>
<p>An addressing mode describes the way in which the operand of an instruction is used. While modern
</p>
<p>computer systems may contain numerous addressing modes with varying complexities, we will focus on
</p>
<p>just a subset of basic addressing modes. These modes are immediate, direct, inherent, and indexed.
</p>
<p>13.2.2.1 Immediate Addressing (IMM)
</p>
<p>Immediate addressing is when the operand of an instruction is the information to be used by the
</p>
<p>instruction. For example, if an instruction existed to put a constant into a register within the CPU using
</p>
<p>immediate addressing, the operand would be the constant. When the CPU reads the operand, it simply
</p>
<p>inserts the contents into the CPU register, and the instruction is complete.
</p>
<p>Fig. 13.4
Anatomy of a computer instruction
</p>
<p>13.2 Computer Software &bull; 433</p>
<p/>
</div>
<div class="page"><p/>
<p>13.2.2.2 Direct Addressing (DIR)
</p>
<p>Direct addressing is when the operand of an instruction contains the address of where the informa-
</p>
<p>tion to be used is located. For example, if an instruction existed to put a constant into a register within the
</p>
<p>CPU using direct addressing, the operand would contain the address of where the constant was located
</p>
<p>in memory. When the CPU reads the operand, it puts this value out on the address bus and performs an
</p>
<p>additional read to retrieve the contents located at that address. The value read is then put into the CPU
</p>
<p>register and the instruction is complete.
</p>
<p>13.2.2.3 Inherent Addressing (INH)
</p>
<p>Inherent addressing refers to an instruction that does not require an operand because the opcode
</p>
<p>itself contains all of the necessary information for the instruction to complete. This type of addressing is
</p>
<p>used on instructions that performmanipulations on data held in CPU registers without the need to access
</p>
<p>the memory system. For example, if an instruction existed to increment the contents of a register (A),
</p>
<p>then once the opcode is read by the CPU, it knows everything it needs to know in order to accomplish the
</p>
<p>task. The CPU simply asserts a series of control signals in order to increment the contents of A, and then
</p>
<p>the instruction is complete. Notice that no operand is needed for this task. Instead, the location of the
</p>
<p>register to be manipulated (i.e., A) is inherent within the opcode.
</p>
<p>13.2.2.4 Indexed Addressing (IND)
</p>
<p>Indexed addressing refers to instructions that will access information at an address in memory to
</p>
<p>complete the instruction, but the address to be accessed is held in another CPU register. In this type of
</p>
<p>addressing, the operand of the instruction is used as an offset that can be applied to the address located
</p>
<p>in the CPU register. For example, let&rsquo;s say an instruction existed to put a constant into a register
</p>
<p>(A) within the CPU using indexed addressing. Let&rsquo;s also say that the instruction was designed to use
</p>
<p>the contents of another register (B) as part of the address of where the constant was located. When the
</p>
<p>CPU reads the opcode, it understands what the instruction is and that B holds part of the address to be
</p>
<p>accessed. It also knows that the operand is applied to B to form the actual address to be accessed.When
</p>
<p>the CPU reads the operand, it adds the value to the contents of B and then puts this new value out on the
</p>
<p>address bus and performs an additional read. The value read is then put into the CPU register A and the
</p>
<p>instruction is complete.
</p>
<p>13.2.3 Classes of Instructions
</p>
<p>There are three general classes of instructions: (1) loads and stores, (2) data manipulations, and
</p>
<p>(3) branches. To illustrate how these instructions are executed, examples will be given based on the
</p>
<p>computer architecture shown in Fig. 13.3.
</p>
<p>13.2.3.1 Loads and Stores
</p>
<p>This class of instructions accomplishes moving information between the CPU and memory. A load
</p>
<p>is an instruction that moves information from memory into a CPU register. When a load instruction uses
</p>
<p>immediate addressing, the operand of the instruction is the data to be loaded into the CPU register. As an
</p>
<p>example, let&rsquo;s look at an instruction to load the general-purpose register A using immediate addressing.
</p>
<p>Let&rsquo;s say that the opcode of the instruction is x&rdquo;86&rdquo;, has a mnemonic LDA_IMM, and is inserted into
</p>
<p>program memory starting at x&rdquo;00&rdquo;. Example 13.2 shows the steps involved in executing the LDA_IMM
</p>
<p>instruction.
</p>
<p>434 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Now let&rsquo;s look at a load instruction using direct addressing. In direct addressing, the operand of the
</p>
<p>instruction is the address of where the data to be loaded resides. As an example, let&rsquo;s look at an
</p>
<p>instruction to load the general-purpose register A. Let&rsquo;s say that the opcode of the instruction is x&rdquo;87&rdquo;,
</p>
<p>has a mnemonic LDA_DIR, and is inserted into program memory starting at x&rdquo;08&rdquo;. The value to be
</p>
<p>loaded into A resides at address x&rdquo;80&rdquo;, which has already been initialized with x&rdquo;AA&rdquo; before this
</p>
<p>instruction. Example 13.3 shows the steps involved in executing the LDA_DIR instruction.
</p>
<p>Example 13.2
Execution of an instruction to &ldquo;load register A using immediate addressing&rdquo;
</p>
<p>13.2 Computer Software &bull; 435</p>
<p/>
</div>
<div class="page"><p/>
<p>A store is an instruction that moves information from a CPU register intomemory. The operand of a
</p>
<p>store instruction indicates the address of where the contents of the CPU register will be written. As an
</p>
<p>example, let&rsquo;s look at an instruction to store the general-purpose register A into memory address x&rdquo;E0&rdquo;.
</p>
<p>Let&rsquo;s say that the opcode of the instruction is x&rdquo;96&rdquo;, has a mnemonic STA_DIR, and is inserted into
</p>
<p>program memory starting at x&rdquo;04&rdquo;. The initial value of A is x&rdquo;CC&rdquo; before the instruction is executed.
</p>
<p>Example 13.4 shows the steps involved in executing the STA_DIR instruction.
</p>
<p>Example 13.3
Execution of an instruction to &ldquo;load register A using direct addressing&rdquo;
</p>
<p>436 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.2.3.2 Data Manipulations
</p>
<p>This class of instructions refers to ALU operations. These operations act on data that resides in the
</p>
<p>CPU registers. These instructions include arithmetic, logic operators, shifts and rotates, and tests and
</p>
<p>compares. Data manipulation instructions typically use inherent addressing because the operations are
</p>
<p>conducted on the contents of CPU registers and don&rsquo;t require additional memory access. As an example,
</p>
<p>let&rsquo;s look at an instruction to perform addition on registers A and B. The sum will be placed back in
</p>
<p>A. Let&rsquo;s say that the opcode of the instruction is x&rdquo;42&rdquo;, has a mnemonic ADD_AB, and is inserted into
</p>
<p>program memory starting at x&rdquo;04&rdquo;. Example 13.5 shows the steps involved in executing the ADD_AB
</p>
<p>instruction.
</p>
<p>Example 13.4
Execution of an instruction to &ldquo;store register A using direct addressing&rdquo;
</p>
<p>13.2 Computer Software &bull; 437</p>
<p/>
</div>
<div class="page"><p/>
<p>13.2.3.3 Branches
</p>
<p>In the previous examples, the program counter was always incremented to point to the address of
</p>
<p>the next instruction in programmemory. This behavior only supports a linear execution of instructions. To
</p>
<p>provide the ability to specifically set the value of the program counter, instructions called branches are
</p>
<p>used. There are two types of branches: unconditional and conditional. In an unconditional branch, the
</p>
<p>program counter is always loaded with the value provided in the operand. As an example, let&rsquo;s look at an
</p>
<p>instruction to branch always to a specific address. This allows the program to perform loops. Let&rsquo;s say
</p>
<p>that the opcode of the instruction is x&rdquo;20&rdquo;, has a mnemonic BRA, and is inserted into program memory
</p>
<p>starting at x&rdquo;06&rdquo;. Example 13.6 shows the steps involved in executing the BRA instruction.
</p>
<p>Example 13.5
Execution of an instruction to &ldquo;add registers A and B&rdquo;
</p>
<p>438 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>In a conditional branch, the program counter is only updated if a particular condition is true. The
</p>
<p>conditions come from the status flags in the condition code register (NZVC). This allows a program to
</p>
<p>selectively execute instructions based on the result of a prior operation. Let&rsquo;s look at an example
</p>
<p>instruction that will branch only if the Z flag is asserted. This instruction is called a branch if equal to
</p>
<p>zero. Let&rsquo;s say that the opcode of the instruction is x&rdquo;23&rdquo;, has a mnemonic BEQ, and is inserted into
</p>
<p>program memory starting at x&rdquo;05&rdquo;. Example 13.7 shows the steps involved in executing the BEQ
</p>
<p>instruction.
</p>
<p>Example 13.6
Execution of an instruction to &ldquo;branch always&rdquo;
</p>
<p>13.2 Computer Software &bull; 439</p>
<p/>
</div>
<div class="page"><p/>
<p>Conditional branches allow computer programs to make decisions about which instructions to
</p>
<p>execute based on the results of previous instructions. This gives computers the ability to react to input
</p>
<p>signals or act based on the results of arithmetic or logic operations. Computer instruction sets typically
</p>
<p>contain conditional branches based on the NZVC flags in the condition code registers. The following
</p>
<p>instructions are based on the values of the NZVC flags.
</p>
<p>&bull; BMI &ndash; Branch if minus (N &frac14; 1)
</p>
<p>&bull; BPL &ndash; Branch if plus (N &frac14; 0)
</p>
<p>&bull; BEQ &ndash; Branch if equal to zero (Z &frac14; 1)
</p>
<p>&bull; BNE &ndash; Branch if not equal to zero (Z &frac14; 0)
</p>
<p>Example 13.7
Execution of an instruction to &ldquo;branch if equal to zero&rdquo;
</p>
<p>440 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>&bull; BVS &ndash; Branch if two&rsquo;s complement overflow occurred, or V is set (V &frac14; 1)
</p>
<p>&bull; BVC &ndash; Branch if two&rsquo;s complement overflow did not occur, or V is clear (V &frac14; 0)
</p>
<p>&bull; BCS &ndash; Branch if a carry occurred, or C is set (C &frac14; 1)
</p>
<p>&bull; BCC &ndash; Branch if a carry did not occur, or C is clear (C &frac14; 0)
</p>
<p>Combinations of these flags can be used to create more conditional branches.
</p>
<p>&bull; BHI &ndash; Branch if higher (C &frac14; 1 and Z &frac14; 0)
</p>
<p>&bull; BLS &ndash; Branch if lower or the same (C &frac14; 0 and Z &frac14; 1)
</p>
<p>&bull; BGE &ndash; Branch if greater than or equal ((N &frac14; 0 and V &frac14; 0) or (N &frac14; 1 and V &frac14; 1)), only valid for
signed numbers
</p>
<p>&bull; BLT &ndash; Branch if less than ((N &frac14; 1 and V &frac14; 0) or (N &frac14; 0 and V &frac14; 1)), only valid for signed
numbers
</p>
<p>&bull; BGT &ndash; Branch if greater than ((N&frac14; 0 and V&frac14; 0 and Z&frac14; 0) or (N&frac14; 1 and V&frac14; 1 and Z&frac14; 0)), only
valid for signed numbers
</p>
<p>&bull; BLE &ndash; Branch if less than or equal ((N&frac14; 1 and V&frac14; 0) or (N&frac14; 0 and V&frac14; 1) or (Z&frac14; 1)), only valid
for signed numbers
</p>
<p>CONCEPT CHECK
</p>
<p>CC13.2 Software development consists of choosing which instructions, and in what order, will
be executed to accomplish a certain task. The group of instructions is called the
program and is inserted into program memory. Which of the following might a software
developer care about?
</p>
<p>A) Minimizing the number of instructions that need to be executed to accomplish
the task in order to increase the computation rate
</p>
<p>B) Minimizing the number of registers used in the CPU to save power
</p>
<p>C) Minimizing the overall size of the program to reduce the amount of program
memory needed
</p>
<p>D) Both A and C
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example
</p>
<p>13.3.1 Top-Level Block Diagram
</p>
<p>Let&rsquo;s now look at the detailed implementation and instruction execution of a computer system. In
</p>
<p>order to illustrate the detailed operation, we will use a simple 8-bit computer system design. Example
</p>
<p>13.8 shows the block diagram for the 8-bit computer system. This block diagram also contains the Verilog
</p>
<p>file and module names, which will be used when the behavioral model is implemented.
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 441</p>
<p/>
</div>
<div class="page"><p/>
<p>We will use the memory map shown in Example 13.1 for our example computer system. This
</p>
<p>mapping provides 128 bytes of program memory, 96 bytes of data memory, 16� output ports, and 16�
</p>
<p>input ports. To simplify the operation of this example computer, the address bus is limited to 8 bits. This
</p>
<p>only provides 256 locations of memory access but allows an entire address to be loaded into the CPU as
</p>
<p>a single operand of an instruction.
</p>
<p>Example 13.8
Top-level block diagram for the 8-bit computer system
</p>
<p>442 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.2 Instruction Set Design
</p>
<p>Example 13.9 shows a basic instruction set for our example computer system. This set provides a
</p>
<p>variety of loads and stores, data manipulations, and branch instructions that will allow the computer to be
</p>
<p>programmed to perform more complex tasks through software development. These instructions are
</p>
<p>sufficient to provide a baseline of functionality in order to get the computer system operational. Additional
</p>
<p>instructions can be added as desired to increase the complexity of the system.
</p>
<p>Example 13.9
Instruction set for the 8-bit computer system
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 443</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.3 Memory System Implementation
</p>
<p>Let&rsquo;s now look at the memory system details. The memory system contains program memory, data
</p>
<p>memory, and input/output ports. Example 13.10 shows the block diagram of the memory system. The
</p>
<p>program and data memory will be implemented using lower-level components (rom_128x8_sync.v and
</p>
<p>rw_96x8_sync.v), while the input and output ports can be modeled using a combination of RTL blocks
</p>
<p>and combinational logic. The program and data memory sub-systems contain dedicated circuitry to
</p>
<p>handle their addressing ranges. Each output port also contains dedicated circuitry to handle its unique
</p>
<p>address. A multiplexer is used to handle the signal routing back to the CPU based on the address
</p>
<p>provided.
</p>
<p>13.3.3.1 Program Memory Implementation in Verilog
</p>
<p>The program memory can be implemented in Verilog using the modeling techniques presented in
</p>
<p>Chap. 12. To make the Verilog more readable, the instruction mnemonics can be declared as
</p>
<p>parameters. This allows the mnemonic to be used when populating the program memory array. The
</p>
<p>following Verilog shows how the mnemonics for our basic instruction set can be defined as parameters.
</p>
<p>Example 13.10
Memory system block diagram for the 8-bit computer system
</p>
<p>444 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>parameter LDA_IMM &frac14; 8&rsquo;h86; //-- Load Register A with Immediate Addressing
parameter LDA_DIR &frac14; 8&rsquo;h87; //-- Load Register A with Direct Addressing
parameter LDB_IMM &frac14; 8&rsquo;h88; //-- Load Register B with Immediate Addressing
parameter LDB_DIR &frac14; 8&rsquo;h89; //-- Load Register B with Direct Addressing
parameter STA_DIR &frac14; 8&rsquo;h96; //-- Store Register A to memory (RAM or IO)
parameter STB_DIR &frac14; 8&rsquo;h97; //-- Store Register B to memory (RAM or IO)
parameter ADD_AB &frac14; 8&rsquo;h42; //-- A &lt;&frac14; A + B
parameter SUB_AB &frac14; 8&rsquo;h43; //-- A &lt;&frac14; A - B
parameter AND_AB &frac14; 8&rsquo;h44; //-- A &lt;&frac14; A and B
parameter OR_AB &frac14; 8&rsquo;h45; //-- A &lt;&frac14; A or B
parameter INCA &frac14; 8&rsquo;h46; //-- A &lt;&frac14; A + 1
parameter INCB &frac14; 8&rsquo;h47; //-- B &lt;&frac14; B + 1
parameter DECA &frac14; 8&rsquo;h48; //-- A &lt;&frac14; A - 1
parameter DECB &frac14; 8&rsquo;h49; //-- B &lt;&frac14; B - 1
parameter BRA &frac14; 8&rsquo;h20; //-- Branch Always
parameter BMI &frac14; 8&rsquo;h21; //-- Branch if N&frac14;1
parameter BPL &frac14; 8&rsquo;h22; //-- Branch if N&frac14;0
parameter BEQ &frac14; 8&rsquo;h23; //-- Branch if Z&frac14;1
parameter BNE &frac14; 8&rsquo;h24; //-- Branch if Z&frac14;0
parameter BVS &frac14; 8&rsquo;h25; //-- Branch if V&frac14;1
parameter BVC &frac14; 8&rsquo;h26; //-- Branch if V&frac14;0
parameter BCS &frac14; 8&rsquo;h27; //-- Branch if C&frac14;1
parameter BCC &frac14; 8&rsquo;h28; //-- Branch if C&frac14;0
</p>
<p>Now the program memory can be declared as an array type with initial values to define the program.
</p>
<p>The following Verilog shows how to declare the program memory and an example program to perform a
</p>
<p>load, a store, and a branch always. This program will continually write x&rdquo;AA&rdquo; to port_out_00.
</p>
<p>reg[7:0] ROM[0:127];
</p>
<p>initial
begin
</p>
<p>ROM[0] &frac14; LDA_IMM;
ROM[1] &frac14; 8&rsquo;hAA;
ROM[2] &frac14; STA_DIR;
ROM[3] &frac14; 8&rsquo;hE0;
ROM[4] &frac14; BRA;
ROM[5] &frac14; 8&rsquo;h00;
</p>
<p>end
</p>
<p>The address mapping for the program memory is handled in two ways. First, notice that the array
</p>
<p>type defined above uses indices from 0 to 127. This provides the appropriate addresses for each location
</p>
<p>in the memory. The second step is to create an internal enable line that will only allow assignments from
</p>
<p>ROM to data_out when a valid address is entered. Consider the following Verilog to create an internal
</p>
<p>enable (EN) that will only be asserted when the address falls within the valid program memory range of
</p>
<p>0 to 127.
</p>
<p>always @ (address)
begin
</p>
<p>if ((address &gt;&frac14; 0) &amp;&amp; (address &lt;&frac14; 127))
EN &frac14; 1&rsquo;b1;
</p>
<p>else
EN &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>If this enable signal is not created, the simulation and synthesis will fail because data_out
</p>
<p>assignments will be attempted for addresses outside of the defined range of the ROM array. This enable
</p>
<p>line can now be used in the behavioral model for the ROM as follows:
</p>
<p>always @ (posedge clock)
begin
</p>
<p>if (EN)
data_out &frac14; ROM[address];
</p>
<p>end
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 445</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.3.2 Data Memory Implementation in Verilog
</p>
<p>The data memory is created using a similar strategy as the program memory. An array signal is
</p>
<p>declared with an address range corresponding to the memory map for the computer system (i.e., 128 to
</p>
<p>223). An internal enable is again created that will prevent data_out assignments for addresses outside of
</p>
<p>this valid range. The following is the Verilog to declare the R/W memory array:
</p>
<p>reg[7:0] RW[128:223];
</p>
<p>The following is the Verilog to model the local enable and signal assignments for the R/W memory:
</p>
<p>always @ (address)
begin
</p>
<p>if ((address &gt;&frac14; 128) &amp;&amp; (address &lt;&frac14; 223))
EN &frac14; 1&rsquo;b1;
</p>
<p>else
EN &frac14; 1&rsquo;b0;
</p>
<p>end
</p>
<p>always @ (posedge clock)
begin
</p>
<p>if (write &amp;&amp; EN)
RW[address] &frac14; data_in;
</p>
<p>else if (!write &amp;&amp; EN)
data_out &frac14; RW[address];
</p>
<p>end
</p>
<p>13.3.3.3 Implementation of Output Ports in Verilog
</p>
<p>Each output port in the computer system is assigned a unique address. Each output port also
</p>
<p>contains storage capability. This allows the CPU to update an output port by writing to its specific
</p>
<p>address. Once the CPU is done storing to the output port address and moves to the next instruction in
</p>
<p>the program, the output port holds its information until it is written to again. This behavior can be modeled
</p>
<p>using an RTL procedural block that uses the address bus and the write signal to create a synchronous
</p>
<p>enable condition. Each output port is modeled with its own block. The following Verilog shows how the
</p>
<p>output ports at x&rdquo;E0&rdquo; and x&rdquo;E1&rdquo; are modeled using address-specific procedural blocks:
</p>
<p>//-- port_out_00 (address E0)
always @ (posedge clock or negedge reset)
</p>
<p>begin
if (!reset)
</p>
<p>port_out_00 &lt;&frac14; 8&rsquo;h00;
else
</p>
<p>if ((address &frac14;&frac14; 8&rsquo;hE0) &amp;&amp; (write))
port_out_00 &lt;&frac14; data_in;
</p>
<p>end
</p>
<p>//-- port_out_01 (address E1)
always @ (posedge clock or negedge reset)
</p>
<p>begin
if (!reset)
</p>
<p>port_out_01 &lt;&frac14; 8&rsquo;h00;
else
if ((address &frac14;&frac14; 8&rsquo;hE1) &amp;&amp; (write))
</p>
<p>port_out_01 &lt;&frac14; data_in;
end
</p>
<p>:
&ldquo;the rest of the output port models go here. . .&rdquo;
</p>
<p>:
</p>
<p>446 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.3.4 Implementation of Input Ports in Verilog
</p>
<p>The input ports do not contain storage but do require a mechanism to selectively route their
</p>
<p>information to the data_out port of the memory system. This is accomplished using the multiplexer
</p>
<p>shown in Example 13.10. The only functionality that is required for the input ports is connecting their
</p>
<p>ports to the multiplexer.
</p>
<p>13.3.3.5 Memory data_out Bus Implementation in Verilog
</p>
<p>Now that all of the memory functionality has been designed, the final step is to implement the
</p>
<p>multiplexer that handles routing the appropriate information to the CPU on the data_out bus based on the
</p>
<p>incoming address. The following Verilog provides a model for this behavior. Recall that a multiplexer is
</p>
<p>combinational logic, so if the behavior is to be modeled using a procedural block, all inputs must be listed
</p>
<p>in the sensitivity list, and blocking assignments are used. These inputs include the outputs from the
</p>
<p>program and data memory in addition to all of the input ports. The sensitivity list must also include the
</p>
<p>address bus as it acts as the select input to the multiplexer. Within the block, an if-else statement is used
</p>
<p>to determine which sub-system drives data_out. Programmemory will drive data_out when the incoming
</p>
<p>address is in the range of 0 to 127 (x&rdquo;00&rdquo; to x&rdquo;7F&rdquo;). Data memory will drive data_out when the address is
</p>
<p>in the range of 128 to 223 (x&rdquo;80&rdquo; to x&rdquo;DF&rdquo;). An input port will drive data_out when the address is in the
</p>
<p>range of 240 to 255 (x&rdquo;F0&rdquo; to x&rdquo;FF&rdquo;). Each input port has a unique address, so the specific addresses are
</p>
<p>listed as nested if-else clauses.
</p>
<p>always @ (address, rom_data_out, rw_data_out,
port_in_00, port_in_01, port_in_02, port_in_03,
port_in_04, port_in_05, port_in_06, port_in_07,
port_in_08, port_in_09, port_in_10, port_in_11,
port_in_12, port_in_13, port_in_14, port_in_15)
</p>
<p>begin: MUX1
</p>
<p>if ((address &gt;&frac14; 0) &amp;&amp; (address &lt;&frac14; 127))
data_out &frac14; rom_data_out;
</p>
<p>else if ((address &gt;&frac14; 128) &amp;&amp; (address &lt;&frac14; 223))
data_out &frac14; rw_data_out;
</p>
<p>else if (address &frac14;&frac14; 8&rsquo;hF0) data_out &frac14; port_in_00;
else if (address &frac14;&frac14; 8&rsquo;hF1) data_out &frac14; port_in_01;
else if (address &frac14;&frac14; 8&rsquo;hF2) data_out &frac14; port_in_02;
else if (address &frac14;&frac14; 8&rsquo;hF3) data_out &frac14; port_in_03;
else if (address &frac14;&frac14; 8&rsquo;hF4) data_out &frac14; port_in_04;
else if (address &frac14;&frac14; 8&rsquo;hF5) data_out &frac14; port_in_05;
else if (address &frac14;&frac14; 8&rsquo;hF6) data_out &frac14; port_in_06;
else if (address &frac14;&frac14; 8&rsquo;hF7) data_out &frac14; port_in_07;
else if (address &frac14;&frac14; 8&rsquo;hF8) data_out &frac14; port_in_08;
else if (address &frac14;&frac14; 8&rsquo;hF9) data_out &frac14; port_in_09;
else if (address &frac14;&frac14; 8&rsquo;hFA) data_out &frac14; port_in_10;
else if (address &frac14;&frac14; 8&rsquo;hFB) data_out &frac14; port_in_11;
else if (address &frac14;&frac14; 8&rsquo;hFC) data_out &frac14; port_in_12;
else if (address &frac14;&frac14; 8&rsquo;hFD) data_out &frac14; port_in_13;
else if (address &frac14;&frac14; 8&rsquo;hFE) data_out &frac14; port_in_14;
else if (address &frac14;&frac14; 8&rsquo;hFF) data_out &frac14; port_in_15;
</p>
<p>end
</p>
<p>13.3.4 CPU Implementation
</p>
<p>Let&rsquo;s now look at the central processing unit details. The CPU contains two components, the control
</p>
<p>unit (control_unit.v) and the data path (data_path.v). The data path contains all of the registers and the
</p>
<p>ALU. The ALU is implemented as a sub-system within the data path (alu.v). The data path also contains
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 447</p>
<p/>
</div>
<div class="page"><p/>
<p>a bus system in order to facilitate data movement between the registers and memory. The bus system is
</p>
<p>implemented with two multiplexers that are controlled by the control unit. The control unit contains the
</p>
<p>finite-state machine that generates all control signals for the data path as it performs the fetch-decode-
</p>
<p>execute steps of each instruction. Example 13.11 shows the block diagram of the CPU in our 8-bit
</p>
<p>microcomputer example.
</p>
<p>13.3.4.1 Data Path Implementation in Verilog
</p>
<p>Let&rsquo;s first look at the data path bus system that handles internal signal routing. The system consists
</p>
<p>of two 8-bit busses (Bus1 and Bus2) and two multiplexers. Bus1 is used as the destination of the PC, A,
</p>
<p>and B register outputs, while Bus2 is used as the input to the IR, MAR, PC, A, and B registers. Bus1 is
</p>
<p>connected directly to the to_memory port of the CPU to allow registers to write data to the memory
</p>
<p>Example 13.11
CPU block diagram for the 8-bit computer system
</p>
<p>448 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>system. Bus2 can be driven by the from_memory port of the CPU to allow the memory system to provide
</p>
<p>data for the CPU registers. The two multiplexers handle all signal routing and have their select lines
</p>
<p>(Bus1_Sel and Bus2_Sel) driven by the control unit. The following Verilog shows how the multiplexers
</p>
<p>are implemented. Again, a multiplexer is combinational logic, so all inputs must be listed in the sensitivity
</p>
<p>list of its procedural block, and blocking assignments are used. Two additional signal assignments are
</p>
<p>also required to connect the MAR to the address port and to connect Bus1 to the to_memory port.
</p>
<p>always @ (Bus1_Sel, PC, A, B)
begin: MUX_BUS1
</p>
<p>case (Bus1_Sel)
2&rsquo;b00 : Bus1 &frac14; PC;
2&rsquo;b01 : Bus1 &frac14; A;
2&rsquo;b10 : Bus1 &frac14; B;
default : Bus1 &frac14; 8&rsquo;hXX;
</p>
<p>endcase
end
</p>
<p>always @ (Bus2_Sel, ALU_Result, Bus1, from_memory)
begin: MUX_BUS2
</p>
<p>case (Bus2_Sel)
2&rsquo;b00 : Bus2 &frac14; ALU_Result;
2&rsquo;b01 : Bus2 &frac14; Bus1;
2&rsquo;b10 : Bus2 &frac14; from_memory;
</p>
<p>default : Bus1 &frac14; 8&rsquo;hXX;
endcase
</p>
<p>end
</p>
<p>always @ (Bus1, MAR)
begin
</p>
<p>to_memory &frac14; Bus1;
address &frac14; MAR;
</p>
<p>end
</p>
<p>Next, let&rsquo;s look at implementing the registers in the data path. Each register is implemented using a
</p>
<p>dedicated procedural block that is sensitive to clock and reset. This models the behavior of synchronous
</p>
<p>latches, or registers. Each register has a synchronous enable line that dictates when the register is
</p>
<p>updated. The register output is only updated when the enable line is asserted and a rising edge of the
</p>
<p>clock is detected. The following Verilog shows how to model the instruction register (IR). Notice that the
</p>
<p>signal IR is only updated if IR_Load is asserted and there is a rising edge of the clock. In this case, IR is
</p>
<p>loaded with the value that resides on Bus2.
</p>
<p>always @ (posedge clock or negedge reset)
begin: INSTRUCTION_REGISTER
</p>
<p>if (!reset)
IR &lt;&frac14; 8&rsquo;h00;
</p>
<p>else
if (IR_Load)
IR &lt;&frac14; Bus2;
</p>
<p>end
</p>
<p>A nearly identical block is used to model the memory address register. A unique signal is declared
</p>
<p>called MAR in order to make the Verilog more readable. MAR is always assigned to address in this
</p>
<p>system.
</p>
<p>always @ (posedge clock or negedge reset)
begin: MEMORY_ADDRESS_REGISTER
if (!reset)
</p>
<p>MAR &lt;&frac14; 8&rsquo;h00;
else
</p>
<p>if (MAR_Load)
MAR &lt;&frac14; Bus2;
</p>
<p>end
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 449</p>
<p/>
</div>
<div class="page"><p/>
<p>Now let&rsquo;s look at the program counter block. This register contains additional functionality beyond
</p>
<p>simply latching in the value of Bus2. The program counter also has an increment feature that will take
</p>
<p>place synchronously when the signal PC_Inc coming from the control unit is asserted. This is handled
</p>
<p>using an additional nested if-else clause under the portion of the block handling the rising edge of the
</p>
<p>clock condition.
</p>
<p>always @ (posedge clock or negedge reset)
begin: PROGRAM_COUNTER
</p>
<p>if (!reset)
PC &lt;&frac14; 8&rsquo;h00;
</p>
<p>else
if (PC_Load)
</p>
<p>PC &lt;&frac14; Bus2;
else if (PC_Inc)
</p>
<p>PC &lt;&frac14; MAR + 1;
end
</p>
<p>The two general-purpose registers A and B are modeled using individual procedural blocks as
</p>
<p>follows:
</p>
<p>always @ (posedge clock or negedge reset)
begin: A_REGISTER
</p>
<p>if (!reset)
A &lt;&frac14; 8&rsquo;h00;
</p>
<p>else
if (A_Load)
</p>
<p>A &lt;&frac14; Bus2;
end
</p>
<p>always @ (posedge clock or negedge reset)
begin: B_REGISTER
</p>
<p>if (!reset)
B &lt;&frac14; 8&rsquo;h00;
</p>
<p>else
if (B_Load)
</p>
<p>B &lt;&frac14; Bus2;
end
</p>
<p>The condition code register latches in the status flags from the ALU (NZVC) when the CCR_Load
</p>
<p>line is asserted. This behavior is modeled using a similar approach as follows:
</p>
<p>always @ (posedge clock or negedge reset)
begin: CONDITION_CODE_REGISTER
</p>
<p>if (!reset)
CCR_Result &lt;&frac14; 8&rsquo;h00;
</p>
<p>else
if (CCR_Load)
</p>
<p>CCR_Result &lt;&frac14; NZVC;
end
</p>
<p>13.3.4.2 ALU Implementation in Verilog
</p>
<p>The ALU is a set of combinational logic circuitry that performs arithmetic and logic operations. The
</p>
<p>output of the ALU operation is called Result. The ALU also outputs four status flags as a 4-bit bus called
</p>
<p>NZVC. The ALU behavior can be modeled using case and if-else statements that decide which operation
</p>
<p>to perform based on the input control signal ALU_Sel. The following Verilog shows an example of how to
</p>
<p>implement the ALU addition functionality. A case statement is used to decide which operation is being
</p>
<p>performed based on the ALU_Sel input. Under each operation clause, a series of procedural statements
</p>
<p>are used to compute the result and update the NZVC flags. Each of these flags is updated individually.
</p>
<p>The N flag can be simply driven with position 7 of the ALU result since this bit is the sign bit for signed
</p>
<p>450 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>numbers. The Z flag can be driven using an if-else condition that checks whether the result was x&rdquo;00&rdquo;.
</p>
<p>The V flag is updated based on the type of the operation. For the addition operation, the V flag will be
</p>
<p>asserted if a POS + POS&frac14;NEG or a NEG + NEG&frac14; POS. These conditions can be checked by looking at
</p>
<p>the sign bits of the inputs and the sign bit of the result. Finally, the C flag can be computed as the 8th bit in
</p>
<p>the addition of A + B.
</p>
<p>always @ (A, B, ALU_Sel)
begin
</p>
<p>case (ALU_Sel)
3&rsquo;b000 : begin //-- Addition
</p>
<p>//-- Sum and Carry Flag
{NZVC[0], Result} &frac14; A + B;
</p>
<p>//-- Negative Flag
NZVC[3] &frac14; Result[7];
</p>
<p>//-- Zero Flag
if (Result &frac14;&frac14; 0)
</p>
<p>NZVC[2] &frac14; 1;
else
</p>
<p>NZVC[2] &frac14; 0;
</p>
<p>//-- Two&rsquo;s Comp Overflow Flag
if (((A[7]&frac14;&frac14;0) &amp;&amp; (B[7]&frac14;&frac14;0) &amp;&amp; (Result[7] &frac14;&frac14; 1)) ||
</p>
<p>((A[7]&frac14;&frac14;1) &amp;&amp; (B[7]&frac14;&frac14;1) &amp;&amp; (Result[7] &frac14;&frac14; 0)))
NZVC[1] &frac14; 1;
</p>
<p>else
NZVC[1] &frac14; 0;
</p>
<p>end
</p>
<p>:
//-- other ALU operations go here...
</p>
<p>:
</p>
<p>default : begin
Result &frac14; 8&rsquo;hXX;
NZVC &frac14; 4&rsquo;hX;
</p>
<p>end
endcase
</p>
<p>end
</p>
<p>13.3.4.3 Control Unit Implementation in Verilog
</p>
<p>Let&rsquo;s now look at how to implement the control unit state machine. We&rsquo;ll first look at the formation of
</p>
<p>the Verilog to model the FSM and then turn to the detailed state transitions in order to accomplish a
</p>
<p>variety of the most common instructions. The control unit sends signals to the data path in order to move
</p>
<p>data in and out of registers and into the ALU to perform data manipulations. The finite-state machine is
</p>
<p>implemented with the behavioral modeling techniques presented in Chap. 9. The model contains three
</p>
<p>processes in order to implement the state memory, next state logic, and output logic of the FSM.
</p>
<p>Parameters are created for each of the states defined in the state diagram of the FSM. The states
</p>
<p>associated with fetching (S_FETCH_0, S_FETCH_1, S_FETCH_2) and decoding the opcode
</p>
<p>(S_DECODE_3) are performed each time an instruction is executed. A unique path is then added
</p>
<p>after the decode state to perform the steps associated with executing each individual instruction. The
</p>
<p>FSM can be created one instruction at a time by adding additional state paths after the decode state. The
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 451</p>
<p/>
</div>
<div class="page"><p/>
<p>following Verilog code shows how the user-defined state names are created for nine basic instructions
</p>
<p>(LDA_IMM, LDA_DIR, STA_DIR, LDB_IMM, LDB_DIR, STB_DIR, ADD_AB, BRA, and BEQ). Eight-bit
</p>
<p>state variables are created for current_state and next_state to accommodate future state codes. The
</p>
<p>state codes are assigned in binary using integer format to allow additional states to be easily added.
</p>
<p>reg [7:0] current_state, next_state;
parameter S_FETCH_0 &frac14; 0, //-- Opcode fetch states
</p>
<p>S_FETCH_1 &frac14; 1,
S_FETCH_2 &frac14; 2,
</p>
<p>S_DECODE_3 &frac14; 3, //-- Opcode decode state
</p>
<p>S_LDA_IMM_4 &frac14; 4, //-- Load A (Immediate) states
S_LDA_IMM_5 &frac14; 5,
S_LDA_IMM_6 &frac14; 6,
</p>
<p>S_LDA_DIR_4 &frac14; 7, //-- Load A (Direct) states
S_LDA_DIR_5 &frac14; 8,
S_LDA_DIR_6 &frac14; 9,
S_LDA_DIR_7 &frac14; 10,
S_LDA_DIR_8 &frac14; 11,
</p>
<p>S_STA_DIR_4 &frac14; 12, //-- Store A (Direct) States
S_STA_DIR_5 &frac14; 13,
S_STA_DIR_6 &frac14; 14,
S_STA_DIR_7 &frac14; 15,
</p>
<p>S_LDB_IMM_4 &frac14; 16, //-- Load B (Immediate) states
S_LDB_IMM_5 &frac14; 17,
S_LDB_IMM_6 &frac14; 18,
</p>
<p>S_LDB_DIR_4 &frac14; 19, //-- Load B (Direct) states
S_LDB_DIR_5 &frac14; 20,
S_LDB_DIR_6 &frac14; 21,
S_LDB_DIR_7 &frac14; 22,
S_LDB_DIR_8 &frac14; 23,
</p>
<p>S_STB_DIR_4 &frac14; 24, //-- Store B (Direct) States
S_STB_DIR_5 &frac14; 25,
S_STB_DIR_6 &frac14; 26,
S_STB_DIR_7 &frac14; 27,
</p>
<p>S_BRA_4 &frac14; 28, //-- Branch Always States
S_BRA_5 &frac14; 29,
S_BRA_6 &frac14; 30,
</p>
<p>S_BEQ_4 &frac14; 31, //-- Branch if Equal States
S_BEQ_5 &frac14; 32,
S_BEQ_6 &frac14; 33,
S_BEQ_7 &frac14; 34,
</p>
<p>S_ADD_AB_4 &frac14; 35; //-- Addition States
</p>
<p>Within the control unit module, the state memory is implemented as a separate procedural block that
</p>
<p>will update the current state with the next state on each rising edge of the clock. The reset state will be the
</p>
<p>first fetch state in the FSM (i.e., S_FETCH_0). The following Verilog shows how the state memory in the
</p>
<p>control unit can be modeled. Note that this block models sequential logic so non-blocking assignments
</p>
<p>are used.
</p>
<p>452 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>always @ (posedge clock or negedge reset)
begin: STATE_MEMORY
</p>
<p>if (!reset)
current_state &lt;&frac14; S_FETCH_0;
</p>
<p>else
current_state &lt;&frac14; next_state;
</p>
<p>end
</p>
<p>The next state logic is also implemented as a separate procedural block. The next state logic
</p>
<p>depends on the current state, the instruction register (IR), and the condition code register (CCR_Result).
</p>
<p>The following Verilog gives a portion of the next state logic process showing how the state transitions can
</p>
<p>be modeled:
</p>
<p>always @ (current_state, IR, CCR_Result)
begin: NEXT_STATE_LOGIC
</p>
<p>case (current_state)
S_FETCH_0 : next_state &frac14; S_FETCH_1; //-- Path for FETCH instruction
S_FETCH_1 : next_state &frac14; S_FETCH_2;
S_FETCH_2 : next_state &frac14; S_DECODE_3;
</p>
<p>S_DECODE_3 : if (IR&frac14;&frac14; LDA_IMM)next_state &frac14; S_LDA_IMM_4; //-- Register A
else if (IR&frac14;&frac14; LDA_DIR)next_state &frac14; S_LDA_DIR_4;
else if (IR&frac14;&frac14; STA_DIR next_state &frac14; S_STA_DIR_4;
else if (IR&frac14;&frac14; LDB_IMM)next_state &frac14; S_LDB_IMM_4; //-- Register B
else if (IR&frac14;&frac14; LDB_DIR)next_state &frac14; S_LDB_DIR_4;
else if (IR&frac14;&frac14; STB_DIR) next_state &frac14; S_STB_DIR_4;
elseif (IR&frac14;&frac14; BRA) next_state &frac14; S_BRA_4; //--BranchAlways
elseif (IR&frac14;&frac14;ADD_AB) next_state &frac14;S_ADD_AB_4; //--ADD
else next_state &frac14; S_FETCH_0; //--others gohere
</p>
<p>S_LDA_IMM_4 : next_state &frac14; S_LDA_IMM_5; //-- Path for LDA_IMM instruction
S_LDA_IMM_5 : next_state &frac14; S_LDA_IMM_6;
S_LDA_IMM_6 : next_state &frac14; S_FETCH_0;
</p>
<p>:
Next state logic for other states goes here. . .
</p>
<p>:
endcase
</p>
<p>end
</p>
<p>Finally, the output logic is modeled as a third, separate procedural block. It is useful to explicitly state
</p>
<p>the outputs of the control unit for each state in the machine to allow easy debugging and avoid
</p>
<p>synthesizing latches. Our example computer system has Moore-type outputs, so the process only
</p>
<p>depends on the current state. The following Verilog shows a portion of the output logic process:
</p>
<p>always @ (current_state)
begin: OUTPUT_LOGIC
</p>
<p>case (current_state)
</p>
<p>S_FETCH_0 : begin //-- Put PC onto MAR to provide address of Opcode
IR_Load &frac14; 0;
MAR_Load &frac14; 1;
PC_Load &frac14; 0;
PC_Inc &frac14; 0;
A_Load &frac14; 0;
B_Load &frac14; 0;
ALU_Sel &frac14; 3&rsquo;b000;
CCR_Load &frac14; 0;
Bus1_Sel &frac14; 2&rsquo;b00;//-- "00"&frac14;PC, "01"&frac14;A, "10"&frac14;B
Bus2_Sel &frac14; 2&rsquo;b01; //-- "00"&frac14;ALU, "01"&frac14;Bus1, "10"&frac14;from_memory
write &frac14; 0;
</p>
<p>end
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 453</p>
<p/>
</div>
<div class="page"><p/>
<p>S_FETCH_1 : begin //-- Increment PC, Opcode will be available next state
IR_Load &frac14; 0;
MAR_Load&frac14; 0;
PC_Load &frac14; 0;
PC_Inc &frac14; 1;
A_Load &frac14; 0;
B_Load &frac14; 0;
ALU_Sel &frac14; 3&rsquo;b000;
CCR_Load&frac14; 0;
Bus1_Sel&frac14; 2&rsquo;b00; //-- "00"&frac14;PC, "01"&frac14;A, "10"&frac14;B
Bus2_Sel&frac14; 2&rsquo;b00; //-- "00"&frac14;ALU, "01"&frac14;Bus1, "10"&frac14;from_memory
write &frac14; 0;
</p>
<p>end;
</p>
<p>:
Output logic for other states goes here. . .
</p>
<p>:
</p>
<p>endcase
end
</p>
<p>13.3.4.3.1 Detailed Execution of LDA_IMM
</p>
<p>Now let&rsquo;s look at the details of the state transitions and output signals in the control unit FSM when
</p>
<p>executing a few of the most common instructions. Let&rsquo;s begin with the instruction to load register A using
</p>
<p>immediate addressing (LDA_IMM). Example 13.12 shows the state diagram for this instruction. The first
</p>
<p>three states (S_FETCH_0, S_FETCH_1, S_FETCH_2) handle fetching the opcode. The purpose of
</p>
<p>these states is to read the opcode from the address being held by the program counter and put it into the
</p>
<p>instruction register. Multiple states are needed to handle putting PC into MAR to provide the address of
</p>
<p>the opcode, waiting for the memory system to provide the opcode, latching the opcode into IR, and
</p>
<p>incrementing PC to the next location in program memory. Another state is used to decode the opcode
</p>
<p>(S_DECODE_3) in order to decide which path to take in the state diagram based on the instruction being
</p>
<p>executed. After the decode state, a series of three more states are needed (S_LDA_IMM_4,
</p>
<p>S_LDA_IMM_5, S_LDA_IMM_6) to execute the instruction. The purpose of these states is to read the
</p>
<p>operand from the address being held by the program counter and put it into A. Multiple states are needed
</p>
<p>to handle putting PC into MAR to provide the address of the operand, waiting for the memory system to
</p>
<p>provide the operand, latching the operand into A, and incrementing PC to the next location in program
</p>
<p>memory. When the instruction completes, the value of the operand resides in A, and PC is pointing to the
</p>
<p>next location in program memory, which is the opcode of the next instruction to be executed.
</p>
<p>454 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.13 shows the simulation waveform for executing LDA_IMM. In this example, register A
</p>
<p>is loaded with the operand of the instruction, which holds the value x&rdquo;AA&rdquo;.
</p>
<p>Example 13.12
State diagram for LDA_IMM
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 455</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.4.3.2 Detailed Execution of LDA_DIR
</p>
<p>Now let&rsquo;s look at the details of the instruction to load register A using direct addressing (LDA_DIR).
</p>
<p>Example 13.14 shows the state diagram for this instruction. The first four states to fetch and decode the
</p>
<p>opcode are the same states as in the previous instruction and are performed each time a new instruction
</p>
<p>is executed. Once the opcode is decoded, the state machine traverses five new states to execute the
</p>
<p>instruction (S_LDA_DIR_4, S_LDA_DIR_5, S_LDA_DIR_6, S_LDA_DIR_7, S_LDA_DIR_8). The pur-
</p>
<p>pose of these states is to read the operand and then use it as the address of where to read the contents to
</p>
<p>put into A.
</p>
<p>Example 13.13
Simulation waveform for LDA_IMM
</p>
<p>456 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.15 shows the simulation waveform for executing LDA_DIR. In this example, register A
</p>
<p>is loaded with the contents located at address x&rdquo;80&rdquo;, which has already been initialized to x&rdquo;AA&rdquo;.
</p>
<p>Example 13.14
State diagram for LDA_DIR
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 457</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.4.3.3 Detailed Execution of STA_DIR
</p>
<p>Now let&rsquo;s look at the details of the instruction to store register A to memory using direct addressing
</p>
<p>(STA_DIR). Example 13.16 shows the state diagram for this instruction. The first four states are again the
</p>
<p>same as prior instructions in order to fetch and decode the opcode. Once the opcode is decoded, the
</p>
<p>state machine traverses four new states to execute the instruction (S_STA_DIR_4, S_STA_DIR_5,
</p>
<p>S_STA_DIR_6, S_STA_DIR_7). The purpose of these states is to read the operand and then use it as
</p>
<p>the address of where to write the contents of A to.
</p>
<p>Example 13.15
Simulation waveform for LDA_DIR
</p>
<p>458 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.17 shows the simulation waveform for executing STA_DIR. In this example, register A
</p>
<p>already contains the value x&rdquo;CC&rdquo; and will be stored to address x&rdquo;E0&rdquo;. The address x&rdquo;E0&rdquo; is an output port
</p>
<p>(port_out_00) in our example computer system.
</p>
<p>Example 13.16
State diagram for STA_DIR
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 459</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.4.3.4 Detailed Execution of ADD_AB
</p>
<p>Now let&rsquo;s look at the details of the instruction to add A to B and store the sum back in A (ADD_AB).
</p>
<p>Example 13.18 shows the state diagram for this instruction. The first four states are again the same as
</p>
<p>prior instructions in order to fetch and decode the opcode. Once the opcode is decoded, the state
</p>
<p>machine only requires one more state to complete the operation (S_ADD_AB_4). The ALU is combina-
</p>
<p>tional logic so it will begin to compute the sum immediately as soon as the inputs are updated. The inputs
</p>
<p>Example 13.17
Simulation waveform for STA_DIR
</p>
<p>460 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>to the ALU are Bus1 and register B. Since B is directly connected to the ALU, all that is required to start
</p>
<p>the addition is to put A onto Bus1. The output of the ALU is put on Bus2 so that it can be latched into A on
</p>
<p>the next clock edge. The ALU also outputs the status flags NZVC, which are directly connected to the
</p>
<p>condition code register. A_Load and CCR_Load are asserted in this state. A and CCR_Result will be
</p>
<p>updated in the next state (i.e., S_FETCH_0).
</p>
<p>Example 13.18
State diagram for ADD_AB
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 461</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.19 shows the simulation waveform for executing ADD_AB. In this example, two load
</p>
<p>immediate instructions were used to initialize the general-purpose registers to A &frac14; x&rdquo;FF&rdquo; and B &frac14; x&rdquo;01&rdquo;
</p>
<p>prior to the addition. The addition of these values will result in a sum of x&rdquo;00&rdquo; and assert the carry (C) and
</p>
<p>zero (Z) flags in the condition code register.
</p>
<p>Example 13.19
Simulation waveform for ADD_AB
</p>
<p>462 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.3.4.3.5 Detailed Execution of BRA
</p>
<p>Now let&rsquo;s look at the details of the instruction to branch always (BRA). Example 13.20 shows the
</p>
<p>state diagram for this instruction. The first four states are again the same as prior instructions in order to
</p>
<p>fetch and decode the opcode. Once the opcode is decoded, the state machine traverses four new states
</p>
<p>to execute the instruction (S_BRA_4, S_BRA_5, S_BRA_6). The purpose of these states is to read the
</p>
<p>operand and put its value into PC to set the new location in program memory to execute instructions.
</p>
<p>Example 13.20
State diagram for BRA
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 463</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.21 shows the simulation waveform for executing BRA. In this example, PC is set back
</p>
<p>to address x&rdquo;00&rdquo;.
</p>
<p>13.3.4.3.6 Detailed Execution of BEQ
</p>
<p>Now let&rsquo;s look at the branch if equal to zero (BEQ) instruction. Example 13.22 shows the state
</p>
<p>diagram for this instruction. Notice that in this conditional branch, the path that is taken through the FSM
</p>
<p>depends on both IR and CCR. In the case that Z &frac14; 1, the branch is taken, meaning that the operand is
</p>
<p>Example 13.21
Simulation waveform for BRA
</p>
<p>464 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>loaded into PC. In the case that Z&frac14; 0, the branch is not taken, meaning that PC is simply incremented to
</p>
<p>bypass the operand and point to the beginning of the next instruction in program memory.
</p>
<p>Example 13.22
State diagram for BEQ
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 465</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.23 shows the simulation waveform for executing BEQwhen the branch is taken. Prior to
</p>
<p>this instruction, an addition was performed on x&rdquo;FF&rdquo; and x&rdquo;01&rdquo;. This resulted in a sum of x&rdquo;00&rdquo;, which
</p>
<p>asserted the Z and C flags in the condition code register. Since Z&frac14; 1 when BEQ is executed, the branch
</p>
<p>is taken.
</p>
<p>Example 13.23
Simulation waveform for BEQ when taking the branch (Z &frac14; 1)
</p>
<p>466 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Example 13.24 shows the simulation waveform for executing BEQ when the branch is not taken.
</p>
<p>Prior to this instruction, an addition was performed on x&rdquo;FE&rdquo; and x&rdquo;01&rdquo;. This resulted in a sum of x&rdquo;FF&rdquo;,
</p>
<p>which did not assert the Z flag. Since Z &frac14; 0 when BEQ is executed, the branch is not taken. When not
</p>
<p>taking the branch, PC must be incremented again in order to bypass the operand and point to the next
</p>
<p>location in program memory.
</p>
<p>Example 13.24
Simulation waveform for BEQ when the branch is not taken (Z &frac14; 0)
</p>
<p>13.3 Computer Implementation: An 8-Bit Computer Example &bull; 467</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC13.3 The 8-bit microcomputer example presented in this section is a very simple architec-
ture used to illustrate the basic concepts of a computer. If we wanted to keep this
computer an 8-bit system but increase the depth of the memory, it would require
adding more address lines to the address bus. What changes to the computer system
would need to be made to accommodate the wider address bus?
</p>
<p>A) The width of the program counter would need to be increased to support the
wider address bus.
</p>
<p>B) The size of the memory address register would need to be increased to
support the wider address bus.
</p>
<p>C) Instructions that use direct addressing would need additional bytes of oper-
and to pass the wider address into the CPU 8 bits at a time.
</p>
<p>D) All of the above.
</p>
<p>13.4 Architecture Considerations
</p>
<p>13.4.1 Von Neumann Architecture
</p>
<p>The computer system just presented represents a very simple architecture in which all memory
</p>
<p>devices (i.e., program, data, and I/O) are grouped into a single memory map. This approach is known as
</p>
<p>the Von Neumann architecture, named after the nineteenth-century mathematician that first described
</p>
<p>this structure in 1945. The advantage of this approach is in the simplicity of the CPU interface. The CPU
</p>
<p>can be constructed based on a single bus system that executes everything in a linear progression of
</p>
<p>states, regardless of whether memory is being accessed for an instruction or a variable. One of the
</p>
<p>drawbacks of this approach is that an instruction and variable data cannot be read at the same time. This
</p>
<p>creates a latency in data manipulation since the system needed to be constantly switching between
</p>
<p>reading instructions and accessing data. This latency became known as the Von Neumann bottleneck.
</p>
<p>13.4.2 Harvard Architecture
</p>
<p>As computer systems evolved and larger data sets in memory were being manipulated, it became
</p>
<p>apparent that it was advantageous to be able to access data in parallel with reading the next instruction.
</p>
<p>The Harvard architecture was proposed to address the Von Neumann bottleneck by separating the
</p>
<p>program and data memory and using two distinct bus systems for the CPU interface. This approach
</p>
<p>allows data and program information to be accessed in parallel and leads to performance improvement
</p>
<p>when large numbers of data manipulations in memory need to be performed. Figure 13.5 shows a
</p>
<p>comparison between the two architectures.
</p>
<p>468 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>CONCEPT CHECK
</p>
<p>CC13.4 Does a computer with a Harvard architecture require two control unit state machines?
</p>
<p>A) Yes. It has two bus systems that need to be managed separately, so two
finite-state machines are required.
</p>
<p>B) No. A single state machine is still used to fetch, decode, and execute the
instruction. The only difference is that if data is required for the execute stage,
it can be retrieved from data memory at the same time the state machine
fetches the opcode of the next instruction from program memory.
</p>
<p>Fig. 13.5
Von Neumann vs. Harvard architecture
</p>
<p>13.4 Architecture Considerations &bull; 469</p>
<p/>
</div>
<div class="page"><p/>
<p>Summary
</p>
<p>v A computer is a collection of hardware
components that are constructed to perform
a specific set of instructions to process and
store data. The main hardware components
of a computer are the central processing unit
(CPU), program memory, data memory, and
input/output ports.
</p>
<p>v The CPU consists of registers for fast stor-
age, an arithmetic logic unit (ALU) for data
manipulation, and a control state machine
that directs all activity to execute an
instruction.
</p>
<p>v A CPU is typically organized into a data path
and a control unit. The data path contains all
circuitry used to store and process informa-
tion. The data path includes the registers and
the ALU. The control unit is a large state
machine that sends control signals to the
data path in order to facilitate instruction
execution.
</p>
<p>v The control unit continuously performs a
fetch-decode-execute cycle in order to com-
plete instructions.
</p>
<p>v The instructions that a computer is designed
to execute is called its instruction set.
</p>
<p>v Instructions are inserted into program mem-
ory in a sequence that when executed will
accomplish a particular task. This sequence
of instructions is called a computer program.
</p>
<p>v An instruction consists of an opcode and a
potential operand. The opcode is the unique
binary code that tells the control state
machine which instruction is being executed.
An operand is additional information that may
be needed for the instruction.
</p>
<p>v An addressing mode refers to the way that
the operand is treated. In immediate
addressing, the operand is the actual data
to be used. In direct addressing, the operand
is the address of where the data is to be
retrieved or stored. In inherent addressing,
all of the information needed to complete
the instruction is contained within the
opcode, so no operand is needed.
</p>
<p>v A computer also contains data memory to
hold temporary variables during run time.
</p>
<p>v A computer also contains input and output
ports to interface with the outside world.
</p>
<p>v A memory-mapped system is one in which
the program memory, data memory, and I/O
ports are all assigned a unique address. This
allows the CPU to simply process information
as data and addresses and allows the pro-
gram to handle where the information is
being sent to. A memory map is a graphical
representation of what address ranges vari-
ous components are mapped to.
</p>
<p>v There are three primary classes of
instructions. These are loads and stores,
data manipulations, and branches.
</p>
<p>v Load instructions move information from
memory into a CPU register. A load instruc-
tion takes multiple read cycles. Store
instructions move information from a CPU
register into memory. A store instruction
takes multiple read cycles and at least one
write cycle.
</p>
<p>v Data manipulation instructions operate on
information being held in CPU registers.
Data manipulation instructions often use
inherent addressing.
</p>
<p>v Branch instructions alter the flow of instruc-
tion execution. Unconditional branches
always change the location in memory of
where the CPU is executing instructions.
Conditional branches only change the loca-
tion of instruction execution if a status flag is
asserted.
</p>
<p>v Status flags are held in the condition code
register and are updated by certain
instructions. The most commonly used flags
are the negative flag (N), zero flag (Z), two&rsquo;s
complement overflow flag (V), and carry flag
(C).
</p>
<p>Exercise Problems
</p>
<p>Section 13.1: Computer Hardware
</p>
<p>13.1.1 What computer hardware sub-system holds
the temporary variables used by the program?
</p>
<p>13.1.2 What computer hardware sub-system contains
fast storage for holding and/or manipulating
data and addresses?
</p>
<p>13.1.3 What computer hardware sub-system allows
the computer to interface to the outside world?
</p>
<p>13.1.4 What computer hardware sub-system contains
the state machine that orchestrates the fetch-
decode-execute process?
</p>
<p>470 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>13.1.5 What computer hardware sub-system contains
the circuitry that performs mathematical and
logic operations?
</p>
<p>13.1.6 What computer hardware sub-system holds
the instructions being executed?
</p>
<p>Section 13.2: Computer Software
</p>
<p>13.2.1 In computer software, what are the names of
the most basic operations that a computer can
perform?
</p>
<p>13.2.2 Which element of computer software is the
binary code that tells the CPUwhich instruction
is being executed?
</p>
<p>13.2.3 Which element of computer software is a col-
lection of instructions that perform a desired
task?
</p>
<p>13.2.4 Which element of computer software is the
supplementary information required by an
instruction such as constants or which
registers to use?
</p>
<p>13.2.5 Which class of instructions handles moving
information between memory and CPU
registers?
</p>
<p>13.2.6 Which class of instructions alters the flow of
program execution?
</p>
<p>13.2.7 Which class of instructions alters data using
either arithmetic or logical operations?
</p>
<p>Section 13.3: Computer Implementation:
An 8-Bit Computer Example
</p>
<p>13.3.1 Design the example 8-bit computer system
presented in this chapter in Verilog with the
ability to execute the three instructions
LDA_IMM, STA_DIR, and BRA. Simulate your
computer system using the following program
that will continually write the patterns x&rdquo;AA&rdquo;
and x&rdquo;BB&rdquo; to output ports port_out_00 and
port_out_01:
</p>
<p>initial
begin
ROM[0] &frac14; LDA_IMM;
ROM[1] &frac14; 8&rsquo;hAA;
ROM[2] &frac14; STA_DIR;
ROM[3] &frac14; 8&rsquo;hE0;
ROM[4] &frac14; STA_DIR;
ROM[5] &frac14; 8&rsquo;hE1;
ROM[6] &frac14; LDB_IMM;
ROM[7] &frac14; 8&rsquo;hBB;
ROM[8] &frac14; STB_DIR;
ROM[9] &frac14; 8&rsquo;hE0;
ROM[10] &frac14; STB_DIR;
ROM[11] &frac14; 8&rsquo;hE1;
ROM[12] &frac14; BRA;
ROM[13] &frac14; 8&rsquo;h00;
</p>
<p>end
</p>
<p>13.3.2 Add the functionality to the computer model
from 13.3.1 the ability to perform the LDA_DIR
instruction. Simulate your computer system
using the following program that will continually
</p>
<p>read from port_in_00 and write its contents to
port_out_00:
</p>
<p>initial
begin
ROM[0] &frac14; LDA_DIR;
ROM[1] &frac14; 8&rsquo;hF0;
ROM[2] &frac14; STA_DIR;
ROM[3] &frac14; 8&rsquo;hE0;
ROM[4] &frac14; BRA;
ROM[5] &frac14; 8&rsquo;h00;
</p>
<p>End
</p>
<p>13.3.3 Add the functionality to the computer model
from 13.3.2 the ability to perform the
instructions LDB_IMM, LDB_DIR, and
STB_DIR. Modify the example programs
given in exercises 13.3.1 and 13.3.2 to use
register B in order to simulate your
implementation.
</p>
<p>13.3.4 Add the functionality to the computer model
from 13.3.3 the ability to perform the addition
instruction ADD_AB. Test your addition instruc-
tion by simulating the following program. The
first addition instruction will perform
x&rdquo;FE&rdquo; + x&rdquo;01&rdquo; &frac14; x&rdquo;FF&rdquo; and assert the negative
(N) flag. The second addition instruction will
perform x&rdquo;01&rdquo; + x&rdquo;FF&rdquo; &frac14; x&rdquo;00&rdquo; and assert the
carry (C) and zero (Z) flags. The third addition
instruction will perform x&rdquo;7F&rdquo; + x&rdquo;7F&rdquo; &frac14; x&rdquo;FE&rdquo;
and assert the two&rsquo;s complement overflow
(V) and negative (N) flags.
</p>
<p>initial
begin
</p>
<p>ROM[0] &frac14; LDA_IMM; //-- test 1
ROM[1] &frac14; 8&rsquo;hFE;
ROM[2] &frac14; LDB_IMM;
ROM[3] &frac14; 8&rsquo;h01;
ROM[4] &frac14; ADD_AB;
ROM[5] &frac14; LDA_IMM; //-- test 2
ROM[6] &frac14; 8&rsquo;h01;
ROM[7] &frac14; LDB_IMM;
ROM[8] &frac14; 8&rsquo;hFF;
ROM[9] &frac14; ADD_AB;
ROM[10] &frac14; LDA_IMM; //-- test 3
ROM[11] &frac14; 8&rsquo;h7F;
ROM[12] &frac14; LDB_IMM;
ROM[13] &frac14; 8&rsquo;h7F;
ROM[14] &frac14; ADD_AB;
ROM[15] &frac14; BRA;
ROM[16] &frac14; 8&rsquo;h00;
</p>
<p>end
</p>
<p>13.3.5 Add the functionality to the computer model
from 13.3.4 the ability to perform the branch if
equal to zero instruction BEQ. Simulate your
implementation using the following program.
The first addition in this program will perform
x&rdquo;FE&rdquo; + x&rdquo;01&rdquo; &frac14; x&rdquo;FF&rdquo; (Z &frac14; 0). The subsequent
BEQ instruction should NOT take the branch.
The second addition in this program will per-
form x&rdquo;FF&rdquo; + x&rdquo;01&rdquo; &frac14; x&rdquo;00&rdquo; (Z &frac14; 1) and
SHOULD take the branch. The final instruction
in this program is a BRA that is inserted for
</p>
<p>Exercise Problems &bull; 471</p>
<p/>
</div>
<div class="page"><p/>
<p>safety. In the event that the BEQ is not
operating properly, the BRA will set the pro-
gram counter back to x&rdquo;00&rdquo; and prevent the
program from running away.
</p>
<p>initial
begin
</p>
<p>ROM[0] &frac14; LDA_IMM; //-- test 1
ROM[1] &frac14; 8&rsquo;hFE;
ROM[2] &frac14; LDB_IMM;
ROM[3] &frac14; 8&rsquo;h01;
ROM[4] &frac14; ADD_AB;
ROM[5] &frac14; BEQ; //--NO branch
ROM[6] &frac14; 8&rsquo;h00;
</p>
<p>ROM[7] &frac14; LDA_IMM; //-- test 2
ROM[8] &frac14; 8&rsquo;h01;
ROM[9] &frac14; LDB_IMM;
ROM[10] &frac14; 8&rsquo;hFF;
ROM[11] &frac14; ADD_AB;
ROM[12] &frac14; BEQ; //-- Branch
ROM[13] &frac14; 8&rsquo;h00;
</p>
<p>ROM[14] &frac14; BRA;
ROM[15] &frac14; 8&rsquo;h00;
</p>
<p>end
</p>
<p>13.3.6 Add the functionality for the SUB_AB instruc-
tion described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.7 Add the functionality for the AND_AB instruc-
tion described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.8 Add the functionality for theOR_AB instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.9 Add the functionality for the INCA instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.10 Add the functionality for the INCB instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.11 Add the functionality for the DECA instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.12 Add the functionality for the DECB instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.13 Add the functionality for the BMI instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.14 Add the functionality for the BPL instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.15 Add the functionality for the BNE instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.16 Add the functionality for the BVS instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.17 Add the functionality for the BVC instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.18 Add the functionality for the BCS instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>13.3.19 Add the functionality for the BCC instruction
described in Example 13.9 to the computer
model from 13.3.4. You will need to create a
test program to verify the execution of the
instruction.
</p>
<p>Section 13.4: Architectural
Considerations
</p>
<p>13.4.1 Would the instruction set need to be different
between a Von Neumann versus a Harvard
architecture? Why or why not?
</p>
<p>13.4.2 Which of the three classes of computer
instructions (loads/stores, data manipulations,
and branches) are sped up by moving from the
Von Neumann architecture to the Harvard
architecture.
</p>
<p>13.4.3 In a memory-mapped, Harvard architecture,
would the I/O system be placed in the program
memory or data memory block?
</p>
<p>13.4.4 A Harvard architecture requires two memory
address registers to handle two separate mem-
ory systems. Does it also require two instruc-
tion registers? Why or why not?
</p>
<p>13.4.5 A Harvard architecture requires two memory
address registers to handle two separate mem-
ory systems. Does it also require two program
counters? Why or why not?
</p>
<p>472 &bull; Chapter 13: Computer System Design</p>
<p/>
</div>
<div class="page"><p/>
<p>Appendix A: List of Worked Examples
</p>
<p>EXAMPLE 2.1 CONVERTING DECIMAL TO DECIMAL ....................................................... ....................................................... 12
</p>
<p>EXAMPLE 2.2 CONVERTING BINARY TO DECIMAL ....................................................... ....................................................... 13
</p>
<p>EXAMPLE 2.3 CONVERTING OCTAL TO DECIMAL ........................................................ ........................................................ 13
</p>
<p>EXAMPLE 2.4 CONVERTING HEXADECIMAL TO DECIMAL ................................................... ................................................... 14
</p>
<p>EXAMPLE 2.5 CONVERTING DECIMAL TO BINARY ........................................................ ....................................................... 16
</p>
<p>EXAMPLE 2.6 CONVERTING DECIMAL TO OCTAL ........................................................ ........................................................ 17
</p>
<p>EXAMPLE 2.7 CONVERTING DECIMAL TO HEXADECIMAL ................................................... ................................................... 18
</p>
<p>EXAMPLE 2.8 CONVERTING BINARY TO OCTAL ......................................................... ........................................................ 19
</p>
<p>EXAMPLE 2.9 CONVERTING BINARY TO HEXADECIMAL .................................................... ................................................... 20
</p>
<p>EXAMPLE 2.10 CONVERTING OCTAL TO BINARY ........................................................ ........................................................ 20
</p>
<p>EXAMPLE 2.11 CONVERTING HEXADECIMAL TO BINARY ................................................... ................................................... 21
</p>
<p>EXAMPLE 2.12 CONVERTING OCTAL TO HEXADECIMAL .................................................... ................................................... 21
</p>
<p>EXAMPLE 2.13 CONVERTING HEXADECIMAL TO OCTAL .................................................... ................................................... 22
</p>
<p>EXAMPLE 2.14 SINGLE-BIT BINARY ADDITION ......................................................... ......................................................... 23
</p>
<p>EXAMPLE 2.15 MULTIPLE-BIT BINARY ADDITION ........................................................ ....................................................... 23
</p>
<p>EXAMPLE 2.16 SINGLE-BIT BINARY SUBTRACTION ...................................................... ...................................................... 24
</p>
<p>EXAMPLE 2.17 MULTIPLE-BIT BINARY SUBTRACTION ..................................................... .................................................... 24
</p>
<p>EXAMPLE 2.18 FINDING THE RANGE OF AN UNSIGNED NUMBER ............................................. ............................................ 26
</p>
<p>EXAMPLE 2.19 DECIMAL VALUES THAT A 4-BIT, SIGNED MAGNITUDE CODE CAN REPRESENT ........................ ........................ 27
</p>
<p>EXAMPLE 2.20 FINDING THE RANGE OF A SIGNED MAGNITUDE NUMBER ....................................... ...................................... 28
</p>
<p>EXAMPLE 2.21 FINDING THE DECIMAL VALUE OF A SIGNED MAGNITUDE NUMBER ................................. ................................ 28
</p>
<p>EXAMPLE 2.22 DECIMAL VALUES THAT A 4-BIT, ONE&rsquo;S COMPLEMENT CODE CAN REPRESENT ........................ ....................... 29
</p>
<p>EXAMPLE 2.23 FINDING THE RANGE OF A 1&rsquo;S COMPLEMENT NUMBER ........................................ ........................................ 30
</p>
<p>EXAMPLE 2.24 FINDING THE DECIMAL VALUE OF A 1&rsquo;S COMPLEMENT NUMBER .................................. .................................. 30
</p>
<p>EXAMPLE 2.25 DECIMAL VALUES THAT A 4-BIT, TWO&rsquo;S COMPLEMENT CODE CAN REPRESENT ........................ ........................ 31
</p>
<p>EXAMPLE 2.26 FINDING THE RANGE OF A TWO&rsquo;S COMPLEMENT NUMBER ...................................... ...................................... 32
</p>
<p>EXAMPLE 2.27 FINDING THE DECIMAL VALUE OF A TWO&rsquo;S COMPLEMENT NUMBER ................................ ................................ 32
</p>
<p>EXAMPLE 2.28 FINDING THE TWO&rsquo;S COMPLEMENT CODE OF A DECIMAL NUMBER ................................ ................................ 33
</p>
<p>EXAMPLE 2.29 TWO&rsquo;S COMPLEMENT ADDITION ......................................................... ........................................................ 35
</p>
<p>EXAMPLE 3.1 CALCULATING ICC AND IGND WHEN SOURCING MULTIPLE LOADS .................................. .................................. 55
</p>
<p>EXAMPLE 3.2 CALCULATING ICC AND IGND WHEN BOTH SOURCING AND SINKING LOADS ............................ ........................... 56
</p>
<p>EXAMPLE 3.3 DETERMINING IF SPECIFICATIONS ARE VIOLATED WHEN DRIVING ANOTHER GATE AS A LOAD ............... ............... 78
</p>
<p>EXAMPLE 3.4 DETERMINING THE OUTPUT CURRENT WHEN DRIVING MULTIPLE GATES AS THE LOAD .................... ................... 79
</p>
<p>EXAMPLE 3.5 DETERMINING THE OUTPUT CURRENT WHEN DRIVING A PULL-UP RESISTOR AS THE LOAD ................ ................ 80
</p>
<p>EXAMPLE 3.6 DETERMINING THE OUTPUT CURRENT WHEN DRIVING A PULL-DOWN RESISTOR AS THE LOAD .............. ............. 81
</p>
<p>EXAMPLE 3.7 DETERMINING THE OUTPUT CURRENT WHEN DRIVING AN LED WHERE HIGH &frac14; ON ................... ................... 82
</p>
<p>EXAMPLE 3.8 DETERMINING THE OUTPUT CURRENT WHEN DRIVING AN LED WHERE HIGH &frac14; OFF ................... .................. 83
</p>
<p>EXAMPLE 4.1 PROVING DEMORGAN&rsquo;S THEOREM OF DUALITY USING PROOF BY EXHAUSTION ........................ ........................ 96
</p>
<p>EXAMPLE 4.2 CONVERTING BETWEEN POSITIVE AND NEGATIVE LOGIC USING DUALITY ............................. ............................ 97
</p>
<p>EXAMPLE 4.3 USING THE COMMUTATIVE PROPERTY TO UNTANGLE CROSSED WIRES ............................. ............................. 101
</p>
<p>EXAMPLE 4.4 USING THE ASSOCIATIVE PROPERTY TO ADDRESS FAN-IN LIMITATIONS ............................. ............................. 102
</p>
<p>EXAMPLE 4.5 USING THE DISTRIBUTIVE PROPERTY TO REDUCE THE NUMBER OF LOGIC GATES IN A CIRCUIT ............ ........... 103
</p>
<p>EXAMPLE 4.6 PROVING THE ABSORPTION THEOREM USING PROOF BY EXHAUSTION .............................. ............................. 104
</p>
<p>EXAMPLE 4.7 PROVING OF THE UNITING THEOREM ..................................................... .................................................... 105
</p>
<p>EXAMPLE 4.8 CONVERTING A SUM OF PRODUCTS FORM INTO ONE THAT USES ONLY NAND GATES .................. ................. 107
</p>
<p>EXAMPLE 4.9 CONVERTING A PRODUCT OF SUMS FORM INTO ONE THAT USES ONLY NOR GATES .................. ................... 108
</p>
<p>EXAMPLE 4.10 USING DEMORGAN&rsquo;S THEOREM IN ALGEBRAIC FORM (1) ...................................... ..................................... 109
</p>
<p>EXAMPLE 4.11 USING DEMORGAN&rsquo;S THEOREM IN ALGEBRAIC FORM (2) ...................................... ..................................... 109
</p>
<p>EXAMPLE 4.12 DETERMINING THE LOGIC EXPRESSION FROM A LOGIC DIAGRAM ................................................................... 112
</p>
<p>EXAMPLE 4.13 DETERMINING THE TRUTH TABLE FROM A LOGIC DIAGRAM ........................................................................... 113
</p>
<p>EXAMPLE 4.14 DETERMINING THE DELAY OF A COMBINATIONAL LOGIC CIRCUIT ................................................................... 114
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5
</p>
<p>473</p>
<p/>
<div class="annotation"><a href="https://doi.org/10.1007/978-3-030-13605-5">https://doi.org/10.1007/978-3-030-13605-5</a></div>
</div>
<div class="page"><p/>
<p>EXAMPLE 4.15 CREATING A CANONICAL SUM OF PRODUCTS LOGIC CIRCUIT USING MINTERMS ............................................. 116
</p>
<p>EXAMPLE 4.16 CREATING A MINTERM LIST FROM A TRUTH TABLE ...................................................................................... 117
</p>
<p>EXAMPLE 4.17 CREATING EQUIVALENT FUNCTIONAL REPRESENTATIONS FROM A MINTERM LIST ............................................. 118
</p>
<p>EXAMPLE 4.18 CREATING A PRODUCT OF SUMS LOGIC CIRCUIT USING MAXTERMS .............................. .............................. 120
</p>
<p>EXAMPLE 4.19 CREATING A MAXTERM LIST FROM A TRUTH TABLE .......................................... ......................................... 121
</p>
<p>EXAMPLE 4.20 CREATING EQUIVALENT FUNCTIONAL REPRESENTATIONS FROM A MAXTERM LIST ...................... ..................... 122
</p>
<p>EXAMPLE 4.21 CREATING EQUIVALENT FORMS TO REPRESENT LOGIC FUNCTIONALITY ............................. ............................ 123
</p>
<p>EXAMPLE 4.22 MINIMIZING A LOGIC EXPRESSION ALGEBRAICALLY .......................................... .......................................... 125
</p>
<p>EXAMPLE 4.23 USING A K-MAP TO FIND A MINIMIZED SUM OF PRODUCTS EXPRESSION (2-INPUT) ................... ................... 130
</p>
<p>EXAMPLE 4.24 USING A K-MAP TO FIND A MINIMIZED SUM OF PRODUCTS EXPRESSION (3-INPUT) ................... ................... 131
</p>
<p>EXAMPLE 4.25 USING A K-MAP TO FIND A MINIMIZED SUM OF PRODUCTS EXPRESSION (4-INPUT) ................... ................... 132
</p>
<p>EXAMPLE 4.26 USING A K-MAP TO FIND A MINIMIZED PRODUCT OF SUMS EXPRESSION (2-INPUT) ................... ................... 133
</p>
<p>EXAMPLE 4.27 USING A K-MAP TO FIND A MINIMIZED PRODUCT OF SUMS EXPRESSION (3-INPUT) ................... ................... 134
</p>
<p>EXAMPLE 4.28 USING A K-MAP TO FIND A MINIMIZED PRODUCT OF SUMS EXPRESSION (4-INPUT) ................... ................... 135
</p>
<p>EXAMPLE 4.29 DERIVING THE MINIMAL SUM FROM A K-MAP .............................................. .............................................. 137
</p>
<p>EXAMPLE 4.30 USING DON&rsquo;T CARES TO PRODUCE A MINIMAL SOP LOGIC EXPRESSION .......................... ......................... 138
</p>
<p>EXAMPLE 4.31 ELIMINATING A TIMING HAZARD BY INCLUDING NONESSENTIAL PRODUCT TERMS ...................... ..................... 143
</p>
<p>EXAMPLE 5.1 DECLARING VERILOG MODULE PORTS .................................................... ................................................... 169
</p>
<p>EXAMPLE 5.2 MODELING COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT
</p>
<p>WITH LOGICAL OPERATORS ........................................................... ........................................................... 177
</p>
<p>EXAMPLE 5.3 MODELING COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT
</p>
<p>WITH CONDITIONAL OPERATORS (1) ..................................................... ..................................................... 178
</p>
<p>EXAMPLE 5.4 MODELING COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT
</p>
<p>WITH CONDITIONAL OPERATORS (2) ..................................................... ..................................................... 179
</p>
<p>EXAMPLE 5.5 MODELING DELAY IN CONTINUOUS ASSIGNMENTS ............................................ ........................................... 180
</p>
<p>EXAMPLE 5.6 INERTIAL DELAY MODELING WHEN USING CONTINUOUS ASSIGNMENT. ............................... .............................. 181
</p>
<p>EXAMPLE 5.7 VERILOG STRUCTURAL DESIGN USING EXPLICIT PORT MAPPING .................................. ................................. 183
</p>
<p>EXAMPLE 5.8 VERILOG STRUCTURAL DESIGN USING POSITIONAL PORT MAPPING ................................ ............................... 184
</p>
<p>EXAMPLE 5.9 MODELING COMBINATIONAL LOGIC CIRCUITS USING GATE-LEVEL PRIMITIVES ......................... ........................ 185
</p>
<p>EXAMPLE 5.10 MODELING COMBINATIONAL LOGIC CIRCUITS WITH A USER-DEFINED PRIMITIVE ...................... ...................... 186
</p>
<p>EXAMPLE 6.1 2-TO-4 ONE-HOT DECODER: LOGIC SYNTHESIS BY HAND ....................................... ...................................... 196
</p>
<p>EXAMPLE 6.2 3-TO-8 ONE-HOT DECODER: VERILOG MODELING USING LOGICAL OPERATORS ....................... ...................... 197
</p>
<p>EXAMPLE 6.3 3-TO-8 ONE-HOT DECODER: VERILOG MODELING USING CONDITIONAL OPERATORS .................... ................... 198
</p>
<p>EXAMPLE 6.4 7-SEGMENT DISPLAY DECODER: TRUTH TABLE ............................................. ............................................. 199
</p>
<p>EXAMPLE 6.5 7-SEGMENT DISPLAY DECODER: LOGIC SYNTHESIS BY HAND ................................... ................................... 200
</p>
<p>EXAMPLE 6.6 7-SEGMENT DISPLAY DECODER: VERILOG MODELING USING LOGICAL OPERATORS ..................... .................... 201
</p>
<p>EXAMPLE 6.7 7-SEGMENT DISPLAY DECODER: VERILOG MODELING USING CONDITIONAL OPERATORS ................. ................. 202
</p>
<p>EXAMPLE 6.8 4-TO-2 BINARY ENCODER: LOGIC SYNTHESIS BY HAND ........................................ ....................................... 203
</p>
<p>EXAMPLE 6.9 4-TO-2 BINARY ENCODER: VERILOG MODELING USING LOGICAL AND CONDITIONAL OPERATORS ............ ............ 204
</p>
<p>EXAMPLE 6.10 2-TO-1 MULTIPLEXER: LOGIC SYNTHESIS BY HAND .......................................... ......................................... 205
</p>
<p>EXAMPLE 6.11 4-TO-1 MULTIPLEXER: VERILOG MODELING USING LOGICAL AND CONDITIONAL OPERATORS .............. .............. 206
</p>
<p>EXAMPLE 6.12 1-TO-2 DEMULTIPLEXER: LOGIC SYNTHESIS BY HAND ........................................ ....................................... 207
</p>
<p>EXAMPLE 6.13 1-TO-4 DEMULTIPLEXER: VERILOG MODELING USING LOGICAL AND CONDITIONAL OPERATORS ............ ............ 208
</p>
<p>EXAMPLE 7.1 PUSH-BUTTON WINDOW CONTROLLER: WORD DESCRIPTION .................................... .................................... 238
</p>
<p>EXAMPLE 7.2 PUSH-BUTTON WINDOW CONTROLLER: STATE DIAGRAM ....................................... ....................................... 240
</p>
<p>EXAMPLE 7.3 PUSH-BUTTON WINDOW CONTROLLER: STATE TRANSITION TABLE ................................. ................................ 241
</p>
<p>EXAMPLE 7.4 SOLVING FOR THE NUMBER OF BITS NEEDED FOR BINARY-STATE ENCODING ......................... ........................ 243
</p>
<p>EXAMPLE 7.5 PUSH-BUTTON WINDOW CONTROLLER: STATE ENCODING ...................................... ...................................... 245
</p>
<p>EXAMPLE 7.6 PUSH-BUTTON WINDOW CONTROLLER: NEXT STATE LOGIC ..................................... .................................... 246
</p>
<p>EXAMPLE 7.7 PUSH-BUTTON WINDOW CONTROLLER: OUTPUT LOGIC ........................................ ....................................... 247
</p>
<p>EXAMPLE 7.8 PUSH-BUTTON WINDOW CONTROLLER: LOGIC DIAGRAM ....................................... ....................................... 248
</p>
<p>EXAMPLE 7.9 SERIAL BIT SEQUENCE DETECTOR (PART 1) ............................................... ............................................... 249
</p>
<p>EXAMPLE 7.10 SERIAL BIT SEQUENCE DETECTOR (PART 2) .............................................. .............................................. 250
</p>
<p>EXAMPLE 7.11 SERIAL BIT SEQUENCE DETECTOR (PART 3) .............................................. .............................................. 251
</p>
<p>EXAMPLE 7.12 VENDING MACHINE CONTROLLER (PART 1) ............................................... ............................................... 252
</p>
<p>EXAMPLE 7.13 VENDING MACHINE CONTROLLER (PART 2) ............................................... ............................................... 253
</p>
<p>EXAMPLE 7.14 VENDING MACHINE CONTROLLER (PART 3) ............................................... ............................................... 254
</p>
<p>474 &bull; Appendix A: List of Worked Examples</p>
<p/>
</div>
<div class="page"><p/>
<p>EXAMPLE 7.15 2-BIT BINARY UP COUNTER (PART 1) ................................................... .................................................. 256
</p>
<p>EXAMPLE 7.16 2-BIT BINARY UP COUNTER (PART 2) ................................................... .................................................. 257
</p>
<p>EXAMPLE 7.17 2-BIT BINARY UP/DOWN COUNTER (PART 1) .............................................. ............................................. 258
</p>
<p>EXAMPLE 7.18 2-BIT BINARY UP/DOWN COUNTER (PART 2) .............................................. ............................................. 259
</p>
<p>EXAMPLE 7.19 2-BIT GRAY CODE UP COUNTER (PART 1) ............................................... ............................................... 260
</p>
<p>EXAMPLE 7.20 2-BIT GRAY CODE UP COUNTER (PART 2) ............................................... ............................................... 261
</p>
<p>EXAMPLE 7.21 2-BIT GRAY CODE UP/DOWN COUNTER (PART 1) ......................................... .......................................... 262
</p>
<p>EXAMPLE 7.22 2-BIT GRAY CODE UP/DOWN COUNTER (PART 2) ......................................... .......................................... 263
</p>
<p>EXAMPLE 7.23 3-BIT ONE-HOT UP COUNTER (PART 1) ................................................. ................................................ 264
</p>
<p>EXAMPLE 7.24 3-BIT ONE-HOT UP COUNTER (PART 2) ................................................. ................................................ 265
</p>
<p>EXAMPLE 7.25 3-BIT ONE-HOT UP/DOWN COUNTER (PART 1) ............................................ ........................................... 266
</p>
<p>EXAMPLE 7.26 3-BIT ONE-HOT UP/DOWN COUNTER (PART 2) ............................................ ............................................ 267
</p>
<p>EXAMPLE 7.27 3-BIT ONE-HOT UP/DOWN COUNTER (PART 3) ............................................ ............................................ 268
</p>
<p>EXAMPLE 7.28 DETERMINING THE NEXT STATE LOGIC AND OUTPUT LOGIC EXPRESSION OF A FSM .................. .................. 271
</p>
<p>EXAMPLE 7.29 DETERMINING THE STATE TRANSITION TABLE OF A FSM ...................................... ..................................... 272
</p>
<p>EXAMPLE 7.30 DETERMINING THE STATE DIAGRAM OF A FSM ............................................ ............................................ 273
</p>
<p>EXAMPLE 7.31 DETERMINING THE MAXIMUM CLOCK FREQUENCY OF A FSM ................................... .................................. 276
</p>
<p>EXAMPLE 8.1 USING BLOCKING ASSIGNMENTS TO MODEL COMBINATIONAL LOGIC ............................... ............................... 293
</p>
<p>EXAMPLE 8.2 USING NON-BLOCKING ASSIGNMENTS TO MODEL SEQUENTIAL LOGIC .............................. ............................. 293
</p>
<p>EXAMPLE 8.3 IDENTICAL BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS ...................... ..................... 294
</p>
<p>EXAMPLE 8.4 DIFFERENT BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS (1) .................. .................. 295
</p>
<p>EXAMPLE 8.5 DIFFERENT BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS (2) ................... .................. 296
</p>
<p>EXAMPLE 8.6 BEHAVIOR OF STATEMENT GROUPS BEGIN/END VS. FORK/JOIN .................................. .................................. 297
</p>
<p>EXAMPLE 8.7 USING IF-ELSE STATEMENTS TO MODEL COMBINATIONAL LOGIC .................................. ................................. 299
</p>
<p>EXAMPLE 8.8 USING CASE STATEMENTS TO MODEL COMBINATIONAL LOGIC ................................... ................................... 301
</p>
<p>EXAMPLE 8.9 TEST BENCH FOR A COMBINATIONAL LOGIC CIRCUIT .......................................... ......................................... 310
</p>
<p>EXAMPLE 8.10 TEST BENCH FOR A SEQUENTIAL LOGIC CIRCUIT ........................................................................................ 311
</p>
<p>EXAMPLE 8.11 PRINTING TEST BENCH RESULTS TO THE TRANSCRIPT ....................................... ....................................... 312
</p>
<p>EXAMPLE 8.12 TEST BENCH WITH AUTOMATIC OUTPUT CHECKING .......................................... ......................................... 313
</p>
<p>EXAMPLE 8.13 USING A LOOP TO GENERATE STIMULUS IN A TEST BENCH .................................... ................................... 315
</p>
<p>EXAMPLE 8.14 PRINTING TEST BENCH RESULTS TO AN EXTERNAL FILE ...................................... ..................................... 316
</p>
<p>EXAMPLE 8.15 READING TEST BENCH STIMULUS VECTORS FROM AN EXTERNAL FILE ............................ ............................ 317
</p>
<p>EXAMPLE 9.1 BEHAVIORAL MODEL OF A D-LATCH IN VERILOG ............................................. ............................................ 323
</p>
<p>EXAMPLE 9.2 BEHAVIORAL MODEL OF A D-FLIP-FLOP IN VERILOG .......................................... ......................................... 324
</p>
<p>EXAMPLE 9.3 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH ASYNCHRONOUS RESET IN VERILOG ..................... .................... 325
</p>
<p>EXAMPLE 9.4 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH ASYNCHRONOUS RESET AND PRESET IN VERILOG ........... ........... 326
</p>
<p>EXAMPLE 9.5 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH SYNCHRONOUS ENABLE IN VERILOG ..................... .................... 327
</p>
<p>EXAMPLE 9.6 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG: DESIGN DESCRIPTION ........................... .......................... 328
</p>
<p>EXAMPLE 9.7 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG: PORT DEFINITION .............................. ............................. 328
</p>
<p>EXAMPLE 9.8 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG: FULL MODEL ................................. ................................ 331
</p>
<p>EXAMPLE 9.9 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG: SIMULATION WAVEFORM ......................... ......................... 332
</p>
<p>EXAMPLE 9.10 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG: CHANGING STATE CODES ....................... ...................... 333
</p>
<p>EXAMPLE 9.11 SERIAL BIT SEQUENCE DETECTOR IN VERILOG: DESIGN DESCRIPTION AND PORT DEFINITION ............ ............ 334
</p>
<p>EXAMPLE 9.12 SERIAL BIT SEQUENCE DETECTOR IN VERILOG: FULL MODEL .................................. .................................. 335
</p>
<p>EXAMPLE 9.13 SERIAL BIT SEQUENCE DETECTOR IN VERILOG: SIMULATION WAVEFORM ........................... .......................... 336
</p>
<p>EXAMPLE 9.14 VENDING MACHINE CONTROLLER IN VERILOG: DESIGN DESCRIPTION AND PORT DEFINITION ............. ............. 336
</p>
<p>EXAMPLE 9.15 VENDING MACHINE CONTROLLER IN VERILOG: FULL MODEL ................................... ................................... 337
</p>
<p>EXAMPLE 9.16 VENDING MACHINE CONTROLLER IN VERILOG: SIMULATION WAVEFORM ............................ ........................... 338
</p>
<p>EXAMPLE 9.17 2-BIT UP/DOWN COUNTER IN VERILOG: DESIGN DESCRIPTION AND PORT DEFINITION ................. ................. 338
</p>
<p>EXAMPLE 9.18 2-BIT UP/DOWN COUNTER IN VERILOG: FULL MODEL (THREE-BLOCK APPROACH) ................... ................... 339
</p>
<p>EXAMPLE 9.19 2-BIT UP/DOWN COUNTER IN VERILOG: SIMULATION WAVEFORM ................................ ............................... 339
</p>
<p>EXAMPLE 9.20 BINARY COUNTER USING A SINGLE-PROCEDURAL BLOCK IN VERILOG ............................. ............................. 341
</p>
<p>EXAMPLE 9.21 BINARY COUNTER WITH RANGE CHECKING IN VERILOG ....................................... ...................................... 342
</p>
<p>EXAMPLE 9.22 BINARY COUNTER WITH ENABLE IN VERILOG .............................................. .............................................. 343
</p>
<p>EXAMPLE 9.23 BINARY COUNTER WITH LOAD IN VERILOG ................................................ ............................................... 344
</p>
<p>EXAMPLE 9.24 RTL MODEL OF AN 8-BIT REGISTER IN VERILOG ........................................... .......................................... 345
</p>
<p>EXAMPLE 9.25 REGISTERS AS AGENTS ON A DATA BUS: SYSTEM TOPOLOGY .................................. ................................. 346
</p>
<p>Appendix A: List of Worked Examples &bull; 475</p>
<p/>
</div>
<div class="page"><p/>
<p>EXAMPLE 9.26 REGISTERS AS AGENTS ON A DATA BUS: RTL MODEL IN VERILOG .............................. .............................. 347
</p>
<p>EXAMPLE 9.27 REGISTERS AS AGENTS ON A DATA BUS: SIMULATION WAVEFORM ............................... ............................... 347
</p>
<p>EXAMPLE 9.28 RTL MODEL OF A 4-STAGE, 8-BIT SHIFT REGISTER IN VERILOG ............................... ............................... 348
</p>
<p>EXAMPLE 10.1 CALCULATING THE FINAL DIGIT LINE VOLTAGE IN A DRAM BASED ON CHARGE SHARING .............. .............. 372
</p>
<p>EXAMPLE 10.2 BEHAVIORAL MODELS OF A 4 � 4 ASYNCHRONOUS READ-ONLY MEMORY IN VERILOG ................ ................. 376
</p>
<p>EXAMPLE 10.3 BEHAVIORAL MODELS OF A 4 � 4 SYNCHRONOUS READ-ONLY MEMORY IN VERILOG .................. ................. 377
</p>
<p>EXAMPLE 10.4 BEHAVIORAL MODEL OF A 4 � 4 ASYNCHRONOUS READ/WRITE MEMORY IN VERILOG ................. ................ 378
</p>
<p>EXAMPLE 10.5 BEHAVIORAL MODEL OF A 4 � 4 SYNCHRONOUS READ/WRITE MEMORY IN VERILOG .................. ................. 379
</p>
<p>EXAMPLE 12.1 DESIGN OF A HALF ADDER .......................................................... .......................................................... 398
</p>
<p>EXAMPLE 12.2 DESIGN OF A FULL ADDER ........................................................... .......................................................... 398
</p>
<p>EXAMPLE 12.3 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .......................................... ......................................... 400
</p>
<p>EXAMPLE 12.4 DESIGN OF A 4-BIT RIPPLE CARRY ADDER (RCA) ......................................... ......................................... 401
</p>
<p>EXAMPLE 12.5 TIMING ANALYSIS OF A 4-BIT RIPPLE CARRY ADDER ........................................ ........................................ 402
</p>
<p>EXAMPLE 12.6 DESIGN OF A 4-BIT CARRY LOOK AHEAD ADDER (CLA) &ndash; OVERVIEW ............................ ........................... 403
</p>
<p>EXAMPLE 12.7 DESIGN OF A 4-BIT CARRY LOOK AHEAD ADDER (CLA) &ndash; ALGEBRAIC FORMATION ................... ................... 404
</p>
<p>EXAMPLE 12.8 TIMING ANALYSIS OF A 4-BIT CARRY LOOK AHEAD ADDER .................................... ................................... 405
</p>
<p>EXAMPLE 12.9 STRUCTURAL MODEL OF A FULL ADDER USING TWO HALF ADDERS IN VERILOG ..................... ..................... 406
</p>
<p>EXAMPLE 12.10 STRUCTURAL MODEL OF A 4-BIT RIPPLE CARRY ADDER IN VERILOG ............................ ............................ 407
</p>
<p>EXAMPLE 12.11 TEST BENCH FOR A 4-BIT RIPPLE CARRY ADDER USING NESTED FOR LOOPS IN VERILOG ............. ............. 408
</p>
<p>EXAMPLE 12.12 STRUCTURAL MODEL OF A 4-BIT CARRY LOOK AHEAD ADDER IN VERILOG ........................ ........................ 409
</p>
<p>EXAMPLE 12.13 4-BIT CARRY LOOK AHEAD ADDER &ndash; SIMULATION WAVEFORM ................................ ................................ 409
</p>
<p>EXAMPLE 12.14 BEHAVIORAL MODEL OF A 4-BIT ADDER IN VERILOG ........................................ ........................................ 410
</p>
<p>EXAMPLE 12.15 DESIGN OF A 4-BIT SUBTRACTOR USING FULL ADDERS ............................................................................ 411
</p>
<p>EXAMPLE 12.16 CREATING A PROGRAMMABLE INVERTER USING AN XOR GATE ................................ ................................ 412
</p>
<p>EXAMPLE 12.17 DESIGN OF A 4-BIT PROGRAMMABLE ADDER/SUBTRACTOR ................................... ................................... 412
</p>
<p>EXAMPLE 12.18 PERFORMING LONG MULTIPLICATION ON DECIMAL NUMBERS .................................. .................................. 414
</p>
<p>EXAMPLE 12.19 PERFORMING LONG MULTIPLICATION ON BINARY NUMBERS ................................... ................................... 414
</p>
<p>EXAMPLE 12.20 DESIGN OF A SINGLE-BIT MULTIPLIER .................................................. ................................................. 415
</p>
<p>EXAMPLE 12.21 DESIGN OF A 4-BIT UNSIGNED MULTIPLIER .............................................. .............................................. 415
</p>
<p>EXAMPLE 12.22 TIMING ANALYSIS OF A 4-BIT UNSIGNED MULTIPLIER ....................................... ....................................... 416
</p>
<p>EXAMPLE 12.23 MULTIPLYING AN UNSIGNED BINARY NUMBER BY TWO USING A LOGICAL SHIFT LEFT ................. ................ 416
</p>
<p>EXAMPLE 12.24 ILLUSTRATING HOW AN UNSIGNED MULTIPLIER INCORRECTLY HANDLES SIGNED NUMBERS .............. .............. 417
</p>
<p>EXAMPLE 12.25 PROCESS TO CORRECTLY HANDLE SIGNED NUMBERS USING AN UNSIGNED MULTIPLIER ............... .............. 418
</p>
<p>EXAMPLE 12.26 PERFORMING LONG DIVISION ON DECIMAL NUMBERS ....................................... ....................................... 419
</p>
<p>EXAMPLE 12.27 PERFORMING LONG MULTIPLICATION ON BINARY NUMBERS ................................... ................................... 420
</p>
<p>EXAMPLE 12.28 DESIGN OF A 4-BIT UNSIGNED DIVIDER USING A SERIES OF ITERATIVE SUBTRACTORS ................ ............... 421
</p>
<p>EXAMPLE 12.29 DIVIDING 11112 (1510) BY 01112 (710) USING THE ITERATIVE SUBTRACTION ARCHITECTURE ........... .......... 422
</p>
<p>EXAMPLE 12.30 DIVIDING AN UNSIGNED BINARY NUMBERS BY TWO USING A LOGICAL SHIFT RIGHT .................. ................. 423
</p>
<p>EXAMPLE 13.1 MEMORY MAP FOR A 256 � 8 MEMORY SYSTEM .......................................... ......................................... 432
</p>
<p>EXAMPLE 13.2 EXECUTION OF AN INSTRUCTION TO &ldquo;LOAD REGISTER A USING IMMEDIATE ADDRESSING&rdquo; ............... ............... 435
</p>
<p>EXAMPLE 13.3 EXECUTION OF AN INSTRUCTION TO &ldquo;LOAD REGISTER A USING DIRECT ADDRESSING&rdquo; ................. ................. 436
</p>
<p>EXAMPLE 13.4 EXECUTION OF AN INSTRUCTION TO &ldquo;STORE REGISTER A USING DIRECT ADDRESSING&rdquo; ................ ................ 437
</p>
<p>EXAMPLE 13.5 EXECUTION OF AN INSTRUCTION TO &ldquo;ADD REGISTERS A AND B&rdquo; ................................ ................................ 438
</p>
<p>EXAMPLE 13.6 EXECUTION OF AN INSTRUCTION TO &ldquo;BRANCH ALWAYS&rdquo; ....................................... ....................................... 439
</p>
<p>EXAMPLE 13.7 EXECUTION OF AN INSTRUCTION TO &ldquo;BRANCH IF EQUAL TO ZERO&rdquo; ............................... ............................... 440
</p>
<p>EXAMPLE 13.8 TOP-LEVEL BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM ............................... ............................... 442
</p>
<p>EXAMPLE 13.9 INSTRUCTION SET FOR THE 8-BIT COMPUTER SYSTEM ....................................... ....................................... 443
</p>
<p>EXAMPLE 13.10 MEMORY SYSTEM BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM .......................... ......................... 444
</p>
<p>EXAMPLE 13.11 CPU BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM .................................. .................................. 448
</p>
<p>EXAMPLE 13.12 STATE DIAGRAM FOR LDA_IMM ..................................................... .................................................... 455
</p>
<p>EXAMPLE 13.13 SIMULATION WAVEFORM FOR LDA_IMM ............................................... ............................................... 456
</p>
<p>EXAMPLE 13.14 STATE DIAGRAM FOR LDA_DIR ..................................................... ..................................................... 457
</p>
<p>EXAMPLE 13.15 SIMULATION WAVEFORM FOR LDA_DIR ................................................ ............................................... 458
</p>
<p>EXAMPLE 13.16 STATE DIAGRAM FOR STA_DIR ..................................................... ..................................................... 459
</p>
<p>EXAMPLE 13.17 SIMULATION WAVEFORM FOR STA_DIR ................................................ ................................................ 460
</p>
<p>EXAMPLE 13.18 STATE DIAGRAM FOR ADD_AB ...................................................... ..................................................... 461
</p>
<p>EXAMPLE 13.19 SIMULATION WAVEFORM FOR ADD_AB ................................................ ................................................ 462
</p>
<p>476 &bull; Appendix A: List of Worked Examples</p>
<p/>
</div>
<div class="page"><p/>
<p>EXAMPLE 13.20 STATE DIAGRAM FOR BRA ......................................................... ......................................................... 463
</p>
<p>EXAMPLE 13.21 SIMULATION WAVEFORM FOR BRA .................................................... ................................................... 464
</p>
<p>EXAMPLE 13.22 STATE DIAGRAM FOR BEQ ......................................................... ......................................................... 465
</p>
<p>EXAMPLE 13.23 SIMULATION WAVEFORM FOR BEQ WHEN TAKING THE BRANCH (Z &frac14; 1) ......................... ......................... 466
</p>
<p>EXAMPLE 13.24 SIMULATION WAVEFORM FOR BEQ WHEN THE BRANCH IS NOT TAKEN (Z &frac14; 0) ..................... .................... 467
</p>
<p>Appendix A: List of Worked Examples &bull; 477</p>
<p/>
</div>
<div class="page"><p/>
<p>Appendix B: Concept Check Solutions
</p>
<p>v CC1.1 B
v CC1.2 C
</p>
<p>v CC2.1 C
v CC2.2 D
v CC2.3 D
v CC2.4 A
</p>
<p>v CC3.1 A
v CC3.4(a) B
v CC3.4(b) C
v CC3.4(c) A
v CC3.3 A
v CC3.4 D
</p>
<p>v CC4.1 B
v CC4.2 B
v CC4.3 D
v CC4.4(a) B
v CC4.4(b) A
v CC4.5 D
</p>
<p>v CC5.1 D
v CC5.2 C
v CC5.3 A
v CC5.4(a) A
v CC5.4(b) B
v CC5.5(a) D
v CC5.5(b) A
v CC5.6 B
v CC5.7 C
</p>
<p>v CC6.1 C
v CC6.2 D
v CC6.3 C
v CC6.4 C
</p>
<p>v CC7.1(a) B
v CC7.1(b) D
v CC7.2 A
</p>
<p>v CC7.3 C
v CC7.4(a) A
v CC7.4(b) C
v CC7.4(c) B
v CC7.4(d) D
v CC7.4(e) A
v CC7.4(f) C
v CC7.5 A
v CC7.6 D
v CC7.7 B
</p>
<p>v CC8.1 A
v CC8.2 B
v CC8.3 B
v CC8.4 B
</p>
<p>v CC9.1 D
v CC9.2 D
v CC9.3 C
v CC9.4 A
v CC9.5 C
</p>
<p>v CC10.1 D
v CC10.2 C
v CC10.3 B
v CC10.4 A
</p>
<p>v CC11.1 C
v CC11.2 B
</p>
<p>v CC12.1 B
v CC12.2 D
v CC12.3 B
v CC12.4 A
</p>
<p>v CC13.1 B
v CC13.2 D
v CC13.3 D
v CC13.4 B
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5
</p>
<p>479</p>
<p/>
<div class="annotation"><a href="https://doi.org/10.1007/978-3-030-13605-5">https://doi.org/10.1007/978-3-030-13605-5</a></div>
</div>
<div class="page"><p/>
<p>Index
</p>
<p>A
</p>
<p>Absorption, 104
</p>
<p>Abstraction, 157
</p>
<p>AC specifications. See Switching characteristics
</p>
<p>Adders
</p>
<p>in Verilog, 405
</p>
<p>Adder/subtractor circuit, 411
</p>
<p>Addition, 22, 397
</p>
<p>AND gate, 46
</p>
<p>Anti-fuse, 361
</p>
<p>Associative property, 102
</p>
<p>Asynchronous memory, 359
</p>
<p>Axioms, 94
</p>
<p>logical negation, 94
</p>
<p>logical precedence, 95
</p>
<p>logical product, 94
</p>
<p>logical sum, 94
</p>
<p>logical values, 94
</p>
<p>B
</p>
<p>Base, 7
</p>
<p>Base conversions, 11
</p>
<p>binary to decimal, 12
</p>
<p>binary to hexadecimal, 19
</p>
<p>binary to octal, 19
</p>
<p>decimal to binary, 15
</p>
<p>decimal to decimal, 11
</p>
<p>decimal to hexadecimal, 18
</p>
<p>decimal to octal, 17
</p>
<p>hexadecimal to binary, 21
</p>
<p>hexadecimal to decimal, 14
</p>
<p>hexadecimal to octal, 22
</p>
<p>octal to binary, 20
</p>
<p>octal to decimal, 13
</p>
<p>octal to hexadecimal, 21
</p>
<p>Binary addition. See Addition
</p>
<p>Binary number system, 9
</p>
<p>Binary subtraction. See Subtraction
</p>
<p>Bipolar junction transistor (BJT), 71
</p>
<p>Bistable, 214
</p>
<p>Boolean algebra, 93
</p>
<p>Boolean algebra theorems, 95
</p>
<p>Borrows, 24
</p>
<p>Break-before-make switch behavior, 234
</p>
<p>Buffer, 45
</p>
<p>Byte, 10
</p>
<p>C
</p>
<p>Canonical product of sums, 118
</p>
<p>Canonical sum of products, 115
</p>
<p>Capacity, 355
</p>
<p>Carry, 22
</p>
<p>Carry look ahead adders (CLA), 402
</p>
<p>Charge sharing, 371
</p>
<p>Classical digital design flow, 161
</p>
<p>CMOS. See Complementary metal oxide semiconductor
</p>
<p>(CMOS)
</p>
<p>CMOS gates, 64
</p>
<p>inverter, 64
</p>
<p>NAND gate, 65
</p>
<p>NOR gate, 68
</p>
<p>CMOS operation, 63
</p>
<p>Combinational logic analysis, 111
</p>
<p>Combining, 105
</p>
<p>Commutative property, 100
</p>
<p>Complementary metal oxide semiconductor (CMOS), 4,
</p>
<p>62
</p>
<p>Complements, 99
</p>
<p>Complete sum, 137
</p>
<p>Complex programmable logic device (CPLD), 387
</p>
<p>Computer system design, 427
</p>
<p>addressing modes, 433
</p>
<p>arithmetic logic unit (ALU), 429
</p>
<p>central processing unit, 429
</p>
<p>condition code register, 429
</p>
<p>control unit, 429
</p>
<p>data memory, 428
</p>
<p>data path, 429
</p>
<p>direct addressing, 434
</p>
<p>example 8-bit system, 441
</p>
<p>control unit, 452
CPU, 448
</p>
<p>detailed instruction execution, 454
</p>
<p>instruction set, 443
</p>
<p>memory system, 444
</p>
<p>general purpose registers, 429
</p>
<p>hardware, 427
</p>
<p>immediate addressing, 433
</p>
<p>indexed addressing, 434
</p>
<p>inherent addressing, 434
</p>
<p>input output ports, 428
</p>
<p>instruction register, 429
</p>
<p>instructions, 427
</p>
<p>branches, 438
</p>
<p>data manipulations, 437
</p>
<p>loads and stores, 434
</p>
<p>memory address register, 429
</p>
<p>memory-mapped, 431
</p>
<p>memory mapped system, 430
</p>
<p>opcodes, 433
</p>
<p>operands, 433
</p>
<p>program, 427
</p>
<p># Springer Nature Switzerland AG 2019
</p>
<p>B. J. LaMeres, Introduction to Logic Circuits &amp; Logic Design with Verilog,
</p>
<p>https://doi.org/10.1007/978-3-030-13605-5
</p>
<p>481</p>
<p/>
<div class="annotation"><a href="https://doi.org/10.1007/978-3-030-13605-5">https://doi.org/10.1007/978-3-030-13605-5</a></div>
</div>
<div class="page"><p/>
<p>Computer system design (cont.)
</p>
<p>program counter, 429
</p>
<p>program memory, 428
</p>
<p>registers, 429
</p>
<p>software, 427, 433
</p>
<p>Configurable logic block (CLB), 389
</p>
<p>Conjunction (^), 94
</p>
<p>Converting between bases. See Base conversions
</p>
<p>Converting between positive and negative logic, 96
</p>
<p>Counters, 256
</p>
<p>designing by hand, 256
</p>
<p>Covering, 104
</p>
<p>Cross-coupled inverter pair, 213
</p>
<p>D
</p>
<p>Data sheet, 57
</p>
<p>7400 DC operating conditions, 74
</p>
<p>DC specifications, 52
</p>
<p>IIH-max, 53
</p>
<p>IIL-max, 53
</p>
<p>II-max, 53
</p>
<p>IOH-max, 52
</p>
<p>IOL-max, 52
</p>
<p>IO-max, 52
</p>
<p>Iq (quiescent current), 54
</p>
<p>NMH, 53
</p>
<p>NML, 53
</p>
<p>VIH-max, 53
</p>
<p>VIH-min, 53
</p>
<p>VIL-max, 53
</p>
<p>VIL-min, 53
</p>
<p>VOH-max, 52
</p>
<p>VOH-min, 52
</p>
<p>VOL-max, 52
</p>
<p>VOL-min, 52
</p>
<p>Decimal number system, 9
</p>
<p>Decoders, 195
</p>
<p>De Morgan&rsquo;s Theorem of Duality, 95
</p>
<p>De Morgan&rsquo;s theorems, 106
</p>
<p>Demultiplexer design by hand, 207
</p>
<p>Demultiplexers, 207
</p>
<p>Design abstraction, 157
</p>
<p>Design domains, 159
</p>
<p>behavioral domain, 159
</p>
<p>physical domain, 159
</p>
<p>structural domain, 159
</p>
<p>Design levels, 159
</p>
<p>algorithmic level, 159
</p>
<p>circuit level, 159
</p>
<p>gate-level, 159
</p>
<p>register transfer level, 159
</p>
<p>system level, 159
</p>
<p>Design simplicity, 4
</p>
<p>D-flip-flop, 225
</p>
<p>Digit, 9
</p>
<p>Digital design flow, 161
</p>
<p>Digit notation, 9
</p>
<p>Diodes, 81
</p>
<p>7400 DIP pinout, 75
</p>
<p>Discrete components, 62
</p>
<p>Disjunction (_), 94
</p>
<p>Distinguished one cells, 137
</p>
<p>Distributive property, 103
</p>
<p>Division, 419
</p>
<p>by powers of 2, 422
</p>
<p>signed, 423
</p>
<p>unsigned, 419
</p>
<p>using iterative subtractions, 420
</p>
<p>D latch, 224
</p>
<p>Don&rsquo;t cares (X), 138
</p>
<p>Double pole, double throw (DPDT) switch, 233
</p>
<p>Double pole, single throw (DPST) switch, 233
</p>
<p>Driving loads, 77
</p>
<p>driving LEDs, 82
</p>
<p>driving resistive loads, 79
</p>
<p>Dual in-line package (DIP), 75
</p>
<p>Duality, 95
</p>
<p>Dynamic hazard, 142
</p>
<p>Dynamic random-access memory (DRAM), 369
</p>
<p>E
</p>
<p>Electrically erasable programmable read-only memory
</p>
<p>(EEPROM), 364
</p>
<p>Electrical signaling, 1
</p>
<p>Encoders, 202
</p>
<p>Erasable programmable read-only memory
</p>
<p>(EPROM), 362
</p>
<p>Essential prime implicant, 137
</p>
<p>F
</p>
<p>Field-programmable gate array (FPGA), 388
</p>
<p>Finite state machines (FSM), 238
</p>
<p>binary state encoding, 242
</p>
<p>design examples by hand, 249
</p>
<p>design process, 248
</p>
<p>final logic diagram, 247
</p>
<p>gray code state encoding, 243
</p>
<p>introduction, 238
</p>
<p>next state logic, 245
</p>
<p>one-hot state encoding, 244
</p>
<p>output logic, 246
</p>
<p>reset condition, 269
</p>
<p>state diagram, 239
</p>
<p>state memory, 242
</p>
<p>state transition table, 240
</p>
<p>state variables, 245
</p>
<p>synthesis by hand, 241
</p>
<p>FLASH memory, 365
</p>
<p>NAND-FLASH, 365
</p>
<p>NOR-FLASH, 365
</p>
<p>482 &bull; Index</p>
<p/>
</div>
<div class="page"><p/>
<p>Floating-gate transistor, 362
</p>
<p>Forward current (IF), 81
</p>
<p>Forward voltage (VF), 81
</p>
<p>Full adders, 398
</p>
<p>Functionally complete sets, 110
</p>
<p>Fuse, 361
</p>
<p>G
</p>
<p>Gajski and Kuhn&rsquo;s Y-chart, 159
</p>
<p>Gates, 43
</p>
<p>Generic array logic (GAL), 385
</p>
<p>Glitches, 141
</p>
<p>H
</p>
<p>Half adders, 398
</p>
<p>Hard array logic (HAL), 386
</p>
<p>Hazards, 141
</p>
<p>Hexadecimal number system, 10
</p>
<p>History of HDLs, 154
</p>
<p>I
</p>
<p>Idempotent, 99
</p>
<p>Identity theorem, 98
</p>
<p>Input/output blocks (IOBs), 393
</p>
<p>Integrated circuit, 62
</p>
<p>Inverter, 46
</p>
<p>Involution, 100
</p>
<p>K
</p>
<p>Karnaugh map (K-map), 125
</p>
<p>L
</p>
<p>Large scale integrated circuit (LSI) logic, 195
</p>
<p>Leading zero, 9
</p>
<p>Least significant bit (LSB), 10
</p>
<p>Light emitting diodes (LEDs), 81
</p>
<p>Logic block (LE), 389
</p>
<p>Logic expression, 44
</p>
<p>Logic families, 62
</p>
<p>Logic function, 44
</p>
<p>Logic HIGH, 51
</p>
<p>Logic levels, 51
</p>
<p>Logic LOW, 51
</p>
<p>Logic minimization, 124
</p>
<p>Logic symbol, 43
</p>
<p>Logic synthesis, 115
</p>
<p>Logic value, 51
</p>
<p>Logic waveform, 45
</p>
<p>Look-up table (LUT), 389
</p>
<p>M
</p>
<p>Mask read-only memory (MROM), 360
</p>
<p>Maxterm list (Π), 120
</p>
<p>Maxterms, 118
</p>
<p>Mealy machine, 239
</p>
<p>Medium scale integrated circuit (MSI) logic, 195
</p>
<p>Memory map model, 355
</p>
<p>Metal oxide semiconductor field effect transistor
</p>
<p>(MOSFET), 62
</p>
<p>Metastability, 214
</p>
<p>Minimal sum, 136, 137
</p>
<p>Minimization, 124
</p>
<p>Minimization of logic algebraically, 124
</p>
<p>Minimization of logic using K-maps, 128
</p>
<p>Minterm list (&sum;), 117
</p>
<p>Minterms, 115
</p>
<p>Modern digital design flow, 161
</p>
<p>Moore machine, 239
</p>
<p>MOSFET. See Metal oxide semiconductor field effect
</p>
<p>transistor (MOSFET)
</p>
<p>Most significant bit (MSB), 10
</p>
<p>Multiplexer design by hand, 204
</p>
<p>Multiplexer modeling in Verilog, 205
</p>
<p>Multiplexers, 204
</p>
<p>Multiplication, 413
</p>
<p>combinational multiplier, 415
</p>
<p>by powers of 2, 416
</p>
<p>shift and add approach, 413
</p>
<p>signed, 417
</p>
<p>unsigned, 413
</p>
<p>N
</p>
<p>NAND-debounce circuit, 235
</p>
<p>NAND gate, 47
</p>
<p>Negation (&Oslash;), 94
</p>
<p>Negative logic, 51
</p>
<p>Nibble, 10
</p>
<p>Noise, 3
</p>
<p>Noise margin HIGH (MNH), 53
</p>
<p>Noise margin LOW (MNL), 53
</p>
<p>Non-volatile memory, 356
</p>
<p>NOR gate, 47
</p>
<p>NPN, 71
</p>
<p>N-type MOSFET (NMOS), 63
</p>
<p>Null element, 98
</p>
<p>Numerals, 7
</p>
<p>O
</p>
<p>Octal number system, 10
</p>
<p>Ohm&rsquo;s law, 79
</p>
<p>One-hot binary encoder design by hand, 203
</p>
<p>One-hot binary encoder modeling in Verilog, 203
</p>
<p>One-hot decoder design by hand, 196
</p>
<p>One-hot decoder modeling in Verilog, 196
</p>
<p>One&rsquo;s complement numbers, 29
</p>
<p>OR gate, 47
</p>
<p>Output DC specifications. See DC specifications
</p>
<p>Output logic macrocell (OLMC), 385
</p>
<p>Index &bull; 483</p>
<p/>
</div>
<div class="page"><p/>
<p>P
</p>
<p>7400 Part numbering scheme, 73
</p>
<p>Place and route, 161
</p>
<p>PNP, 71
</p>
<p>Positional number system, 7
</p>
<p>Positional weight, 11
</p>
<p>Positive logic, 51
</p>
<p>Postulates, 94
</p>
<p>Power consumption, 4
</p>
<p>Power supplies, 54
</p>
<p>ICC, 54
</p>
<p>IGND, 54
</p>
<p>VCC, 54
</p>
<p>Prime implicant, 129
</p>
<p>Product of sums (POS) form, 106
</p>
<p>Programmable array logic (PAL), 384
</p>
<p>Programmable interconnect points (PIPs), 392
</p>
<p>Programmable logic array (PLA), 383
</p>
<p>Programmable read-only memory (PROM), 361
</p>
<p>Proof by exhaustion, 95
</p>
<p>P-type MOSFET (PMOS), 63
</p>
<p>Pull-down network, 64
</p>
<p>Pull-up network, 64
</p>
<p>Q
</p>
<p>Quiescent current (Iq), 54
</p>
<p>R
</p>
<p>Radix, 7
</p>
<p>Radix point, 8
</p>
<p>Random-access-memory (RAM), 356
</p>
<p>Range
</p>
<p>one&rsquo;s1 complement numbers, 29
</p>
<p>signed magnitude numbers, 27
</p>
<p>two&rsquo;s complement numbers, 31
</p>
<p>unsigned numbers, 25, 27, 29, 31
</p>
<p>Read cycle, 355
</p>
<p>Read-only memory (ROM), 356, 357
</p>
<p>Read/write (RW) memory, 356
</p>
<p>Ripple carry adders (RCA), 400
</p>
<p>Ripple counter, 231
</p>
<p>S
</p>
<p>7-segment decoder design by hand, 198
</p>
<p>7-segment decoder modeling in Verilog, 201
</p>
<p>Semiconductor memory, 355
</p>
<p>Sequential access memory, 356
</p>
<p>Sequential logic analysis, 270
</p>
<p>Sequential logic timing, 229
</p>
<p>7400 series logic families, 73
</p>
<p>Shift register, 237
</p>
<p>Signaling, 1
</p>
<p>Signed magnitude numbers, 26
</p>
<p>Signed numbers, 26
</p>
<p>Simple programmable logic device (SPLD), 387
</p>
<p>Single pole, double throw (SPDT) switch, 233
</p>
<p>Single pole, single throw (SPST) switch, 233
</p>
<p>Sinking current, 52, 53
</p>
<p>Small scale integrated circuit (SSI) logic, 195
</p>
<p>Sourcing and sinking multiple loads, 56
</p>
<p>Sourcing current, 52
</p>
<p>Sourcing multiple loads, 55
</p>
<p>SR latch, 217, 219
</p>
<p>SR latch with enable, 222
</p>
<p>Static 0 hazard, 142
</p>
<p>Static 1 hazard, 142
</p>
<p>Static random-access memory (SRAM), 366
</p>
<p>Subtraction, 24, 411
</p>
<p>Sum of products (SOP) form, 106
</p>
<p>Switch debouncing, 232
</p>
<p>Switching characteristics, 57
</p>
<p>tf (fall time), 57
</p>
<p>tPHL (propagation delay HIGH to LOW), 57
</p>
<p>tPLH (propagation delay LOW to HIGH), 57
</p>
<p>tr (rise time), 57
</p>
<p>tt (transition time), 57
</p>
<p>Synchronous memory, 359
</p>
<p>T
</p>
<p>Technology mapping, 161
</p>
<p>Timing hazards, 141
</p>
<p>Toggle flop (T-flop), 230
</p>
<p>Trailing zero, 9
</p>
<p>Transistor-transistor logic (TTL), 71
</p>
<p>Transmitter/receiver circuit, 50
</p>
<p>Truth table formation, 44
</p>
<p>TTL operation, 71
</p>
<p>Two&rsquo;s complement arithmetic, 34
</p>
<p>Two&rsquo;s complement numbers, 31
</p>
<p>U
</p>
<p>Uniting, 105
</p>
<p>Unsigned numbers, 25
</p>
<p>V
</p>
<p>Verification, 159
</p>
<p>Verilog, 153
</p>
<p>always blocks, 290
</p>
<p>arrays, 167
</p>
<p>behavioral modeling techniques
</p>
<p>adders, 405
</p>
<p>agents on a bus, 346
</p>
<p>counters, 340
up counter, 340
</p>
<p>up counters with enables, 342
</p>
<p>up counters with loads, 343
</p>
<p>up counter with range checking, 341
D-flip-flops, 324
</p>
<p>D-flip-flop with enable, 326
</p>
<p>D-flip-flop with preset, 325
</p>
<p>D-flip-flop with reset, 324
</p>
<p>484 &bull; Index</p>
<p/>
</div>
<div class="page"><p/>
<p>D-latches, 323
finite state machines, 328
</p>
<p>encoding styles, 332
</p>
<p>next state logic, 329
output logic, 330
</p>
<p>state memory, 329
</p>
<p>state variables, 329
</p>
<p>registers, 345
RTL modeling, 344
</p>
<p>shift registers, 348
</p>
<p>casex statements, 301
</p>
<p>casez statements, 301
</p>
<p>compiler directives, 171
</p>
<p>include, 171
</p>
<p>timescale, 171
</p>
<p>continuous assignment, 176
</p>
<p>continuous assignment with conditional operators,
</p>
<p>177
</p>
<p>continuous assignment with delay, 179
</p>
<p>continuous assignment with logical operators, 176
</p>
<p>counters, 340
</p>
<p>data types, 165
</p>
<p>disable, 304
</p>
<p>drive strength, 165
</p>
<p>finite state machines, 328
</p>
<p>forever loops, 302
</p>
<p>for loops, 303
</p>
<p>gate level primitives, 184
</p>
<p>history, 155
</p>
<p>if-else statements, 298, 300
</p>
<p>initial blocks, 290
</p>
<p>net data types, 166
</p>
<p>number formatting
</p>
<p>binary, 167
</p>
<p>decimal, 167
</p>
<p>hex, 167
octal, 167
</p>
<p>operators, 171
</p>
<p>assignment, 171
bitwise logical, 171
</p>
<p>bitwise replication, 174
</p>
<p>Boolean logic, 172
concatenation, 173
</p>
<p>conditional, 173
</p>
<p>numerical, 174
</p>
<p>precedence, 175
reduction, 172
</p>
<p>relational, 172
</p>
<p>parameters, 170
</p>
<p>procedural assignment, 289
</p>
<p>procedural blocks, 289
</p>
<p>repeat loops, 303
</p>
<p>resolution, 165
</p>
<p>RTL modeling, 344
</p>
<p>sensitivity lists, 291
</p>
<p>signal declaration, 169
</p>
<p>statement groups, 297
</p>
<p>structural design and hierarchy, 182
</p>
<p>explicity port mapping, 183
</p>
<p>gate level primities, 184
instantiation, 182
</p>
<p>positional port mapping, 183
</p>
<p>user defined primities, 185
</p>
<p>system tasks, 304
</p>
<p>file I/O, 306
</p>
<p>simulation control, 308
text I/O, 304
</p>
<p>user defined primities, 185
</p>
<p>value set, 165
</p>
<p>variable data types, 166
</p>
<p>vectors, 166
</p>
<p>while loops, 302
</p>
<p>Very large scale integrated circuit (VLSI) logic, 195
</p>
<p>Volatile memory, 356
</p>
<p>W
</p>
<p>Weight, 11
</p>
<p>Word, 10
</p>
<p>Write cycle, 355
</p>
<p>X
</p>
<p>X-don&rsquo;t cares, 138
</p>
<p>XNOR gate, 49
</p>
<p>XOR gate, 48
</p>
<p>XOR/XNOR gates in K-maps, 138
</p>
<p>Y
</p>
<p>Y-chart, 159
</p>
<p>Index &bull; 485</p>
<p/>
</div>
<ul>	<li>Preface</li>
<ul>	<li>Written the Way It Is Taught</li>
	<li>Learning Outcomes</li>
	<li>Teaching by Example</li>
	<li>Course Design</li>
	<li>Instructor Resources</li>
	<li>What&acute;s New in the Second Edition</li>
</ul>
	<li>Acknowledgment</li>
	<li>Contents</li>
	<li>1: Introduction: Analog Versus Digital</li>
<ul>	<li>1.1 Differences Between Analog and Digital Systems</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>1.2 Advantages of Digital Systems over Analog Systems</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>2: Number Systems</li>
<ul>	<li>2.1 Positional Number Systems</li>
<ul>	<li>2.1.1 Generic Structure</li>
	<li>2.1.2 Decimal Number System (Base 10)</li>
	<li>2.1.3 Binary Number System (Base 2)</li>
	<li>2.1.4 Octal Number System (Base 8)</li>
	<li>2.1.5 Hexadecimal Number System (Base 16)</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>2.2 Base Conversion</li>
<ul>	<li>2.2.1 Converting to Decimal</li>
<ul>	<li>2.2.1.1 Binary to Decimal</li>
	<li>2.2.1.2 Octal to Decimal</li>
	<li>2.2.1.3 Hexadecimal to Decimal</li>
</ul>
	<li>2.2.2 Converting from Decimal</li>
<ul>	<li>2.2.2.1 Decimal to Binary</li>
	<li>2.2.2.2 Decimal to Octal</li>
	<li>2.2.2.3 Decimal to Hexadecimal</li>
</ul>
	<li>2.2.3 Converting Between 2n Bases</li>
<ul>	<li>2.2.3.1 Binary to Octal</li>
	<li>2.2.3.2 Binary to Hexadecimal</li>
	<li>2.2.3.3 Octal to Binary</li>
	<li>2.2.3.4 Hexadecimal to Binary</li>
	<li>2.2.3.5 Octal to Hexadecimal</li>
	<li>2.2.3.6 Hexadecimal to Octal</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>2.3 Binary Arithmetic</li>
<ul>	<li>2.3.1 Addition (Carries)</li>
	<li>2.3.2 Subtraction (Borrows)</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>2.4 Unsigned and Signed Numbers</li>
<ul>	<li>2.4.1 Unsigned Numbers</li>
	<li>2.4.2 Signed Numbers</li>
<ul>	<li>2.4.2.1 Signed Magnitude</li>
	<li>2.4.2.2 One&acute;s Complement</li>
	<li>2.4.2.3 Two&acute;s Complement</li>
	<li>2.4.2.4 Arithmetic with Two&acute;s Complement</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
</ul>
	<li>3: Digital Circuitry and Interfacing</li>
<ul>	<li>3.1 Basic Gates</li>
<ul>	<li>3.1.1 Describing the Operation of a Logic Circuit</li>
<ul>	<li>3.1.1.1 The Logic Symbol</li>
	<li>3.1.1.2 The Truth Table</li>
	<li>3.1.1.3 The Logic Function</li>
	<li>3.1.1.4 The Logic Waveform</li>
</ul>
	<li>3.1.2 The Buffer</li>
	<li>3.1.3 The Inverter</li>
	<li>3.1.4 The AND Gate</li>
	<li>3.1.5 The NAND Gate</li>
	<li>3.1.6 The OR Gate</li>
	<li>3.1.7 The NOR Gate</li>
	<li>3.1.8 The XOR Gate</li>
	<li>3.1.9 The XNOR Gate</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>3.2 Digital Circuit Operation</li>
<ul>	<li>3.2.1 Logic Levels</li>
	<li>3.2.2 Output DC Specifications</li>
	<li>3.2.3 Input DC Specifications</li>
	<li>3.2.4 Noise Margins</li>
	<li>3.2.5 Power Supplies</li>
	<li>3.2.6 Switching Characteristics</li>
	<li>3.2.7 Data Sheets</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>3.3 Logic Families</li>
<ul>	<li>3.3.1 Complementary Metal-Oxide Semiconductors (CMOS)</li>
<ul>	<li>3.3.1.1 CMOS Operation</li>
	<li>3.3.1.2 CMOS Inverter</li>
	<li>3.3.1.3 CMOS NAND Gate</li>
	<li>3.3.1.4 CMOS NOR Gate</li>
</ul>
	<li>3.3.2 Transistor-Transistor Logic (TTL)</li>
<ul>	<li>3.3.2.1 TTL Operation</li>
</ul>
	<li>3.3.3 The 7400 Series Logic Families</li>
<ul>	<li>3.3.3.1 Part-Numbering Scheme</li>
	<li>3.3.3.2 DC Operating Conditions</li>
	<li>3.3.3.3 Pin-Out Information for the DIP Packages</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>3.4 Driving Loads</li>
<ul>	<li>3.4.1 Driving Other Gates</li>
	<li>3.4.2 Driving Resistive Loads</li>
	<li>3.4.3 Driving LEDs</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>4: Combinational Logic Design</li>
<ul>	<li>4.1 Boolean Algebra</li>
<ul>	<li>4.1.1 Operations</li>
	<li>4.1.2 Axioms</li>
<ul>	<li>4.1.2.1 Axiom #1: Logical Values</li>
	<li>4.1.2.2 Axiom #2: Definition of Logical Negation</li>
	<li>4.1.2.3 Axiom #3: Definition of a Logical Product</li>
	<li>4.1.2.4 Axiom #4: Definition of a Logical Sum</li>
	<li>4.1.2.5 Axiom #5: Logical Precedence</li>
</ul>
	<li>4.1.3 Theorems</li>
<ul>	<li>4.1.3.1 De Morgan&acute;s Theorem of Duality</li>
	<li>4.1.3.2 Identity</li>
	<li>4.1.3.3 Null Element</li>
	<li>4.1.3.4 Idempotent</li>
	<li>4.1.3.5 Complements</li>
	<li>4.1.3.6 Involution</li>
	<li>4.1.3.7 Commutative Property</li>
	<li>4.1.3.8 Associative Property</li>
	<li>4.1.3.9 Distributive Property</li>
	<li>4.1.3.10 Absorption</li>
	<li>4.1.3.11 Uniting</li>
	<li>4.1.3.12 De Morgan&acute;s Theorem</li>
</ul>
	<li>4.1.4 Functionally Complete Operation Sets</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>4.2 Combinational Logic Analysis</li>
<ul>	<li>4.2.1 Finding the Logic Expression from a Logic Diagram</li>
	<li>4.2.2 Finding the Truth Table from a Logic Diagram</li>
	<li>4.2.3 Timing Analysis of a Combinational Logic Circuit</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>4.3 Combinational Logic Synthesis</li>
<ul>	<li>4.3.1 Canonical Sum of Products</li>
	<li>4.3.2 The Minterm List (Sigma)</li>
	<li>4.3.3 Canonical Product of Sums (POS)</li>
	<li>4.3.4 The Maxterm List (Pi)</li>
	<li>4.3.5 Minterm and Maxterm List Equivalence</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>4.4 Logic Minimization</li>
<ul>	<li>4.4.1 Algebraic Minimization</li>
	<li>4.4.2 Minimization Using Karnaugh Maps</li>
<ul>	<li>4.4.2.1 Formation of a K-Map</li>
	<li>4.4.2.2 Logic Minimization Using K-Maps (Sum of Products)</li>
	<li>4.4.2.3 Logic Minimization Using K-Maps (Product of Sums)</li>
	<li>4.4.2.4 Minimal Sum</li>
</ul>
	<li>4.4.3 Don&acute;t Cares</li>
	<li>4.4.4 Using XOR Gates</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>4.5 Timing Hazards and Glitches</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>5: Verilog (Part 1)</li>
<ul>	<li>5.1 History of Hardware Description Languages</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>5.2 HDL Abstraction</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>5.3 The Modern Digital Design Flow</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>5.4 Verilog Constructs</li>
<ul>	<li>5.4.1 Data Types</li>
<ul>	<li>5.4.1.1 Value Set</li>
	<li>5.4.1.2 Net Data Types</li>
	<li>5.4.1.3 Variable Data Types</li>
	<li>5.4.1.4 Vectors</li>
	<li>5.4.1.5 Arrays</li>
	<li>5.4.1.6 Expressing Numbers Using Different Bases</li>
	<li>5.4.1.7 Assigning Between Different Types</li>
</ul>
	<li>5.4.2 The Module</li>
<ul>	<li>5.4.2.1 Port Definitions</li>
	<li>5.4.2.2 Signal Declarations</li>
	<li>5.4.2.3 Parameter Declarations</li>
	<li>5.4.2.4 Compiler Directives</li>
</ul>
	<li>5.4.3 Verilog Operators</li>
<ul>	<li>5.4.3.1 Assignment Operator</li>
	<li>5.4.3.2 Bitwise Logical Operators</li>
	<li>5.4.3.3 Reduction Logic Operators</li>
	<li>5.4.3.4 Boolean Logic Operators</li>
	<li>5.4.3.5 Relational Operators</li>
	<li>5.4.3.6 Conditional Operators</li>
	<li>5.4.3.7 Concatenation Operator</li>
	<li>5.4.3.8 Replication Operator</li>
	<li>5.4.3.9 Numerical Operators</li>
	<li>5.4.3.10 Operator Precedence</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>5.5 Modeling Concurrent Functionality in Verilog</li>
<ul>	<li>5.5.1 Continuous Assignment</li>
	<li>5.5.2 Continuous Assignment with Logical Operators</li>
	<li>5.5.3 Continuous Assignment with Conditional Operators</li>
	<li>5.5.4 Continuous Assignment with Delay</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>5.6 Structural Design and Hierarchy</li>
<ul>	<li>5.6.1 Lower-Level Module Instantiation</li>
<ul>	<li>5.6.1.1 Explicit Port Mapping</li>
	<li>5.6.1.2 Positional Port Mapping</li>
</ul>
	<li>5.6.2 Gate-Level Primitives</li>
	<li>5.6.3 User-Defined Primitives</li>
	<li>5.6.4 Adding Delay to Primitives</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>5.7 Overview of Simulation Test Benches</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>6: MSI Logic</li>
<ul>	<li>6.1 Decoders</li>
<ul>	<li>6.1.1 Example: One-Hot Decoder</li>
	<li>6.1.2 Example: 7-Segment Display Decoder</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>6.2 Encoders</li>
<ul>	<li>6.2.1 Example: One-Hot Binary Encoder</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>6.3 Multiplexers</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>6.4 Demultiplexers</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>7: Sequential Logic Design</li>
<ul>	<li>7.1 Sequential Logic Storage Devices</li>
<ul>	<li>7.1.1 The Cross-Coupled Inverter Pair</li>
	<li>7.1.2 Metastability</li>
	<li>7.1.3 The SR Latch</li>
	<li>7.1.4 The S&acute;R&acute; Latch</li>
	<li>7.1.5 SR Latch with Enable</li>
	<li>7.1.6 The D-Latch</li>
	<li>7.1.7 The D-Flip-Flop</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>7.2 Sequential Logic Timing Considerations</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>7.3 Common Circuits Based on Sequential Storage Devices</li>
<ul>	<li>7.3.1 Toggle Flop Clock Divider</li>
	<li>7.3.2 Ripple Counter</li>
	<li>7.3.3 Switch Debouncing</li>
	<li>7.3.4 Shift Registers</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>7.4 Finite-State Machines</li>
<ul>	<li>7.4.1 Describing the Functionality of a FSM</li>
<ul>	<li>7.4.1.1 State Diagrams</li>
	<li>7.4.1.2 State Transition Tables</li>
</ul>
	<li>7.4.2 Logic Synthesis for a FSM</li>
<ul>	<li>7.4.2.1 State Memory</li>
	<li>7.4.2.2 Next State Logic</li>
	<li>7.4.2.3 Output Logic</li>
	<li>7.4.2.4 The Final Logic Diagram</li>
</ul>
	<li>7.4.3 FSM Design Process Overview</li>
	<li>7.4.4 FSM Design Examples</li>
<ul>	<li>7.4.4.1 Serial Bit Sequence Detector</li>
	<li>7.4.4.2 Vending Machine Controller</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>7.5 Counters</li>
<ul>	<li>7.5.1 2-Bit Binary Up Counter</li>
	<li>7.5.2 2-Bit Binary Up/Down Counter</li>
	<li>7.5.3 2-Bit Gray Code Up Counter</li>
	<li>7.5.4 2-Bit Gray Code Up/Down Counter</li>
	<li>7.5.5 3-Bit One-Hot Up Counter</li>
	<li>7.5.6 3-Bit One-Hot Up/Down Counter</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>7.6 Finite-State Machine&acute;s Reset Condition</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>7.7 Sequential Logic Analysis</li>
<ul>	<li>7.7.1 Finding the State Equations and Output Logic Expressions of a FSM</li>
	<li>7.7.2 Finding the State Transition Table of a FSM</li>
	<li>7.7.3 Finding the State Diagram of a FSM</li>
	<li>7.7.4 Determining the Maximum Clock Frequency of a FSM</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>8: Verilog (Part 2)</li>
<ul>	<li>8.1 Procedural Assignment</li>
<ul>	<li>8.1.1 Procedural Blocks</li>
<ul>	<li>8.1.1.1 Initial Blocks</li>
	<li>8.1.1.2 Always Blocks</li>
	<li>8.1.1.3 Sensitivity Lists</li>
</ul>
	<li>8.1.2 Procedural Statements</li>
<ul>	<li>8.1.2.1 Blocking Assignments</li>
	<li>8.1.2.2 Non-blocking Assignments</li>
</ul>
	<li>8.1.3 Statement Groups</li>
	<li>8.1.4 Local Variables</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>8.2 Conditional Programming Constructs</li>
<ul>	<li>8.2.1 if-else Statements</li>
	<li>8.2.2 case Statements</li>
	<li>8.2.3 casez and casex Statements</li>
	<li>8.2.4 forever Loops</li>
	<li>8.2.5 while Loops</li>
	<li>8.2.6 repeat Loops</li>
	<li>8.2.7 for loops</li>
	<li>8.2.8 disable</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>8.3 System Tasks</li>
<ul>	<li>8.3.1 Text Output</li>
	<li>8.3.2 File Input/Output</li>
	<li>8.3.3 Simulation Control and Monitoring</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>8.4 Test Benches</li>
<ul>	<li>8.4.1 Common Stimulus Generation Techniques</li>
	<li>8.4.2 Printing Results to the Simulator Transcript</li>
	<li>8.4.3 Automatic Result Checking</li>
	<li>8.4.4 Using Loops to Generate Stimulus</li>
	<li>8.4.5 Using External Files in Test Benches</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>9: Behavioral Modeling of Sequential Logic</li>
<ul>	<li>9.1 Modeling Sequential Storage Devices in Verilog</li>
<ul>	<li>9.1.1 D-Latch</li>
	<li>9.1.2 D-Flip-Flop</li>
	<li>9.1.3 D-Flip-Flop with Asynchronous Reset</li>
	<li>9.1.4 D-Flip-Flop with Asynchronous Reset and Preset</li>
	<li>9.1.5 D-Flip-Flop with Synchronous Enable</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>9.2 Modeling Finite-State Machines in Verilog</li>
<ul>	<li>9.2.1 Modeling the States</li>
	<li>9.2.2 The State Memory Block</li>
	<li>9.2.3 The Next State Logic Block</li>
	<li>9.2.4 The Output Logic Block</li>
	<li>9.2.5 Changing the State Encoding Approach</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>9.3 FSM Design Examples in Verilog</li>
<ul>	<li>9.3.1 Serial Bit Sequence Detector in Verilog</li>
	<li>9.3.2 Vending Machine Controller in Verilog</li>
	<li>9.3.3 2-Bit, Binary Up/Down Counter in Verilog</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>9.4 Modeling Counters in Verilog</li>
<ul>	<li>9.4.1 Counters in Verilog Using a Single-Procedural Block</li>
	<li>9.4.2 Counters with Range Checking</li>
	<li>9.4.3 Counters with Enables in Verilog</li>
	<li>9.4.4 Counters with Loads</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>9.5 RTL Modeling</li>
<ul>	<li>9.5.1 Modeling Registers in Verilog</li>
	<li>9.5.2 Registers as Agents on a Data Bus</li>
	<li>9.5.3 Shift Registers in Verilog</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>10: Memory</li>
<ul>	<li>10.1 Memory Architecture and Terminology</li>
<ul>	<li>10.1.1 Memory Map Model</li>
	<li>10.1.2 Volatile Versus Non-volatile Memory</li>
	<li>10.1.3 Read-Only Versus Read/Write Memory</li>
	<li>10.1.4 Random Access Versus Sequential Access</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>10.2 Non-volatile Memory Technology</li>
<ul>	<li>10.2.1 ROM Architecture</li>
	<li>10.2.2 Mask Read-Only Memory (MROM)</li>
	<li>10.2.3 Programmable Read-Only Memory (PROM)</li>
	<li>10.2.4 Erasable Programmable Read-Only Memory (EPROM)</li>
	<li>10.2.5 Electrically Erasable Programmable Read-Only Memory (EEPROM)</li>
	<li>10.2.6 FLASH Memory</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>10.3 Volatile Memory Technology</li>
<ul>	<li>10.3.1 Static Random-Access Memory (SRAM)</li>
	<li>10.3.2 Dynamic Random-Access Memory (DRAM)</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>10.4 Modeling Memory with Verilog</li>
<ul>	<li>10.4.1 Read-Only Memory in Verilog</li>
	<li>10.4.2 Read/Write Memory in Verilog</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>11: Programmable Logic</li>
<ul>	<li>11.1 Programmable Arrays</li>
<ul>	<li>11.1.1 Programmable Logic Array (PLA)</li>
	<li>11.1.2 Programmable Array Logic (PAL)</li>
	<li>11.1.3 Generic Array Logic (GAL)</li>
	<li>11.1.4 Hard Array Logic (HAL)</li>
	<li>11.1.5 Complex Programmable Logic Devices (CPLD)</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>11.2 Field-Programmable Gate Arrays (FPGAs)</li>
<ul>	<li>11.2.1 Configurable Logic Block (or Logic Element)</li>
	<li>11.2.2 Look-Up Tables (LUTs)</li>
	<li>11.2.3 Programmable Interconnect Points (PIPs)</li>
	<li>11.2.4 Input/Output Block (IOB)</li>
	<li>11.2.5 Configuration Memory</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>12: Arithmetic Circuits</li>
<ul>	<li>12.1 Addition</li>
<ul>	<li>12.1.1 Half Adders</li>
	<li>12.1.2 Full Adders</li>
	<li>12.1.3 Ripple Carry Adder (RCA)</li>
	<li>12.1.4 Carry Look Ahead Adder (CLA)</li>
	<li>12.1.5 Adders in Verilog</li>
<ul>	<li>12.1.5.1 Structural Model of a Ripple Carry Adder in Verilog</li>
	<li>12.1.5.2 Structural Model of a Carry Look Ahead Adder in Verilog</li>
	<li>12.1.5.3 Behavior Model of an Adder Using Arithmetic Operators in Verilog</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>12.2 Subtraction</li>
<ul>	<li>Concept Check</li>
</ul>
	<li>12.3 Multiplication</li>
<ul>	<li>12.3.1 Unsigned Multiplication</li>
	<li>12.3.2 A Simple Circuit to Multiply by Powers of Two</li>
	<li>12.3.3 Signed Multiplication</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>12.4 Division</li>
<ul>	<li>12.4.1 Unsigned Division</li>
	<li>12.4.2 A Simple Circuit to Divide by Powers of Two</li>
	<li>12.4.3 Signed Division</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>13: Computer System Design</li>
<ul>	<li>13.1 Computer Hardware</li>
<ul>	<li>13.1.1 Program Memory</li>
	<li>13.1.2 Data Memory</li>
	<li>13.1.3 Input/Output Ports</li>
	<li>13.1.4 Central Processing Unit</li>
<ul>	<li>13.1.4.1 Control Unit</li>
	<li>13.1.4.2 Data Path: Registers</li>
	<li>13.1.4.3 Data Path: Arithmetic Logic Unit (ALU)</li>
</ul>
	<li>13.1.5 A Memory-Mapped System</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
	<li>13.2 Computer Software</li>
<ul>	<li>13.2.1 Opcodes and Operands</li>
	<li>13.2.2 Addressing Modes</li>
<ul>	<li>13.2.2.1 Immediate Addressing (IMM)</li>
	<li>13.2.2.2 Direct Addressing (DIR)</li>
	<li>13.2.2.3 Inherent Addressing (INH)</li>
	<li>13.2.2.4 Indexed Addressing (IND)</li>
</ul>
	<li>13.2.3 Classes of Instructions</li>
<ul>	<li>13.2.3.1 Loads and Stores</li>
	<li>13.2.3.2 Data Manipulations</li>
	<li>13.2.3.3 Branches</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>13.3 Computer Implementation: An 8-Bit Computer Example</li>
<ul>	<li>13.3.1 Top-Level Block Diagram</li>
	<li>13.3.2 Instruction Set Design</li>
	<li>13.3.3 Memory System Implementation</li>
<ul>	<li>13.3.3.1 Program Memory Implementation in Verilog</li>
	<li>13.3.3.2 Data Memory Implementation in Verilog</li>
	<li>13.3.3.3 Implementation of Output Ports in Verilog</li>
	<li>13.3.3.4 Implementation of Input Ports in Verilog</li>
	<li>13.3.3.5 Memory data_out Bus Implementation in Verilog</li>
</ul>
	<li>13.3.4 CPU Implementation</li>
<ul>	<li>13.3.4.1 Data Path Implementation in Verilog</li>
	<li>13.3.4.2 ALU Implementation in Verilog</li>
	<li>13.3.4.3 Control Unit Implementation in Verilog</li>
<ul>	<li>13.3.4.3.1 Detailed Execution of LDA_IMM</li>
	<li>13.3.4.3.2 Detailed Execution of LDA_DIR</li>
	<li>13.3.4.3.3 Detailed Execution of STA_DIR</li>
	<li>13.3.4.3.4 Detailed Execution of ADD_AB</li>
	<li>13.3.4.3.5 Detailed Execution of BRA</li>
	<li>13.3.4.3.6 Detailed Execution of BEQ</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
</ul>
	<li>13.4 Architecture Considerations</li>
<ul>	<li>13.4.1 Von Neumann Architecture</li>
	<li>13.4.2 Harvard Architecture</li>
<ul>	<li>Concept Check</li>
</ul>
</ul>
</ul>
	<li>Appendix A: List of Worked Examples</li>
	<li>Appendix B: Concept Check Solutions</li>
	<li>Index</li>
</ul>
</body></html>