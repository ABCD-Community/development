<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
</head>
<body><div class="page"><p/>
<p>Undergraduate Topics in Computer Science
</p>
<p>Kent&nbsp;D.&nbsp;Lee
Steve&nbsp;Hubbard
</p>
<p>Data 
Structures and 
Algorithms 
with Python</p>
<p/>
</div>
<div class="page"><p/>
<p>Undergraduate Topics in Computer
Science
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Undergraduate Topics in Computer Science (UTiCS) delivers high-quality
</p>
<p>instructional content for undergraduates studying in all areas of computing and
</p>
<p>information science. From core foundational and theoretical material to final-year
</p>
<p>topics and applications, UTiCS books take a fresh, concise, and modern approach
</p>
<p>and are ideal for self-study or for a one- or two-semester course. The texts are all
</p>
<p>authored by established experts in their fields, reviewed by an international advisory
</p>
<p>board, and contain numerous examples and problems. Many include fully worked
</p>
<p>solutions.
</p>
<p>More information about this series at http://www.springer.com/series/7592
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://www.springer.com/series/7592">http://www.springer.com/series/7592</a></div>
</div>
<div class="page"><p/>
<p>Kent D. Lee &bull; Steve Hubbard
</p>
<p>Data Structures and
Algorithms with Python
</p>
<p>123
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Kent D. Lee
Steve Hubbard
Luther College
Decorah, IA
USA
</p>
<p>ISSN 1863-7310 ISSN 2197-1781 (electronic)
ISBN 978-3-319-13071-2 ISBN 978-3-319-13072-9 (eBook)
DOI 10.1007/978-3-319-13072-9
</p>
<p>Library of Congress Control Number: 2014953918
</p>
<p>Springer Cham Heidelberg New York Dordrecht London
</p>
<p>&copy; Springer International Publishing Switzerland 2015
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or
information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar
methodology now known or hereafter developed. Exempted from this legal reservation are brief
excerpts in connection with reviews or scholarly analysis or material supplied specifically for the
purpose of being entered and executed on a computer system, for exclusive use by the purchaser of
the work. Duplication of this publication or parts thereof is permitted only under the provisions of the
Copyright Law of the Publisher&rsquo;s location, in its current version, and permission for use must
always be obtained from Springer. Permissions for use may be obtained through RightsLink at the
Copyright Clearance Center. Violations are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a specific statement, that such names are exempt
from the relevant protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for
any errors or omissions that may be made. The publisher makes no warranty, express or implied, with
respect to the material contained herein.
</p>
<p>Printed on acid-free paper
</p>
<p>Springer is part of Springer Science+Business Media (www.springer.com)
</p>
<p>Series editor
</p>
<p>Ian Mackie
</p>
<p>Advisory Board
</p>
<p>Samson Abramsky, University of Oxford, Oxford, UK
</p>
<p>Karin Breitman, Pontifical Catholic University of Rio de Janeiro, Rio de Janeiro, Brazil
</p>
<p>Chris Hankin, Imperial College London, London, UK
</p>
<p>Dexter Kozen, Cornell University, Ithaca, USA
</p>
<p>Andrew Pitts, University of Cambridge, Cambridge, UK
</p>
<p>Hanne Riis Nielson, Technical University of Denmark, Kongens Lyngby, Denmark
</p>
<p>Steven Skiena, Stony Brook University, Stony Brook, USA
</p>
<p>Iain Stewart, University of Durham, Durham, UK
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Preface
</p>
<p>Thanks for choosing Data Structures and Algorithms with Python. This text was
</p>
<p>written based on classroom notes for two courses, an introductory data structures
</p>
<p>and algorithms course and an advanced data structures and algorithms course. The
</p>
<p>material contained in this text can be taught in two semesters. The early chapters in
</p>
<p>this text are intended as an introductory text for data structures and algorithms,
</p>
<p>while the later chapters cover advanced topics that are suitable for the second course
</p>
<p>in data structures and algorithms. The Python language is used throughout the text
</p>
<p>and some familiarity with Python or some other object-oriented language is
</p>
<p>assumed. However, the first chapter contains a Python primer for those coming
</p>
<p>from a different language background.
</p>
<p>This text serves well as a follow-on text to Python Programming Fundamentals
</p>
<p>by Kent D. Lee and published by Springer, but does not require you to have read
</p>
<p>that text. In this text the next steps are taken to teach you how to handle large
</p>
<p>amounts of data efficiently. A number of algorithms are introduced and the need for
</p>
<p>them is motivated through examples that bring meaning to the problems we face as
</p>
<p>computer programmers. An algorithm is a well-defined procedure for accom-
</p>
<p>plishing a task. Algorithms are an important part of Computer Science and this text
</p>
<p>explores many algorithms to give you the background you need when writing
</p>
<p>programs of your own. The goal is that having seen some of the sorts of algorithms
</p>
<p>presented in this text, you will be able to apply these techniques to other programs
</p>
<p>you write in the future.
</p>
<p>Another goal of this text is to introduce you to the idea of computational
</p>
<p>complexity. While there are many unique and interesting algorithms that we could
</p>
<p>explore, it is important to understand that some algorithms are more efficient than
</p>
<p>others. While computers are very good at doing calculations quickly, an inefficient
</p>
<p>algorithm can make the fastest computer seem very slow or even make it appear to
</p>
<p>come to a halt. This text will show you what can and cannot be computed effi-
</p>
<p>ciently. The text builds this idea of efficiency from the most basic of facts giving
</p>
<p>you the tools you will need to determine just how efficient any algorithm is so you
</p>
<p>can make informed judgements about the programs you write.
</p>
<p>v
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>The text assumes that you have some prior experience in computer program-
</p>
<p>ming, probably from an introductory programming course where you learned to
</p>
<p>break simple problems into steps that could be solved by a computer. The language
</p>
<p>you used may have been Python, but not necessarily. Python is an excellent lan-
</p>
<p>guage for a text on data structures and algorithms whether you have used it before
</p>
<p>or not. Python is an object-oriented programming language with operator over-
</p>
<p>loading and dynamic typing. Whether this is your first exposure to Python or you
</p>
<p>used it in your first course, you will learn more about the language from this text.
</p>
<p>The first chapter of the text reviews some of the fundamentals of computer pro-
</p>
<p>gramming along with the basic syntax of Python to get you up to speed in the
</p>
<p>language. Then subsequent chapters dive into more advanced topics and should be
</p>
<p>read in sequence.
</p>
<p>At the beginning of every chapter the goals of the chapter are stated. At the end
</p>
<p>of every chapter is a set of review questions that reinforce the goals of the chapter.
</p>
<p>These review questions are followed in each chapter by a few programming
</p>
<p>problems that relate to the chapter goals by asking you to use the things you learned
</p>
<p>in the chapter and apply them to a computer program. You can motivate your
</p>
<p>reading of a chapter by first consulting the review questions and then reading the
</p>
<p>chapter to answer them. Along the way, there are lots of examples to illustrate the
</p>
<p>concepts being introduced.
</p>
<p>We hope you enjoy the text! If you have any questions or comments please send
</p>
<p>them to kentdlee@luther.edu.
</p>
<p>Kent D. Lee
</p>
<p>Steve Hubbard
</p>
<p>vi Preface
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>For Teachers
</p>
<p>A typical introductory data structures course covers the first seven chapters of this
</p>
<p>text. Chapter 1 introduces Python programming and the Tkinter module which is
</p>
<p>used in various places in the text. Tkinter comes with Python, so no special
</p>
<p>libraries need be installed for students to use it. Tkinter is used to visualize many
</p>
<p>of the results in this text.
</p>
<p>Chapter 2 introduces complexity analysis and depending on your needs, some
</p>
<p>of the material in Chap. 2 could be skipped in an introductory data structures
</p>
<p>course. In particular, the material on Î˜ notation and amortized complexity can be
</p>
<p>skipped. Big-Oh notation is enough for the first seven chapters. Typically, Chap. 7
</p>
<p>is covered lightly and near the end of a semester course. It seems there is generally
</p>
<p>not enough time in a semester to cover graph theory in much detail.
</p>
<p>Advanced courses in data structures and algorithms should start with Chap. 1 if
</p>
<p>students are unfamiliar with Python or Tkinter. A brief refresher may not be bad
</p>
<p>even for those that have programmed using Python before. Chapter 2 should be
</p>
<p>covered in detail including the material on Î˜ notation and amortized complexity.
</p>
<p>Some review of hashing as it is used in sets and maps in Chap. 5 may be good
</p>
<p>review earlier in the advanced course along with a brief discussion of binary search
</p>
<p>trees and tree traversals in Chap. 6. Depending on your needs, Chap. 7 would be a
</p>
<p>good chapter to cover next including the material on depth first search of a graph.
</p>
<p>Chapter 8 is where the advanced material begins with assumptions made that
</p>
<p>students understand the concepts presented in the earlier chapters. The two
</p>
<p>introductory chapters along with Chaps. 8&ndash;12 make a seven-chapter sequence that
</p>
<p>will fill a semeseter in an advanced course nicely.
</p>
<p>This text is very project oriented. Solutions for all projects are available from
</p>
<p>Kent D. Lee. You can contact Kent at kentdlee@luther.edu for instructor solutions.
</p>
<p>You must provide proof (through a website or other reference) that you are an
</p>
<p>instructor at an educational institution to get access to the instructor materials.
</p>
<p>vii
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1">http://dx.doi.org/10.1007/978-3-319-13072-9_1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1">http://dx.doi.org/10.1007/978-3-319-13072-9_1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8">http://dx.doi.org/10.1007/978-3-319-13072-9_8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8">http://dx.doi.org/10.1007/978-3-319-13072-9_8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
</div>
<div class="page"><p/>
<p>If you have any suggestions or find any errors in the text, please let us know by
</p>
<p>emailing Kent at kentdlee@luther.edu. Thanks and we hope you enjoy using the text
</p>
<p>in your course!
</p>
<p>Kent D. Lee
</p>
<p>Steve Hubbard
</p>
<p>viii For Teachers
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Credits
</p>
<p>Connect Four is referenced in Chaps. 4, 12 and Appendix H. Connect Four is a
</p>
<p>trademark of the Milton Bradley Company in the United States and other
</p>
<p>countries. Chapter 2 references Mac OS X. Mac and Mac OS are registered
</p>
<p>trademarks of Apple Inc., registered in the U.S. and other countries. Microsoft
</p>
<p>Windows is also referenced in Chap. 2. Windows is a registered trademark of
</p>
<p>Microsoft Corporation in the United Stated and other countries.
</p>
<p>ix
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>Contents
</p>
<p>1 Python Programming 101 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
</p>
<p>1.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
</p>
<p>1.2 Creating Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
</p>
<p>1.3 Calling Methods on Objects . . . . . . . . . . . . . . . . . . . . . . . . 5
</p>
<p>1.4 Implementing a Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
</p>
<p>1.5 Operator Overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
</p>
<p>1.6 Importing Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
</p>
<p>1.7 Indentation in Python Programs . . . . . . . . . . . . . . . . . . . . . 11
</p>
<p>1.8 The Main Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
</p>
<p>1.9 Reading from a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
</p>
<p>1.10 Reading Multi-line Records from a File . . . . . . . . . . . . . . . . 16
</p>
<p>1.11 A Container Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
</p>
<p>1.12 Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
</p>
<p>1.13 The Accumulator Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . 22
</p>
<p>1.14 Implementing a GUI with Tkinter . . . . . . . . . . . . . . . . . . . . 24
</p>
<p>1.15 XML Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
</p>
<p>1.16 Reading XML Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
</p>
<p>1.17 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
</p>
<p>1.18 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
</p>
<p>1.19 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
</p>
<p>2 Computational Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>2.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
</p>
<p>2.2 Computer Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
</p>
<p>2.3 Accessing Elements in a Python List . . . . . . . . . . . . . . . . . . 44
</p>
<p>2.4 Big-Oh Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
</p>
<p>2.5 The PyList Append Operation . . . . . . . . . . . . . . . . . . . . . . 50
</p>
<p>2.6 A Proof by Induction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
</p>
<p>xi
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1">http://dx.doi.org/10.1007/978-3-319-13072-9_1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1">http://dx.doi.org/10.1007/978-3-319-13072-9_1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec27">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec27</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec27">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec27</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec32">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec32</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec32">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec32</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec36">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec36</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec36">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec36</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec38">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec38</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec38">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec38</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec39">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec39</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec39">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec39</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec40">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec40</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec40">http://dx.doi.org/10.1007/978-3-319-13072-9_1#Sec40</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec8">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec8">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec10</a></div>
</div>
<div class="page"><p/>
<p>2.7 Making the PyList Append Efficient . . . . . . . . . . . . . . . . . . 53
</p>
<p>2.8 Commonly Occurring Computational Complexities . . . . . . . . 55
</p>
<p>2.9 More Asymptotic Notation . . . . . . . . . . . . . . . . . . . . . . . . . 56
</p>
<p>2.10 Amortized Complexity. . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
</p>
<p>2.11 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
</p>
<p>2.12 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
</p>
<p>2.13 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
</p>
<p>3 Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
</p>
<p>3.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
</p>
<p>3.2 Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
</p>
<p>3.3 The Run-Time Stack and the Heap . . . . . . . . . . . . . . . . . . . 72
</p>
<p>3.4 Writing a Recursive Function . . . . . . . . . . . . . . . . . . . . . . . 75
</p>
<p>3.5 Tracing the Execution of a Recursive Function . . . . . . . . . . . 78
</p>
<p>3.6 Recursion in Computer Graphics. . . . . . . . . . . . . . . . . . . . . 82
</p>
<p>3.7 Recursion on Lists and Strings . . . . . . . . . . . . . . . . . . . . . . 83
</p>
<p>3.8 Using Type Reflection. . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
</p>
<p>3.9 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
</p>
<p>3.10 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>3.11 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
</p>
<p>4 Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
</p>
<p>4.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
</p>
<p>4.2 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
</p>
<p>4.3 Cloning Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
</p>
<p>4.4 Item Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
</p>
<p>4.5 Selection Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
</p>
<p>4.6 Merge Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
</p>
<p>4.7 Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
</p>
<p>4.8 Two-Dimensional Sequences . . . . . . . . . . . . . . . . . . . . . . . 112
</p>
<p>4.9 The Minimax Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 116
</p>
<p>4.10 Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
</p>
<p>4.11 Stacks and Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
</p>
<p>4.12 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>4.13 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
</p>
<p>4.14 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
</p>
<p>5 Sets and Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
</p>
<p>5.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
</p>
<p>5.2 Playing Sudoku . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
</p>
<p>5.3 Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
</p>
<p>5.4 Hashing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
</p>
<p>5.5 The HashSet Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
</p>
<p>5.6 Solving Sudoku . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
</p>
<p>xii Contents
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec21">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec21</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec21">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec21</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec23">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec23</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec23">http://dx.doi.org/10.1007/978-3-319-13072-9_2#Sec23</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3">http://dx.doi.org/10.1007/978-3-319-13072-9_3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3">http://dx.doi.org/10.1007/978-3-319-13072-9_3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec26">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec26</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec26">http://dx.doi.org/10.1007/978-3-319-13072-9_3#Sec26</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec23">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec23</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec23">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec23</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec25">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec25</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec27">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec27</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec27">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec27</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec31">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec31</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec31">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec31</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec39">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec39</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec39">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec39</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec47">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec47</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec47">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec47</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec48">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec48</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec48">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec48</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec49">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec49</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec49">http://dx.doi.org/10.1007/978-3-319-13072-9_4#Sec49</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec22</a></div>
</div>
<div class="page"><p/>
<p>5.7 Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
</p>
<p>5.8 Memoization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
</p>
<p>5.9 Correlating Two Sources of Information . . . . . . . . . . . . . . . 158
</p>
<p>5.10 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>5.11 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
</p>
<p>5.12 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
</p>
<p>6 Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
</p>
<p>6.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
</p>
<p>6.2 Abstract Syntax Trees and Expressions . . . . . . . . . . . . . . . . 164
</p>
<p>6.3 Prefix and Postfix Expressions . . . . . . . . . . . . . . . . . . . . . . 166
</p>
<p>6.4 Parsing Prefix Expressions . . . . . . . . . . . . . . . . . . . . . . . . . 167
</p>
<p>6.5 Binary Search Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
</p>
<p>6.6 Search Spaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
</p>
<p>6.7 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
</p>
<p>6.8 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
</p>
<p>6.9 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
</p>
<p>7 Graphs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
</p>
<p>7.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
</p>
<p>7.2 Graph Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
</p>
<p>7.3 Searching a Graph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
</p>
<p>7.4 Kruskal&rsquo;s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
</p>
<p>7.5 Dijkstra&rsquo;s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
</p>
<p>7.6 Graph Representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
</p>
<p>7.7 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
</p>
<p>7.8 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
</p>
<p>7.9 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
</p>
<p>8 Membership Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
</p>
<p>8.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
</p>
<p>8.2 Bloom Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
</p>
<p>8.3 The Trie Datatype . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
</p>
<p>8.4 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
</p>
<p>8.5 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
</p>
<p>8.6 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
</p>
<p>9 Heaps. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
</p>
<p>9.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
</p>
<p>9.2 Key Ideas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
</p>
<p>9.3 Building a Heap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
</p>
<p>9.4 The Heapsort Algorithm Version 1 . . . . . . . . . . . . . . . . . . . 219
</p>
<p>9.5 Analysis of Version 1 Phase I. . . . . . . . . . . . . . . . . . . . . . . 221
</p>
<p>Contents xiii
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec24">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec24</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec28">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec28</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec28">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec28</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec30">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec30</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec31">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec31</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec31">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec31</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec32">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec32</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec32">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec32</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec33">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec33</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec33">http://dx.doi.org/10.1007/978-3-319-13072-9_5#Sec33</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_6#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec10">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_7#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8">http://dx.doi.org/10.1007/978-3-319-13072-9_8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8">http://dx.doi.org/10.1007/978-3-319-13072-9_8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_8#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9">http://dx.doi.org/10.1007/978-3-319-13072-9_9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9">http://dx.doi.org/10.1007/978-3-319-13072-9_9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec8">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec8</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec8">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec8</a></div>
</div>
<div class="page"><p/>
<p>9.6 Phase II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
</p>
<p>9.7 Analysis of Phase II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
</p>
<p>9.8 The Heapsort Algorithm Version 2 . . . . . . . . . . . . . . . . . . . 229
</p>
<p>9.9 Analysis of Heapsort Version 2 . . . . . . . . . . . . . . . . . . . . . 232
</p>
<p>9.10 Comparison to Other Sorting Algorithms . . . . . . . . . . . . . . . 233
</p>
<p>9.11 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
</p>
<p>9.12 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
</p>
<p>9.13 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
</p>
<p>10 Balanced Binary Search Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . 237
</p>
<p>10.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
</p>
<p>10.2 Binary Search Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
</p>
<p>10.3 AVL Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
</p>
<p>10.4 Splay Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
</p>
<p>10.5 Iterative Splaying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
</p>
<p>10.6 Recursive Splaying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
</p>
<p>10.7 Performance Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
</p>
<p>10.8 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
</p>
<p>10.9 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
</p>
<p>10.10 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
</p>
<p>11 B-Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
</p>
<p>11.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
</p>
<p>11.2 Relational Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
</p>
<p>11.3 B-Tree Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
</p>
<p>11.4 The Advantages of B-Trees . . . . . . . . . . . . . . . . . . . . . . . . 272
</p>
<p>11.5 B-Tree Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
</p>
<p>11.6 B-Tree Insert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
</p>
<p>11.7 B-Tree Delete . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
</p>
<p>11.8 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
</p>
<p>11.9 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
</p>
<p>11.10 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
</p>
<p>12 Heuristic Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
</p>
<p>12.1 Chapter Goals. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
</p>
<p>12.2 Depth First Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
</p>
<p>12.3 Breadth First Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
</p>
<p>12.4 Hill Climbing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
</p>
<p>12.5 Best First Search. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
</p>
<p>12.6 A* Search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
</p>
<p>12.7 Minimax Revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
</p>
<p>12.8 Chapter Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
</p>
<p>12.9 Review Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
</p>
<p>12.10 Programming Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
</p>
<p>xiv Contents
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_9#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10">http://dx.doi.org/10.1007/978-3-319-13072-9_10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10">http://dx.doi.org/10.1007/978-3-319-13072-9_10</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec21">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec21</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec21">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec21</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec22">http://dx.doi.org/10.1007/978-3-319-13072-9_10#Sec22</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11">http://dx.doi.org/10.1007/978-3-319-13072-9_11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11">http://dx.doi.org/10.1007/978-3-319-13072-9_11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec11">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec11</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec12">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec14">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec16">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_11#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec7">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec9">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec9</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec13">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec15">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec17">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec18">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec19">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec20">http://dx.doi.org/10.1007/978-3-319-13072-9_12#Sec20</a></div>
</div>
<div class="page"><p/>
<p>13 Appendix A: Integer Operators . . . . . . . . . . . . . . . . . . . . . . . . . . 299
</p>
<p>14 Appendix B: Float Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
</p>
<p>15 Appendix C: String Operators and Methods . . . . . . . . . . . . . . . . 303
</p>
<p>16 Appendix D: List Operators and Methods . . . . . . . . . . . . . . . . . . 307
</p>
<p>17 Appendix E: Dictionary Operators and Methods . . . . . . . . . . . . . 309
</p>
<p>18 Appendix F: Turtle Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
</p>
<p>19 Appendix G: TurtleScreen Methods. . . . . . . . . . . . . . . . . . . . . . . 323
</p>
<p>20 Appendix H: Complete Programs . . . . . . . . . . . . . . . . . . . . . . . . 331
</p>
<p>20.1 The Draw Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
</p>
<p>20.2 The Scope Program. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
</p>
<p>20.3 The Sort Animation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
</p>
<p>20.4 The PlotData Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
</p>
<p>20.5 The Tic Tac Toe Application . . . . . . . . . . . . . . . . . . . . . . . 348
</p>
<p>20.6 The Connect Four Front-End . . . . . . . . . . . . . . . . . . . . . . . 353
</p>
<p>Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
</p>
<p>Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
</p>
<p>Contents xv
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_13">http://dx.doi.org/10.1007/978-3-319-13072-9_13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_13">http://dx.doi.org/10.1007/978-3-319-13072-9_13</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_14">http://dx.doi.org/10.1007/978-3-319-13072-9_14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_14">http://dx.doi.org/10.1007/978-3-319-13072-9_14</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_15">http://dx.doi.org/10.1007/978-3-319-13072-9_15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_15">http://dx.doi.org/10.1007/978-3-319-13072-9_15</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_16">http://dx.doi.org/10.1007/978-3-319-13072-9_16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_16">http://dx.doi.org/10.1007/978-3-319-13072-9_16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_17">http://dx.doi.org/10.1007/978-3-319-13072-9_17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_17">http://dx.doi.org/10.1007/978-3-319-13072-9_17</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_18">http://dx.doi.org/10.1007/978-3-319-13072-9_18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_18">http://dx.doi.org/10.1007/978-3-319-13072-9_18</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_19">http://dx.doi.org/10.1007/978-3-319-13072-9_19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_19">http://dx.doi.org/10.1007/978-3-319-13072-9_19</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec1">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec1</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec2">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec3">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec3</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec4">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec5">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec6">http://dx.doi.org/10.1007/978-3-319-13072-9_20#Sec6</a></div>
</div>
<div class="page"><p/>
<p>1Python Programming 101
</p>
<p>This Computer Science text further develops the skills you learned in your first CS
</p>
<p>text or course and adds to your bag of tricks by teaching you how to use efficient
</p>
<p>algorithms for dealing with large amounts of data. Without the proper understanding
</p>
<p>of efficiency, it is possible to bring even the fastest computers to a grinding halt when
</p>
<p>working with large data sets. This has happened before, and soon you will understand
</p>
<p>just how easy it can occur. But first, we&rsquo;ll review some patterns for programming and
</p>
<p>look at the Python programming language to make sure you understand the basic
</p>
<p>structure and syntax of the language.
</p>
<p>To begin writing programs using Python you need to install Python on your com-
</p>
<p>puter. The examples in this text use Python 3. Python 2 is not compatible with Python
</p>
<p>3 so you&rsquo;ll want to be sure you have Python 3 or later installed on your computer.
</p>
<p>When writing programs in any language a good Integrated Development Environ-
</p>
<p>ment (IDE) is a valuable tool so you&rsquo;ll want to install an IDE, too. Examples within
</p>
<p>this text will use Wing IDE 101 as pictured in Fig. 1.1, although other acceptable
</p>
<p>IDEs are available as well. The Wing IDE is well maintained, simple to use, and has
</p>
<p>a nice debugger which will be useful as you write Python programs. If you want to
</p>
<p>get Wing IDE 101 then go to http://wingware.com. The website http://cs.luther.edu/
</p>
<p>~leekent/CS1 has directions for installing both Python 3 and Wing IDE 101. Wing
</p>
<p>IDE 101 is the free version of Wing for educational use.
</p>
<p>There are some general concepts about Python that you should know when reading
</p>
<p>the text. Python is an interpreted language. That means that you don&rsquo;t have to go
</p>
<p>through any extra steps after writing Python code before you can run it. You can
</p>
<p>simply press the debug button in the Wing IDE (it looks like an insect) and it will
</p>
<p>ask you to save your program if you haven&rsquo;t already done so at least once. Then
</p>
<p>it will run your program. Python is also dynamically typed. This means that you
</p>
<p>will not get any type errors before you run your program as you would with some
</p>
<p>programming languages. It is especially important for you to understand the types of
</p>
<p>data you are using in your program. More on this in just a bit. Finally, your Python
</p>
<p>programs are interpreted by the Python interpreter. The shell is another name for
</p>
<p>the Python interpreter and Wing IDE 101 gives you access to a shell within the IDE
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_1
</p>
<p>1
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://wingware.com">http://wingware.com</a></div>
<div class="annotation"><a href="http://cs.luther.edu/~leekent/CS1">http://cs.luther.edu/~leekent/CS1</a></div>
<div class="annotation"><a href="http://cs.luther.edu/~leekent/CS1">http://cs.luther.edu/~leekent/CS1</a></div>
</div>
<div class="page"><p/>
<p>2 1 Python Programming 101
</p>
<p>Fig. 1.1 The Wing IDE
</p>
<p>itself. You can type Python statements and expressions into the window pane that
</p>
<p>says Python Shell to quickly try out a snippet of code before you put it in a program.
</p>
<p>Like most programming languages, there are a couple kinds of errors you can get
</p>
<p>in your Python programs. Syntax errors are found before your program runs. These
</p>
<p>are things like missing a colon or forgetting to indent something. An IDE like Wing
</p>
<p>IDE 101 will highlight these syntax errors so you can correct them. Run-time errors
</p>
<p>are found when your program runs. Run-time errors come from things like variables
</p>
<p>with unexpected values and operations on these values. To find a run-time error you
</p>
<p>can look at the Stack Data tab as it appears in Fig. 1.1. When a run-time error occurs
</p>
<p>the program will stop executing and the Stack Data tab will let you examine the
</p>
<p>run-time stack where you can see the program variables.
</p>
<p>In the event that you still don&rsquo;t understand a problem, the Wing IDE 101 (and
</p>
<p>most other IDEs) lets you step through your code so you can watch as an error is
</p>
<p>reproduced. The three icons in the upper right corner of Fig. 1.1 let you Step Into a
</p>
<p>function, Step Over code, and Step Out Of a function, respectively. Stepping over or
</p>
<p>into your code can be valuable when trying to understand a run-time error and how
</p>
<p>it occurred.
</p>
<p>One other less than obvious tool is provided by the Wing IDE. By clicking on the
</p>
<p>line number on the left side of the IDE it is possible to set a breakpoint. A breakpoint
</p>
<p>causes the program to stop execution just before the breakpoint. From there it is
</p>
<p>possible to begin stepping over your code to determine how an error occurred.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1 Python Programming 101 3
</p>
<p>To motivate learning or reviewing Python in this chapter, the text will develop
</p>
<p>a simple drawing application using turtle graphics and a Graphical User Interface
</p>
<p>(GUI) framework called Tkinter. Along the way, you&rsquo;ll discover some patterns for
</p>
<p>programming including the accumulator pattern and the loop and a half pattern for
</p>
<p>reading records from a file. You&rsquo;ll also see functions in Python and begin to learn
</p>
<p>how to implement your own datatypes by designing and writing a class definition.
</p>
<p>1.1 Chapter Goals
</p>
<p>By the end of this chapter, you should be able to answer these questions.
</p>
<p>&bull; What two parts are needed for the accumulator pattern?
</p>
<p>&bull; When do you need to use the loop and a half pattern for reading from a file?
</p>
<p>&bull; What is the purpose of a class definition?
</p>
<p>&bull; What is an object and how do we create one?
</p>
<p>&bull; What is a mutator method?
</p>
<p>&bull; What is an accessor method?
</p>
<p>&bull; What is a widget and how does one use widgets in GUI programming?
</p>
<p>1.2 Creating Objects
</p>
<p>Python is an object-oriented language. All data items in Python are objects. In Python,
</p>
<p>data items that could be thought of as similar are named by a type or class. The term
</p>
<p>type and class in Python are synonymous: they are two names for the same thing. So
</p>
<p>when you read about types in Python you can think of classes or vice versa.
</p>
<p>There are several built-in types of data in Python including int, float, str, list, and
</p>
<p>dict which is short for dictionary. These types of data and their associated operations
</p>
<p>are included in the appendices at the end of the text so you have a quick reference
</p>
<p>if you need to refer to it while programming. You can also get help for any type
</p>
<p>by typing help(typename) in the Python shell, where typename is a type or class in
</p>
<p>Python. A very good language reference can be found at http://python.org/doc, the
</p>
<p>official Python documentation website.
</p>
<p>1.2.1 Literal Values
</p>
<p>There are two ways to create objects in Python. In a few cases, you can use a literal
</p>
<p>value to create an object. Literal values are used when we want to set some variable
</p>
<p>to a specific value within our program. For example, the literal 6 denotes any object
</p>
<p>with the integer value of 6.
</p>
<p>x = 6
</p>
<p>This creates an int object containing the value 6. It also points the reference called
</p>
<p>x at this object as pictured in Fig. 1.2. All assignments in Python point references
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://python.org/doc">http://python.org/doc</a></div>
</div>
<div class="page"><p/>
<p>4 1 Python Programming 101
</p>
<p>Fig. 1.2 A Reference and Object
</p>
<p>at objects. Any time you see an assignment statement, you should remember that
</p>
<p>the thing on the left side of the equals sign is a reference and the thing on the right
</p>
<p>side is either another reference or a newly created object. In this case, writing x = 6
</p>
<p>makes a new object and then points x at this object.
</p>
<p>Other literal values may be written in Python as well. Here are some literal values
</p>
<p>that are possible in Python.
</p>
<p>&bull; int literals: 6, 3, 10, &minus;2, etc.
</p>
<p>&bull; float literals: 6.0, &minus;3.2, 4.5E10
</p>
<p>&bull; str literals: &lsquo;hi there&rsquo;, &ldquo;how are you&rdquo;
</p>
<p>&bull; list literals: [], [6, &lsquo;hi there&rsquo;]
</p>
<p>&bull; dict literals: {}, {&lsquo;hi there&rsquo;:6, &lsquo;how are you&rsquo;:4}
</p>
<p>Python lets you specify float literals with an exponent.
</p>
<p>So, 4.5E10 represents the float 45000000000.0. Any number written with a deci-
</p>
<p>mal point is a float, whether there is a 0 or some other value after the decimal point. If
</p>
<p>you write a number using the E or exponent notation, it is a float as well. Any number
</p>
<p>without a decimal point is an int, unless it is written in E notation. String literals are
</p>
<p>surrounded by either single or double quotes. List literals are surrounded by [ and ].
</p>
<p>The [] literal represents the empty list. The {} literal is the empty dictionary.
</p>
<p>You may not have previously used dictionaries. A dictionary is a mapping of keys
</p>
<p>to values. In the dictionary literal, the key &lsquo;hi there&rsquo; is mapped to the value 6, and
</p>
<p>the key &lsquo;how are you&rsquo; is mapped to 4. Dictionaries will be covered in some detail in
</p>
<p>Chap. 5.
</p>
<p>1.2.2 Non-literal Object Creation
</p>
<p>Most of the time, when an object is created, it is not created from a literal value.
</p>
<p>Of course, we need literal values in programming languages, but most of the time
</p>
<p>we have an object already and want to create another object by using one or more
</p>
<p>existing objects. For instance, if we have a string in Python, like &lsquo;6&rsquo; and want to
</p>
<p>create an int object from that string, we can do the following.
</p>
<p>y = &rsquo;6&rsquo;
</p>
<p>x = int(y)
</p>
<p>print(x)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
</div>
<div class="page"><p/>
<p>1.2 Creating Objects 5
</p>
<p>In this short piece of code, y is a reference to the str object created from the string
</p>
<p>literal. The variable x is a reference to an object that is created by using the object
</p>
<p>that y refers to. In general, when we want to create an object based on other object
</p>
<p>values we write the following:
</p>
<p>variable = type(other_object_values)
</p>
<p>The type is any type or class name in Python, like int, float, str or any other
</p>
<p>type. The other_object_values is a comma-separated sequence of references to other
</p>
<p>objects that are needed by the class or type to create an instance (i.e. an object) of
</p>
<p>that type. Here are some examples of creating objects from non-literal values.
</p>
<p>z = float(&rsquo;6.3&rsquo;)
</p>
<p>w = str(z)
</p>
<p>u = list(w) # this results in the list [&rsquo;6&rsquo;, &rsquo;.&rsquo;, &rsquo;3&rsquo;]
</p>
<p>1.3 Calling Methods on Objects
</p>
<p>Objects are useful because they allow us to collect related information and group
</p>
<p>them with behavior that act on this data. These behaviors are called methods in
</p>
<p>Python. There are two kinds of methods in any object-oriented language: mutator
</p>
<p>and accessor methods. Accessor methods access the current state of an object but
</p>
<p>don&rsquo;t change the object. Accessor methods return new object references when called.
</p>
<p>x = &rsquo;how are you&rsquo;
</p>
<p>y = x.upper()
</p>
<p>print(y)
</p>
<p>Here, the method upper is called on the object that x refers to. The upper accessor
</p>
<p>method returns a new object, a str object, that is an upper-cased version of the
</p>
<p>original string. Note that x is not changed by calling the upper method on it. The
</p>
<p>upper method is an accessor method. There are many accessor methods available on
</p>
<p>the str type which you can learn about in the appendices.
</p>
<p>Some methods are mutator methods. These methods actually change the existing
</p>
<p>object. One good example of this is the reverse method on the list type.
</p>
<p>myList = [1, 2, 3]
</p>
<p>myList.reverse()
</p>
<p>print(myList) # This prints [3, 2, 1] to the screen
</p>
<p>The reverse method mutates the existing object, in this case the list that myList
</p>
<p>refers to. Once called, a mutator method can&rsquo;t be undone. The change or mutation
</p>
<p>is permanent until mutated again by some other mutator method.
</p>
<p>All classes contain accessor methods. Without accessor methods, the class would
</p>
<p>be pretty uninteresting. We use accessor methods to retrieve a value that is stored
</p>
<p>in an object or to retrieve a value that depends on the value stored in an object.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6 1 Python Programming 101
</p>
<p>If a class had no accessor methods we could put values in the object but we could
</p>
<p>never retrieve them.
</p>
<p>Some classes have mutator methods and some don&rsquo;t. For instance, the list class has
</p>
<p>mutator methods, including the reverse method. There are some classes that don&rsquo;t
</p>
<p>have any mutator methods. For instance, the str class does not have any mutator
</p>
<p>methods. When a class does not contain any mutator methods, we say that the class
</p>
<p>is immutable. We can form new values from the data in an immutable class, but
</p>
<p>once an immutable object is created, it cannot be changed. Other immutable classes
</p>
<p>include int and float.
</p>
<p>1.4 Implementing a Class
</p>
<p>Programming in an object-oriented language usually means implementing classes
</p>
<p>that describe objects which hold information that is needed by the program you
</p>
<p>are writing. Objects contain data and methods operate on that data. A class is the
</p>
<p>definition of the data and methods for a specific type of object.
</p>
<p>Every class contains one special method called a constructor. The constructor&rsquo;s
</p>
<p>job is to create an instance of an object by placing references to data within the object
</p>
<p>itself. For example, consider a class called Dog. A dog has a name, a birthday, and a
</p>
<p>sound it makes when it barks. When we create a Dog object, we write code like that
</p>
<p>appearing in Sect. 1.4.1.
</p>
<p>1.4.1 Creating Objects and Calling Methods
</p>
<p>1 boyDog = Dog("Mesa", 5, 15, 2004, "WOOOF")
</p>
<p>2 girlDog = Dog("Sequoia", 5, 6, 2004, "barkbark")
</p>
<p>3 print(boyDog.speak())
</p>
<p>4 print(girlDog.speak())
</p>
<p>5 print(boyDog.birthDate())
</p>
<p>6 print(girlDog.birthDate())
</p>
<p>7 boyDog.changeBark("woofywoofy")
</p>
<p>8 print(boyDog.speak())
</p>
<p>Once created in the memory of the computer, dog objects looks like those appear-
</p>
<p>ing in Fig. 1.3. Each object is referenced by the variable reference assigned to it,
</p>
<p>either girlDog or boyDog in this case. The objects themselves are a collection of
</p>
<p>references that point to the information that is stored in the object. Each object has
</p>
<p>name, month, day, year, and speakText references that point to the associated data
</p>
<p>that make up a Dog object.
</p>
<p>To be able to create Dog objects like these two objects we need a Dog class to define
</p>
<p>these objects. In addition, we&rsquo;ll need to define speak, birthDate, and changeBark
</p>
<p>methods. We can do this by writing a class as shown in Sect. 1.4.2. Comments about
</p>
<p>each part of the class appear in the code. The special variable self always points
</p>
<p>at the current object and must be the first parameter to each method in the class.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.4 Implementing a Class 7
</p>
<p>Fig. 1.3 A Couple of Dog Objects
</p>
<p>Python takes care of passing the self argument to the methods. The other arguments
</p>
<p>are passed by the programmer when the method is called (see the example of calling
</p>
<p>each method in Sect. 1.4.1).
</p>
<p>1.4.2 The Dog Class
</p>
<p>1 class Dog:
</p>
<p>2     # This is the constructor for the class. It is called whenever a Dog
</p>
<p>3     # object is created. The reference called "self" is created by Python
</p>
<p>4     # and made to point to the space for the newly created object. Python
</p>
<p>5     # does this automatically for us but we have to have "self" as the first
</p>
<p>6     # parameter to the __init__ method (i.e. the constructor).
</p>
<p>7     def __init__(self, name, month, day, year, speakText):
</p>
<p>8         self.name = name
</p>
<p>9         self.month = month
</p>
<p>10         self.day = day
</p>
<p>11         self.year = year
</p>
<p>12         self.speakText = speakText
</p>
<p>13
</p>
<p>14     # This is an accessor method that returns the speakText stored in the
</p>
<p>15     # object. Notice that "self" is a parameter. Every method has "self" as its
</p>
<p>16     # first parameter. The "self" parameter is a reference to the current
</p>
<p>17     # object. The current object appears on the left hand side of the dot (i.e.
</p>
<p>18     # the .) when the method is called.
</p>
<p>19     def speak(self):
</p>
<p>20         return self.speakText
</p>
<p>21
</p>
<p>22     # Here is an accessor method to get the name
</p>
<p>23     def getName(self):
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8 1 Python Programming 101
</p>
<p>24         return self.name
</p>
<p>25
</p>
<p>26     # This is another accessor method that uses the birthday information to
</p>
<p>27     # return a string representing the date.
</p>
<p>28     def birthDate(self):
</p>
<p>29         return str(self.month) + "/" + str(self.day) + "/" + str(self.year)
</p>
<p>30
</p>
<p>31     # This is a mutator method that changes the speakText of the Dog object.
</p>
<p>32     def changeBark(self,bark):
</p>
<p>33         self.speakText = bark
</p>
<p>1.5 Operator Overloading
</p>
<p>Python provides operator overloading, which is a nice feature of programming lan-
</p>
<p>guages because it makes it possible for the programmer to interact with objects in a
</p>
<p>very natural way. Operator overloading is already implemented for a variety of the
</p>
<p>built-in classes or types in Python. For instance, integers (i.e. the int type) understand
</p>
<p>how they can be added together to form a new integer object. Addition is implemented
</p>
<p>by a special method in Python called the __add__ method. When two integers are
</p>
<p>added together, this method is called to create a new integer object. If you look in the
</p>
<p>appendices, you&rsquo;ll see examples of these special methods and how they are called.
</p>
<p>For example, in Chap. 13 the __add__ method is called by writing x + y where
</p>
<p>x is an integer. The methods that begin and end with two underscores are methods
</p>
<p>that Python associates with a corresponding operator.
</p>
<p>When we say that Python supports operator overloading we mean that if you
</p>
<p>define a method for your class with a name that is operator overloaded, your class
</p>
<p>will support that operator as well. Python figures out which method to call based
</p>
<p>on the types of the operands involved. For instance, writing x + y calls the int class
</p>
<p>__add__ method when x is an integer, but it calls the float type&rsquo;s __add__ method
</p>
<p>when x is a float. This is because in the case of the __add__ method, the object on the
</p>
<p>left hand side of the + operator corresponds to the object on the left hand side of the
</p>
<p>dot (i.e. the period) in the equivalent method call x.__add__(y). The object on the left
</p>
<p>side of the dot determines which add method is called. The + operator is overloaded.
</p>
<p>If we wanted to define addition for our Dog class, we would include an __add__
</p>
<p>method in the class definition. It might be natural to write boyDog+girlDog to create
</p>
<p>a new puppy object. If we wished to do that we would extend our Dog class as shown
</p>
<p>in Sect. 1.5.1.
</p>
<p>1.5.1 The Dog Class with Overloaded Addition
</p>
<p>1 class Dog:
</p>
<p>2     # This is the constructor for the class. It is called whenever a Dog
</p>
<p>3     # object is created. The reference called "self" is created by Python
</p>
<p>4     # and made to point to the space for the newly created object. Python
</p>
<p>5     # does this automatically for us but we have to have "self" as the first
</p>
<p>6     # parameter to the __init__ method (i.e. the constructor).
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_13">http://dx.doi.org/10.1007/978-3-319-13072-9_13</a></div>
</div>
<div class="page"><p/>
<p>1.5 Operator Overloading 9
</p>
<p>7     def __init__(self, name, month, day, year, speakText):
</p>
<p>8         self.name = name
</p>
<p>9         self.month = month
</p>
<p>10         self.day = day
</p>
<p>11         self.year = year
</p>
<p>12         self.speakText = speakText
</p>
<p>13
</p>
<p>14     # This is an accessor method that returns the speakText stored in the
</p>
<p>15     # object. Notice that "self" is a parameter. Every method has "self" as its
</p>
<p>16     # first parameter. The "self" parameter is a reference to the current
</p>
<p>17     # object. The current object appears on the left hand side of the dot (i.e.
</p>
<p>18     # the .) when the method is called.
</p>
<p>19     def speak(self):
</p>
<p>20         return self.speakText
</p>
<p>21
</p>
<p>22     # Here is an accessor method to get the name
</p>
<p>23     def getName(self):
</p>
<p>24         return self.name
</p>
<p>25
</p>
<p>26     # This is another accessor method that uses the birthday information to
</p>
<p>27     # return a string representing the date.
</p>
<p>28     def birthDate(self):
</p>
<p>29         return str(self.month) + "/" + str(self.day) + "/" + str(self.year)
</p>
<p>30
</p>
<p>31     # This is a mutator method that changes the speakText of the Dog object.
</p>
<p>32     def changeBark(self,bark):
</p>
<p>33         self.speakText = bark
</p>
<p>34
</p>
<p>35     # When creating the new puppy we don&rsquo;t know it&rsquo;s birthday. Pick the
</p>
<p>36     # first dog&rsquo;s birthday plus one year. The speakText will be the
</p>
<p>37     # concatenation of both dog&rsquo;s text. The dog on the left side of the +
</p>
<p>38     # operator is the object referenced by the "self" parameter. The
</p>
<p>39     # "otherDog" parameter is the dog on the right side of the + operator.
</p>
<p>40     def __add__(self,otherDog):
</p>
<p>41         return Dog("Puppy of " + self.name + " and " + otherDog.name, \
</p>
<p>42                    self.month, self.day, self.year + 1, \
</p>
<p>43                    self.speakText + otherDog.speakText)
</p>
<p>44
</p>
<p>45 def main():
</p>
<p>46     boyDog = Dog("Mesa", 5, 15, 2004, "WOOOOF")
</p>
<p>47     girlDog = Dog("Sequoia", 5, 6, 2004, "barkbark")
</p>
<p>48     print(boyDog.speak())
</p>
<p>49     print(girlDog.speak())
</p>
<p>50     print(boyDog.birthDate())
</p>
<p>51     print(girlDog.birthDate())
</p>
<p>52     boyDog.changeBark("woofywoofy")
</p>
<p>53     print(boyDog.speak())
</p>
<p>54     puppy = boyDog + girlDog
</p>
<p>55     print(puppy.speak())
</p>
<p>56     print(puppy.getName())
</p>
<p>57     print(puppy.birthDate())
</p>
<p>58
</p>
<p>59 if __name__ == "__main__":
</p>
<p>60     main()
</p>
<p>This text uses operator overloading fairly extensively. There are many operators
</p>
<p>that are defined in Python. Python programmers often call these operators Magic
</p>
<p>Methods because a method automatically gets called when an operator is used in an
</p>
<p>expression. Many of the common operators are given in the table in Fig. 1.4 for your
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10 1 Python Programming 101
</p>
<p>Method Defintion Operator Description
</p>
<p>__add__(self,y) x + y The addition of two objects. The type of x determines which add
</p>
<p>operator is called.
</p>
<p>__contains__(self,y) y in x When x is a collection you can test to see if y is in it.
</p>
<p>__eq__(self,y) x == y Returns True or False depending on the values of x and y.
</p>
<p>__ge__(self,y) x &gt;= y Returns True or False depending on the values of x and y.
</p>
<p>__getitem__(self,y) x[y] Returns the item at the yth position in x.
</p>
<p>__gt__(self,y) x &gt; y Returns True or False depending on the values of x and y.
</p>
<p>__hash__(self) hash(x) Returns an integral value for x.
</p>
<p>__int__(self) int(x) Returns an integer representation of x.
</p>
<p>__iter__(self) for v in x Returns an iterator object for the sequence x.
</p>
<p>__le__(self,y) x &lt;= y Returns True or False depending on the values of x and y.
</p>
<p>__len__(self) len(x) Returns the size of x where x has some length attribute.
</p>
<p>__lt__(self,y) x &lt; y Returns True or False depending on the values of x and y.
</p>
<p>__mod__(self,y) x % y Returns the value of x modulo y. This is the remainder of x/y.
</p>
<p>__mul__(self,y) x * y Returns the product of x and y.
</p>
<p>__ne__(self,y) x != y Returns True or False depending on the values of x and y.
</p>
<p>__neg__(self) -x Returns the unary negation of x.
</p>
<p>__repr__(self) repr(x) Returns a string version of x suitable to be evaluated by the eval
</p>
<p>function.
</p>
<p>__setitem__(self,i,y) x[i] = y Sets the item at the ith position in x to y.
</p>
<p>__str__(self) str(x) Return a string representation of x suitable for user-level interac-
</p>
<p>tion.
</p>
<p>__sub__(self,y) x - y The difference of two objects.
</p>
<p>Fig. 1.4 Python Operator Magic Methods
</p>
<p>convenience. For each operator the magic method is given, how to call the operator
</p>
<p>is given, and a short description of it as well. In the table, self and x refer to the
</p>
<p>same object. The type of x determines which operator method is called in each case
</p>
<p>in the table.
</p>
<p>The repr(x) and the str(x) operators deserve a little more explanation. Both oper-
</p>
<p>ators return a string representation of x. The difference is that the str operator should
</p>
<p>return a string that is suitable for human interaction while the repr operator is called
</p>
<p>when a string representation is needed that can be evaluated. For instance, if we
</p>
<p>wanted to define these two operators on the Dog class, the repr method would
</p>
<p>return the string &ldquo;Dog(&lsquo;Mesa&rsquo;, 5,15,2004, &lsquo;WOOOF&rsquo;)&rdquo; while the str operator might
</p>
<p>return just the dog&rsquo;s name. The repr operator, when called, will treat the string as an
</p>
<p>expression that could later be evaluated by the eval function in Python whereas the
</p>
<p>str operator simply returns a string for an object.
</p>
<p>1.6 Importing Modules
</p>
<p>In Python, programs can be broken up into modules. Typically, when you write a
</p>
<p>program in Python you are going to use code that someone else wrote. Code that
</p>
<p>others wrote is usually provided in a module. To use a module, you import it. There
</p>
<p>are two ways to import a module. For the drawing program we are developing in this
</p>
<p>chapter, we want to use turtle graphics. Turtle graphics was first developed a long
</p>
<p>time ago for a programming language called Logo. Logo was created around 1967
</p>
<p>so the basis for turtle graphics is pretty ancient in terms of Computer Science. It still
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.6 Importing Modules 11
</p>
<p>remains a useful way of thinking about Computer Graphics. The idea is that a turtle
</p>
<p>is wandering a beach and as it walks around it drags its tail in the sand leaving a trail
</p>
<p>behind it. All that you can do with a turtle is discussed in the Chap. 18.
</p>
<p>There are two ways to import a module in Python: the convenient way and the
</p>
<p>safe way. Which way you choose to import code may be a personal preference, but
</p>
<p>there are some implications about using the convenient method of importing code.
</p>
<p>The convenient way to import the turtle module would be to write the following.
</p>
<p>from turtle import *
</p>
<p>t = Turtle()
</p>
<p>This is convenient, because whenever you want to use the Turtle class, you can
</p>
<p>just write Turtle which is convenient, but not completely safe because you then have
</p>
<p>to make sure you never use the identifier Turtle for anything else in your code. In
</p>
<p>fact, there may be other identifiers that the turtle module defines that you are unaware
</p>
<p>of that would also be identifiers you should not use in your code. The safe way to
</p>
<p>import the turtle module would be as follows.
</p>
<p>import turtle
</p>
<p>t = turtle.Turtle()
</p>
<p>While this is not quite as convenient, because you must precede Turtle with &ldquo;tur-
</p>
<p>tle.&rdquo;, it is safe because the namespace of your module and the turtle module are kept
</p>
<p>separate. All identifiers in the turtle module are in the turtle namespace, while the
</p>
<p>local identifiers are in the local namespace. This idea of namespaces is an important
</p>
<p>feature of most programming languages. It helps programmers keep from stepping
</p>
<p>on each others&rsquo; toes. The rest of this text will stick to using the safe method of
</p>
<p>importing modules.
</p>
<p>1.7 Indentation in Python Programs
</p>
<p>Indentation plays an important role in Python programs. An indented line belongs
</p>
<p>to the line it is indented under. The body of a function is indented under its function
</p>
<p>definition line. The then part of an if statement is indented under the if. A while
</p>
<p>loop&rsquo;s body is indented under it. The methods of a class are all indented under the
</p>
<p>class definition line. All statements that are indented the same amount and grouped
</p>
<p>together are called a block. It is important that all statements within a block are
</p>
<p>indented exactly the same amount. If they are not, then Python will complain about
</p>
<p>inconsistent indentation.
</p>
<p>Because indentation is so important to Python, the Wing IDE 101 lets you select a
</p>
<p>series of lines and adjust their indentation as a group, as shown in Fig. 1.5. You first
</p>
<p>select the lines of the block and then press the tab key to increase their indentation.
</p>
<p>To decrease the indentation of a block you select the lines of the block and press
</p>
<p>Shift-tab. As you write Python code this is a common chore and being able to adjust
</p>
<p>the indentation of a whole block at a time is a real timesaver.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_18">http://dx.doi.org/10.1007/978-3-319-13072-9_18</a></div>
</div>
<div class="page"><p/>
<p>12 1 Python Programming 101
</p>
<p>Fig. 1.5 Adjusting Indentation in Wing IDE 101
</p>
<p>1.8 The Main Function
</p>
<p>Programs are typically written with many function definitions and function calls.
</p>
<p>One function definition is written by convention in Python, usually called the main
</p>
<p>function. This function contains code the program typically executes when it is first
</p>
<p>started. The general outline of a Python program is given in Sect. 1.8.1.
</p>
<p>1.8.1 Python Program Structure
</p>
<p>1 # Imports at the top.
</p>
<p>2 import turtle
</p>
<p>3
</p>
<p>4 # other function definitions followed by the main function definition
</p>
<p>5 def main():
</p>
<p>6     # The main code of the program goes here
</p>
<p>7     t = turtle.Turtle()
</p>
<p>8
</p>
<p>9 # this code calls the main function to get everything started. The condition in this
</p>
<p>10 # if statement evaluates to True when the module is executed by the interpreter, but
</p>
<p>11 # not when it is imported into another module.
</p>
<p>12 if __name__ == "__main__":
</p>
<p>13     main()
</p>
<p>The if statement at the end of the code in Sect. 1.8.1 is the first code executed
</p>
<p>after the import statements. The if statement&rsquo;s condition evaluates to True when the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.8 The Main Function 13
</p>
<p>program is run as a stand-alone program. Sometimes we write modules that we may
</p>
<p>want to import into another module. Writing this if statement to call the main func-
</p>
<p>tion makes the module execute its own main function when it is run as a stand-alone
</p>
<p>program. When the module is imported into another module it will not execute its
</p>
<p>main function. Later you will have the opportunity to write a module to be imported
</p>
<p>into another module so it is a good habit to form to always call the main function in
</p>
<p>this way.
</p>
<p>1.9 Reading from a File
</p>
<p>To begin our drawing program, let&rsquo;s assume that a picture is stored in a file and we
</p>
<p>wish to read this file when the program is started. We&rsquo;ll assume that each line of the
</p>
<p>file contains a drawing command and its associated data. We&rsquo;ll keep it simple and
</p>
<p>stick to drawing commands that look like this in the input file:
</p>
<p>&bull; goto, x, y, width, color
</p>
<p>&bull; circle, radius, width, color
</p>
<p>&bull; beginfill, color
</p>
<p>&bull; endfill
</p>
<p>&bull; penup
</p>
<p>&bull; pendown
</p>
<p>Each line of the file will contain a record with the needed information. We can
</p>
<p>draw a picture by providing a file with the right sequence of these commands. The
</p>
<p>file in Sect. 1.9.1 contains records that describe a pickup truck.
</p>
<p>1.9.1 A Text File with Single Line Records
</p>
<p>1 beginfill, black
</p>
<p>2 circle, 20, 1, black
</p>
<p>3 endfill
</p>
<p>4 penup
</p>
<p>5 goto, 120, 0, 1, black
</p>
<p>6 pendown
</p>
<p>7 beginfill, black
</p>
<p>8 circle, 20, 1, black
</p>
<p>9 endfill
</p>
<p>10 penup
</p>
<p>11 goto, 150, 40, 1, black
</p>
<p>12 pendown
</p>
<p>13 beginfill, yellow
</p>
<p>14 goto, -30, 40, 1, black
</p>
<p>15 goto, -30, 70, 1, black
</p>
<p>16 goto, 60, 70, 1, black
</p>
<p>17 goto, 60, 100, 1, black
</p>
<p>18 goto, 90, 100, 1, black
</p>
<p>19 goto, 115, 70, 1, black
</p>
<p>20 goto, 150, 70, 1, black
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>14 1 Python Programming 101
</p>
<p>21 goto, 150, 40, 1, black
</p>
<p>22 endfill
</p>
<p>To process the records in the file in Sect. 1.9.1, we can write a Python program
</p>
<p>that reads the lines of this file and does the appropriate turtle graphics commands
</p>
<p>for each record in the file. Since each record (i.e. drawing command) is on its own
</p>
<p>line in the file format described in Sect. 1.9.1, we can read the file by using a for
</p>
<p>loop to read the lines of the file. The code of Sect. 1.9.2 is a program that reads these
</p>
<p>commands and processes each record in the file, drawing the picture that it contains.
</p>
<p>1.9.2 Reading and Processing Single Line Records
</p>
<p>1 # This imports the turtle graphics module.
</p>
<p>2 import turtle
</p>
<p>3
</p>
<p>4 # The main function is where the main code of the program is written.
</p>
<p>5 def main():
</p>
<p>6     # This line reads a line of input from the user.
</p>
<p>7     filename = input("Please enter drawing filename: ")
</p>
<p>8
</p>
<p>9     # Create a Turtle Graphics window to draw in.
</p>
<p>10     t = turtle.Turtle()
</p>
<p>11     # The screen is used at the end of the program.
</p>
<p>12     screen = t.getscreen()
</p>
<p>13
</p>
<p>14     # The next line opens the file for "r" or reading. "w" would open it for
</p>
<p>15     # writing, and "a" would open the file to append to it (i.e. add to the
</p>
<p>16     # end). In this program we are only interested in reading the file.
</p>
<p>17     file = open(filename, "r")
</p>
<p>18
</p>
<p>19     # The following for loop reads the lines of the file, one at a time
</p>
<p>20     # and executes the body of the loop once for each line of the file.
</p>
<p>21     for line in file:
</p>
<p>22
</p>
<p>23         # The strip method strips off the newline character at the end of the line
</p>
<p>24         # and any blanks that might be at the beginning or end of the line.
</p>
<p>25         text = line.strip()
</p>
<p>26
</p>
<p>27         # The following line splits the text variable into its pieces.
</p>
<p>28         # For instance, if text contained "goto, 10, 20, 1, black" then
</p>
<p>29         # commandList will be equal to ["goto", "10", "20", "1", "black"] after
</p>
<p>30         # splitting text.
</p>
<p>31         commandList = text.split(",")
</p>
<p>32
</p>
<p>33         # get the drawing command
</p>
<p>34         command = commandList[0]
</p>
<p>35
</p>
<p>36         if command == "goto":
</p>
<p>37             # Writing float(commandList[1]) makes a float object out of the
</p>
<p>38             # string found in commandList[1]. You can do similar conversion
</p>
<p>39             # between types for int objects.
</p>
<p>40             x = float(commandList[1])
</p>
<p>41             y = float(commandList[2])
</p>
<p>42             width = float(commandList[3])
</p>
<p>43             color = commandList[4].strip()
</p>
<p>44             t.width(width)
</p>
<p>45             t.pencolor(color)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.9 Reading from a File 15
</p>
<p>46             t.goto(x,y)
</p>
<p>47         elif command == "circle":
</p>
<p>48             radius = float(commandList[1])
</p>
<p>49             width = float(commandList[2])
</p>
<p>50             color = commandList[3].strip()
</p>
<p>51             t.width(width)
</p>
<p>52             t.pencolor(color)
</p>
<p>53             t.circle(radius)
</p>
<p>54         elif command == "beginfill":
</p>
<p>55             color = commandList[1].strip()
</p>
<p>56             t.fillcolor(color)
</p>
<p>57             t.begin_fill()
</p>
<p>58         elif command == "endfill":
</p>
<p>59             t.end_fill()
</p>
<p>60         elif command == "penup":
</p>
<p>61             t.penup()
</p>
<p>62         elif command == "pendown":
</p>
<p>63             t.pendown()
</p>
<p>64         else:
</p>
<p>65             print("Unknown command found in file:",command)
</p>
<p>66
</p>
<p>67     #close the file
</p>
<p>68     file.close()
</p>
<p>69
</p>
<p>70     #hide the turtle that we used to draw the picture.
</p>
<p>71     t.ht()
</p>
<p>72
</p>
<p>73     # This causes the program to hold the turtle graphics window open
</p>
<p>74     # until the mouse is clicked.
</p>
<p>75     screen.exitonclick()
</p>
<p>76     print("Program Execution Completed.")
</p>
<p>77
</p>
<p>78
</p>
<p>79 # This code calls the main function to get everything started.
</p>
<p>80 if __name__ == "__main__":
</p>
<p>81     main()
</p>
<p>When you have a data file where each line of the file is its own separate record,
</p>
<p>you can process those records as we did in Sect. 1.9.2. The general pattern is to open
</p>
<p>the file, use a for loop to iterate through the file, and have the body of the for loop
</p>
<p>process each record. The pseudo-code in Sect. 1.9.3 is the abstract pattern for reading
</p>
<p>one-line records from a file.
</p>
<p>1.9.3 Pattern for Reading Single Line Records from a File
</p>
<p>1 # First the file must be opened.
</p>
<p>2 file = open(filename,"r")
</p>
<p>3
</p>
<p>4 # The body of the for loop is executed once for each line in the file.
</p>
<p>5 for line in file:
</p>
<p>6     # Process each record of the file. Each record must be exactly one line of the
</p>
<p>7     # input file. What processing a record means will be determined by the
</p>
<p>8       # program you are writing.
</p>
<p>9     print(line)
</p>
<p>10
</p>
<p>11 # Closing the file is always a good idea, but it will be closed when your program
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>16 1 Python Programming 101
</p>
<p>12 # terminates if you do not close it explicitly.
</p>
<p>13 file.close()
</p>
<p>1.10 Reading Multi-line Records from a File
</p>
<p>Sometimes records of a file are not one per line. Records of a file may cross multiple
</p>
<p>lines. In that case, you can&rsquo;t use a for loop to read the file. You need a while loop
</p>
<p>instead. When you use a while loop, you need to be able to check a condition to see
</p>
<p>if you are done reading the file. But, to check the condition you must first try to read
</p>
<p>at least a little of a record. This is a kind of chicken and egg problem. Which came
</p>
<p>first, the chicken or the egg? Computer programmers have a name for this problem
</p>
<p>as it relates to reading from files. It is called the Loop and a Half Pattern. To use a
</p>
<p>while loop to read from a file, we need a loop and a half. The half comes before the
</p>
<p>while loop.
</p>
<p>Consider the program we are writing in this chapter. Let&rsquo;s assume that the records
</p>
<p>of the file cross multiple lines. In fact, let&rsquo;s assume that we have variable length
</p>
<p>records. That is, the records of our file consist of one to five lines. The drawing
</p>
<p>commands will be exactly as they were before. But, instead of all the data for a
</p>
<p>record appearing on one line, we&rsquo;ll put each piece of data on its own separate line as
</p>
<p>shown in Sect. 1.10.1.
</p>
<p>1.10.1 A Text File with Multiple Line Records
</p>
<p>1 beginfill
</p>
<p>2 black
</p>
<p>3 circle
</p>
<p>4 20
</p>
<p>5 1
</p>
<p>6 black
</p>
<p>7 endfill
</p>
<p>8 penup
</p>
<p>9 goto
</p>
<p>10 120
</p>
<p>11 0
</p>
<p>12 1
</p>
<p>13 black
</p>
<p>14 pendown
</p>
<p>15 beginfill
</p>
<p>16 black
</p>
<p>17 circle
</p>
<p>18 20
</p>
<p>19 1
</p>
<p>20 black
</p>
<p>21 endfill
</p>
<p>22 penup
</p>
<p>23 goto
</p>
<p>24 150
</p>
<p>25 40
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.10 Reading Multi-line Records from a File 17
</p>
<p>26 1
</p>
<p>27 black
</p>
<p>28 pendown
</p>
<p>29 beginfill
</p>
<p>30 yellow
</p>
<p>31 goto
</p>
<p>32 -30
</p>
<p>33 40
</p>
<p>34 1
</p>
<p>35 black
</p>
<p>36 goto
</p>
<p>37 -30
</p>
<p>38 70
</p>
<p>39 1
</p>
<p>40 black
</p>
<p>41 goto
</p>
<p>42 60
</p>
<p>43 70
</p>
<p>44 1
</p>
<p>45 black
</p>
<p>46 goto
</p>
<p>47 60
</p>
<p>48 100
</p>
<p>49 1
</p>
<p>50 black
</p>
<p>51 goto
</p>
<p>52 90
</p>
<p>53 100
</p>
<p>54 1
</p>
<p>55 black
</p>
<p>56 goto
</p>
<p>57 115
</p>
<p>58 70
</p>
<p>59 1
</p>
<p>60 black
</p>
<p>61 goto
</p>
<p>62 150
</p>
<p>63 70
</p>
<p>64 1
</p>
<p>65 black
</p>
<p>66 goto
</p>
<p>67 150
</p>
<p>68 40
</p>
<p>69 1
</p>
<p>70 black
</p>
<p>71 endfill
</p>
<p>To read a file as shown in Sect. 1.10.1 we write our loop and a half to read the
</p>
<p>first line of each record and then check that line (i.e. the graphics command) so we
</p>
<p>know how many more lines to read. The code in Sect. 1.10.2 uses a while loop to
</p>
<p>read these variable length records.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 1 Python Programming 101
</p>
<p>1.10.2 Reading and Processing Multi-line Records
</p>
<p>1 import turtle
</p>
<p>2
</p>
<p>3 def main():
</p>
<p>4     filename = input("Please enter drawing filename: ")
</p>
<p>5
</p>
<p>6     t = turtle.Turtle()
</p>
<p>7     screen = t.getscreen()
</p>
<p>8
</p>
<p>9     file = open(filename, "r")
</p>
<p>10
</p>
<p>11     # Here we have the half a loop to get things started. Reading our first
</p>
<p>12     # graphics command here lets us determine if the file is empty or not.
</p>
<p>13     command = file.readline().strip()
</p>
<p>14
</p>
<p>15     # If the command is empty, then there are no more commands left in the file.
</p>
<p>16     while command != "":
</p>
<p>17
</p>
<p>18         # Now we must read the rest of the record and then process it. Because
</p>
<p>19         # records are variable length, we&rsquo;ll use an if-elif to determine which
</p>
<p>20         # type of record it is and then we&rsquo;ll read and process the record.
</p>
<p>21
</p>
<p>22         if command == "goto":
</p>
<p>23             x = float(file.readline())
</p>
<p>24             y = float(file.readline())
</p>
<p>25             width = float(file.readline())
</p>
<p>26             color = file.readline().strip()
</p>
<p>27             t.width(width)
</p>
<p>28             t.pencolor(color)
</p>
<p>29             t.goto(x,y)
</p>
<p>30         elif command == "circle":
</p>
<p>31             radius = float(file.readline())
</p>
<p>32             width = float(file.readline())
</p>
<p>33             color = file.readline().strip()
</p>
<p>34             t.width(width)
</p>
<p>35             t.pencolor(color)
</p>
<p>36             t.circle(radius)
</p>
<p>37         elif command == "beginfill":
</p>
<p>38             color = file.readline().strip()
</p>
<p>39             t.fillcolor(color)
</p>
<p>40             t.begin_fill()
</p>
<p>41         elif command == "endfill":
</p>
<p>42             t.end_fill()
</p>
<p>43         elif command == "penup":
</p>
<p>44             t.penup()
</p>
<p>45         elif command == "pendown":
</p>
<p>46             t.pendown()
</p>
<p>47         else:
</p>
<p>48             print("Unknown command found in file:",command)
</p>
<p>49
</p>
<p>50         # This is still inside the while loop. We must (attempt to) read
</p>
<p>51         # the next command from the file. If the read succeeds, then command
</p>
<p>52         # will not be the empty string and the loop will be repeated. If
</p>
<p>53         # command is empty it is because there were no more commands in the
</p>
<p>54         # file and the while loop will terminate.
</p>
<p>55         command = file.readline().strip()
</p>
<p>56
</p>
<p>57
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.10 Reading Multi-line Records from a File 19
</p>
<p>58     # close the file
</p>
<p>59     file.close()
</p>
<p>60
</p>
<p>61     t.ht()
</p>
<p>62     screen.exitonclick()
</p>
<p>63     print("Program Execution Completed.")
</p>
<p>64
</p>
<p>65 if __name__ == "__main__":
</p>
<p>66     main()
</p>
<p>When reading a file with multi-line records, a while loop is needed. Notice that
</p>
<p>on line 13 the first line of the first record is read prior to the while loop. For the body
</p>
<p>of the while loop to execute, the condition must be tested prior to executing the loop.
</p>
<p>Reading a line prior to the while loop is necessary so we can check to see if the file is
</p>
<p>empty or not. The first line of every other record is read at the end of the while loop on
</p>
<p>line 55. This is the loop and a half pattern. The first line of the first record is read before
</p>
<p>the while loop while the first line of every other record is read inside the while loop
</p>
<p>just before the end. When the condition becomes false, the while loop terminates.
</p>
<p>The abstract pattern for reading multi-line records from a file is shown in
</p>
<p>Sect. 1.10.3. There are certainly other forms of this pattern that can be used, but
</p>
<p>memorizing this pattern is worth-while since the pattern will work using pretty much
</p>
<p>any programming language.
</p>
<p>1.10.3 Pattern for Reading Multi-line Records from a File
</p>
<p>1 # First the file must be opened
</p>
<p>2 file = open(filename, "r")
</p>
<p>3
</p>
<p>4 # Read the first line of the first record in the file. Of course, firstLine should be
</p>
<p>5 # called something that makes sense in your program.
</p>
<p>6 firstLine = file.readline().strip()
</p>
<p>7
</p>
<p>8 while firstLine != "":
</p>
<p>9     # Read the rest of the record
</p>
<p>10     secondLine = file.readline().strip()
</p>
<p>11     thirdLine = file.readline().strip()
</p>
<p>12     # ...
</p>
<p>13
</p>
<p>14     # Then process the record. This will be determined by the program you are
</p>
<p>15     # writing.
</p>
<p>16     print(firstLine, secondLine, thirdLine)
</p>
<p>17
</p>
<p>18     # Finally, finish the loop by reading the first line of the next record to
</p>
<p>19     # set up for the next iteration of the loop.
</p>
<p>20     firstLine = file.readline().strip()
</p>
<p>21
</p>
<p>22 # It&rsquo;s a good idea to close the file, but it will be automatically closed when your
</p>
<p>23 # program terminates.
</p>
<p>24 file.close()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20 1 Python Programming 101
</p>
<p>1.11 A Container Class
</p>
<p>To further enhance our drawing program we will first create a data structure to hold
</p>
<p>all of our drawing commands. This is our first example of defining our own class in
</p>
<p>this text so we&rsquo;ll go slow and provide a lot of detail about what is happening and
</p>
<p>why. To begin let&rsquo;s figure out what we want to do with this container class.
</p>
<p>Our program will begin by creating an empty container. To do this, we&rsquo;ll write a
</p>
<p>line like this.
</p>
<p>graphicsCommands = PyList()
</p>
<p>Then, we will want to add graphics commands to our list using an append method
</p>
<p>like this.
</p>
<p>command = GotoCommand(x, y, width, color)
</p>
<p>graphicsCommands.append(command)
</p>
<p>We would also like to be able to iterate over the commands in our list.
</p>
<p>for command in graphicsCommands:
</p>
<p>    # draw each command on the screen using the turtle called t.
</p>
<p>    command.draw(t)
</p>
<p>At this point, our container class looks a lot like a list. We are defining our own
</p>
<p>list class to illustrate a first data structure and to motivate discussion of how lists can
</p>
<p>be implemented efficiently in this and the next chapter.
</p>
<p>1.12 Polymorphism
</p>
<p>One important concept in Object-Oriented Programming is called polymorphism.
</p>
<p>The word polymorphic literally means many forms. As this concept is applied to
</p>
<p>computer programming, the idea is that there can be many ways that a particular
</p>
<p>behavior might be implemented. In relationship to our PyList container class that we
</p>
<p>are building, the idea is that each type of graphics command will know how to draw
</p>
<p>itself correctly. For instance, one type of graphics command is the GoToCommand.
</p>
<p>When a GoToCommand is drawn it draws a line on the screen from the current point
</p>
<p>to some new (x,y) coordinate. But, when a CircleCommand is drawn, it draws a circle
</p>
<p>on the screen with a particular radius. This polymorphic behavior can be defined by
</p>
<p>creating a class and draw method for each different type of behavior. The code in
</p>
<p>Sect. 1.12.1 is a collection of classes that define the polymorphic behavior of the
</p>
<p>different graphics draw methods. There is one class for each drawing command that
</p>
<p>will be processed by the program.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.12 Polymorphism 21
</p>
<p>1.12.1 Graphics Command Classes
</p>
<p>1 # Each of the command classes below hold information for one of the
</p>
<p>2 # types of commands found in a graphics file. For each command there must
</p>
<p>3 # be a draw method that is given a turtle and uses the turtle to draw
</p>
<p>4 # the object. By having a draw method for each class, we can
</p>
<p>5 # polymorphically call the right draw method when traversing a sequence of
</p>
<p>6 # these commands. Polymorphism occurs when the "right" draw method gets
</p>
<p>7 # called without having to know which graphics command it is being called on.
</p>
<p>8 class GoToCommand:
</p>
<p>9     # Here the constructor is defined with default values for width and color.
</p>
<p>10     # This means we can construct a GoToCommand objects as GoToCommand(10,20),
</p>
<p>11     # or GoToCommand(10,20,5), or GoToCommand(10,20,5,"yellow").
</p>
<p>12     def __init__(self,x,y,width=1,color="black"):
</p>
<p>13         self.x = x
</p>
<p>14         self.y = y
</p>
<p>15         self.color = color
</p>
<p>16         self.width = width
</p>
<p>17
</p>
<p>18     def draw(self,turtle):
</p>
<p>19         turtle.width(self.width)
</p>
<p>20         turtle.pencolor(self.color)
</p>
<p>21         turtle.goto(self.x,self.y)
</p>
<p>22
</p>
<p>23 class CircleCommand:
</p>
<p>24     def __init__(self,radius, width=1,color="black"):
</p>
<p>25         self.radius = radius
</p>
<p>26         self.width = width
</p>
<p>27         self.color = color
</p>
<p>28
</p>
<p>29     def draw(self,turtle):
</p>
<p>30         turtle.width(self.width)
</p>
<p>31         turtle.pencolor(self.color)
</p>
<p>32         turtle.circle(self.radius)
</p>
<p>33
</p>
<p>34 class BeginFillCommand:
</p>
<p>35     def __init__(self,color):
</p>
<p>36         self.color = color
</p>
<p>37
</p>
<p>38     def draw(self,turtle):
</p>
<p>39         turtle.fillcolor(self.color)
</p>
<p>40         turtle.begin_fill()
</p>
<p>41
</p>
<p>42 class EndFillCommand:
</p>
<p>43     def __init__(self):
</p>
<p>44         # pass is a statement placeholder and does nothing. We have nothing
</p>
<p>45         # to initialize in this class because all we want is the polymorphic
</p>
<p>46         # behavior of the draw method.
</p>
<p>47         pass
</p>
<p>48
</p>
<p>49     def draw(self,turtle):
</p>
<p>50         turtle.end_fill()
</p>
<p>51
</p>
<p>52 class PenUpCommand:
</p>
<p>53     def __init__(self):
</p>
<p>54         pass
</p>
<p>55
</p>
<p>56     def draw(self,turtle):
</p>
<p>57         turtle.penup()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>22 1 Python Programming 101
</p>
<p>58
</p>
<p>59 class PenDownCommand:
</p>
<p>60     def __init__(self):
</p>
<p>61         pass
</p>
<p>62
</p>
<p>63     def draw(self,turtle):
</p>
<p>64         turtle.pendown()
</p>
<p>1.13 The Accumulator Pattern
</p>
<p>To use the different command classes that we have just defined, our program will
</p>
<p>read the variable length records from the file as it did before using the loop and a half
</p>
<p>pattern that we have already seen. Patterns of programming, sometimes called idioms,
</p>
<p>are important in Computer Science. Once we have learned an idiom we can apply it
</p>
<p>over and over in our programs. This is useful to us because as we solve problems its
</p>
<p>nice to say, &ldquo;Oh, yes, I can solve this problem using that idiom&rdquo;. Having idioms at
</p>
<p>our fingertips frees our minds to deal with the tougher problems we encounter while
</p>
<p>programming.
</p>
<p>One important pattern in programming is the Accumulator Pattern. This pattern
</p>
<p>is used in nearly every program we write. When using this pattern you initialize an
</p>
<p>accumulator before a loop and then inside the loop you add to the accumulator. For
</p>
<p>instance, the code in Sect. 1.13.1 uses the accumulator pattern to construct the list of
</p>
<p>squares from 1 to 10.
</p>
<p>1.13.1 List of Squares
</p>
<p>1 # initialize the accumulator, in this case a list
</p>
<p>2 accumulator = []
</p>
<p>3
</p>
<p>4 # write some kind of for loop or while loop
</p>
<p>5 for i in range(1,11):
</p>
<p>6     # add to the accumulator, in this case add to the list
</p>
<p>7     accumulator = accumulator + [i ** 2]
</p>
<p>To complete our graphics program, we&rsquo;ll use the loop and a half pattern to
</p>
<p>read the records from a file and the accumulator pattern to add a command object
</p>
<p>to our PyList container for each record we find in the file. The code is given in
</p>
<p>Sect. 1.13.2.
</p>
<p>1.13.2 A Graphics Program
</p>
<p>1 import turtle
</p>
<p>2
</p>
<p>3 # Command classes would be inserted here but are left out because they
</p>
<p>4 # were defined earlier in the chapter.
</p>
<p>5
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.13 The Accumulator Pattern 23
</p>
<p>6 # This is our PyList class. It holds a list of our graphics
</p>
<p>7 # commands.
</p>
<p>8
</p>
<p>9 class PyList:
</p>
<p>10     def __init__(self):
</p>
<p>11         self.items = []
</p>
<p>12
</p>
<p>13     def append(self,item):
</p>
<p>14         self.items = self.items + [item]
</p>
<p>15
</p>
<p>16     # if we want to iterate over this sequence, we define the special method
</p>
<p>17     # called __iter__(self). Without this we&rsquo;ll get "builtins.TypeError:
</p>
<p>18     # &rsquo;PyList&rsquo; object is not iterable" if we try to write
</p>
<p>19     # for cmd in seq:
</p>
<p>20     # where seq is one of these sequences. The yield below will yield an
</p>
<p>21     # element of the sequence and will suspend the execution of the for
</p>
<p>22     # loop in the method below until the next element is needed. The ability
</p>
<p>23     # to yield each element of the sequence as needed is called "lazy" evaluation
</p>
<p>24     # and is very powerful. It means that we only need to provide access to as
</p>
<p>25     # many of elements of the sequence as are necessary and no more.
</p>
<p>26     def __iter__(self):
</p>
<p>27         for c in self.items:
</p>
<p>28             yield c
</p>
<p>29
</p>
<p>30 def main():
</p>
<p>31     filename = input("Please enter drawing filename: ")
</p>
<p>32
</p>
<p>33     t = turtle.Turtle()
</p>
<p>34     screen = t.getscreen()
</p>
<p>35     file = open(filename, "r")
</p>
<p>36
</p>
<p>37     # Create a PyList to hold the graphics commands that are
</p>
<p>38     # read from the file.
</p>
<p>39     graphicsCommands = PyList()
</p>
<p>40
</p>
<p>41     command = file.readline().strip()
</p>
<p>42
</p>
<p>43     while command != "":
</p>
<p>44
</p>
<p>45         # Now we must read the rest of the record and then process it. Because
</p>
<p>46         # records are variable length, we&rsquo;ll use an if-elif to determine which
</p>
<p>47         # type of record it is and then we&rsquo;ll read and process the record.
</p>
<p>48         # In this program, processing the record means creating a command object
</p>
<p>49         # using one of the classes above and then adding that object to our
</p>
<p>50         # graphicsCommands PyList object.
</p>
<p>51
</p>
<p>52         if command == "goto":
</p>
<p>53             x = float(file.readline())
</p>
<p>54             y = float(file.readline())
</p>
<p>55             width = float(file.readline())
</p>
<p>56             color = file.readline().strip()
</p>
<p>57             cmd = GoToCommand(x,y,width,color)
</p>
<p>58
</p>
<p>59         elif command == "circle":
</p>
<p>60             radius = float(file.readline())
</p>
<p>61             width = float(file.readline())
</p>
<p>62             color = file.readline().strip()
</p>
<p>63             cmd = CircleCommand(radius,width,color)
</p>
<p>64
</p>
<p>65         elif command == "beginfill":
</p>
<p>66             color = file.readline().strip()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>24 1 Python Programming 101
</p>
<p>67             cmd = BeginFillCommand(color)
</p>
<p>68
</p>
<p>69         elif command == "endfill":
</p>
<p>70             cmd = EndFillCommand()
</p>
<p>71
</p>
<p>72         elif command == "penup":
</p>
<p>73             cmd = PenUpCommand()
</p>
<p>74
</p>
<p>75         elif command == "pendown":
</p>
<p>76             cmd = PenDownCommand()
</p>
<p>77         else:
</p>
<p>78             # raising an exception will terminate the program immediately
</p>
<p>79             # which is what we want to happen if we encounter an unknown
</p>
<p>80             # command. The RuntimeError exception is a common exception
</p>
<p>81             # to raise. The string will be printed when the exception is
</p>
<p>82             # printed.
</p>
<p>83             raise RuntimeError("Unknown Command: " + command)
</p>
<p>84
</p>
<p>85         # Finish processing the record by adding the command to the sequence.
</p>
<p>86         graphicsCommands.append(cmd)
</p>
<p>87
</p>
<p>88         # Read one more line to set up for the next time through the loop.
</p>
<p>89         command = file.readline().strip()
</p>
<p>90
</p>
<p>91     # This code iterates through the commands to do the drawing and
</p>
<p>92     # demonstrates the use of the __iter(self)__ method in the
</p>
<p>93     # PyList class above.
</p>
<p>94     for cmd in graphicsCommands:
</p>
<p>95         cmd.draw(t)
</p>
<p>96
</p>
<p>97     file.close()
</p>
<p>98     t.ht()
</p>
<p>99     screen.exitonclick()
</p>
<p>100     print("Program Execution Completed.")
</p>
<p>101
</p>
<p>102 if __name__ == "__main__":
</p>
<p>103     main()
</p>
<p>1.14 Implementing a GUI with Tkinter
</p>
<p>The word GUI means Graphical User Interface. Implementing a Graphical User
</p>
<p>Interface in Python is very easy using a module called Tkinter. The Tcl/Tk language
</p>
<p>and toolkit was designed as a cross-platform method of creating GUI interfaces.
</p>
<p>Python provides an interface to this toolkit via the Tkinter module.
</p>
<p>A GUI is an event-driven program. This means that you write your code to respond
</p>
<p>to events that occur in the program. The events occur as a result of mouse clicks,
</p>
<p>dragging the mouse, button presses, and menu items being selected.
</p>
<p>To build a GUI you place widgets in a window. Widgets are any element of a GUI
</p>
<p>like labels, buttons, entry boxes, and sometimes invisible widgets called frames. A
</p>
<p>frame is a widget that can hold other widgets. The drawing application you see in
</p>
<p>Fig. 1.6 is one such GUI built with Tkinter. In this section we&rsquo;ll develop this drawing
</p>
<p>application so you learn how to create your own GUI applications using Tkinter and
</p>
<p>to improve or refresh your Python programming skills.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.14 Implementing a GUI with Tkinter 25
</p>
<p>Fig. 1.6 The Draw Program
</p>
<p>To construct a GUI you need to create a window. It is really very simple to do this
</p>
<p>using Tkinter.
</p>
<p>root = tkinter.Tk()
</p>
<p>This creates an empty window on the screen, but of course does not put anything
</p>
<p>in it. We need to place widgets in it so it looks like the window in Fig. 1.6 (without
</p>
<p>the nice picture that Denise drew for us; thanks Denise!). We also need to create
</p>
<p>event handlers to handle events in the drawing application.
</p>
<p>Putting widgets in a window is called layout. Laying out a window relies on a
</p>
<p>layout manager of some sort. Windowing toolkits support some kind of layout. In
</p>
<p>Tkinter you either pack, grid, or place widgets within a window. When you pack
</p>
<p>widgets it&rsquo;s like packing a suitcase and each widget is stacked either beside or below
</p>
<p>the previous widget packed in the GUI. Packing widgets will give you the desired
</p>
<p>layout in most situations, but at times a grid may be useful for laying out a window.
</p>
<p>The place layout manager lets you place widgets at a particular location within a
</p>
<p>window. We&rsquo;ll use the pack layout manager to layout our drawing application.
</p>
<p>When packing widgets, to get the proper layout, sometimes you need to create
</p>
<p>a Frame widget. Frame widgets hold other widgets. In Fig. 1.7 two frame widgets
</p>
<p>have been created. The DrawingApplication frame is the size of the whole window
</p>
<p>and holds just two widgets that are placed side by side within it: the canvas and the
</p>
<p>sideBar frame. A canvas is a widget on which a turtle can draw. The sideBar widget
</p>
<p>holds all the buttons, entry boxes, and labels.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>26 1 Python Programming 101
</p>
<p>Fig. 1.7 The Draw Program Layout
</p>
<p>The DrawingApplication frame inherits from Frame. When programming in
</p>
<p>an object-oriented language, sometimes you want to implement a class, but it is
</p>
<p>almost like another class. In this case, the DrawingApplication is a Frame. This
</p>
<p>means there are two parts to DrawingApplication objects, the Frame part of the
</p>
<p>DrawingApplication and the rest of it, which in this case is the PyList sequence of
</p>
<p>graphics commands. Our frame will keep track of the graphics commands that are
</p>
<p>used to draw the picture on the canvas. Portions of the code appear in Sect. 1.14.1.
</p>
<p>The code in Sect. 1.14.1 shows you all the widgets that are created and how they are
</p>
<p>packed within the window.
</p>
<p>The canvas and the sideBar widgets are added side by side to the Drawing
</p>
<p>Application frame. Then all the entry, label, and button widgets are added to the
</p>
<p>sideBar frame.
</p>
<p>In addition, there is a menu with the Draw application. The menu is another
</p>
<p>widget that is added to the window (called self.master in the code in Sect. 1.14.1).
</p>
<p>The fileMenu is what appears on the menu bar. The menu items &ldquo;New&rdquo;, &ldquo;Load...&rdquo;,
</p>
<p>&ldquo;Load Into...&rdquo;, &ldquo;Save As...&rdquo;, and &ldquo;Exit&rdquo; are all added to this menu. Each menu item
</p>
<p>is linked to an event handler that is executed when it is selected.
</p>
<p>When theTurtle object is created in Sect. 1.14.1, it is created as a RawTurtle. A
</p>
<p>RawTurtle is just like a turtle except that a RawTurtle can be provided a canvas to
</p>
<p>draw on. A Turtle object creates its own canvas when the first turtle is created. Since
</p>
<p>we already have a canvas for the turtle, we create a RawTurtle object.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.14 Implementing a GUI with Tkinter 27
</p>
<p>In addition to the event handlers for the widgets, there are three other event han-
</p>
<p>dlers. The onclick event occurs when you click the mouse button on the canvas. The
</p>
<p>ondrag event handler occurs when the turtle is dragged around the canvas. Finally,
</p>
<p>the undoHandler is called when the u key is pressed on the keyboard.
</p>
<p>1.14.1 A GUI Drawing Application
</p>
<p>1 # This class defines the drawing application. The following line says that
</p>
<p>2 # the DrawingApplication class inherits from the Frame class. This means
</p>
<p>3 # that a DrawingApplication is like a Frame object except for the code
</p>
<p>4 # written here which redefines/extends the behavior of a Frame.
</p>
<p>5 class DrawingApplication(tkinter.Frame):
</p>
<p>6     def __init__(self, master=None):
</p>
<p>7         super().__init__(master)
</p>
<p>8         self.pack()
</p>
<p>9         self.buildWindow()
</p>
<p>10         self.graphicsCommands = PyList()
</p>
<p>11
</p>
<p>12     # This method is called to create all the widgets, place them in the GUI,
</p>
<p>13     # and define the event handlers for the application.
</p>
<p>14     def buildWindow(self):
</p>
<p>15
</p>
<p>16         # The master is the root window. The title is set as below.
</p>
<p>17         self.master.title("Draw")
</p>
<p>18
</p>
<p>19         # Here is how to create a menu bar. The tearoff=0 means that menus
</p>
<p>20         # can&rsquo;t be separated from the window which is a feature of tkinter.
</p>
<p>21         bar = tkinter.Menu(self.master)
</p>
<p>22         fileMenu = tkinter.Menu(bar,tearoff=0)
</p>
<p>23
</p>
<p>24         # This code is called by the "New" menu item below when it is selected.
</p>
<p>25         # The same applies for loadFile, addToFile, and saveFile below. The
</p>
<p>26         # "Exit" menu item below calls quit on the "master" or root window.
</p>
<p>27         def newWindow():
</p>
<p>28             # This sets up the turtle to be ready for a new picture to be
</p>
<p>29             # drawn. It also sets the sequence back to empty. It is necessary
</p>
<p>30             # for the graphicsCommands sequence to be in the object (i.e.
</p>
<p>31             # self.graphicsCommands) because otherwise the statement:
</p>
<p>32             # graphicsCommands = PyList()
</p>
<p>33             # would make this variable a local variable in the newWindow
</p>
<p>34             # method. If it were local, it would not be set anymore once the
</p>
<p>35             # newWindow method returned.
</p>
<p>36             theTurtle.clear()
</p>
<p>37             theTurtle.penup()
</p>
<p>38             theTurtle.goto(0,0)
</p>
<p>39             theTurtle.pendown()
</p>
<p>40             screen.update()
</p>
<p>41             screen.listen()
</p>
<p>42             self.graphicsCommands = PyList()
</p>
<p>43
</p>
<p>44         fileMenu.add_command(label="New",command=newWindow)
</p>
<p>45
</p>
<p>46         # The parse function adds the contents of an XML file to the sequence.
</p>
<p>47         def parse(filename):
</p>
<p>48             xmldoc = xml.dom.minidom.parse(filename)
</p>
<p>49
</p>
<p>50             graphicsCommandsElement = xmldoc.getElementsByTagName("GraphicsCommands")[0]
</p>
<p>51
</p>
<p>52             graphicsCommands = graphicsCommandsElement.getElementsByTagName("Command")
</p>
<p>53
</p>
<p>54             for commandElement in graphicsCommands:
</p>
<p>55                 print(type(commandElement))
</p>
<p>56                 command = commandElement.firstChild.data.strip()
</p>
<p>57                 attr = commandElement.attributes
</p>
<p>58                 if command == "GoTo":
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>28 1 Python Programming 101
</p>
<p>59                     x = float(attr["x"].value)
</p>
<p>60                     y = float(attr["y"].value)
</p>
<p>61                     width = float(attr["width"].value)
</p>
<p>62                     color = attr["color"].value.strip()
</p>
<p>63                     cmd = GoToCommand(x,y,width,color)
</p>
<p>64
</p>
<p>65                 elif command == "Circle":
</p>
<p>66                     radius = float(attr["radius"].value)
</p>
<p>67                     width = float(attr["width"].value)
</p>
<p>68                     color = attr["color"].value.strip()
</p>
<p>69                     cmd = CircleCommand(radius,width,color)
</p>
<p>70
</p>
<p>71                 elif command == "BeginFill":
</p>
<p>72                     color = attr["color"].value.strip()
</p>
<p>73                     cmd = BeginFillCommand(color)
</p>
<p>74
</p>
<p>75                 elif command == "EndFill":
</p>
<p>76                     cmd = EndFillCommand()
</p>
<p>77
</p>
<p>78                 elif command == "PenUp":
</p>
<p>79                     cmd = PenUpCommand()
</p>
<p>80
</p>
<p>81                 elif command == "PenDown":
</p>
<p>82                     cmd = PenDownCommand()
</p>
<p>83                 else:
</p>
<p>84                     raise RuntimeError("Unknown Command: " + command)
</p>
<p>85
</p>
<p>86                 self.graphicsCommands.append(cmd)
</p>
<p>87
</p>
<p>88         def loadFile():
</p>
<p>89
</p>
<p>90             filename = tkinter.filedialog.askopenfilename(title="Select a Graphics File")
</p>
<p>91
</p>
<p>92             newWindow()
</p>
<p>93
</p>
<p>94             # This re-initializes the sequence for the new picture.
</p>
<p>95             self.graphicsCommands = PyList()
</p>
<p>96
</p>
<p>97             # calling parse will read the graphics commands from the file.
</p>
<p>98             parse(filename)
</p>
<p>99
</p>
<p>100             for cmd in self.graphicsCommands:
</p>
<p>101                 cmd.draw(theTurtle)
</p>
<p>102
</p>
<p>103             # This line is necessary to update the window after the picture is drawn.
</p>
<p>104             screen.update()
</p>
<p>105
</p>
<p>106
</p>
<p>107         fileMenu.add_command(label="Load...",command=loadFile)
</p>
<p>108
</p>
<p>109         def addToFile():
</p>
<p>110             filename = tkinter.filedialog.askopenfilename(title="Select a Graphics File")
</p>
<p>111
</p>
<p>112             theTurtle.penup()
</p>
<p>113             theTurtle.goto(0,0)
</p>
<p>114             theTurtle.pendown()
</p>
<p>115             theTurtle.pencolor("#000000")
</p>
<p>116             theTurtle.fillcolor("#000000")
</p>
<p>117             cmd = PenUpCommand()
</p>
<p>118             self.graphicsCommands.append(cmd)
</p>
<p>119             cmd = GoToCommand(0,0,1,"#000000")
</p>
<p>120             self.graphicsCommands.append(cmd)
</p>
<p>121             cmd = PenDownCommand()
</p>
<p>122             self.graphicsCommands.append(cmd)
</p>
<p>123             screen.update()
</p>
<p>124             parse(filename)
</p>
<p>125
</p>
<p>126             for cmd in self.graphicsCommands:
</p>
<p>127                 cmd.draw(theTurtle)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.14 Implementing a GUI with Tkinter 29
</p>
<p>128
</p>
<p>129             screen.update()
</p>
<p>130
</p>
<p>131         fileMenu.add_command(label="Load Into...",command=addToFile)
</p>
<p>132
</p>
<p>133         # The write function writes an XML file to the given filename
</p>
<p>134         def write(filename):
</p>
<p>135             file = open(filename, "w")
</p>
<p>136             file.write(&rsquo;&lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;\n&rsquo;)
</p>
<p>137             file.write(&rsquo;&lt;GraphicsCommands&gt;\n&rsquo;)
</p>
<p>138             for cmd in self.graphicsCommands:
</p>
<p>139                 file.write(&rsquo;    &rsquo;+str(cmd)+"\n")
</p>
<p>140
</p>
<p>141             file.write(&rsquo;&lt;/GraphicsCommands&gt;\n&rsquo;)
</p>
<p>142
</p>
<p>143             file.close()
</p>
<p>144
</p>
<p>145         def saveFile():
</p>
<p>146             filename = tkinter.filedialog.asksaveasfilename(title="Save Picture As...")
</p>
<p>147             write(filename)
</p>
<p>148
</p>
<p>149         fileMenu.add_command(label="Save As...",command=saveFile)
</p>
<p>150
</p>
<p>151
</p>
<p>152         fileMenu.add_command(label="Exit",command=self.master.quit)
</p>
<p>153
</p>
<p>154         bar.add_cascade(label="File",menu=fileMenu)
</p>
<p>155
</p>
<p>156         # This tells the root window to display the newly created menu bar.
</p>
<p>157         self.master.config(menu=bar)
</p>
<p>158
</p>
<p>159         # Here several widgets are created. The canvas is the drawing area on
</p>
<p>160         # the left side of the window.
</p>
<p>161         canvas = tkinter.Canvas(self,width=600,height=600)
</p>
<p>162         canvas.pack(side=tkinter.LEFT)
</p>
<p>163
</p>
<p>164         # By creating a RawTurtle, we can have the turtle draw on this canvas.
</p>
<p>165         # Otherwise, a RawTurtle and a Turtle are exactly the same.
</p>
<p>166         theTurtle = turtle.RawTurtle(canvas)
</p>
<p>167
</p>
<p>168         # This makes the shape of the turtle a circle.
</p>
<p>169         theTurtle.shape("circle")
</p>
<p>170         screen = theTurtle.getscreen()
</p>
<p>171
</p>
<p>172         # This causes the application to not update the screen unless
</p>
<p>173         # screen.update() is called. This is necessary for the ondrag event
</p>
<p>174         # handler below. Without it, the program bombs after dragging the
</p>
<p>175         # turtle around for a while.
</p>
<p>176         screen.tracer(0)
</p>
<p>177
</p>
<p>178         # This is the area on the right side of the window where all the
</p>
<p>179         # buttons, labels, and entry boxes are located. The pad creates some empty
</p>
<p>180         # space around the side. The side puts the sideBar on the right side of the
</p>
<p>181         # this frame. The fill tells it to fill in all space available on the right
</p>
<p>182         # side.
</p>
<p>183         sideBar = tkinter.Frame(self,padx=5,pady=5)
</p>
<p>184         sideBar.pack(side=tkinter.RIGHT, fill=tkinter.BOTH)
</p>
<p>185
</p>
<p>186         # This is a label widget. Packing it puts it at the top of the sidebar.
</p>
<p>187         pointLabel = tkinter.Label(sideBar,text="Width")
</p>
<p>188         pointLabel.pack()
</p>
<p>189
</p>
<p>190         # This entry widget allows the user to pick a width for their lines.
</p>
<p>191         # With the widthSize variable below you can write widthSize.get() to get
</p>
<p>192         # the contents of the entry widget and widthSize.set(val) to set the value
</p>
<p>193         # of the entry widget to val. Initially the widthSize is set to 1. str(1) is
</p>
<p>194         # needed because the entry widget must be given a string.
</p>
<p>195         widthSize = tkinter.StringVar()
</p>
<p>196         widthEntry = tkinter.Entry(sideBar,textvariable=widthSize)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>30 1 Python Programming 101
</p>
<p>197         widthEntry.pack()
</p>
<p>198         widthSize.set(str(1))
</p>
<p>199
</p>
<p>200         radiusLabel = tkinter.Label(sideBar,text="Radius")
</p>
<p>201         radiusLabel.pack()
</p>
<p>202         radiusSize = tkinter.StringVar()
</p>
<p>203         radiusEntry = tkinter.Entry(sideBar,textvariable=radiusSize)
</p>
<p>204         radiusSize.set(str(10))
</p>
<p>205         radiusEntry.pack()
</p>
<p>206
</p>
<p>207         # A button widget calls an event handler when it is pressed. The circleHandler
</p>
<p>208         # function below is the event handler when the Draw Circle button is pressed.
</p>
<p>209         def circleHandler():
</p>
<p>210             # When drawing, a command is created and then the command is drawn by calling
</p>
<p>211             # the draw method. Adding the command to the graphicsCommands sequence means the
</p>
<p>212             # application will remember the picture.
</p>
<p>213             cmd = CircleCommand(float(radiusSize.get()), float(widthSize.get()), penColor.get())
</p>
<p>214             cmd.draw(theTurtle)
</p>
<p>215             self.graphicsCommands.append(cmd)
</p>
<p>216
</p>
<p>217             # These two lines are needed to update the screen and to put the focus back
</p>
<p>218             # in the drawing canvas. This is necessary because when pressing "u" to undo,
</p>
<p>219             # the screen must have focus to receive the key press.
</p>
<p>220             screen.update()
</p>
<p>221             screen.listen()
</p>
<p>222
</p>
<p>223         # This creates the button widget in the sideBar. The fill=tkinter.BOTH causes the button
</p>
<p>224         # to expand to fill the entire width of the sideBar.
</p>
<p>225         circleButton = tkinter.Button(sideBar, text = "Draw Circle", command=circleHandler)
</p>
<p>226         circleButton.pack(fill=tkinter.BOTH)
</p>
<p>227
</p>
<p>228         # The color mode 255 below allows colors to be specified in RGB form (i.e. Red/
</p>
<p>229         # Green/Blue). The mode allows the Red value to be set by a two digit hexadecimal
</p>
<p>230         # number ranging from 00-FF. The same applies for Blue and Green values. The
</p>
<p>231         # color choosers below return a string representing the selected color and a slice
</p>
<p>232         # is taken to extract the #RRGGBB hexadecimal string that the color choosers return.
</p>
<p>233         screen.colormode(255)
</p>
<p>234         penLabel = tkinter.Label(sideBar,text="Pen Color")
</p>
<p>235         penLabel.pack()
</p>
<p>236         penColor = tkinter.StringVar()
</p>
<p>237         penEntry = tkinter.Entry(sideBar,textvariable=penColor)
</p>
<p>238         penEntry.pack()
</p>
<p>239         # This is the color black.
</p>
<p>240         penColor.set("#000000")
</p>
<p>241
</p>
<p>242         def getPenColor():
</p>
<p>243             color = tkinter.colorchooser.askcolor()
</p>
<p>244             if color != None:
</p>
<p>245                 penColor.set(str(color)[-9:-2])
</p>
<p>246
</p>
<p>247         penColorButton = tkinter.Button(sideBar, text = "Pick Pen Color", command=getPenColor)
</p>
<p>248         penColorButton.pack(fill=tkinter.BOTH)
</p>
<p>249
</p>
<p>250         fillLabel = tkinter.Label(sideBar,text="Fill Color")
</p>
<p>251         fillLabel.pack()
</p>
<p>252         fillColor = tkinter.StringVar()
</p>
<p>253         fillEntry = tkinter.Entry(sideBar,textvariable=fillColor)
</p>
<p>254         fillEntry.pack()
</p>
<p>255         fillColor.set("#000000")
</p>
<p>256
</p>
<p>257         def getFillColor():
</p>
<p>258             color = tkinter.colorchooser.askcolor()
</p>
<p>259             if color != None:
</p>
<p>260                 fillColor.set(str(color)[-9:-2])
</p>
<p>261
</p>
<p>262         fillColorButton = \
</p>
<p>263             tkinter.Button(sideBar, text = "Pick Fill Color", command=getFillColor)
</p>
<p>264         fillColorButton.pack(fill=tkinter.BOTH)
</p>
<p>265
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.14 Implementing a GUI with Tkinter 31
</p>
<p>266
</p>
<p>267         def beginFillHandler():
</p>
<p>268             cmd = BeginFillCommand(fillColor.get())
</p>
<p>269             cmd.draw(theTurtle)
</p>
<p>270             self.graphicsCommands.append(cmd)
</p>
<p>271
</p>
<p>272         beginFillButton = tkinter.Button(sideBar, text = "Begin Fill", command=beginFillHandler)
</p>
<p>273         beginFillButton.pack(fill=tkinter.BOTH)
</p>
<p>274
</p>
<p>275         def endFillHandler():
</p>
<p>276             cmd = EndFillCommand()
</p>
<p>277             cmd.draw(theTurtle)
</p>
<p>278             self.graphicsCommands.append(cmd)
</p>
<p>279
</p>
<p>280         endFillButton = tkinter.Button(sideBar, text = "End Fill", command=endFillHandler)
</p>
<p>281         endFillButton.pack(fill=tkinter.BOTH)
</p>
<p>282
</p>
<p>283         penLabel = tkinter.Label(sideBar,text="Pen Is Down")
</p>
<p>284         penLabel.pack()
</p>
<p>285
</p>
<p>286         def penUpHandler():
</p>
<p>287             cmd = PenUpCommand()
</p>
<p>288             cmd.draw(theTurtle)
</p>
<p>289             penLabel.configure(text="Pen Is Up")
</p>
<p>290             self.graphicsCommands.append(cmd)
</p>
<p>291
</p>
<p>292         penUpButton = tkinter.Button(sideBar, text = "Pen Up", command=penUpHandler)
</p>
<p>293         penUpButton.pack(fill=tkinter.BOTH)
</p>
<p>294
</p>
<p>295         def penDownHandler():
</p>
<p>296             cmd = PenDownCommand()
</p>
<p>297             cmd.draw(theTurtle)
</p>
<p>298             penLabel.configure(text="Pen Is Down")
</p>
<p>299             self.graphicsCommands.append(cmd)
</p>
<p>300
</p>
<p>301         penDownButton = tkinter.Button(sideBar, text = "Pen Down", command=penDownHandler)
</p>
<p>302         penDownButton.pack(fill=tkinter.BOTH)
</p>
<p>303
</p>
<p>304         # Here is another event handler. This one handles mouse clicks on the screen.
</p>
<p>305         def clickHandler(x,y):
</p>
<p>306             # When a mouse click occurs, get the widthSize entry value and set the width of the
</p>
<p>307             # pen to the widthSize value. The float(widthSize.get()) is needed because
</p>
<p>308             # the width is a float, but the entry widget stores it as a string.
</p>
<p>309             cmd = GoToCommand(x,y,float(widthSize.get()),penColor.get())
</p>
<p>310             cmd.draw(theTurtle)
</p>
<p>311             self.graphicsCommands.append(cmd)
</p>
<p>312             screen.update()
</p>
<p>313             screen.listen()
</p>
<p>314
</p>
<p>315         # Here is how we tie the clickHandler to mouse clicks.
</p>
<p>316         screen.onclick(clickHandler)
</p>
<p>317
</p>
<p>318         def dragHandler(x,y):
</p>
<p>319             cmd = GoToCommand(x,y,float(widthSize.get()),penColor.get())
</p>
<p>320             cmd.draw(theTurtle)
</p>
<p>321             self.graphicsCommands.append(cmd)
</p>
<p>322             screen.update()
</p>
<p>323             screen.listen()
</p>
<p>324
</p>
<p>325         theTurtle.ondrag(dragHandler)
</p>
<p>326
</p>
<p>327         # the undoHandler undoes the last command by removing it from the
</p>
<p>328         # sequence and then redrawing the entire picture.
</p>
<p>329         def undoHandler():
</p>
<p>330             if len(self.graphicsCommands) &gt; 0:
</p>
<p>331                 self.graphicsCommands.removeLast()
</p>
<p>332                 theTurtle.clear()
</p>
<p>333                 theTurtle.penup()
</p>
<p>334                 theTurtle.goto(0,0)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>32 1 Python Programming 101
</p>
<p>335                 theTurtle.pendown()
</p>
<p>336                 for cmd in self.graphicsCommands:
</p>
<p>337                     cmd.draw(theTurtle)
</p>
<p>338                 screen.update()
</p>
<p>339                 screen.listen()
</p>
<p>340
</p>
<p>341         screen.onkeypress(undoHandler, "u")
</p>
<p>342         screen.listen()
</p>
<p>343
</p>
<p>344 # The main function in our GUI program is very simple. It creates the
</p>
<p>345 # root window. Then it creates the DrawingApplication frame which creates
</p>
<p>346 # all the widgets and has the logic for the event handlers. Calling mainloop
</p>
<p>347 # on the frames makes it start listening for events. The mainloop function will
</p>
<p>348 # return when the application is exited.
</p>
<p>349 def main():
</p>
<p>350     root = tkinter.Tk()
</p>
<p>351     drawingApp = DrawingApplication(root)
</p>
<p>352
</p>
<p>353     drawingApp.mainloop()
</p>
<p>354     print("Program Execution Completed.")
</p>
<p>355
</p>
<p>356 if __name__ == "__main__":
</p>
<p>357     main()
</p>
<p>1.15 XML Files
</p>
<p>Reading a standard text file, like the graphics commands file we read using the loop
</p>
<p>and a half pattern in Sect. 1.13.2, is a common task in computer programs. The only
</p>
<p>problem is that the program must be written to read the specific format of the input
</p>
<p>file. If we later wish to change the format of the input file to include, for example,
</p>
<p>a new option like fill color for a circle, then we are stuck updating the program and
</p>
<p>updating all the files it once read. The input file format and the program must always
</p>
<p>be synchronized. This means that all old formatted input files must be converted to
</p>
<p>the new format or they must be thrown away. That is simply not acceptable to most
</p>
<p>businesses because data is valuable.
</p>
<p>To deal with this problem, computer programmers designed a language for
</p>
<p>describing data input files called XML which stands for eXtensible Markup Lan-
</p>
<p>guage. XML is a meta-language for data description. A meta-language is a language
</p>
<p>for describing other languages. The XML meta-language is universally accepted.
</p>
<p>In fact, the XML format is governed by a standards committee, which means that
</p>
<p>we can count on the XML format remaining very stable and backwards compatible
</p>
<p>forever. Any additions to XML will have to be compatible with what has already
</p>
<p>been defined.
</p>
<p>An XML document begins with a special line to identify it as an XML file. This
</p>
<p>line looks like this.
</p>
<p>&lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;
</p>
<p>The rest of an XML file consists of elements or nodes. Each node is identified by
</p>
<p>a tag or a pair of beginning and ending tags. Each tag is delimited (i.e. surrounded)
</p>
<p>by angle brackets. For instance, here is one such tag.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.15 XML Files 33
</p>
<p>&lt;GraphicsCommands&gt;
</p>
<p>Most XML elements are delimited by a opening tag and a closing tag. The tag
</p>
<p>above is an opening tag. Its matching closing tag looks like this.
</p>
<p>&lt;/GraphicsCommands&gt;
</p>
<p>The slash just before the tag name means that it is a closing tag. An opening and
</p>
<p>closing tag may have text or other XML elements in between the two tags so XML
</p>
<p>documents may contain XML elements nested as deeply as necessary depending on
</p>
<p>the data you are trying to encode.
</p>
<p>Each XML element may have attributes associated with it. For instance, consider
</p>
<p>an XML element that encapsulates the information needed to do a GoTo graphics
</p>
<p>command. To complete a GoTo command we need the x and y coordinates, the width
</p>
<p>of the line, and the pen color. Here is an example of encoding that information in
</p>
<p>XML format.
</p>
<p>&lt;Command x="1.0" y="1.0" width="1.0" color="#000000"&gt;GoTo&lt;/Command&gt;
</p>
<p>In this example the attributes are x, y, width, and color. Each attribute is mapped to
</p>
<p>its value as shown above. The GoTo text is the text that appears between the opening
</p>
<p>and closing tags. That text is sometimes called the child data.
</p>
<p>By encoding an entire graphics commands input file in XML format we eliminate
</p>
<p>some of the dependence between the Draw program and its data. Except for the
</p>
<p>XML format (i.e. the grammar) the contents of the XML file are completely up to
</p>
<p>the programmer or programmers using the data. The file in Sect. 1.15.1 is an example
</p>
<p>of the truck picture&rsquo;s XML input file.
</p>
<p>1.15.1 The Truck XML File
</p>
<p>1 &lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;
</p>
<p>2 &lt;GraphicsCommands&gt;
</p>
<p>3     &lt;Command color="black"&gt;BeginFill&lt;/Command&gt;
</p>
<p>4     &lt;Command radius="20.0" width="1" color="black"&gt;Circle&lt;/Command&gt;
</p>
<p>5     &lt;Command&gt;EndFill&lt;/Command&gt;
</p>
<p>6     &lt;Command&gt;PenUp&lt;/Command&gt;
</p>
<p>7     &lt;Command x="120.0" y="0.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>8     &lt;Command&gt;PenDown&lt;/Command&gt;
</p>
<p>9     &lt;Command color="black"&gt;BeginFill&lt;/Command&gt;
</p>
<p>10     &lt;Command radius="20.0" width="1" color="black"&gt;Circle&lt;/Command&gt;
</p>
<p>11     &lt;Command&gt;EndFill&lt;/Command&gt;
</p>
<p>12     &lt;Command&gt;PenUp&lt;/Command&gt;
</p>
<p>13     &lt;Command x="150.0" y="40.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>14     &lt;Command&gt;PenDown&lt;/Command&gt;
</p>
<p>15     &lt;Command color="yellow"&gt;BeginFill&lt;/Command&gt;
</p>
<p>16     &lt;Command x="-30.0" y="40.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>17     &lt;Command x="-30.0" y="70.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>18     &lt;Command x="60.0" y="70.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>19     &lt;Command x="60.0" y="100.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>20     &lt;Command x="90.0" y="100.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>34 1 Python Programming 101
</p>
<p>21     &lt;Command x="115.0" y="70.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>22     &lt;Command x="150.0" y="70.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>23     &lt;Command x="150.0" y="40.0" width="1.0" color="black"&gt;GoTo&lt;/Command&gt;
</p>
<p>24     &lt;Command&gt;EndFill&lt;/Command&gt;
</p>
<p>25 &lt;/GraphicsCommands&gt;
</p>
<p>XML files are text files. They just contain extra XML formatted data to help stan-
</p>
<p>dardize how XML files are read. Writing an XML file is as simple as writing a text
</p>
<p>file. While indentation is not necessary in XML files, it is often used to highlight
</p>
<p>the format of the file. In Sect. 1.15.1 the GraphicsCommands element contains one
</p>
<p>Command element for each drawing command in the picture. Each drawing com-
</p>
<p>mand contains the command type as its text. The command types are GoTo, Circle,
</p>
<p>BeginFill, EndFill, PenUp, and PenDown. The attributes of a command are data like
</p>
<p>x, y, width, radius, and color that are used by the various types of commands.
</p>
<p>To write the commands to a file, each of the Command classes can be modified
</p>
<p>to produce an XML element when converted to a string using the special __str__
</p>
<p>method. For instance, Sect. 1.15.2 contains the modified GoToCommand class sup-
</p>
<p>porting the creation of an XML element.
</p>
<p>1.15.2 The GoToCommand with XML Creation Code
</p>
<p>1 # The following classes define the different commands that
</p>
<p>2 # are supported by the drawing application.
</p>
<p>3 class GoToCommand:
</p>
<p>4     def __init__(self,x,y,width=1,color="black"):
</p>
<p>5         self.x = x
</p>
<p>6         self.y = y
</p>
<p>7         self.width = width
</p>
<p>8         self.color = color
</p>
<p>9
</p>
<p>10     # The draw method for each command draws the command
</p>
<p>11     # using the given turtle
</p>
<p>12     def draw(self,turtle):
</p>
<p>13         turtle.width(self.width)
</p>
<p>14         turtle.pencolor(self.color)
</p>
<p>15         turtle.goto(self.x,self.y)
</p>
<p>16
</p>
<p>17     # The __str__ method is a special method that is called
</p>
<p>18     # when a command is converted to a string. The string
</p>
<p>19     # version of the command is how it appears in the graphics
</p>
<p>20     # file format.
</p>
<p>21     def __str__(self):
</p>
<p>22         return &rsquo;&lt;Command x="&rsquo; + str(self.x) + &rsquo;" y="&rsquo; + str(self.y) + &rsquo;" width="&rsquo; +  \
</p>
<p>23                str(self.width) + &rsquo;" color="&rsquo; + self.color + &rsquo;"&gt;GoTo&lt;/Command&gt;&rsquo;
</p>
<p>By returning a string like this from each of the command objects, the code to write
</p>
<p>the draw program&rsquo;s data to a file is very simple. All that is needed is some code that
</p>
<p>writes the xml line as the first line, followed by the &lt;GraphicsCommands&gt; tag and
</p>
<p>the command elements. Finally, the &lt;GraphicsCommands&gt; tag must be written.
</p>
<p>The code in Sect. 1.15.3 accomplishes this.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.15 XML Files 35
</p>
<p>1.15.3 Writing Graphics Commands to an XML File
</p>
<p>1 file = open(filename, "w")
</p>
<p>2 file.write(&rsquo;&lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;\n&rsquo;)
</p>
<p>3 file.write(&rsquo;&lt;GraphicsCommands&gt;\n&rsquo;)
</p>
<p>4 for cmd in self.graphicsCommands:
</p>
<p>5     file.write(&rsquo;    &rsquo;+str(cmd)+"\n")
</p>
<p>6
</p>
<p>7 file.write(&rsquo;&lt;/GraphicsCommands&gt;\n&rsquo;)
</p>
<p>8 file.close()
</p>
<p>Writing an XML file is like writing any text file except that the text file must
</p>
<p>conform to the XML grammar specification. There are certainly ways to create XML
</p>
<p>files that differ from how it was presented in Sect. 1.15.3. In the next section we&rsquo;ll
</p>
<p>learn about XML parsers and a very simple way to read XML documents. It turns
</p>
<p>out there are at least some XML frameworks that make writing an XML document
</p>
<p>just as simple.
</p>
<p>1.16 Reading XML Files
</p>
<p>XML files would be difficult to read if we had to read them like we read a regular text
</p>
<p>file. This is especially true because XML files are not line-oriented. They conform
</p>
<p>to the XML grammar, but the grammar does not specify anything about the lines in
</p>
<p>the file. Instead of reading an XML file by reading lines of the file, we use a special
</p>
<p>tool called a parser. A parser is written according to the rules of a grammar, in
</p>
<p>this case the XML grammar. There are many XML parsers that have been written
</p>
<p>and different parsers have different features. The one we will use in this text is one
</p>
<p>of the simpler parsers called minidom. The minidom parser reads an entire XML
</p>
<p>file by calling the parse method on it. It places the entire contents of an XML file
</p>
<p>into an sequence of Element objects. An Element object contains the child data and
</p>
<p>attributes of an XML element along with any other elements that might be defined
</p>
<p>inside this element.
</p>
<p>To use the minidom parser, you must first import the module where the minidom
</p>
<p>parser is defined.
</p>
<p>import xml.dom.minidom
</p>
<p>Then, you can read an entire XML file by calling the parse method on an XML
</p>
<p>document as follows.
</p>
<p>xmldoc = xml.dom.minidom.parse(filename)
</p>
<p>Once you have done that, you can read a specific type of element from the XML
</p>
<p>file by calling the method getElementsByTagName on it. For instance, to get the
</p>
<p>GraphicsCommands element from the graphics commands XML file, you would
</p>
<p>write this.
</p>
<p>graphicsCommands = xmldoc.getElementsByTagName("GraphicsCommands")[0]
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>36 1 Python Programming 101
</p>
<p>The XML document contains the GraphicsCommands element. Calling getEle-
</p>
<p>mentsByTagName on GraphicsCommands returns a list of all elements that match
</p>
<p>this tag name. Since we know there is only one of these tags in the file, we can
</p>
<p>write [0] to get the first element from the list. Then, the graphicsCommands element
</p>
<p>contains just the one element from the file and all the Command elements of the file
</p>
<p>are located within it. If we want to go through all these elements we can use a for
</p>
<p>loop as in the code in Sect. 1.16.1.
</p>
<p>1.16.1 Using an XML Parser
</p>
<p>1 for commandElement in graphicsCommands:
</p>
<p>2     print(type(commandElement))
</p>
<p>3     command = commandElement.firstChild.data.strip()
</p>
<p>4     attr = commandElement.attributes
</p>
<p>5     if command == "GoTo":
</p>
<p>6         x = float(attr["x"].value)
</p>
<p>7         y = float(attr["y"].value)
</p>
<p>8         width = float(attr["width"].value)
</p>
<p>9         color = attr["color"].value.strip()
</p>
<p>10         cmd = GoToCommand(x,y,width,color)
</p>
<p>11
</p>
<p>12     elif command == "Circle":
</p>
<p>13         radius = float(attr["radius"].value)
</p>
<p>14         width = float(attr["width"].value)
</p>
<p>15         color = attr["color"].value.strip()
</p>
<p>16         cmd = CircleCommand(radius,width,color)
</p>
<p>17
</p>
<p>18     elif command == "BeginFill":
</p>
<p>19         color = attr["color"].value.strip()
</p>
<p>20         cmd = BeginFillCommand(color)
</p>
<p>21
</p>
<p>22     elif command == "EndFill":
</p>
<p>23         cmd = EndFillCommand()
</p>
<p>24
</p>
<p>25     elif command == "PenUp":
</p>
<p>26         cmd = PenUpCommand()
</p>
<p>27
</p>
<p>28     elif command == "PenDown":
</p>
<p>29         cmd = PenDownCommand()
</p>
<p>30     else:
</p>
<p>31         raise RuntimeError("Unknown Command: " + command)
</p>
<p>32
</p>
<p>33     self.append(cmd)
</p>
<p>In the code in Sect. 1.16.1 the attr variable is a dictionary mapping the attribute
</p>
<p>names (i.e. keys) to their associated values. The child data of a Command node can be
</p>
<p>found by looking at the firstChild.data for the node. The strip method is used to strip
</p>
<p>away any unwanted blanks, tabs, or newline characters that might appear in the string.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>1.17 Chapter Summary 37
</p>
<p>1.17 Chapter Summary
</p>
<p>In this first chapter we have covered a large amount of material which should be
</p>
<p>mostly review but probably covered some things that are new to you as well. Don&rsquo;t
</p>
<p>be too overwhelmed by it all. The purpose of this chapter is to get you asking questions
</p>
<p>about the things you don&rsquo;t understand. If you don&rsquo;t understand something, you should
</p>
<p>ask your teacher or someone who knows more about programming in Python. They
</p>
<p>can likely help you. Asking questions is a great way to learn and Computer Science
</p>
<p>is all about a lifetime of learning.
</p>
<p>Here is a list of the important concepts you should have learned in this chapter.
</p>
<p>You should:
</p>
<p>&bull; know how to create an object, both from a literal value and by calling the object&rsquo;s
</p>
<p>constructor explicitly.
</p>
<p>&bull; understand the concept of a reference pointing at a value (i.e. an object) in Python.
</p>
<p>&bull; know how to call a method on an object.
</p>
<p>&bull; know how to import a module.
</p>
<p>&bull; understand the importance of indentation in Python programs.
</p>
<p>&bull; know why you write a main function in Python programs and how to call the main
</p>
<p>function.
</p>
<p>&bull; know how to read records from a file whether they be multi-line, single line, fixed
</p>
<p>length, or variable length records.
</p>
<p>&bull; know how to define a container class like PyList defined in this chapter.
</p>
<p>&bull; understand the concept of polymorphism and how that means an object will do the
</p>
<p>right thing when a method is called.
</p>
<p>&bull; understand the Accumulator pattern and how to use it in a program.
</p>
<p>&bull; know how to implement a simple GUI using Tkinter in Python. Entry boxes, labels,
</p>
<p>buttons, frames, and event handlers should all be concepts that are understood and
</p>
<p>can be programmed by looking back at the examples in this chapter.
</p>
<p>&bull; and finally you should know how to read and write XML files in your programs.
</p>
<p>There is a lot of example code in this chapter and the final version of the Draw
</p>
<p>program is provided on the text&rsquo;s website or in Sect. 20.1. While it is doubtful you
</p>
<p>will be able to memorize each line of the code you found in this chapter, you should
</p>
<p>make sure you know how things work when you look at it and you should remember
</p>
<p>that you can use this chapter as a resource. Come back to it often when you need to
</p>
<p>see how to do something in later chapters. Using this example code as a reference
</p>
<p>will help to answer a lot of your questions in future chapters.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>38 1 Python Programming 101
</p>
<p>1.18 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. What does IDE stand for and why is it a good idea to use an IDE?
</p>
<p>2. What code would you write to create a string containing the words Happy Birth-
</p>
<p>day!? Write some code to point a reference called text at that newly created object.
</p>
<p>3. What code would you write to take the string you created in the last question
</p>
<p>and split it into a list containing two strings? Point the reference lst at this newly
</p>
<p>created list.
</p>
<p>4. What code would you write to upper-case the string created in the second ques-
</p>
<p>tion. Point the reference named bDayWish at this upper-cased string.
</p>
<p>5. If you were to execute the code you wrote for answering the last three questions,
</p>
<p>what would the string referenced by text contain after executing these three lines
</p>
<p>of code?
</p>
<p>6. How would you create a dictionary that maps &ldquo;Kent&rdquo; to &ldquo;Denise&rdquo; and maps
</p>
<p>&ldquo;Steve&rdquo; to &ldquo;Lindy&rdquo;? In these two cases &ldquo;Kent&rdquo; and &ldquo;Steve&rdquo; are the keys and
</p>
<p>&ldquo;Denise&rdquo; and &ldquo;Lindy&rdquo; are the values.
</p>
<p>7. Consult Chap. 17. How would you map a key to a value as in the previous prob-
</p>
<p>lem when the dictionary was first created as an empty dictionary? HINT: This
</p>
<p>would be called setting an item in the documentation in the appendix. Write
</p>
<p>a short piece of code to create an empty dictionary and then map &ldquo;Kent&rdquo; to
</p>
<p>&ldquo;Denise&rdquo; and &ldquo;Steve&rdquo; to &ldquo;Lindy&rdquo;.
</p>
<p>8. What method is called when x &lt; y is written? In which class is the method a
</p>
<p>member? In other words, if you were presented with x &lt; y in a program, how
</p>
<p>would you figure out which class you needed to examine to understand exactly
</p>
<p>what x &lt; y meant?
</p>
<p>9. What method is called when x â‰ª y is written?
</p>
<p>10. What is the loop and a half problem and how is it solved?
</p>
<p>11. Do you need to use the solution to the loop and a half problem to read an XML
</p>
<p>file? Why or why not?
</p>
<p>12. Polymorphism and Operator Overloading are closely related concepts. Can you
</p>
<p>briefly explain how the two concepts are similar and how Python supports them?
</p>
<p>HINT: No is not a valid answer.
</p>
<p>13. What would you write so that a program asks the user to enter an integer and
</p>
<p>then adds up all the even integers from 2 to the integer entered by the user. HINT:
</p>
<p>You might want to review how to use the range function to accomplish this and
</p>
<p>decide on what pattern of programming you might use.
</p>
<p>14. How do you create a window using Tkinter?
</p>
<p>15. What is the purpose of a Frame object in a Tkinter program?
</p>
<p>16. What are three types of widgets in the Tkinter framework?
</p>
<p>17. When reading an XML file, how many lines of code does it take to read the file?
</p>
<p>18. How do you get a single element from an XML document? What line(s) of code
</p>
<p>do you have to write? Provide an example.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_17">http://dx.doi.org/10.1007/978-3-319-13072-9_17</a></div>
</div>
<div class="page"><p/>
<p>1.18 Review Questions 39
</p>
<p>19. When traversing an XML document, how do you get a list of elements from it?
</p>
<p>What line(s) of code do you have to write? Provide an example.
</p>
<p>20. What is an attribute in an XML document and how do you access an attribute&rsquo;s
</p>
<p>value? Provide an example from the text or from another example you find
</p>
<p>online.
</p>
<p>1.19 Programming Problems
</p>
<p>1. Starting with the version of the Draw program that reads an input file with variable
</p>
<p>length records, add a new graphics command of your choice to the program.
</p>
<p>Consider how it would be written to a file, create a test file, write your code,
</p>
<p>and test it. You must design two files: a sample test file, and the program itself.
</p>
<p>Some examples might be a graphics command to draw a star with some number
</p>
<p>of points, a rectangle with a height and width, etc.
</p>
<p>2. Starting with the Draw program provided in Sect. 20.1, extend the program to
</p>
<p>include a new button to draw a new shape for the Draw program. For instance,
</p>
<p>have the draw program draw a star on the screen or a smiley face or something
</p>
<p>of your choosing. HINT: If you use the forward and back methods to draw your
</p>
<p>shape, you can scale it by multiplying each forward and back amount by a scale
</p>
<p>value. Then, you can let the user pick a scale for it (or use the radius amount
</p>
<p>as your scale) and draw your shape in whatever size you like. To complete this
</p>
<p>exercise you must extend your XML format to include a new graphics command
</p>
<p>to store the relevant information for drawing your new shape. You must also
</p>
<p>define a new graphicsCommand class for your new shape.
</p>
<p>3. Add the ability to draw a text string on a Draw picture. You&rsquo;ll need to let the
</p>
<p>user pick a point size. For a real challenge, let the user pick the font type from
</p>
<p>a drop-down list of font types. Draw a string that you have the user enter in an
</p>
<p>entry box.
</p>
<p>4. Find an XML document of your choice on the internet, write code to parse through
</p>
<p>the data and plot something from that data whether it be some value over time or
</p>
<p>something else. Use turtle graphics to plot the data that you find.
</p>
<p>5. Add a new button to the drawing program presented in Sect. 20.1 that draws a
</p>
<p>rainbow centered above the current location of the turtle. This can be done quite
</p>
<p>easily by using sin and cos (i.e. sine and cosine). The sin and cos functions take
</p>
<p>radians as a parameter. To draw a rainbow, the radians would range from 0 to
</p>
<p>math.pi from the math module. You must import the math module to get access
</p>
<p>to math.cos and math.sin as well as math.pi. To draw values in an arc, you can use
</p>
<p>a for loop and let a variable, i, range from 0 to 100. Then radius * math.cos(i/100.0
</p>
<p>* math.pi), radius * math.sin(i/100.0 * math.pi) is the next x,y coordinate of the
</p>
<p>rainbow&rsquo;s arc. By varying the radius you will get several stripes for your rainbow.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>40 1 Python Programming 101
</p>
<p>Each stripe should have a different color. To vary the color, you might convert a
</p>
<p>24-bit number to hex. To convert a number to hexadecimal in Python you can use
</p>
<p>the hex function. You must make sure that your color string is 6 digits long and
</p>
<p>starts with a pound sign (i.e. #) for it to be a valid color string in Python.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2Computational Complexity
</p>
<p>In the last chapter we developed a drawing program. To hold the drawing commands
</p>
<p>we built the PyList container class which is a lot like the built-in Python list class,
</p>
<p>but helps illustrate our first data structure. When we added a drawing command to
</p>
<p>the sequence we called the append method. It turns out that this method is called
</p>
<p>a lot. In fact, the flower picture in the first chapter took around 700 commands to
</p>
<p>draw. You can imagine that a complex picture with lots of free-hand drawing could
</p>
<p>contain thousands of drawing commands. When creating a free-hand drawing we
</p>
<p>want to append the next drawing command to the sequence quickly because there
</p>
<p>are so many commands being appended. How long does it take to append a drawing
</p>
<p>command to the sequence? Can we make a guess? Should we care about the exact
</p>
<p>amount of time?
</p>
<p>In this chapter you&rsquo;ll learn how to answer these questions and you&rsquo;ll learn what
</p>
<p>questions are important for you as a computer programmer. First you&rsquo;ll read about
</p>
<p>some principles of computer architecture to understand something about how long
</p>
<p>it takes a computer to do some simple operations. With that knowledge you&rsquo;ll have
</p>
<p>the tools you&rsquo;ll need to make informed decisions about how much time it might take
</p>
<p>to execute some code you have written.
</p>
<p>2.1 Chapter Goals
</p>
<p>By the end of this chapter you should be able to answer these questions.
</p>
<p>&bull; What are some of the primitive operations that a computer can perform?
</p>
<p>&bull; How much time does it take to perform these primitive operations?
</p>
<p>&bull; What does the term computational complexity mean?
</p>
<p>&bull; Why do we care about computational complexity?
</p>
<p>&bull; When do we need to be concerned about the complexity of a piece of code?
</p>
<p>&bull; What can we do to improve the efficiency of a piece of code?
</p>
<p>&bull; What is the definition of Big-Oh notation?
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_2
</p>
<p>41
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>42 2 Computational Complexity
</p>
<p>&bull; What is the definition of Theta notation?
</p>
<p>&bull; What is amortized complexity and what is its importance?
</p>
<p>&bull; How can we apply what we learned to make the PyList container class better?
</p>
<p>2.2 Computer Architecture
</p>
<p>A computer consists of a Central Processing Unit (i.e. the CPU) that interacts with
</p>
<p>Input/Output (i.e. I/O) devices like a keyboard, mouse, display, and network interface.
</p>
<p>When you run a program it is first read from a storage device like a hard drive into the
</p>
<p>Random Access Memory, or RAM, of the computer. RAM loses its contents when
</p>
<p>the power is shut off, so copies of programs are only stored in RAM while they are
</p>
<p>running. The permanent copy of a program is stored on the hard drive or some other
</p>
<p>permanent storage device.
</p>
<p>The RAM of a computer holds a program as it is executing and also holds data that
</p>
<p>the program is manipulating. While a program is running, the CPU reads input from
</p>
<p>the input devices and stores data values in the RAM. The CPU also contains a very
</p>
<p>limited amount of memory, usually called registers. When an operation is performed
</p>
<p>by the CPU, such as adding two numbers together, the operands must be in registers in
</p>
<p>the CPU. Typical operations that are performed by the CPU are addition, subtraction,
</p>
<p>multiplication, division, and storing and retrieving values from the RAM.
</p>
<p>2.2.1 Running a Program
</p>
<p>When a user runs a program on a computer, the following actions occur:
</p>
<p>1. The program is read from the disk or other storage device into RAM.
</p>
<p>2. The operating system (typically Mac OS X, Microsoft Windows, or Linux) sets
</p>
<p>up two more areas of RAM called the run-time stack and the heap for use by the
</p>
<p>program.
</p>
<p>3. The operating system starts the program executing by telling the CPU to start
</p>
<p>executing the first instruction of the computer.
</p>
<p>4. The program reads data from the keyboard, mouse, disk, and other input sources.
</p>
<p>5. Each instruction of the program retrieves small pieces of data from RAM, acts
</p>
<p>on them, and writes new data back to RAM.
</p>
<p>6. Once the data is processed the result is provided as output on the screen or some
</p>
<p>other output device.
</p>
<p>Because there is so little memory in the CPU, the normal mode of operation is to
</p>
<p>store values in the RAM until they are needed for a CPU operation. The RAM is a
</p>
<p>much bigger storage space than the CPU. But, because it is bigger, it is also slower
</p>
<p>than the CPU. Storing a value in RAM or retrieving a value from RAM can take as
</p>
<p>much time as several CPU operations. When needed, the values are copied from the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.2 Computer Architecture 43
</p>
<p>Fig. 2.1 Conceptual View of a Computer
</p>
<p>RAM into the CPU, the operation is performed, and the result is then typically written
</p>
<p>back into the RAM. The RAM of a computer is accessed frequently as a program
</p>
<p>runs, so it is important that we understand what happens when it is accessed (Fig. 2.1).
</p>
<p>One analogy that is often used is that of a post office. The RAM of a computer is
</p>
<p>like a collection of post office boxes. Each box has an address and can hold a value.
</p>
<p>The values you can put in RAM are called bytes (i.e. eight bits grouped together).
</p>
<p>With eight bits, 256 different values can be stored. Usually bytes are interpreted as
</p>
<p>integers, so a byte can hold values from 0 to 255. If we want to store bigger values,
</p>
<p>we can group bytes together into words. The word size of a computer is either 32 bits
</p>
<p>(i.e. four bytes) or 64 bits, depending on the architecture of the computer&rsquo;s hardware.
</p>
<p>All modern computer hardware is capable of retrieving or storing a word at a time.
</p>
<p>The post office box analogy helps us to visualize how the RAM of a computer
</p>
<p>is organized, but the analogy does not serve well to show us how the RAM of a
</p>
<p>computer behaves. If we were going to get something from a post office box, or store
</p>
<p>something in a post office box, there would have to be some kind of search done to
</p>
<p>find the post office box first. Then the letter or letters could be placed in it or taken
</p>
<p>from it. The more post office boxes in the post office, the longer that search would
</p>
<p>take. This helps us understand the fundamental problem we study in this text. As the
</p>
<p>size of a problem space grows, how does a program or algorithm behave? In terms
</p>
<p>of this analogy, as the number of post office boxes grows, how much longer does it
</p>
<p>take to store or retrieve a value?
</p>
<p>The RAM of a computer does not behave like a post office. The computer does
</p>
<p>not need to find the right RAM location before the it can retrieve or store a value. A
</p>
<p>much better analogy is a group of people, each person representing a memory location
</p>
<p>within the RAM of the computer. Each person is assigned an address or name. To
</p>
<p>store a value in a location, you call out the name of the person and then tell them
</p>
<p>what value to remember. It does not take any time to find the right person because all
</p>
<p>the people are listening, just in case their name is called. To retrieve a value, you call
</p>
<p>the name of the person and they tell you the value they were told to remember. In this
</p>
<p>way it takes exactly the same amount of time to retrieve any value from any memory
</p>
<p>location. This is how the RAM of a computer works. It takes exactly the same amount
</p>
<p>of time to store a value in any location within the RAM. Likewise, retrieving a value
</p>
<p>takes the same amount of time whether it is in the first RAM location or the last.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>44 2 Computational Complexity
</p>
<p>2.3 Accessing Elements in a Python List
</p>
<p>With experimentation we can verify that all locations within the RAM of a computer
</p>
<p>can be accessed in the same amount of time. A Python list is a collection of contiguous
</p>
<p>memory locations. The word contiguous means that the memory locations of a list
</p>
<p>are grouped together consecutively in RAM. If we want to verify that the RAM of
</p>
<p>a computer behaves like a group of people all remembering their names and their
</p>
<p>values, we can run some tests with Python lists of different sizes to find the average
</p>
<p>time to retrieve from or store a value into a random element of the list.
</p>
<p>To test the behavior of Python lists we can write a program that randomly stores
</p>
<p>and retrieves values in a list. We can test two different theories in this program.
</p>
<p>1. The size of a list does not affect the average access time in the list.
</p>
<p>2. The average access time at any location within a list is the same, regardless of its
</p>
<p>location within the list.
</p>
<p>To test these two theories, we&rsquo;ll need to time retrieval and storing of values within
</p>
<p>a list. Thankfully, Python includes a datetime module that can be used to record the
</p>
<p>current time. By subtracting two datetime objects we can compute the number of
</p>
<p>microseconds (i.e. millionths of a second) for any operation within a program. The
</p>
<p>program in Sect. 2.3.1 was written to test list access and record the access time for
</p>
<p>retrieving values and storing values in a Python list.
</p>
<p>2.3.1 List Access Timing
</p>
<p>1 import datetime
</p>
<p>2 import random
</p>
<p>3 import time
</p>
<p>4
</p>
<p>5 def main():
</p>
<p>6
</p>
<p>7     # Write an XML file with the results
</p>
<p>8     file = open("ListAccessTiming.xml","w")
</p>
<p>9
</p>
<p>10     file.write(&rsquo;&lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;\n&rsquo;)
</p>
<p>11
</p>
<p>12     file.write(&rsquo;&lt;Plot title="Average List Element Access Time"&gt;\n&rsquo;)
</p>
<p>13
</p>
<p>14     # Test lists of size 1000 to 200000.
</p>
<p>15     xmin = 1000
</p>
<p>16     xmax = 200000
</p>
<p>17
</p>
<p>18     # Record the list sizes in xList and the average access time within
</p>
<p>19     # a list that size in yList for 1000 retrievals.
</p>
<p>20     xList = []
</p>
<p>21     yList = []
</p>
<p>22
</p>
<p>23     for x in range(xmin, xmax+1, 1000):
</p>
<p>24
</p>
<p>25         xList.append(x)
</p>
<p>26
</p>
<p>27         prod = 0
</p>
<p>28
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.3 Accessing Elements in a Python List 45
</p>
<p>29         # Creates a list of size x with all 0&rsquo;s
</p>
<p>30         lst = [0] * x
</p>
<p>31
</p>
<p>32         # let any garbage collection/memory allocation complete or at least
</p>
<p>33         # settle down
</p>
<p>34         time.sleep(1)
</p>
<p>35
</p>
<p>36         # Time before the 1000 test retrievals
</p>
<p>37         starttime = datetime.datetime.now()
</p>
<p>38
</p>
<p>39         for v in range(1000):
</p>
<p>40             # Find a random location within the list
</p>
<p>41             # and retrieve a value. Do a dummy operation
</p>
<p>42             # with that value to ensure it is really retrieved.
</p>
<p>43             index = random.randint(0,x-1)
</p>
<p>44             val = lst[index]
</p>
<p>45             prod = prod * val
</p>
<p>46         # Time after the 1000 test retrievals
</p>
<p>47         endtime = datetime.datetime.now()
</p>
<p>48
</p>
<p>49         # The difference in time between start and end.
</p>
<p>50         deltaT = endtime - starttime
</p>
<p>51
</p>
<p>52         # Divide by 1000 for the average access time
</p>
<p>53         # But also multiply by 1000000 for microseconds.
</p>
<p>54         accessTime = deltaT.total_seconds() * 1000
</p>
<p>55
</p>
<p>56         yList.append(accessTime)
</p>
<p>57
</p>
<p>58     file.write(&rsquo;  &lt;Axes&gt;\n&rsquo;)
</p>
<p>59     file.write(&rsquo;    &lt;XAxis min="&rsquo;+str(xmin)+&rsquo;" max="&rsquo;+str(xmax)+&rsquo;"&gt;List Size&lt;/XAxis&gt;\n&rsquo;)
</p>
<p>60     file.write(&rsquo;    &lt;YAxis min="&rsquo;+str(min(yList))+&rsquo;" max="&rsquo;+str(60)+&rsquo;"&gt;Microseconds&lt;/YAxis&gt;\n&rsquo;)
</p>
<p>61     file.write(&rsquo;  &lt;/Axes&gt;\n&rsquo;)
</p>
<p>62
</p>
<p>63     file.write(&rsquo;  &lt;Sequence title="Average Access Time vs List Size" color="red"&gt;\n&rsquo;)
</p>
<p>64
</p>
<p>65     for i in range(len(xList)):
</p>
<p>66         file.write(&rsquo;    &lt;DataPoint x="&rsquo;+str(xList[i])+&rsquo;" y="&rsquo;+str(yList[i])+&rsquo;"/&gt;\n&rsquo;)
</p>
<p>67
</p>
<p>68     file.write(&rsquo;  &lt;/Sequence&gt;\n&rsquo;)
</p>
<p>69
</p>
<p>70     # This part of the program tests access at 100 random locations within a list
</p>
<p>71     # of 200,000 elements to see that all the locations can be accessed in
</p>
<p>72     # about the same amount of time.
</p>
<p>73     xList = lst
</p>
<p>74     yList = [0] * 200000
</p>
<p>75
</p>
<p>76     time.sleep(2)
</p>
<p>77
</p>
<p>78     for i in range(100):
</p>
<p>79         starttime = datetime.datetime.now()
</p>
<p>80         index = random.randint(0,200000-1)
</p>
<p>81         xList[index] = xList[index] + 1
</p>
<p>82         endtime = datetime.datetime.now()
</p>
<p>83         deltaT = endtime - starttime
</p>
<p>84         yList[index] = yList[index] + deltaT.total_seconds() * 1000000
</p>
<p>85
</p>
<p>86     file.write(&rsquo;  &lt;Sequence title="Access Time Distribution" color="blue"&gt;\n&rsquo;)
</p>
<p>87
</p>
<p>88     for i in range(len(xList)):
</p>
<p>89         if xList[i] &gt; 0:
</p>
<p>90             file.write(&rsquo;    &lt;DataPoint x="&rsquo;+str(i)+&rsquo;" y="&rsquo;+str(yList[i]/xList[i])+&rsquo;"/&gt;\n&rsquo;)
</p>
<p>91
</p>
<p>92     file.write(&rsquo;  &lt;/Sequence&gt;\n&rsquo;)
</p>
<p>93     file.write(&rsquo;&lt;/Plot&gt;\n&rsquo;)
</p>
<p>94     file.close()
</p>
<p>1 if __name__ == "__main__":
</p>
<p>2     main()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>46 2 Computational Complexity
</p>
<p>When running a program like this the times that you get will depend not only
</p>
<p>on the actual operations being performed, but the times will also depend on what
</p>
<p>other activity is occurring on the computer where the test is being run. All modern
</p>
<p>operating systems, like Mac OS X, Linux, or Microsoft Windows, are multi-tasking.
</p>
<p>This means the operating system can switch between tasks so that we can get email
</p>
<p>while writing a computer program, for instance. When we time something we will not
</p>
<p>only see the effects of our own program running, but all programs that are currently
</p>
<p>running on the computer. It is nearly impossible to completely isolate one program in
</p>
<p>a multi-tasking system. However, most of the time a short program will run without
</p>
<p>too much interruption.
</p>
<p>The program in Sect. 2.3.1 writes an XML file with its results. The XML file format
</p>
<p>supports the description of experimentally collected data for a two dimensional plot
</p>
<p>of one or more sequences of data. One sample of the data that this program generates
</p>
<p>looks like Sect. 2.3.2. The data is abbreviated, but the format is as shown in Sect. 2.3.2.
</p>
<p>2.3.2 A Plot XML Sample
</p>
<p>1 &lt;?xml version="1.0" encoding="UTF-8" standalone="no" ?&gt;
</p>
<p>2 &lt;Plot title="Average List Element Access Time"&gt;
</p>
<p>3   &lt;Axes&gt;
</p>
<p>4     &lt;XAxis min="1000" max="200000"&gt;List Size&lt;/XAxis&gt;
</p>
<p>5     &lt;YAxis min="20.244" max="60"&gt;Microseconds&lt;/YAxis&gt;
</p>
<p>6   &lt;/Axes&gt;
</p>
<p>7   &lt;Sequence title="Average Access Time vs List Size" color="red"&gt;
</p>
<p>8     &lt;DataPoint x="1000" y="33.069"/&gt;
</p>
<p>9     &lt;DataPoint x="2000" y="27.842"/&gt;
</p>
<p>10     &lt;DataPoint x="3000" y="23.908"/&gt;
</p>
<p>11     &lt;DataPoint x="4000" y="26.349"/&gt;
</p>
<p>12     &lt;DataPoint x="5000" y="23.212"/&gt;
</p>
<p>13     &lt;DataPoint x="6000" y="23.765"/&gt;
</p>
<p>14     &lt;DataPoint x="7000" y="21.251"/&gt;
</p>
<p>15     &lt;DataPoint x="8000" y="21.321"/&gt;
</p>
<p>16     &lt;DataPoint x="9000" y="23.197"/&gt;
</p>
<p>17     &lt;DataPoint x="10000" y="21.527"/&gt;
</p>
<p>18     &lt;DataPoint x="11000" y="35.799"/&gt;
</p>
<p>19     &lt;DataPoint x="12000" y="22.173"/&gt;
</p>
<p>20     ...
</p>
<p>21     &lt;DataPoint x="197000" y="26.245"/&gt;
</p>
<p>22     &lt;DataPoint x="198000" y="30.013"/&gt;
</p>
<p>23     &lt;DataPoint x="199000" y="25.888"/&gt;
</p>
<p>24     &lt;DataPoint x="200000" y="23.578"/&gt;
</p>
<p>25   &lt;/Sequence&gt;
</p>
<p>26   &lt;Sequence title="Access Time Distribution" color="blue"&gt;
</p>
<p>27     &lt;DataPoint x="219" y="41.0"/&gt;
</p>
<p>28     &lt;DataPoint x="2839" y="38.0"/&gt;
</p>
<p>29     &lt;DataPoint x="5902" y="38.0"/&gt;
</p>
<p>30     &lt;DataPoint x="8531" y="58.0"/&gt;
</p>
<p>31     &lt;DataPoint x="11491" y="38.0"/&gt;
</p>
<p>32     &lt;DataPoint x="15415" y="38.0"/&gt;
</p>
<p>33     &lt;DataPoint x="17645" y="31.0"/&gt;
</p>
<p>34     &lt;DataPoint x="18658" y="38.0"/&gt;
</p>
<p>35     &lt;DataPoint x="20266" y="40.0"/&gt;
</p>
<p>36     &lt;DataPoint x="21854" y="31.0"/&gt;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.3 Accessing Elements in a Python List 47
</p>
<p>37     ...
</p>
<p>38     &lt;DataPoint x="197159" y="37.0"/&gt;
</p>
<p>39     &lt;DataPoint x="199601" y="40.0"/&gt;
</p>
<p>40   &lt;/Sequence&gt;
</p>
<p>41 &lt;/Plot&gt;
</p>
<p>Since we&rsquo;ll be taking a look at quite a bit of experimental data in this text, we
</p>
<p>have written a Tkinter program that will read an XML file with the format given in
</p>
<p>Sect. 2.3.2 and plot the sequences to the screen. The PlotData.py program is given
</p>
<p>in Chap. 20.4.
</p>
<p>If we use the program to plot the data gathered by the list access experiment, we
</p>
<p>see a graph like the one in Fig. 2.2. This graph provides the experimental data to back
</p>
<p>up the two statements we made earlier about lists in Python. The red line shows the
</p>
<p>average element access time of 1,000 element accesses on a list of the given size. The
</p>
<p>average access time (computed from a sample of 1,000 random list accesses) is no
</p>
<p>longer on a list of 10,000 than it is on a list of 160,000. While the exact values are not
</p>
<p>printed in the graph, the exact values are not important. What we would be interested
</p>
<p>in seeing is any trend toward longer or shorter average access times. Clearly the only
</p>
<p>trend is that the size of the list does not affect the average access time. There are
</p>
<p>some ups and downs in the experimental data, but this is caused by the system being
</p>
<p>Fig. 2.2 Access Times in a Python List
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>48 2 Computational Complexity
</p>
<p>a multi-tasking system. Another factor is likely the caching of memory locations. A
</p>
<p>cache is a way of speeding up access to memory in some situations and it is likely
</p>
<p>that the really low access times benefited from the existence of a cache for the RAM
</p>
<p>of the computer. The experimental data backs up the claim that the size of a list does
</p>
<p>not affect the average access time in the list.
</p>
<p>The blue line in the plot is the result of doing 100 list retrieval and store operations
</p>
<p>on one list of 200,000 elements. The reason the blue line is higher than the red line is
</p>
<p>likely the result of doing both a retrieval from and a store operation into the element
</p>
<p>of the list. In addition, the further apart the values in memory, the less likely a cache
</p>
<p>will help reduce the access time. Whatever the reason for the blue line being higher
</p>
<p>the important thing to notice is that accessing the element at index 0 takes no more
</p>
<p>time than accessing any other element of the sequence. All locations within the list
</p>
<p>are treated equally. This backs up the claim that the average access time at any
</p>
<p>location within a list is the same, regardless of its location within the list.
</p>
<p>2.4 Big-Oh Notation
</p>
<p>Whichever line we look at in the experimental data, the access time never exceeds
</p>
<p>100&micro;s for any of the memory accesses, even with the other things the computer might
</p>
<p>be doing. We are safe concluding that accessing memory takes less than 100&micro;s. In
</p>
<p>fact, 100&micro;s is much more time than is needed to access or store a value in a memory
</p>
<p>location. Our experimental data backs up the two claims we made earlier. However,
</p>
<p>technically, it does not prove our claim that accessing memory takes a constant
</p>
<p>amount of time. The architecture of the RAM in a computer could be examined to
</p>
<p>prove that accessing any memory location takes a constant amount of time. Accessing
</p>
<p>memory is just like calling out a name in a group of people and having that person
</p>
<p>respond with the value they were assigned. It doesn&rsquo;t matter which person&rsquo;s name is
</p>
<p>called out. The response time will be the same, or nearly the same. The actual time
</p>
<p>to access the RAM of a computer may vary a little bit if a cache is available, but at
</p>
<p>least we can say that there is an upper bound to how much time accessing a memory
</p>
<p>location will take.
</p>
<p>This idea of an upper bound can be stated more formally. The formal statement
</p>
<p>of an upper bound is called Big-Oh notation. The Big-Oh refers to the Greek letter
</p>
<p>Omicron which is typically used when talking about upper bounds. As computer
</p>
<p>programmers, our number one concern is how our programs will perform when we
</p>
<p>have large amounts of data. In terms of the memory of a computer, we wanted to
</p>
<p>know how our program would perform if we have a very large list of elements. We
</p>
<p>found that all elements of a list are accessed in the same amount of time independent
</p>
<p>of how big this list is. Let&rsquo;s represent the size of the list by a variable called n. Let
</p>
<p>the average access time for accessing an element of a list of size n be given by f (n).
</p>
<p>Now we can state the following.
</p>
<p>O(g(n)) = { f | &exist;d &gt; 0, n0 &isin; Z
+ &ni; 0 &le; f (n) &le; d g(n),&forall;n &ge; n0}
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.4 Big-Oh Notation 49
</p>
<p>In English this reads as follows: The class of functions designated by O(g(n)) consists
</p>
<p>of all functions f, where there exists a d greater than 0 and an n0 (a positive integer)
</p>
<p>such that 0 is less than or equal to f(n) is less than or equal to d times g(n) for all n
</p>
<p>greater than or equal to n0.
</p>
<p>If f is an element of O(g(n)), we say that f(n) is O(g(n)). The function g is called
</p>
<p>an asymptotic upper bound for f in this case. You may not be comfortable with the
</p>
<p>mathematical description above. Stated in English the set named O(g(n)) consists
</p>
<p>of the set of all functions, f(n), that have an upper bound of d*g(n), as n approaches
</p>
<p>infinity. This is the meaning of the word asymptotic. The idea of an asymptotic bound
</p>
<p>means that for some small values of n the value of f(n) might be bigger than the value
</p>
<p>of d*g(n), but once n gets big enough (i.e. bigger than n0), then for all bigger n it
</p>
<p>will always be true that f(n) is less than d*g(n). This idea of an asymptotic upper
</p>
<p>bound is pictured in Fig. 2.3. For some smaller values the function&rsquo;s performance,
</p>
<p>shown in green, may be worse than the blue upper bound line, but eventually the
</p>
<p>upper bound is bigger for all larger values of n.
</p>
<p>We have seen that the average time to access an element in a list is constant and
</p>
<p>does not depend on the list size. In the example in Fig. 2.2, the list size is the n in
</p>
<p>the definition and the average time to access an element in a list of size n is the f(n).
</p>
<p>Fig. 2.3 An Upper Bound
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>50 2 Computational Complexity
</p>
<p>Because the time to access an element does not depend on n, we can pick g(n) = 1.
</p>
<p>So, we say that the average time to access an element in a list of size n is O(1). If
</p>
<p>we assume it never takes longer than 100&micro;s to access an element of a list in Python,
</p>
<p>then a good choice for d would be 100. According to the definition above then it
</p>
<p>must be the case that f(n) is less than or equal to 100 once n gets big enough.
</p>
<p>The choice of g(n) = 1 is arbitrary in computing the complexity of accessing an
</p>
<p>element of a list. We could have chosen g(n) = 2. If g(n) = 2 were chosen, d might
</p>
<p>be chosen to be 50 instead of 100. But, since we are only concerned with the overall
</p>
<p>growth in the function g, the choice of 1 or 2 is irrelevant and the simplest function
</p>
<p>is chosen, in this case O(1). In English, when an operation or program is O(1), we
</p>
<p>say it is a constant time operation or program. This means the operation does not
</p>
<p>depend on the size of n.
</p>
<p>It turns out that most operations that a computer can perform are O(1). For instance,
</p>
<p>adding two numbers together is a O(1) operation. So is multiplication of two numbers.
</p>
<p>While both operations require several cycles in a computer, the total number of
</p>
<p>cycles does not depend on the size of the integers or floating point numbers being
</p>
<p>added or multiplied. A cycle is simply a unit of time in a computer. Comparing two
</p>
<p>values is also a constant time operation. When computing complexity, any arithmetic
</p>
<p>calculation or comparison can be considered a constant time operation.
</p>
<p>This idea of computational complexity is especially important when the com-
</p>
<p>plexity of a piece of code depends on n. In the next section we&rsquo;ll see some code that
</p>
<p>depends on the size of the list it is working with and how important it is that we
</p>
<p>understand the implications of how we write even a small piece of code.
</p>
<p>2.5 The PyList Append Operation
</p>
<p>We have established that accessing a memory location or storing a value in a memory
</p>
<p>location is a O(1), or constant time, operation. The same goes for accessing an element
</p>
<p>of a list or storing a value in a list. The size of the list does not change the time needed
</p>
<p>to access or store an element and there is a fixed upper bound for the amount of time
</p>
<p>needed to access or store a value in memory or in a list.
</p>
<p>With this knowledge, let&rsquo;s look at the drawing program again and specifically
</p>
<p>at the piece of code that appends graphics commands to the PyList. This code is
</p>
<p>used a lot in the program. Every time a new graphics command is created, it is
</p>
<p>appended to the sequence. When the user is doing some free-hand drawing, hundreds
</p>
<p>of graphics commands are getting appended every minute or so. Since free-hand
</p>
<p>drawing is somewhat compute intensive, we want this code to be as efficient as
</p>
<p>possible.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.5 The PyList Append Operation 51
</p>
<p>2.5.1 Inefficient Append
</p>
<p>1 class PyList:
</p>
<p>2     def __init__(self):
</p>
<p>3         self.items = []
</p>
<p>4
</p>
<p>5     # The append method is used to add commands to the sequence.
</p>
<p>6     def append(self,item):
</p>
<p>7         self.items = self.items + [item]
</p>
<p>8
</p>
<p>9     ...
</p>
<p>The code in Sect. 2.5.1 appends a new item to the list as follows:
</p>
<p>1. The item is made into a list by putting [and] around it. We should be careful about
</p>
<p>how we say this. The item itself is not changed. A new list is constructed from
</p>
<p>the item.
</p>
<p>2. The two lists are concatenated together using the + operator. The + operator is
</p>
<p>an accessor method that does not change either original list. The concatenation
</p>
<p>creates a new list from the elements in the two lists.
</p>
<p>3. The assignment of self.items to this new list updates the PyList object so it now
</p>
<p>refers to the new list.
</p>
<p>The question we want to ask is, how does this append method perform as the size
</p>
<p>of the PyList grows? Let&rsquo;s consider the first time that the append method is called.
</p>
<p>How many elements are in the list that is referenced by self.items? Zero, right? And
</p>
<p>there is always one element in [item]. So the append method must access one element
</p>
<p>of a list to form the new list, which also has one element in it.
</p>
<p>What happens the second time the append method is called? This time, there is one
</p>
<p>element in the list referenced by self.items and again one element in [item]. Now, two
</p>
<p>elements must be accessed to form the new list. The next time append is called three
</p>
<p>elements must be accessed to form the new list. Of course, this pattern continues for
</p>
<p>each new element that is appended to the PyList. When the nth element is appended
</p>
<p>to the sequence there will have to be n elements copied to form the new list. Overall,
</p>
<p>how many elements must be accessed to append n elements?
</p>
<p>2.6 A Proof by Induction
</p>
<p>We have already established that accessing each element of a list takes a constant
</p>
<p>amount of time. So, if we want to calculate the amount of time it takes to append n
</p>
<p>elements to the PyList we would have to add up all the list accesses and multiply by
</p>
<p>the amount of time it takes to access a list element plus the time it takes to store a
</p>
<p>list element. To count the total number of access and store operations we must start
</p>
<p>with the number of access and store operations for copying the list the first time an
</p>
<p>element is appended. That&rsquo;s one element copied. The second append requires two
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>52 2 Computational Complexity
</p>
<p>copy operations. The third append requires three copy operations. So, we have the
</p>
<p>following number of list elements being copied.
</p>
<p>1 + 2 + 3 + 4 + &middot; &middot; &middot; + n =
</p>
<p>n
&sum;
</p>
<p>i=1
</p>
<p>i
</p>
<p>In mathematics we can express this sum with a summation symbol (i.e.
&sum;
</p>
<p>). This is
</p>
<p>the mathematical way of expressing the sum of the first n integers. But, what is this
</p>
<p>equal to? It turns out with a little work, we can find that the following is true.
</p>
<p>n
&sum;
</p>
<p>i=1
</p>
<p>i =
n(n + 1)
</p>
<p>2
</p>
<p>We can prove this is true using a proof technique from Mathematics called mathe-
</p>
<p>matical induction. There are a couple of variations of mathematical induction. We&rsquo;ll
</p>
<p>use what is called weak induction to prove this. When proving something using
</p>
<p>induction you are really constructing a meta-proof. A meta-proof is a set of steps
</p>
<p>that you can repeat over and over again to find your desired result. The power of
</p>
<p>induction is that once we have constructed the meta-proof, we have proved that the
</p>
<p>result is true for all possible values of n.
</p>
<p>We want to prove that the formula given above is valid for all n. To do this we
</p>
<p>first show it is true for a simple value of n. In our case we&rsquo;ll pick 1 as our value of
</p>
<p>n. In that case we have the following.
</p>
<p>1
&sum;
</p>
<p>i=1
</p>
<p>i = 1 =
1(1 + 1)
</p>
<p>2
</p>
<p>This is surely true. This step is called the base case of the inductive proof. Every
</p>
<p>proof by induction must have a base case and it is usually trivial.
</p>
<p>The next step is to create the meta-proof. This meta-proof is called the inductive
</p>
<p>case. When forming the inductive case we get to assume that the formula holds for all
</p>
<p>values, m, where m is less than n. This is called strong induction. In weak induction we
</p>
<p>get to assume that the formula is valid for n&minus;1 and we want to show that it is valid for
</p>
<p>n. We&rsquo;ll use weak induction in this problem to finish our proof. Again, this step helps
</p>
<p>us form a set of steps that we can apply over and over again to get from our base case
</p>
<p>to whatever value of n we need to find. To begin we will make note of the following.
</p>
<p>n
&sum;
</p>
<p>i=1
</p>
<p>i =
</p>
<p>(n&minus;1
&sum;
</p>
<p>i=1
</p>
<p>i
</p>
<p>)
</p>
<p>+ n
</p>
<p>This is true by the definition of summation. But now we have a sum that goes to n&minus;1
</p>
<p>and weak induction says that we know the equation is valid for n &minus; 1 . This is called
</p>
<p>the inductive hypothesis. Since it holds for n &minus; 1 we know the following is true.
</p>
<p>We get this by substituting n &minus; 1 everyplace that we see an n in the original formula.
</p>
<p>n&minus;1
&sum;
</p>
<p>i=1
</p>
<p>i =
(n &minus; 1)n
</p>
<p>2
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.6 A Proof by Induction 53
</p>
<p>Now we can use this fact in proving the equality of our original formula. Here we go!
</p>
<p>n
&sum;
</p>
<p>i=1
</p>
<p>i =
</p>
<p>(n&minus;1
&sum;
</p>
<p>i=1
</p>
<p>i
</p>
<p>)
</p>
<p>+ n =
n(n &minus; 1)
</p>
<p>2
+ n =
</p>
<p>n(n &minus; 1)
</p>
<p>2
+
</p>
<p>2n
</p>
<p>2
=
</p>
<p>n2 &minus; n + 2n
</p>
<p>2
=
</p>
<p>n2 + n
</p>
<p>2
=
</p>
<p>n(n + 1)
</p>
<p>2
</p>
<p>If you look at the left side and all the way over at the right side of this formula you
</p>
<p>can see the two things that we set out to prove were equal are indeed equal. This
</p>
<p>concludes our proof by induction. The meta-proof is in the formula above. It is a
</p>
<p>template that we could use to prove that the equality holds for n = 2. To prove the
</p>
<p>equality holds for n = 2 we needed to use the fact that the equality holds for n = 1.
</p>
<p>This was our base case. Once we have proved that it holds for n = 2 we could use
</p>
<p>that same formula to prove that the equality holds for n = 3. Mathematical induction
</p>
<p>doesn&rsquo;t require us to go through all the steps. As long as we&rsquo;ve created this meta-proof
</p>
<p>we have proved that the equality holds for all n. That&rsquo;s the power of induction.
</p>
<p>2.7 Making the PyList Append Efficient
</p>
<p>Now, going back to our original problem, we wanted to find out how much time it
</p>
<p>takes to append n items to a PyList. It turns out, using the append method in Sect. 2.5.1,
</p>
<p>it will perform in O(n2) time. This is because the first time we called append we had
</p>
<p>to copy one element of the list. The second time we needed to copy two elements. The
</p>
<p>third time append was called we needed to copy three elements. Our proof in Sect. 2.6
</p>
<p>is that 1 + 2 + 3 + &middot; &middot; &middot; + n equals n*(n + 1)/2. The highest powered term in
</p>
<p>this formula is the n2 term. Therefore, the append method in Sect. 2.5.1 exhibits
</p>
<p>O(n2) complexity. This is not really a good result. The red curve in the graph of
</p>
<p>Fig. 2.4 shows the actual results of how much time it takes to append 200,000 ele-
</p>
<p>ments to a PyList. The line looks somewhat like the graph of f(n) = n2. What this
</p>
<p>tells us is that if we were to draw a complex program with say 100,000 graphics com-
</p>
<p>mands in it, to add one more command to the sequence it would take around 27 s.
</p>
<p>This is unacceptable! We may never draw anything that complex, but a computer
</p>
<p>should be able to add one more graphic command quicker than that!
</p>
<p>In terms of big-Oh notation we say that the append method is O(n2). When n gets
</p>
<p>large, programs or functions with O(n2) complexity are not very good. You typically
</p>
<p>want to stay away from writing code that has this kind of computational complex-
</p>
<p>ity associated with it unless you are absolutely sure it will never be called on large
</p>
<p>data sizes.
</p>
<p>One real-world example of this occurred a few years ago. A tester was testing
</p>
<p>some code and placed a CD in a CD drive. On this computer all the directories and
</p>
<p>file names on the CD were read into memory and sorted alphabetically. The sorting
</p>
<p>algorithm that was used in that case had O(n2) complexity. This was OK because
</p>
<p>most CDs put in this computer had a relatively small number of directories and files
</p>
<p>on them. However, along came one CD with literally hundreds of thousands of files
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>54 2 Computational Complexity
</p>
<p>on it. The computer did nothing but sort those file names alphabetically for around
</p>
<p>12 h. When this was discovered, the programmer rewrote the sorting code to be more
</p>
<p>efficient and reduced the sorting time to around 15 s. That&rsquo;s a BIG difference! It also
</p>
<p>illustrates just how important this idea of computational complexity is.
</p>
<p>If we take another look at our PyList append method we might be able to make
</p>
<p>it more efficient if we didn&rsquo;t have to access each element of the first list when
</p>
<p>concatenating the two lists. The use of the + operator is what causes Python to
</p>
<p>access each element of that first list. When + is used a new list is created with space
</p>
<p>for one more element. Then all the elements from the old list must be copied to the
</p>
<p>new list and the new element is added at the end of this list.
</p>
<p>Using the append method on lists changes the code to use a mutator method to
</p>
<p>alter the list by adding just one more element. It turns out that adding one more
</p>
<p>element to an already existing list is very efficient in Python. In fact, appending an
</p>
<p>item to a list is a O(1) operation as we&rsquo;ll see later in this chapter. This means to append
</p>
<p>n items to a list we have gone from O(n2) to O(n). Later in this chapter we&rsquo;ll learn
</p>
<p>just how Python can insure that we get O(1) complexity for the append operation.
</p>
<p>The blue line in Fig. 2.4 shows how the PyList append method works when the
</p>
<p>+ operator is replaced by calling the list append method instead. At 100,000 elements
</p>
<p>Fig. 2.4 The Complexity of Appending to a Pylist
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.7 Making the PyList Append Efficient 55
</p>
<p>in the PyList we go from 27 s to add another element to maybe a second, but probably
</p>
<p>less than that. That&rsquo;s a nice speedup in our program. After making this change, the
</p>
<p>PyList append method is given in Sect. 2.7.1.
</p>
<p>2.7.1 Efficient Append
</p>
<p>1 class PyList:
</p>
<p>2     def __init__(self):
</p>
<p>3         self.items = []
</p>
<p>4
</p>
<p>5     # The append method is used to add commands to the sequence.
</p>
<p>6     def append(self,item):
</p>
<p>7         self.items.append(item)
</p>
<p>8
</p>
<p>9     ...
</p>
<p>2.8 Commonly Occurring Computational Complexities
</p>
<p>The algorithms we will study in this text will be of one of the complexities of O(1),
</p>
<p>O(log n), O(n log n), O(n2), or O(cn). A graph of the shapes of these functions appears
</p>
<p>in Fig. 2.5. Most algorithms have one of these complexities corresponding to some
</p>
<p>factor of n. Constant values added or multiplied to the terms in a formula for measur-
</p>
<p>ing the time needed to complete a computation do not affect the overall complexity
</p>
<p>of that operation. Computational complexity is only affected by the highest power
</p>
<p>term of the equation. The complexities graphed in Fig. 2.5 are of some power n or
</p>
<p>the log of n, except for the really awful exponential complexity of O(cn), where c is
</p>
<p>some constant value.
</p>
<p>As you are reading the text and encounter algorithms with differing complexities,
</p>
<p>they will be one of the complexities shown in Fig. 2.5. As always, the variable n
</p>
<p>represents the size of the data provided as input to the algorithm. The time taken
</p>
<p>to process that data is the vertical axis in the graph. While we don&rsquo;t care about the
</p>
<p>exact numbers in this graph, we do care about the overall shape of these functions.
</p>
<p>The flatter the line, the lower the slope, the better the algorithm performs. Clearly an
</p>
<p>algorithm that has exponential complexity (i.e. O(cn)) or n-squared complexity (i.e.
</p>
<p>O(n2)) complexity will not perform very well except for very small values of n. If
</p>
<p>you know your algorithm will never be called for large values of n then an inefficient
</p>
<p>algorithm might be acceptable, but you would have to be really sure that you knew
</p>
<p>that your data size would always be small. Typically we want to design algorithms
</p>
<p>that are as efficient as possible.
</p>
<p>In subsequent chapters you will encounter sorting algorithms that are O(n2) and
</p>
<p>then you&rsquo;ll learn that we can do better and achieve O(n log n) complexity. You&rsquo;ll
</p>
<p>see search algorithms that are O(n) and then learn how to achieve O(log n) com-
</p>
<p>plexity. You&rsquo;ll also learn a technique called hashing that will search in O(1) time.
</p>
<p>The techniques you learn will help you deal with large amounts of data as efficiently
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>56 2 Computational Complexity
</p>
<p>Fig. 2.5 Common Big-Oh Complexities
</p>
<p>as possible. As each of these techniques are explored, you&rsquo;ll also have the opportu-
</p>
<p>nity to write some fun programs and you&rsquo;ll learn a good deal about object-oriented
</p>
<p>programming.
</p>
<p>2.9 More Asymptotic Notation
</p>
<p>Earlier in this chapter we developed Big-Oh notation for describing an upper bound
</p>
<p>on the complexity of an algorithm. There we began with an intuitive understanding
</p>
<p>of the idea of efficiency saying that a function exhibits a complexity if it is bounded
</p>
<p>above by a function of n where n represents the size of the data given to the algo-
</p>
<p>rithm. In this section we further develop these concepts to bound the efficiency of
</p>
<p>an algorithm from both above and below.
</p>
<p>We begin with an in-depth discussion of efficiency and the measurement of it in
</p>
<p>Computer Science. When concerning ourselves with algorithm efficiency there are
</p>
<p>two issues that must be considered.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.9 More Asymptotic Notation 57
</p>
<p>&bull; The amount of time an algorithm takes to run
</p>
<p>&bull; and, related to that, the amount of space an algorithm uses while running.
</p>
<p>Typically, computer scientists will talk about a space/time tradeoff in algorithms.
</p>
<p>Sometimes we can achieve a faster running time by using more memory. But, if we
</p>
<p>use too much memory we can slow down the computer and other running programs.
</p>
<p>The space that is referred to is the amount of RAM needed to solve a problem. The
</p>
<p>time we are concerned with is a measure of how the number of operations grow as
</p>
<p>the size of the data grows.
</p>
<p>Consider a function T(n) that is a description of the running time of an algorithm,
</p>
<p>where n is the size of the data given to the algorithm. As computer scientists we want to
</p>
<p>study the asymptotic behavior of this function. In other words, we want to study how
</p>
<p>T(n) increases as n &rarr; &infin;. The value of n is a Natural number representing possible
</p>
<p>sizes of input data. The natural numbers are the set of non-negative integers. The
</p>
<p>definition in Sect. 2.9.1 is a re-statement of the Big-Oh notation definition presented
</p>
<p>earlier in this chapter.
</p>
<p>2.9.1 Big-Oh Asymptotic Upper Bound
</p>
<p>O(g(n)) = { f (n) | &exist;d &gt; 0 and n0 &gt; 0 &ni; 0 &le; f (n) &le; dg(n) &forall;n &ge; n0}
</p>
<p>We write that
</p>
<p>f (n) is= O(g(n)) &hArr; f &isin; O((g(n)))
</p>
<p>and we say that f is big-oh g of n. The definition of Big-Oh says that we can find an
</p>
<p>upper bound for the time it will take for an algorithm to run. Consider the plot of time
</p>
<p>versus data size given in Fig. 2.3. Data size, or n is the x axis, while time is the y axis.
</p>
<p>Imagine that the green line represents the observed behavior of some algorithm.
</p>
<p>The blue line clearly is an upper bound to the green line after about n = 4. This is
</p>
<p>what the definition of big-Oh means. For a while, the upper bounding function may
</p>
<p>not be an upper bound, but eventually it becomes an upper bound and stays that way
</p>
<p>all the way to the limit as n approaches infinity.
</p>
<p>But, does the blue line represent a tight bound on the complexity of the algorithm
</p>
<p>whose running time is depicted by the green line? We&rsquo;d like to know that when
</p>
<p>we describe the complexity of an algorithm it is truly representational of the actual
</p>
<p>running time. Saying that the algorithm runs in O(n2) is accurate even if the algorithm
</p>
<p>runs in time proportional to n because Big-Oh notation only describes an upper bound.
</p>
<p>If we truly want to say what the algorithm&rsquo;s running time is proportional to, then we
</p>
<p>need a little more power. This leads us to our next definition in Sect. 2.9.2.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>58 2 Computational Complexity
</p>
<p>2.9.2 Asymptotic Lower Bound
</p>
<p>ï¿½(g(n)) = { f (n) | &exist;c &gt; 0 and n0 &gt; 0 &ni; 0 &le; cg(n) &le; f (n) &forall;n &ge; n0}
</p>
<p>Omega notation serves as a way to describe a lower bound of a function. In this case
</p>
<p>the lower bound definition says for a while it might be greater, but eventually there
</p>
<p>is some n0 where T(n) dominates g(n) for all bigger values of n. In that case, we can
</p>
<p>write that the algorithm is ï¿½(g(n)). Considering our graph once again, we see that
</p>
<p>the purple line is dominated by the observed behavior sometime after n = 75. As
</p>
<p>with the upper bound, for a while the lower bound may be greater than the observed
</p>
<p>behavior, but after a while, the lower bound stays below the observed behavior for
</p>
<p>all bigger values of n.
</p>
<p>With both a lower bound and and upper bound definition, we now have the notation
</p>
<p>to define an asymptotically tight bound. This is called Theta notation.
</p>
<p>2.9.3 Theta Asymptotic Tight Bound
</p>
<p>ï¿½(g(n)) = { f (n) | &exist; c &gt; 0, d &gt; 0 and n0 &gt; 0 &ni; 0 &le; cg(n) &le; f (n) &le; dg(n) &forall;n &ge; n0}
</p>
<p>If we can find such a function g, then we can declare thatï¿½(g(n)) is an asymptotically
</p>
<p>tight bound for T(n), the observed behavior of an algorithm. In Fig. 2.6 the upper
</p>
<p>bound blue line is g(n) = n2 and the lower bound purple line is a plot of g(n)/110. If
</p>
<p>we let c = 1 and d = 1/110, we have the asymptotically tight bound of T(n) at ï¿½(n2).
</p>
<p>Now, instead of saying that n-squared is an upper bound on the algorithm&rsquo;s behavior,
</p>
<p>we can proclaim that the algorithm truly runs in time proportional to n-squared. The
</p>
<p>behavior is bounded above and below by functions of n-squared proving the claim
</p>
<p>that the algorithm is an n-squared algorithm.
</p>
<p>2.10 Amortized Complexity
</p>
<p>Sometimes it is not possible to find a tight upper bound on an algorithm. For instance,
</p>
<p>most operations may be bounded by some function c*g(n) but every once in a while
</p>
<p>there may be an operation that takes longer. In these cases it may be helpful to employ
</p>
<p>something called Amortized Complexity. Amortization is a term used by accountants
</p>
<p>when spreading the cost of some business transaction over a number of years rather
</p>
<p>than applying the whole expense to the books in one fiscal year. This same idea is
</p>
<p>employed in Computer Science when the cost of an operation is averaged. The key
</p>
<p>idea behind all amortization methods is to get as tight an upper bound as we can
</p>
<p>for the worst case running time of any sequence of n operations on a data structure
</p>
<p>(which usually starts out empty). By dividing by n we get the average or amortized
</p>
<p>running time of each operation in the sequence.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.10 Amortized Complexity 59
</p>
<p>Fig. 2.6 A Lower and Upper Bound
</p>
<p>Consider the PyList append operation discussed earlier in this chapter. The latest
</p>
<p>version of the PyList append method simply calls the Python append operation on
</p>
<p>lists. Python is implemented in C. It turns out that while Python supports an append
</p>
<p>operation for lists, lists are implemented as arrays in C and it is not possible to add
</p>
<p>to an array in C. An array can be allocated with a fixed size, but cannot have its size
</p>
<p>increased once created.
</p>
<p>Pretend for a moment that Python lists, like C arrays, did not support the append
</p>
<p>method on lists and that the only way to create a list was to write something like
</p>
<p>[None]*n where n was a fixed value. Writing [None]*n creates a fixed size list of n
</p>
<p>elements each referencing the value None. This is the way C and C++ arrays are allo-
</p>
<p>cated. In our example, since we are pretending that Python does not support append
</p>
<p>we must implement our PyList append method differently. We can&rsquo;t use the append
</p>
<p>method and earlier in this chapter we saw that that adding on item at a time with the
</p>
<p>+ operator was a bad idea. We&rsquo;ll do something a little different. Our PyList append
</p>
<p>operation, when it runs out of space in the fixed size list, will double the size of the list
</p>
<p>copying all items from the old list to the new list as shown in the code in Sect. 2.10.1.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>60 2 Computational Complexity
</p>
<p>2.10.1 A PyList Class
</p>
<p>1 class PyList:
</p>
<p>2     # The size below is an initial number of locations for the list object. The
</p>
<p>3     # numItems instance variable keeps track of how many elements are currently stored
</p>
<p>4     # in the list since self.items may have empty locations at the end.
</p>
<p>5     def __init__(self,size=1):
</p>
<p>6         self.items = [None] * size
</p>
<p>7         self.numItems = 0
</p>
<p>8
</p>
<p>9     def append(self,item):
</p>
<p>10         if self.numItems == len(self.items):
</p>
<p>11             # We must make the list bigger by allocating a new list and copying
</p>
<p>12             # all the elements over to the new list.
</p>
<p>13             newlst = [None] * self.numItems * 2
</p>
<p>14             for k in range(len(self.items)):
</p>
<p>15                 newlst[k] = self.items[k]
</p>
<p>16
</p>
<p>17             self.items = newlst
</p>
<p>18
</p>
<p>19         self.items[self.numItems] = item
</p>
<p>20         self.numItems += 1
</p>
<p>21
</p>
<p>22 def main():
</p>
<p>23     p = PyList()
</p>
<p>24
</p>
<p>25     for k in range(100):
</p>
<p>26         p.append(k)
</p>
<p>27
</p>
<p>28     print(p.items)
</p>
<p>29     print(p.numItems)
</p>
<p>30     print(len(p.items))
</p>
<p>31
</p>
<p>32 if __name__ == "__main__":
</p>
<p>33     main()
</p>
<p>The claim is that, using this new PyList append method, a sequence of n append
</p>
<p>operations on a PyList object, starting with an empty list, takes O(n) time meaning
</p>
<p>that individual operations must not take longer than O(1) time. How can this be true?
</p>
<p>Whenever the list runs out of space a new list is allocated and all the old elements
</p>
<p>are copied to the new list. Clearly, copying n elements from one list to another takes
</p>
<p>longer than O(1) time. Understanding how append could exhibit O(1) complexity
</p>
<p>relies on computing the amortized complexity of the append operation. Technically,
</p>
<p>when the list size is doubled the complexity of append is O(n). But how often does
</p>
<p>that happen? The answer is not that often.
</p>
<p>2.10.2 Proof of Append Complexity
</p>
<p>The proof that the append method has O(1) complexity uses what is called the
</p>
<p>accounting method to find the amortized complexity of append. The accounting
</p>
<p>method stores up cyber dollars to pay for expensive operations later. The idea is that
</p>
<p>there must be enough cyber dollars to pay for any operation that is more expensive
</p>
<p>than the desired complexity.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.10 Amortized Complexity 61
</p>
<p>Consider a sequence of n append operations on an initially empty list. Appending
</p>
<p>the first element to the list is done in O(1) time since there is space for the first item
</p>
<p>added to the list because one slot was initially allocated in the list. Storing a value
</p>
<p>in an already allocated slot takes O(1) time. However, according to the accounting
</p>
<p>method, we&rsquo;ll claim that the cost of doing the append operation requires an additional
</p>
<p>two cyber dollars. This is still O(1) complexity. Each time we run out of space we&rsquo;ll
</p>
<p>double the number of slots in the fixed size list. Allocating a fixed size list is a
</p>
<p>O(1) operation regardless of the list size. The extra work comes when copying the
</p>
<p>elements from the old list to the new list.
</p>
<p>Fig. 2.7 Append Cyber Dollars
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>62 2 Computational Complexity
</p>
<p>The first time we need to double the size is when the second append is called.
</p>
<p>There are two cyber dollars stored up at this point in time. One of them is needed
</p>
<p>when copying the one element stored in the old list to the new fixed size list capable
</p>
<p>of holding two elements. Transition one in Fig. 2.7 shows the two stored cyber dollars
</p>
<p>and the result after copying to the new list when moving from step A to step B.
</p>
<p>When append is called on version B of the list the result is version C. At this
</p>
<p>point, three cyber dollars are stored to be used when doubling the list size to four
</p>
<p>locations. The first two are filled with the old contents of the list. Two of the three
</p>
<p>stored cyber dollars are used while copying these values to the new list. When the
</p>
<p>list of size four fills, two additional append operations have occurred, storing five
</p>
<p>cyber dollars. Four of these cyber dollars are used in the copy from step E to step F.
</p>
<p>Again, when the list of size eight fills in step G there are nine stored cyber dollars to
</p>
<p>be used in doubling the list size and copying the elements over.
</p>
<p>But, what if we didn&rsquo;t double the size of the list each time. If we increased the
</p>
<p>list size by one half its previous size each time, we could still make this argument
</p>
<p>work if we stored four cyber dollars for each append operation. In fact, as long as
</p>
<p>the size of the list grows proportionally to its current size each time it is expanded
</p>
<p>this argument still works to prove that appending to a list is a O(1) operation when
</p>
<p>lists must be allocated with a fixed size.
</p>
<p>As mentioned earlier, the Python list object is implemented in C. While Python
</p>
<p>provides an append operation, the C language can only allocate fixed size lists, called
</p>
<p>arrays in C. And yet, Python list objects can append objects in O(1) time as can be
</p>
<p>observed by experimentation or by analyzing the C code that implements Python
</p>
<p>list objects. The Python list append implementation achieves this by increasing the
</p>
<p>list size as described in this section when the fixed size array runs out of space to
</p>
<p>achieve an amortized complexity of O(1).
</p>
<p>2.11 Chapter Summary
</p>
<p>This chapter covered some important topics related to the efficiency of algorithms.
</p>
<p>Efficiency is an important topic because even the fastest computers will not be able
</p>
<p>to solve problems in a reasonable amount of time if the programs that are written for
</p>
<p>them are inefficient. In fact, some problems can&rsquo;t be solved in a reasonable amount
</p>
<p>of time no matter how the program is written. Nevertheless, it is important that we
</p>
<p>understand these issues of efficiency. Finding the complexity of a piece of code is
</p>
<p>an important skill that you will get better at the more you practice. Here are some of
</p>
<p>the things you should have learned in this chapter. You should:
</p>
<p>&bull; know the complexity of storing or retrieving a value from a list or the memory of
</p>
<p>the computer.
</p>
<p>&bull; know how memory is like a post office.
</p>
<p>&bull; know how memory is NOT like a post office.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.11 Chapter Summary 63
</p>
<p>&bull; know how to use the datetime module to get information about the time it takes to
</p>
<p>complete an operation in a program.
</p>
<p>&bull; know how to write an XML file that can be used by the plotting program to plot
</p>
<p>information about the performance of an algorithm or piece of code.
</p>
<p>&bull; understand the definition of big-Oh notation and how it establishes an upper bound
</p>
<p>on the performance of a piece of code.
</p>
<p>&bull; understand why the list + operation is not as efficient as the append operation.
</p>
<p>&bull; understand the difference between O(n), O(n2), and other computational complex-
</p>
<p>ities and why those differences are important to us as computer programmers.
</p>
<p>&bull; Understand Theta notation and what an asymptotically tight bound says about an
</p>
<p>algorithm.
</p>
<p>&bull; Understand Amortized complexity and how to apply it in some simple situations.
</p>
<p>2.12 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. How is a list like a bunch of post office boxes?
</p>
<p>2. How is accessing an element of a list NOT like retrieving the contents of a post
</p>
<p>office box?
</p>
<p>3. How can you compute the amount of time it takes to complete an operation in a
</p>
<p>computer using Python?
</p>
<p>4. In terms of computational complexity, which is better, an algorithm that is O(n2)
</p>
<p>or an algorithm that is O(2n)?
</p>
<p>5. Describe, in English, what it means for an algorithm to be O(n2).
</p>
<p>6. When doing a proof by induction, what two parts are there to the proof?
</p>
<p>7. If you had an algorithm with a loop that executed n steps the first time through,
</p>
<p>then n &minus; 2 the second time, n &minus; 4 the next time, and kept repeating until the
</p>
<p>last time through the loop it executed 2 steps, what would be the complex-
</p>
<p>ity measure of this loop? Justify your answer with what you learned in this
</p>
<p>chapter.
</p>
<p>8. Assume you had a data set of size n and two algorithms that processed that data
</p>
<p>set in the same way. Algorithm A took 10 steps to process each item in the data
</p>
<p>set. Algorithm B processed each item in 100 steps. What would the complexity
</p>
<p>be of these two algorithms?
</p>
<p>9. Explain why the append operation on a list is more efficient than the + operator.
</p>
<p>10. Describe an algorithm for finding a particular value in a list. Then give the
</p>
<p>computational complexity of this algorithm. You may make any assumptions
</p>
<p>you want, but you should state your assumptions along with your algorithm.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>64 2 Computational Complexity
</p>
<p>2.13 Programming Problems
</p>
<p>1. Devise an experiment to discover the complexity of comparing strings in Python.
</p>
<p>Does the size of the string affect the efficiency of the string comparison and if so,
</p>
<p>what is the complexity of the comparison? In this experiment you might want to
</p>
<p>consider a best case, worst case, and average case complexity. Write a program
</p>
<p>that produces an XML file with your results in the format specified in this chapter.
</p>
<p>Then use the PlotData.py program to visualize those results.
</p>
<p>2. Conduct an experiment to prove that the product of two numbers does not depend
</p>
<p>on the size of the two numbers being multiplied. Write a program that plots the
</p>
<p>results of multiplying numbers of various sizes together. HINT: To get a good
</p>
<p>reading you may want to do more than one of these multiplications and time
</p>
<p>them as a group since a multiplication happens pretty quickly in a computer.
</p>
<p>Verify that it truly is a O(1) operation. Do you see any anomalies? It might be
</p>
<p>explained by Python&rsquo;s support of large integers. What is the cutoff point for
</p>
<p>handling multiplications in constant time? Why? Write a program that produces
</p>
<p>an XML file with your results in the format given in this chapter. Then visualize
</p>
<p>your results with the PlotData.py program provided in this chapter.
</p>
<p>3. Write a program to gather experimental data about comparing integers. Compare
</p>
<p>integers of different sizes and plot the amount of time it takes to do those com-
</p>
<p>parisons. Plot your results by writing an XML file in the Ploy.py format. Is the
</p>
<p>comparison operation always O(1)? If not, can you theorize why? HINT: You
</p>
<p>may want to read about Python&rsquo;s support for large integers.
</p>
<p>4. Write a short function that searches for a particular value in a list and returns the
</p>
<p>position of that value in the list (i.e. its index). Then write a program that times
</p>
<p>how long it takes to search for an item in lists of different sizes. The size of the
</p>
<p>list is your n. Gather results from this experiment and write them to an XML file
</p>
<p>in the PlotData.py format. What is the complexity of this algorithm? Answer this
</p>
<p>question in a comment in your program and verify that the experimental results
</p>
<p>match your prediction. Then, compare this with the index method on a list. Which
</p>
<p>is more efficient in terms of computational complexity? HINT: You need to be
</p>
<p>careful to consider the average case for this problem, not just a trivial case.
</p>
<p>5. Write a short function that given a list, adds together all the values in the list and
</p>
<p>returns the sum. Write your program so it does this operation with varying sizes
</p>
<p>of lists. Record the time it takes to find the sum for various list sizes. Record this
</p>
<p>information in an XML file in the PlotData.py format. What complexity is this
</p>
<p>algorithm? Answer this in a comment at the top of your program and verify it
</p>
<p>with your experimental data. Compare this data with the built-in sum function in
</p>
<p>Python that does the same thing. Which is more efficient in terms of computational
</p>
<p>complexity? HINT: You need to be careful to consider the average case for this
</p>
<p>problem, not just a trivial case.
</p>
<p>6. Assume that you have a datatype called the Clearable type. This data type has a
</p>
<p>fixed size list inside it when it is created. So Clearable(10) would create a clearable
</p>
<p>list of size 10. Objects of the Clearable type should support an append operation
</p>
<p>and a lookup operation. The lookup operation is called __getitem__(item). If cl is
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>2.13 Programming Problems 65
</p>
<p>a Clearable list, then writing cl[item] will return the item if it is in the list and return
</p>
<p>None otherwise. Writing cl[item] results in a method call of cl.__getitem__(item).
</p>
<p>Unlike the append operation described in Sect. 2.10.1, when the Clearable object
</p>
<p>fills up the list is automatically cleared or emptied on the next call to append
</p>
<p>by setting all elements of the list back to None. The Clearable object should
</p>
<p>always keep track of the number of values currently stored in the object. Form a
</p>
<p>theory about the complexity of the append operation on this datatype. Then write
</p>
<p>a test program to test the Clearable object on different initial sizes and numbers
</p>
<p>of append operations. Create one sequence for each different initial size of the
</p>
<p>Clearable datatype and write your results in the plot format described in this
</p>
<p>chapter. Then comment on how your theory holds up or does not hold up given
</p>
<p>your experimentation results.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3Recursion
</p>
<p>Don&rsquo;t think too hard! That&rsquo;s one of the central themes of this chapter. It&rsquo;s not often
</p>
<p>that you tell computer programmers not to think too hard, but this is one time when
</p>
<p>it is appropriate. You need to read this chapter if you have not written recursive
</p>
<p>functions before. Most computer science students start by learning to program in a
</p>
<p>style called imperative programming. This simply means that you are likely used
</p>
<p>to thinking about creating variables, storing values, and updating those values as a
</p>
<p>program proceeds. In this chapter you are going to begin learning a different style
</p>
<p>of programming called functional programming. When you program in the func-
</p>
<p>tional style, you think much more about the definition of what you are programming
</p>
<p>than how you are going to program it. Some say that writing recursive functions
</p>
<p>is a declarative approach rather than an imperative approach. You&rsquo;ll start to learn
</p>
<p>what that means for you very soon. When you start to get good at writing recursive
</p>
<p>functions you&rsquo;ll be surprised how easy it can be!
</p>
<p>Python programs are executed by an interpreter. An interpreter is a program that
</p>
<p>reads another program as its input and does what it says. The Python interpreter,
</p>
<p>usually called python, was written in a language called C. That C program reads a
</p>
<p>Python program and does what the Python program says to do in its statements. An
</p>
<p>interpreter interprets a program by running or executing what is written within it. The
</p>
<p>interpreter interacts with the operating system of the computer to use the network,
</p>
<p>the keyboard, the mouse, the monitor, the hard drive, and any other I/O device that
</p>
<p>it needs to complete the work that is described in the program it is interpreting. The
</p>
<p>picture in Fig. 3.1 shows you how all these pieces fit together.
</p>
<p>In this chapterwe&rsquo;ll introduce you to scope, the run-time stack, and the heap so you
</p>
<p>understand how the interpreter calls functions and where local variables are stored.
</p>
<p>Then we&rsquo;ll provide several examples of recursive functions so you can begin to see
</p>
<p>how they arewritten. Therewill be a number of recursive functions for you to practice
</p>
<p>writing and we&rsquo;ll apply recursion to drawing pictures as well.
</p>
<p>One thing you will not do in the homework for this chapter is write code that uses
</p>
<p>a for loop or a while loop. If you find yourself trying to write code that uses either
</p>
<p>kind of loop you are trying to write a function imperatively rather than functionally.
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_3
</p>
<p>67
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>68 3 Recursion
</p>
<p>Fig. 3.1 The Python Interpreter
</p>
<p>Recursion is the way we will repeat code in this chapter. A recursive function has no
</p>
<p>need for a for or while loop.
</p>
<p>3.1 Chapter Goals
</p>
<p>By the end of this chapter, you should be able to answer these questions.
</p>
<p>&bull; How does Python determine the meaning of an identifier in a program?
</p>
<p>&bull; What happens to the run-time stack when a function is called?
</p>
<p>&bull; What happens to the run-time stack when a function returns from a call?
</p>
<p>&bull; What are the two important parts to a recursive function and which part comes
</p>
<p>first?
</p>
<p>&bull; Exactly what happens when a return statement is executed?
</p>
<p>&bull; Why should we write recursive functions?
</p>
<p>&bull; What are the computational complexities of various recursive functions?
</p>
<p>You should also be able to write some simple recursive functions yourself without
</p>
<p>thinking too hard about how they work. In addition, you should be able to use a
</p>
<p>debugger to examine the contents of the run-time stack for a recursive function.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2 Scope 69
</p>
<p>3.2 Scope
</p>
<p>To form a complete mental picture of how your programs work we should further
</p>
<p>explore just how the Python interpreter executes a Python program. In the first chapter
</p>
<p>we explored how references are the things which we name and that references point
</p>
<p>to objects, which are unnamed. However, we sometimes call an object by the name
</p>
<p>of the reference that is pointing at it. For instance, if we write:
</p>
<p>x = 6
</p>
<p>it means that x is a reference that points to an object with a 6 inside it. But
</p>
<p>sometimes we are careless and just say that x equals 6. It is important that you
</p>
<p>understand that even when we say things like x equals 6 what we really mean is
</p>
<p>that x is a reference that points to an object that contains 6. You can see why we
</p>
<p>are careless sometimes. It takes too many words to say what we really mean and
</p>
<p>as long as everyone understands that references have names and objects are pointed
</p>
<p>to by references, then we can save the words. The rest of this text will make this
</p>
<p>assumption at times. When it is really important, we&rsquo;ll make sure we distinguish
</p>
<p>between references and objects.
</p>
<p>Part of our mental picture must include Scope in a Python program. Scope refers
</p>
<p>to a part of a program where a collection of identifiers are visible. Let&rsquo;s look at a
</p>
<p>simple example program.
</p>
<p>3.2.1 Local Scope
</p>
<p>Consider the code in Fig. 3.2. In this program there are several scopes. Every colored
</p>
<p>region of the figure delimits one of those scopes. While executing line 23 of the
</p>
<p>program in Fig. 3.2 the light green region is called the Local scope. The local scope
</p>
<p>is the scope of the function that the computer is currently executing. When your
</p>
<p>program is executing a line of code, the scope that surrounds that line of code is called
</p>
<p>the local scope. When you reference an identifier in a statement in your program,
</p>
<p>Python first examines the local scope to see if the identifier is defined there, within
</p>
<p>the local scope. An identifier, id, is defined under one of three conditions.
</p>
<p>&bull; A statement like id =&hellip;appears somewhere within the current scope. In this case
</p>
<p>id would be a reference to an object in the local scope.
</p>
<p>&bull; id appears as a parameter name of the function in the current scope. In this case
</p>
<p>id would be a reference to an object that was passed to the current function as an
</p>
<p>argument.
</p>
<p>&bull; id appears as a name of a function or class through the use of a function def or
</p>
<p>class definition within the current scope.
</p>
<p>While Python is executing line 23 in Fig. 3.2, the reference val is defined within
</p>
<p>its local scope. If Python finds id in the local scope, it looks up the corresponding
</p>
<p>value and retrieves it. This is what happens when val is encountered on line 23. The
</p>
<p>object that is referenced by val is retrieved and returned.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>70 3 Recursion
</p>
<p>Fig. 3.2 Scopes within a Simple Program
</p>
<p>3.2.2 Enclosing Scope
</p>
<p>If Python does not find the reference id within the local scope, it will examine the
</p>
<p>Enclosing scope to see if it can find id there. In the program in Fig. 3.2, while Python
</p>
<p>is executing the statement on line 23, the enclosing scope is the purple region of the
</p>
<p>program. The identifiers defined in this enclosing scope include historyOfPrompts,
</p>
<p>historyOfOutput, rString, r, val, getInput, and showInput. Notice that function names
</p>
<p>are included as identifiers. Again, Python looks for the identifier using the same
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.2 Scope 71
</p>
<p>conditions as defined in Sect. 3.2.1 for the local scope. The identifier must be defined
</p>
<p>using id = &hellip;, it must be a parameter to the enclosing function, or it must be an
</p>
<p>identifier for a class or function definition in the enclosing scope&rsquo;s function. On line
</p>
<p>23, when Python encounters the identifier historyOfOutput it finds that identifier
</p>
<p>defined in the enclosing scope and retrieves it for use in the call to the append
</p>
<p>method.
</p>
<p>Which scope is local depends on where your program is currently executing.
</p>
<p>When executing line 23, the light green region is the local scope. When executing
</p>
<p>line 18 the brown region is the local scope. When executing line 14 or line 26 the
</p>
<p>purple region is the local scope. When executing line 6 the darker green region is the
</p>
<p>local scope. Finally, when executing line 1 or 3 the blue region is the local scope.
</p>
<p>The local scope is determined by where your program is currently executing.
</p>
<p>Scopes are nested. This means that each scope is nested inside another scope.
</p>
<p>The final enclosing scope of a module is the module itself. Each module has its own
</p>
<p>scope. The blue region of Fig. 3.2 corresponds to the module scope. Identifiers that
</p>
<p>are defined outside of any other functions, but inside the module, are at the module
</p>
<p>level. The reference PI in Fig. 3.2 is defined at the module level. The functions area
</p>
<p>and main are also defined at the module level scope.
</p>
<p>While executing line 23 of the program in Fig. 3.2 the identifier val is defined in
</p>
<p>the local scope. But, val is also defined in the enclosing scope. This is acceptable
</p>
<p>and often happens in Python programs. Each scope has its own copy of identifiers.
</p>
<p>The choice of which val is visible is made by always selecting the innermost scope
</p>
<p>that defines the identifier. While executing line 23 of the program in Fig. 3.2 the val
</p>
<p>in the local scope is visible and the val in the enclosing scope is hidden. This is
</p>
<p>why it is important that we choose our variable names and identifiers carefully in
</p>
<p>our programs. If we use an identifier that is already defined in an outer scope, we
</p>
<p>will no longer be able to access it from an inner scope where the same identifier is
</p>
<p>defined.
</p>
<p>It is relatively easy to determine all the nested scopes within a module. Every
</p>
<p>function definition (including the definition of methods) within a module defines a
</p>
<p>different scope. The scope never includes the function name itself, but includes its
</p>
<p>parameters and the body of the function. You can follow this pattern to mentally
</p>
<p>draw boxes around any scope so you know where it begins and ends in your code.
</p>
<p>3.2.3 Global Scope
</p>
<p>Using Python it is possible to define variables at the Global level. Generally this is
</p>
<p>a bad programming practice and we will not do this in this text. If interested you
</p>
<p>can read more about global variables in Python online. But, using too many global
</p>
<p>variables will generally lead to name conflicts and will likely lead to unwanted side
</p>
<p>effects. Poor use of global variables contributes to spaghetti code which is named
</p>
<p>for the big mess you would have trying to untangle it to figure out what it does.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>72 3 Recursion
</p>
<p>3.2.4 Built-In Scope
</p>
<p>The final scope in Python is the Built-In scope. If an identifier is not found
</p>
<p>within any of the nested scopes within a module and it is not defined in the
</p>
<p>global scope, then Python will examine the built-in identifiers to see if it is
</p>
<p>defined there. For instance, consider the identifier int. If you were to write the
</p>
<p>following:
</p>
<p>x = int("6")
</p>
<p>Python would first look in the local scope to see if int were defined as a function
</p>
<p>or variable within that local scope. If int is not found within the local scope, Python
</p>
<p>would look in all the enclosing scopes starting with the next inner-most local scope
</p>
<p>andworking outwards from there. If not found in any of the enclosing scopes, Python
</p>
<p>would then look in the global scope for the int identifier. If not found there, then
</p>
<p>Python would consult the Built-In scope, where it would find the int class or type.
</p>
<p>With this explanation, it should now be clear why you should not use identifiers
</p>
<p>that already exist in the built-in scope. If you use int as an identifier you will not be
</p>
<p>able to use the int from the built-in scope because Python will find int in a local or
</p>
<p>enclosing scope first.
</p>
<p>3.2.5 LEGB
</p>
<p>Mark Lutz, in his book Learning Python [6], described the rules of scope in Python
</p>
<p>programs using the LEGB acronym. This acronym, standing for Local, Enclosing,
</p>
<p>Global, and Built-In can help you memorize the rules of scope in Python. The order
</p>
<p>of the letters in the acronym is important. When the Python interpreter encounters an
</p>
<p>identifier in a program, it searches the local scope first, followed by all the enclosing
</p>
<p>scopes from the inside outward, followed by the global scope, and finally the built-in
</p>
<p>scope.
</p>
<p>3.3 The Run-Time Stack and the Heap
</p>
<p>As we learned in the last section, the parameters and body of each function define
</p>
<p>a scope within a Python program. The parameters and variables defined within the
</p>
<p>local scope of a function must be stored someplace within the RAM of a computer.
</p>
<p>Python splits the RAM up into two parts called the Run-time Stack and the Heap.
</p>
<p>The run-time stack is like a stack of trays in a cafeteria. Most cafeterias have
</p>
<p>a device that holds these trays. When the stack of trays gets short enough a spring
</p>
<p>below the trays pops the trays up so they are at a nice height. As more trays are added
</p>
<p>to the stack, the spring in this device compresses and the stack pushes down. A Stack
</p>
<p>in Computer Science is similar in many ways to this kind of device. The run-time
</p>
<p>stack is a stack of Activation Records. The Python interpreter pushes an activation
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.3 The Run-Time Stack and the Heap 73
</p>
<p>record onto the run-time stack when a function is called. When a function returns the
</p>
<p>Python interpreter pops the corresponding activation record off the run-time stack.
</p>
<p>Python stores the identifiers defined in the local scope in an activation record.
</p>
<p>When a function is called, a new scope becomes the local scope. At the same time a
</p>
<p>new activation record is pushed onto the run-time stack. This new activation record
</p>
<p>holds all the variables that are defined within the new local scope. When a function
</p>
<p>returns its corresponding activation record is popped from the run-time stack.
</p>
<p>The Heap is the area of RAM where all objects are stored. When an object is
</p>
<p>created it resides in the heap. The run-time stack never contains objects. References
</p>
<p>to objects are stored within the run-time stack and those references point to objects
</p>
<p>in the heap.
</p>
<p>Consider the program in Fig. 3.2. When the Python interpreter is executing lines
</p>
<p>23 and 24 of the program, the run-time stack looks as it does in Fig. 3.3. There are
</p>
<p>three activation records on the run-time stack. The first activation record pushed onto
</p>
<p>the run-time stack was for the module. When the module first began executing, the
</p>
<p>Python interpreter went through the module from top to bottom and put any variable
</p>
<p>definitions in the module scope into the activation record for the module. In this
</p>
<p>program that consisted of the reference PI to the value 3.14159.
</p>
<p>Then, at the end of the module the if statement called the main function. This
</p>
<p>caused the Python interpreter to push the activation record for the main function.
</p>
<p>The variables defined within the main function include historyOfPrompts, history-
</p>
<p>OfOutput, rString, r, and val. Each of these appear within the activation record for
</p>
<p>the main function.
</p>
<p>As the main function began executing it called the getInput function. When that
</p>
<p>call occurred there was an activation record pushed for the function call. That acti-
</p>
<p>vation record contained the prompt and x variables. This activation record does not
</p>
<p>appear in the figure because by the time we execute line 23 and 24 of the program
</p>
<p>the Python interpreter has already returned from the getInput function. When the
</p>
<p>interpreter returned from the function call the corresponding activation record was
</p>
<p>popped from the run-time stack.
</p>
<p>Finally, the program calls the showOutput function on line 26 and execution of the
</p>
<p>function begins. An activation record for the showOutpout function call was pushed
</p>
<p>onto the run-time stack when showOutput was called. The references local to that
</p>
<p>scope, which includes just the val variable, were stored the activation record for this
</p>
<p>function call.
</p>
<p>You can run this example program using Wing or some other IDE. The code for
</p>
<p>it appears in Sect. 20.2. When you use the Wing IDE to run this program you can
</p>
<p>stop the program at any point and examine the run-time stack. For instance, Fig. 3.4
</p>
<p>shows Wing in the midst of running this program. A breakpoint has been set on line
</p>
<p>24 to stop the program. The tab at the bottom of the Wing IDE window shows the
</p>
<p>Stack Data. This is the run-time stack.
</p>
<p>Right below the Stack Data tab there is a combination box that currently displays
</p>
<p>showOutput(): Scope.py, line 24. This combo box lets you pick from the activation
</p>
<p>record that is currently being displayed. If you pick a different activation record, its
</p>
<p>contents will be displayed directly below it in the Wing IDE.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>74 3 Recursion
</p>
<p>Fig. 3.3 The Run-time Stack and the Heap
</p>
<p>One important note should be made here. Figure3.4 shows historyOfOutput as a
</p>
<p>local variable in the showOutput function. This is not really the case, because the
</p>
<p>historyOfOutput reference is not defined within the local scope of the showOutput
</p>
<p>function. However, due to the way Python is implemented the reference for this vari-
</p>
<p>able shows up in the activation record for showOutput because it is being referenced
</p>
<p>from this scope. But, the reference to historyOfOutput in the activation record for
</p>
<p>showOutput and the reference called historyOfOutput in the main activation record
</p>
<p>point at the same object so no real harm is done. The important thing to note is that
</p>
<p>the Wing IDE is correct in showing the historyOfOutput variable as a local variable
</p>
<p>in this activation record since this is a reflection of Python&rsquo;s implementation and not
</p>
<p>due to a bug in Wing IDE 101.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.4 Writing a Recursive Function 75
</p>
<p>Fig. 3.4 The Wing IDE Showing the Run-time Stack
</p>
<p>3.4 Writing a Recursive Function
</p>
<p>A recursive function is simply a function that calls itself. It&rsquo;s really very simple to
</p>
<p>write a recursive function, but of course you want to write recursive functions that
</p>
<p>actually do something interesting. In addition, if a function just kept calling itself it
</p>
<p>would never finish. Actually, it would finish when run on a computer because we
</p>
<p>just learned that every time you call a function, an activation record is pushed on the
</p>
<p>run-time stack. If a recursive function continues to call itself over and over it will
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>76 3 Recursion
</p>
<p>eventually fill up the run-time stack and you will get a stack overflow error when
</p>
<p>running such a program.
</p>
<p>To prevent a recursive function from running forever, or overflowing the run-
</p>
<p>time stack, every recursive function must have a base case, just like an inductive
</p>
<p>proof must have a base case. There are many similarities between inductive proofs
</p>
<p>and recursive functions. The base case in a recursive function must be written first,
</p>
<p>before the function is called recursively.
</p>
<p>Now, wrapping your head around just how a recursive function works is a little
</p>
<p>difficult at first. Actually, understanding how a recursive function works isn&rsquo;t all that
</p>
<p>important. When writing recursive functions we want to think more about what it
</p>
<p>does than how it works. It doesn&rsquo;t pay to think too hard about how recursive functions
</p>
<p>work, but in fact even that will get much easier with some practice.
</p>
<p>When writing a recursive function there are four rules that you adhere to. These
</p>
<p>rules are not negotiable and will ensure that your recursive function will eventually
</p>
<p>finish. If you memorize and learn to follow these rules you will be writing recursive
</p>
<p>functions in no time. The rules are:
</p>
<p>1. Decide on the name of your function and the arguments that must be passed to it
</p>
<p>to complete its work as well as what value the function should return.
</p>
<p>2. Write the base case for your recursive function first. The base case is an if state-
</p>
<p>ment that handles a very simple case in the recursive function by returning a
</p>
<p>value.
</p>
<p>3. Finally, you must call the function recursively with an argument or arguments
</p>
<p>that are smaller in some way than the parameters that were passed to the function
</p>
<p>when the last call was made. The argument or arguments that get smaller are the
</p>
<p>same argument or arguments you examined in your base case.
</p>
<p>4. Look at a concrete example. Pick some values to try out with your recursive
</p>
<p>function. Trust that the recursive call you made in the last step works. Take the
</p>
<p>result from that recursive call and use it to form the result you want your function
</p>
<p>to return. Use the concrete example to help you see how to form that result.
</p>
<p>We&rsquo;ll do a very simple example to begin with. In the last chapter we proved the
</p>
<p>following.
n&sum;
</p>
<p>i=1
</p>
<p>i =
n(n + 1)
</p>
<p>2
</p>
<p>So, if we wanted to compute the sum of the first n integers, we could write a Python
</p>
<p>program as shown in Sect. 3.4.1.
</p>
<p>3.4.1 Sum of Integers
</p>
<p>1 def sumFirstN(n):
</p>
<p>2     return n * (n+1) // 2
</p>
<p>3
</p>
<p>4 def main():
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.4 Writing a Recursive Function 77
</p>
<p>5     x = int(input("Please enter a non-negative integer: "))
</p>
<p>6
</p>
<p>7     s = sumFirstN(x)
</p>
<p>8
</p>
<p>9     print("The sum of the first", x, "integers is", str(s)+".")
</p>
<p>10
</p>
<p>11 if __name__ == "__main__":
</p>
<p>12     main()
</p>
<p>In this case, this would be the best function we could write because the complexity
</p>
<p>of the sumFirstN function isO(1). Thismeans the time it takes to execute this function
</p>
<p>is not dependent on the size of the data, n. However, to illustrate a recursive function,
</p>
<p>let&rsquo;s go back to the definition of summation. The definition for summation has two
</p>
<p>parts. First, the base case of the definition.
</p>
<p>0&sum;
i=1
</p>
<p>i = 0
</p>
<p>The recursive part of the definition is as follows. This is what we call a recursive
</p>
<p>definition because it is defined in terms of itself. Notice that the recursive definition
</p>
<p>is defined in terms of a smaller n, in this case n &minus; 1. The summation to n &minus; 1 is our
</p>
<p>recursive call and it will work. If we want to compute the sum of the first 5 integers,
</p>
<p>then the recursive call computes 1+ 2+ 3+ 4 to give us 10. Adding n will give use
</p>
<p>15, the result we want.
</p>
<p>n&sum;
i=1
</p>
<p>i =
</p>
<p>(
n&minus;1&sum;
i=1
</p>
<p>i
</p>
<p>)
+ n
</p>
<p>The two parts of this recursive definition can be translated directly into a recursive
</p>
<p>function in Python. The recursive definition is given in Sect. 3.4.2.
</p>
<p>3.4.2 Recursive Sum of Integers
</p>
<p>1 def recSumFirstN(n):
</p>
<p>2     if n == 0:
</p>
<p>3         return 0
</p>
<p>4     else:
</p>
<p>5         return recSumFirstN(n-1) + n
</p>
<p>6
</p>
<p>7 def main():
</p>
<p>8     x = int(input("Please enter a non-negative integer: "))
</p>
<p>9
</p>
<p>10     s = recSumFirstN(x)
</p>
<p>11
</p>
<p>12     print("The sum of the first", x, "integers is", str(s)+".")
</p>
<p>13
</p>
<p>14 if __name__ == "__main__":
</p>
<p>15     main()
</p>
<p>The recSumFirstN function in the code of Sect. 3.4.2 is recursive. It calls itselfwith
</p>
<p>a smaller value and it has a base case that comes first, so it is well-formed. There is
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>78 3 Recursion
</p>
<p>one thing that we might point out in this recursive function. The else is not necessary.
</p>
<p>When the Python interpreter encounters a return statement, the interpreter returns
</p>
<p>immediately and does not execute the rest of the function. So, in Sect. 3.4.2, if the
</p>
<p>function returns 0 in the then part of the if statement, the rest of the function is not
</p>
<p>executed. If n is not zero, then we want to execute the code on the else statement.
</p>
<p>This means we could rewrite this function as shown in Sect. 3.4.3.
</p>
<p>3.4.3 No Else Needed
</p>
<p>1 def recSumFirstN(n):
</p>
<p>2     if n == 0:
</p>
<p>3         return 0
</p>
<p>4
</p>
<p>5     return recSumFirstN(n-1) + n
</p>
<p>The format of the code in Sect. 3.4.3 is a commonway towrite recursive functions.
</p>
<p>Sometimes a recursive function has more than one base case. Each base case can be
</p>
<p>handled by an if statement with a return in it. The recursive case does not need to be
</p>
<p>in an else when all base cases result in a return. The recursive case comes last in the
</p>
<p>recursive function definition.
</p>
<p>3.5 Tracing the Execution of a Recursive Function
</p>
<p>Early in this chapter youwere given themandate &ldquo;Don&rsquo;t think too hard&rdquo;whenwriting
</p>
<p>a recursive function. Understanding exactly how a recursive function works may be a
</p>
<p>bit difficult when you are first learning about them. Itmay help to follow the execution
</p>
<p>of a recursive function in an example. Consider the program in the previous section.
</p>
<p>Let&rsquo;s assume that the user entered the integer 4 at the keyboard. When this program
</p>
<p>begins running it will have an activation record on the run-time stack for the module
</p>
<p>and the main function.
</p>
<p>When theprogramgets to line 10 in the codeofSect. 3.4.2,where the recSumFirstN
</p>
<p>function is first called, a new activation record will be pushed for the function call,
</p>
<p>resulting in three activation records on the run-time stack. The Python interpreter
</p>
<p>then jumps to line 2 with n pointing at the number 4 as shown in the picture of
</p>
<p>Fig. 3.5. Execution of the function proceeds. The value of n is not zero, so Python
</p>
<p>executes line 5 where there is another function call to recSumFirstN. This causes the
</p>
<p>Python interpreter to push another activation record on the run-time stack and the
</p>
<p>interpreter jumps to line 2 again. This time the value of n is 3. But again, this is not
</p>
<p>zero, so line 5 is executed and another activation record is pushed with a new value
</p>
<p>of 2 for n. This repeats two more times for values of 1 and 0 for n.
</p>
<p>The important thing to note in this program execution is that there is one copy of
</p>
<p>the variable n for each recursive function call. An activation record holds the local
</p>
<p>variables and parameters of all variables that are in the local scope of the function.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.5 Tracing the Execution of a Recursive Function 79
</p>
<p>Fig. 3.5 The Run-time Stack of a Recursive Function Call
</p>
<p>Each time the function is called a new activation record is pushed and a new copy
</p>
<p>of the local variables is stored within the activation record. The picture in Fig. 3.5
</p>
<p>depicts the run-time stack at its deepest point.
</p>
<p>When execution of the function gets to the point when n equals 0, the Python
</p>
<p>interpreter finds that n equals 0 on line 2 of the code. It is at this point that the
</p>
<p>sumFirstN function returns its first value. It returns 0 to the previous function call
</p>
<p>where n was 1. The return occurs on line 5 of the code. The activation record for
</p>
<p>the function call when n was 0 is popped from the run-time stack. This is depicted
</p>
<p>in Fig. 3.6 by the shading of the activation record in the figure. When the function
</p>
<p>returns the space for the activation record is reclaimed for use later. The shaded
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>80 3 Recursion
</p>
<p>Fig. 3.6 The First Return from recSumFirstN
</p>
<p>object containing 0 on the heap is also reclaimed by the garbage collector because
</p>
<p>there are no references pointing at it anymore.
</p>
<p>After the first return of the RecSumFirstN, the Python interpreter returns to line 5
</p>
<p>in the previous function call. But, this statement contains a return statement as well.
</p>
<p>So, the function returns again. Again, it returns to line 5, but this time with a value
</p>
<p>of 1. The function returns again, but with a value of 3 this time. Again, since it
</p>
<p>returned to line 5, the function returns again with a value of 6. Finally, once again
</p>
<p>the function returns, this time with a value of 10. But this time the recSumFirstN
</p>
<p>function returns to line 10 of the main function where s is made to point to the value
</p>
<p>of 10. This is depicted in Fig. 3.7.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.5 Tracing the Execution of a Recursive Function 81
</p>
<p>Fig. 3.7 The Last Return from recSumFirstN
</p>
<p>The program terminates after printing the 10 to the screen and returning from
</p>
<p>the main function after line 12 and from the module after line 15. The importance
</p>
<p>of this example is to illustrate that each recursive call to recSumFirstN has its own
</p>
<p>copy of the variable n because it is local to the scope of the recSumFirstN function.
</p>
<p>Each time the function is called, the local variables and parameters are copied into
</p>
<p>the corresponding activation record. When a function call returns, the corresponding
</p>
<p>activation record is popped off the run-time stack. This is how a recursive function
</p>
<p>is executed.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>82 3 Recursion
</p>
<p>3.6 Recursion in Computer Graphics
</p>
<p>Recursion can be applied to lots of different problems including sorting, searching,
</p>
<p>drawing pictures, etc. The program given in Sect. 3.6.1 draws a spiral on the screen
</p>
<p>as shown in Fig. 3.8.
</p>
<p>3.6.1 Recursive Spiral
</p>
<p>1 import turtle
</p>
<p>2
</p>
<p>3 def drawSpiral(t, length, color, colorBase):
</p>
<p>4     #color is a 24 bit value that is changing a bit
</p>
<p>5     #each time for a nice color effect
</p>
<p>6     if length == 0:
</p>
<p>7         return
</p>
<p>8
</p>
<p>9     # add 2Ë†10 to the old color modulo 2Ë†24
</p>
<p>10     # the modulo 2Ë†24 prevents the color from
</p>
<p>11     # getting too big.
</p>
<p>12     newcolor = (int(color[1:],16) + 2**10)%(2**24)
</p>
<p>13
</p>
<p>14     # find the color base integer value
</p>
<p>15     base = int(colorBase[1:],16)
</p>
<p>16
</p>
<p>17     # now if the new color is less than the base
</p>
<p>18     # add the base modulo 2Ë†24.
</p>
<p>19     if newcolor &lt; base:
</p>
<p>20         newcolor = (newcolor + base)%(2**24)
</p>
<p>21
</p>
<p>22     # let newcolor be the hex string after conversion.
</p>
<p>23     newcolor = hex(newcolor)[2:]
</p>
<p>24
</p>
<p>25     # add a pound sign and zeroes to the front so it
</p>
<p>26     # is 6 characters long plus the pound sign for a
</p>
<p>27     # proper color string.
</p>
<p>28     newcolor = "#"+("0"*(6-len(newcolor)))+newcolor
</p>
<p>29
</p>
<p>30     t.color(newcolor)
</p>
<p>31     t.forward(length)
</p>
<p>32     t.left(90)
</p>
<p>33
</p>
<p>34     drawSpiral(t, length-1, newcolor, colorBase)
</p>
<p>35
</p>
<p>36 def main():
</p>
<p>37     t = turtle.Turtle()
</p>
<p>38     screen = t.getscreen()
</p>
<p>39     t.speed(100)
</p>
<p>40     t.penup()
</p>
<p>41     t.goto(-100,-100)
</p>
<p>42     t.pendown()
</p>
<p>43
</p>
<p>44     drawSpiral(t, 200, "#000000", "#ff00ff")
</p>
<p>45
</p>
<p>46     screen.exitonclick()
</p>
<p>47
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.6 Recursion in Computer Graphics 83
</p>
<p>Fig. 3.8 A Spiral Image
</p>
<p>48 if __name__ == "__main__":
</p>
<p>49     main()
</p>
<p>In this program the drawSpiral function is recursive. It has a base case that is
</p>
<p>written first: when the length of the side is zero it exits. It calls itself on something
</p>
<p>smaller: the new length passed to it is the old lengthminus one. The newcolor formula
</p>
<p>is perhaps the most complex part of the code. There is some slicing going on there to
</p>
<p>convert the color string from a hexadecimal string to an integer so 1024 can be added,
</p>
<p>modulo 2 to the 24th. Then it must be converted back to a hexadecimal color string
</p>
<p>with the &ldquo;#ffffff&rdquo; format. The program draws a spiral like the one pictured in Fig. 3.8.
</p>
<p>Notice that this recursive function does not return anything. Most recursive func-
</p>
<p>tions do return a value. This one does not because the purpose of the function is to
</p>
<p>draw a spiral. It has a side-effect instead of returning a value.
</p>
<p>3.7 Recursion on Lists and Strings
</p>
<p>Recursive functions can be written for many different purposes. Many problems
</p>
<p>can be solved by solving a simpler problem and then applying that simpler solution
</p>
<p>recursively. For instance, consider trying to write a function that returns the reverse
</p>
<p>of a list. If we wrote this non-recursively, we might write it as follows.
</p>
<p>3.7.1 List Recursion
</p>
<p>1 def revList(lst):
</p>
<p>2     accumulator = []
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>84 3 Recursion
</p>
<p>3
</p>
<p>4     for x in lst:
</p>
<p>5         accumulator = [x] + accumulator
</p>
<p>6
</p>
<p>7     return accumulator
</p>
<p>8
</p>
<p>9 def main():
</p>
<p>10     print(revList([1,2,3,4]))
</p>
<p>11
</p>
<p>12 if __name__ == "__main__":
</p>
<p>13     main()
</p>
<p>When run, this program prints [4, 3, 2, 1] to the screen. The code in Sect. 3.7.1
</p>
<p>uses the accumulator pattern to solve the problem of reversing a list. This is a pattern
</p>
<p>you have probably used before if you first learned to program imperatively. If we
</p>
<p>think about the problem recursively, we would first consider how to reverse a very
</p>
<p>simple list, say the empty list. The reverse of the empty list is just the empty list.
</p>
<p>Once we have solved the problem for a very simple list, we can assume that if
</p>
<p>we call a recursive reverse function on something smaller (i.e. a shorter list), it will
</p>
<p>work. So, then to complete a recursive solution, we have only to piece our solution
</p>
<p>together. A recursive solution to reversing a list is found in Sect. 3.7.2.
</p>
<p>3.7.2 Reversing a List
</p>
<p>1 def revList(lst):
</p>
<p>2     # Here is the base case
</p>
<p>3     if lst == []:
</p>
<p>4         return []
</p>
<p>5
</p>
<p>6     # The rest of this function is the recursive case.
</p>
<p>7     # This works because we called it on something smaller.
</p>
<p>8     # The lst[1:] is a slice of all but the first item in lst.
</p>
<p>9     restrev = revList(lst[1:])
</p>
<p>10     first = lst[0:1]
</p>
<p>11
</p>
<p>12     # Now put the pieces together.
</p>
<p>13     result = restrev + first
</p>
<p>14
</p>
<p>15     return result
</p>
<p>16
</p>
<p>17
</p>
<p>18 def main():
</p>
<p>19     print(revList([1,2,3,4]))
</p>
<p>20
</p>
<p>21 if __name__ == "__main__":
</p>
<p>22     main()
</p>
<p>You can write recursive functions that work with strings too. Strings and lists are
</p>
<p>both sequences. In the code of Sect. 3.7.2 we made sure we recursively called our
</p>
<p>function on something smaller. The same is true when working with strings. A string
</p>
<p>reverse function is given in Sect. 3.7.3.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.7 Recursion on Lists and Strings 85
</p>
<p>3.7.3 Reversing a String
</p>
<p>1 def revString(s):
</p>
<p>2     if s == "":
</p>
<p>3         return ""
</p>
<p>4
</p>
<p>5     restrev = revString(s[1:])
</p>
<p>6     first = s[0:1]
</p>
<p>7     # Now put the pieces together.
</p>
<p>8     result = restrev + first
</p>
<p>9
</p>
<p>10     return result
</p>
<p>11
</p>
<p>12
</p>
<p>13 def main():
</p>
<p>14     print(revString("hello"))
</p>
<p>15
</p>
<p>16 if __name__ == "__main__":
</p>
<p>17     main()
</p>
<p>Notice the similarity of these two functions. The functions are nearly identical.
</p>
<p>That&rsquo;s because the recursive definition of reverse did not change. The only change is
</p>
<p>that we must use the string concatenation operator instead of the list concatenation
</p>
<p>operator and the empty string instead of the empty list.
</p>
<p>3.7.4 Another Version of Reverse
</p>
<p>1 def revList2(lst):
</p>
<p>2
</p>
<p>3     def revListHelper(index):
</p>
<p>4         if index == -1:
</p>
<p>5             return []
</p>
<p>6
</p>
<p>7         restrev = revListHelper(index-1)
</p>
<p>8         first = [lst[index]]
</p>
<p>9
</p>
<p>10         # Now put the pieces together.
</p>
<p>11         result = first + restrev
</p>
<p>12
</p>
<p>13         return result
</p>
<p>14
</p>
<p>15     # this is the one line of code for the
</p>
<p>16     # revList2 function.
</p>
<p>17     return revListHelper(len(lst)-1)
</p>
<p>18
</p>
<p>19
</p>
<p>20 def main():
</p>
<p>21     print(revList2([1,2,3,4]))
</p>
<p>22
</p>
<p>23 if __name__ == "__main__":
</p>
<p>24     main()
</p>
<p>The examples in Sects. 3.7.2 and 3.7.3 used slicing to make the list or string
</p>
<p>smaller on each recursive call. It is possible to make a list or string smaller without
</p>
<p>actually making it physically smaller. Using an index to keep track of your position
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>86 3 Recursion
</p>
<p>within a list can serve to make the list or string smaller. In that case it may be helpful
</p>
<p>to write a function that calls a helper function to do the recursion. Consider the
</p>
<p>program in Sect. 3.7.4. This code uses a nested helper function called revListHelper
</p>
<p>to do the actual recursion. The list itself does not get smaller in the helper function.
</p>
<p>Instead, the index argument gets smaller, counting down to &minus;1 when the empty
</p>
<p>list is returned. The revList2 function contains only one line of code to call the
</p>
<p>revListHelper function.
</p>
<p>Because the revListHelper function is nested inside revList2 the helper func-
</p>
<p>tion is not visible to anything but the revList2 function since we don&rsquo;t want other
</p>
<p>programmers to call the helper function except by calling the revList2 function
</p>
<p>first.
</p>
<p>It is important to note that you don&rsquo;t have to physicallymake a list or string smaller
</p>
<p>to use it in a recursive function. As long as indexing is available to you, a recursive
</p>
<p>function can make use of an index into a list or string and the index can get smaller
</p>
<p>on each recursive call.
</p>
<p>One other thing to note. In this example the index gets smaller by approaching
</p>
<p>zero on each recursive call. There are other ways for the argument to the recursive
</p>
<p>function to get smaller. For instance, this example could be rewritten so the index
</p>
<p>grows toward the length of the list. In that case the distance between the index and
</p>
<p>the length of the list is the value that would get smaller on each recursive call.
</p>
<p>3.8 Using Type Reflection
</p>
<p>Many of the similarities in the two functions of Sects. 3.7.3 and 3.7.2 are due to
</p>
<p>operator overloading inPython. Pythonhas another very nice feature called reflection.
</p>
<p>Reflection refers to the ability for code to be able to examine attributes about objects
</p>
<p>that might be passed as parameters to a function. One interesting aspect of reflection
</p>
<p>is the ability to see what the type of an object is. If wewrite type(obj) then Pythonwill
</p>
<p>return an object which represents the type of obj. For instance, if obj is a reference to
</p>
<p>a string, then Python will return the str type object. Further, if we write str() we get
</p>
<p>a string which is the empty string. In other words, writing str() is the same thing as
</p>
<p>writing &ldquo;&rdquo;. Likewise, writing list() is the same thing aswriting []. Using reflection, we
</p>
<p>can write one recursive reverse function that will work for strings, lists, and any other
</p>
<p>sequence that supports slicing and concatenation. A recursive version of reverse that
</p>
<p>will reverse both strings and lists is provided in Sect. 3.8.1.
</p>
<p>3.8.1 Reflection Reverse
</p>
<p>1 def reverse(seq):
</p>
<p>2     SeqType = type(seq)
</p>
<p>3     emptySeq = SeqType()
</p>
<p>4
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.8 Using Type Reflection 87
</p>
<p>5     if seq == emptySeq:
</p>
<p>6         return emptySeq
</p>
<p>7
</p>
<p>8     restrev = reverse(seq[1:])
</p>
<p>9     first = seq[0:1]
</p>
<p>10
</p>
<p>11     # Now put the pieces together.
</p>
<p>12     result = restrev + first
</p>
<p>13
</p>
<p>14     return result
</p>
<p>15
</p>
<p>16
</p>
<p>17 def main():
</p>
<p>18     print(reverse([1,2,3,4]))
</p>
<p>19     print(reverse("hello"))
</p>
<p>20 if __name__ == "__main__":
</p>
<p>21     main()
</p>
<p>After writing the code in Sect. 3.8.1 we have a polymorphic reverse function that
</p>
<p>will work to reverse any sequence. It is polymorphic due to reflection and operator
</p>
<p>overloading. Pretty neat stuff!
</p>
<p>3.9 Chapter Summary
</p>
<p>In this chapter, you were introduced to some concepts that are important to your
</p>
<p>understanding of algorithms to be presented later in this text. Understanding how
</p>
<p>the run-time stack and the heap work to make it possible to call functions in our
</p>
<p>programs will make you a better programmer. Forming a mental model of how our
</p>
<p>code works makes it possible to predict what our code will do. Writing recursive
</p>
<p>functions is also a skill that is important to computer programmers. Here is what you
</p>
<p>should have learned in this chapter. You should:
</p>
<p>&bull; be able to identify the various scopes within a program.
</p>
<p>&bull; be able to identifywhich scope a variable reference belongs to: the local, enclosing,
</p>
<p>global, or built-in scope. Remember the LEGB rule.
</p>
<p>&bull; be able to trace the execution of a program by drawing a picture of the run-time
</p>
<p>stack and the heap for a program as it executes.
</p>
<p>&bull; be able to write a simple recursive function by writing a base case and a recursive
</p>
<p>case where the function is called with a smaller value.
</p>
<p>&bull; be able to trace the execution of a recursive function, showing the run-time stack
</p>
<p>and heap as it executes.
</p>
<p>&bull; understand a little about reflection as it relates to examining types in Python code.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>88 3 Recursion
</p>
<p>3.10 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. What is an interpreter?
</p>
<p>2. What is the Python interpreter called?
</p>
<p>3. When the Python interpreter sees an identifier, in which scope does it look for
</p>
<p>the identifier first?
</p>
<p>4. What order are the various scopes inspected to see where or if a variable is
</p>
<p>defined?
</p>
<p>5. Pick a sample program from among the programs you have written, preferably a
</p>
<p>short one, and identify three scopes within it by drawing a box around the scopes.
</p>
<p>6. When is an activation record pushed onto the run-time stack?
</p>
<p>7. When is an activation record popped from the run-time stack?
</p>
<p>8. What goes in the Heap in a computer?
</p>
<p>9. What goes in an activation record on the run-time stack?
</p>
<p>10. When writing a recursive function, what are the two cases for which you must
</p>
<p>write code?
</p>
<p>11. If a recursive function did not have a base case, what would happen when it was
</p>
<p>called?
</p>
<p>12. What must be true of the recursive call in a recursive function? In other words,
</p>
<p>what must you ensure when making this recursive call?
</p>
<p>13. What does the type function return in Python? If you call the type function in a
</p>
<p>program, what aspect of Python are you using?
</p>
<p>3.11 Programming Problems
</p>
<p>1. Write a recursive function called intpow that given a number, x, and an integer, n,
</p>
<p>will compute x ^ n. You must write this function recursively to get full credit. Be
</p>
<p>sure to put it in a program with several test cases to test that your function works
</p>
<p>correctly.
</p>
<p>2. Write a recursive function to compute the factorial of an integer. The factorial of
</p>
<p>0 is 1. The factorial of any integer, n, greater than zero is n times the factorial
</p>
<p>of n&minus;1. Write a program that tests your factorial function by asking the user to
</p>
<p>enter an integer and printing the factorial of that integer. Be sure your program
</p>
<p>has a main function. Comment your code with the base case and recursive case
</p>
<p>in your recursive function.
</p>
<p>3. Write a recursive function that computes the length of a string. You cannot use
</p>
<p>the len function while computing the length of the string. You must rely on the
</p>
<p>function you are writing. Put this function in a program that prompts the user to
</p>
<p>enter a string and then prints the length of that string.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>3.11 Programming Problems 89
</p>
<p>Fig. 3.9 A Tree
</p>
<p>4. Write a recursive function that takes a string like &ldquo;abcdefgh&rdquo; and returns &ldquo;bad-
</p>
<p>cfehg&rdquo;. Call this function swap since it swaps every two elements of the original
</p>
<p>string. Put this function in a program and call it with at least a few test cases.
</p>
<p>5. Write a recursive function that draws a tree. Call your function drawBranch. Pass
</p>
<p>it a turtle to draw with, an angle, and the number of littler branches to draw like
</p>
<p>the tree that appears in Fig. 3.9. Each time you recursively call this function you
</p>
<p>can decrease the number of branches and the angle. Each littler branch is drawn at
</p>
<p>some angle from the current branch so your function can change the angle of the
</p>
<p>turtle by turning left or right.When your number of branches gets to zero, you can
</p>
<p>draw a leaf as a little green square. If you make the width of the turtle line thicker
</p>
<p>for bigger branches and smaller for littler branches, you&rsquo;ll get a nice tree. You
</p>
<p>might write one more function called drawTree that will set up everything (except
</p>
<p>the turtle) to draw a nice tree. Put this function in a program that draws at least
</p>
<p>one tree. HINT: In your drawBranch function, after you have drawn the branch
</p>
<p>(and all sub-branches) you will want to return the turtle to the original position
</p>
<p>and direction you started at. This is necessary so after calling drawBranch you
</p>
<p>will know where the turtle is located. If you don&rsquo;t return it to its original position,
</p>
<p>the turtle will end up stranded out at a leaf somewhere.
</p>
<p>6. Write a recursive function that draws a circular spiral. To do this, you&rsquo;ll need
</p>
<p>to use polar coordinates. Polar coordinates are a way of specifying any point
</p>
<p>in the plane with an angle and a radius. Zero degrees goes to the right and the
</p>
<p>angles go counter-clockwise in a circle. With an angle and a radius, any point
</p>
<p>in the plane can be described. To convert an angle, a, and radius, r, from polar
</p>
<p>coordinates to Cartesian coordinates you would use sine and cosine. You must
</p>
<p>import the math module. Then x = r * math.cos (a) and y = r * math.sin (a).
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>90 3 Recursion
</p>
<p>The drawSpiral function will be given a radius for the sprial. To get a circular
</p>
<p>spiral, every recursive call to the drawSpiral function must decrease the radius
</p>
<p>just a bit and increase the angle. You convert the angle and the radius to its (x,y)
</p>
<p>coordinate equivalent and then draw a line to that location. You must also pass
</p>
<p>an (x,y) coordinate to the drawSpiral function for the center point of your spiral.
</p>
<p>Then, any coordinates you compute will be added to the center (x,y). You can
</p>
<p>follow the square spiral example in the text. Put this code in a program that draws
</p>
<p>a spiral to the screen.
</p>
<p>7. Write a program to gather performance data for the reverse function found in this
</p>
<p>chapter. Write an XML file in the plot format found in this text to visualize that
</p>
<p>performance data. Because this function is recursive, keep your data size small
</p>
<p>and just gather data for string sizes of 1&ndash;10. This will help you visualize your
</p>
<p>result. What is the complexity of this reverse function? Put a comment at the top
</p>
<p>of your program stating the complexity of reverse in big-Oh notation. Justify your
</p>
<p>answer by analyzing the code found in the reverse function.
</p>
<p>8. Rewrite the program in Sect. 3.7.4 to use an index that approaches the length
</p>
<p>of the list instead of an index that approaches zero. Then write a main function
</p>
<p>that thoroughly tests your new reverse function on lists. You must test it on both
</p>
<p>simple and more complex examples of lists to test it thoroughly.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4Sequences
</p>
<p>Computers are really good at dealing with large amounts of information. They can
</p>
<p>repeat a task over and over again without getting bored. When they repeat a task
</p>
<p>they are generally doing the same thing to similar data or objects. It is natural to
</p>
<p>want to organize those objects into some kind of structure so that our program can
</p>
<p>easily switch from one object to the next. How objects are added to a sequence or
</p>
<p>collection and how we move from one item to the next has some impact on how we
</p>
<p>might want to organize the collection of data in a program.
</p>
<p>In this chapter we look at different ways of organizing data into a sequence.
</p>
<p>We&rsquo;ll also examine how to use Python to make working with sequences convenient.
</p>
<p>Operator overloading in Python lets us build sequences that we can manipulate with
</p>
<p>intuitive operations. Finally, we&rsquo;ll also examine how the organization of a sequence
</p>
<p>affects the computation complexity of operations on it.
</p>
<p>An Abstract Data Type is a term that is used to describe a way of organizing data.
</p>
<p>Lists are one way of organizing a sequence of data, but in this chapter we&rsquo;ll discover
</p>
<p>other ways of organizing sequences as well. Ascending and descending sequences,
</p>
<p>linked lists, stacks, and queues are all abstract data types that we&rsquo;ll explore in this
</p>
<p>chapter.
</p>
<p>4.1 Chapter Goals
</p>
<p>In this chapter youwill read about differentways of organizing datawithin a program.
</p>
<p>By the end of the chapter you should be able to answer these questions.
</p>
<p>&bull; When presented with an algorithm that requires you to maintain a sequence of
</p>
<p>data, which organizational scheme fits best?
</p>
<p>&bull; What are the trade-offs of selecting one type of sequence as opposed to another?
</p>
<p>&bull; What are some interesting algorithms that use lists, linked lists, stacks, or queues?
</p>
<p>&bull; What sorting algorithm ismost commonly usedwhen sorting a sequence of ordered
</p>
<p>values?
</p>
<p>&bull; What search algorithms are possible in a sequence?
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_4
</p>
<p>91
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>92 4 Sequences
</p>
<p>&bull; What is the complexity of many of the common operations on sequences and how
</p>
<p>is that complexity affected by the underlying organization of the data.
</p>
<p>You will also be presented with a few interesting programming problems that will
</p>
<p>help you learn to select and use appropriate data structures to solve some interesting
</p>
<p>problems.
</p>
<p>4.2 Lists
</p>
<p>In the first and second chapter we developed a sequence called PyList. The PyList
</p>
<p>class is really just a repackaging of the Python list class. The example sequence
</p>
<p>demonstrates some of the operators that are supported by Python. In this section we
</p>
<p>want to look more deeply into how lists are implemented. There are many operations
</p>
<p>supported on lists. Chapter16 contains the full list. The table in Fig. 4.1 is a subset
</p>
<p>of the operations supported by lists.
</p>
<p>Each of the operations in the table has an associated complexity. The performance
</p>
<p>of an algorithm depends on the complexity of the operations used in implementing
</p>
<p>that algorithm. In the following sections we&rsquo;ll further develop our own list datatype,
</p>
<p>called PyList, using the built-in list only for setting and getting elements in a list. The
</p>
<p>indexed get and indexed set operations can be observed to haveO(1) complexity. This
</p>
<p>complexity is achieved because the memory of a computer is randomly accessible,
</p>
<p>which is why it is called Random Access Memory. In Chap.2 we spent some time
</p>
<p>demonstrating that each location within a list is accessible in the same amount of
</p>
<p>time regardless of list size and location being retrieved. In the following sections
</p>
<p>we&rsquo;ll enhance the PyList datatype to support the operations given in this table.
</p>
<p>Operation Complexity Usage Method
</p>
<p>List creation O(n) or O(1) x = list(y) calls __init__(y)
</p>
<p>indexed get O(1) a = x[i] x.__getitem__(i)
</p>
<p>indexed set O(1) x[i] = a x.__setitem__(i,a)
</p>
<p>concatenate O(n) z = x + y z = x.__add__(y)
</p>
<p>append O(1) x.append(a) x.append(a)
</p>
<p>insert O(n) x.insert(i,e) x.insert(i,e))
</p>
<p>delete O(n) del x[i] x.__delitem__(i)
</p>
<p>equality O(n) x == y x.__eq__(y)
</p>
<p>iterate O(n) for a in x: x.__iter__()
</p>
<p>length O(1) len(x) x.__len__()
</p>
<p>membership O(n) a in x x.__contains__(a)
</p>
<p>sort O(n log n) x.sort() x.sort()
</p>
<p>Fig. 4.1 Complexity of List Operations
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_16">http://dx.doi.org/10.1007/978-3-319-13072-9_16</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>4.2 Lists 93
</p>
<p>4.2.1 The PyList Datatype
</p>
<p>In the first couple of chapters we began developing our PyList data structure. To
</p>
<p>support the O(1) complexity of the append operation, the PyList contains empty
</p>
<p>locations that can be filled when append is called as first described in Sect. 2.10.
</p>
<p>We&rsquo;ll keep track of the number of locations being used and the actual size of the
</p>
<p>internal list in our PyList objects. So, we&rsquo;ll need three pieces of information: the list
</p>
<p>itself called items, the size of the internal list called size, and the number of locations
</p>
<p>in the internal list that are currently being used called numItems. While we wouldn&rsquo;t
</p>
<p>have to keep track of the size of the list, because we could call the len function, we&rsquo;ll
</p>
<p>store the size in the object to avoid the overhead of calling len in multiple places in
</p>
<p>the code.
</p>
<p>All the used locations in the internal list will occur at the beginning of the list. In
</p>
<p>other words, there will be no holes in the middle of a list that we will have to worry
</p>
<p>about. We&rsquo;ll call this assumption an invariant on our data structure. An invariant is
</p>
<p>something that is true before and after any method call on the data structure. The
</p>
<p>invariant for this list is that the internal list will have the first numItems filled with
</p>
<p>no holes. The code in Sect. 4.2.3 provides a constructor that can also be passed a list
</p>
<p>for its initial contents.
</p>
<p>Storing all the items at the beginning of the list, without holes, also means that
</p>
<p>we can randomly access elements of the list in O(1) time. We don&rsquo;t have to search
</p>
<p>for the proper location of an element. Indexing into the PyList will simply index into
</p>
<p>the internal items list to find the proper element as seen in the next sections.
</p>
<p>4.2.2 The PyList Constructor
</p>
<p>1     class PyList:
</p>
<p>2         def __init__(self,contents=[], size=10):
</p>
<p>3             # The contents allows the programmer to construct a list with
</p>
<p>4             # the initial contents of this value. The initial_size
</p>
<p>5             # lets the programmer pick a size for the internal size of the
</p>
<p>6             # list. This is useful if the programmer knows he/she is going
</p>
<p>7             # to add a specific number of items right away to the list.
</p>
<p>8             self.items = [None] * size
</p>
<p>9             self.numItems = 0
</p>
<p>10             self.size = size
</p>
<p>11
</p>
<p>12             for e in contents:
</p>
<p>13                 self.append(e)
</p>
<p>The code in Sect. 4.2.3 builds a PyList object by creating a list of 10 None values.
</p>
<p>None is the special value in Python for references that point at nothing. Figure4.2
</p>
<p>shows a sample list after it was created and three items were appended to it. The
</p>
<p>special None value is indicated in the figure by the three horizontal lines where
</p>
<p>the empty slots in the list point. The initial size of the internal items list is 10 by
</p>
<p>default, but a user could pass a larger size initially if they wanted to. This is only
</p>
<p>the initial size. The list will still grow when it needs to. The contents parameter lets
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>94 4 Sequences
</p>
<p>Fig. 4.2 A Sample Pylist Object
</p>
<p>the programmer pass in a list or sequence to put in the list initially. For instance, the
</p>
<p>object in Fig. 4.2 could have been created by writing the following.
</p>
<p>sampleList = PyList(["a", "b", "c"])
</p>
<p>Each element of the sequence is added as a separate list item. The complexity of
</p>
<p>creating a PyList object is O(1) if no value is passed to the constructor and O(n) if
</p>
<p>a sequence is passed to the constructor, where n is the number of elements in the
</p>
<p>sequence.
</p>
<p>4.2.3 PyList Get and Set
</p>
<p>1 def __getitem__(self,index):
</p>
<p>2     if index &gt;= 0 and index &lt; self.numItems:
</p>
<p>3         return self.items[index]
</p>
<p>4
</p>
<p>5     raise IndexError("PyList index out of range")
</p>
<p>6
</p>
<p>7 def __setitem__(self,index,val):
</p>
<p>8     if index &gt;= 0 and index &lt; self.numItems:
</p>
<p>9         self.items[index] = val
</p>
<p>10         return
</p>
<p>11
</p>
<p>12     raise IndexError("PyList assignment index out of range")
</p>
<p>Our PyList class is a wrapper for the built-in list class. So, to implement the get
</p>
<p>item and set item operations on PyList, we&rsquo;ll use the get and set operations on the
</p>
<p>built-in list class. The code is given here. The complexity of both operations is O(1).
</p>
<p>In both cases, we want to make sure the index is in the range of acceptable indices.
</p>
<p>If it is not, we&rsquo;ll raise an IndexError exception just as the built-in list class does.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.2 Lists 95
</p>
<p>4.2.4 PyList Concatenate
</p>
<p>1 def __add__(self,other):
</p>
<p>2     result = PyList(size=self.numItems+other.numItems)
</p>
<p>3
</p>
<p>4     for i in range(self.numItems):
</p>
<p>5         result.append(self.items[i])
</p>
<p>6
</p>
<p>7     for i in range(other.numItems):
</p>
<p>8         result.append(other.items[i])
</p>
<p>9
</p>
<p>10     return result
</p>
<p>To concatenate two lists we must build a new list that contains the contents of
</p>
<p>both. This is an accessor method because it does not mutate either list. Instead, it
</p>
<p>builds a new list. We can do this operation in O(n) time where n is the sum of the
</p>
<p>lengths of the two lists. Here is some code to accomplish this.
</p>
<p>In Sect. 4.2.5 the size is set to the needed size for the result of concatenating the
</p>
<p>two lists. The complexity of the __add__ method is O(n) where n is the length of the
</p>
<p>two lists. The initial size of the list does not have to be set because append has O(1)
</p>
<p>complexity as we saw in Sect. 2.10. However, since we know the size of the resulting
</p>
<p>list, setting the initial size should speed up the concatenation operation slightly.
</p>
<p>4.2.5 PyList Append
</p>
<p>1 # This method is hidden since it starts with two underscores.
</p>
<p>2 # It is only available to the class to use.
</p>
<p>3 def __makeroom(self):
</p>
<p>4     # increase list size by 1/4 to make more room.
</p>
<p>5     # add one in case for some reason self.size is 0.
</p>
<p>6     newlen = (self.size // 4) + self.size + 1
</p>
<p>7     newlst = [None] * newlen
</p>
<p>8     for i in range(self.numItems):
</p>
<p>9         newlst[i] = self.items[i]
</p>
<p>10
</p>
<p>11     self.items = newlst
</p>
<p>12     self.size = newlen
</p>
<p>13
</p>
<p>14 def append(self,item):
</p>
<p>15     if self.numItems == self.size:
</p>
<p>16         self.__makeroom()
</p>
<p>17
</p>
<p>18     self.items[self.numItems] = item
</p>
<p>19     self.numItems += 1 # Same as writing self.numItems = self.numItems + 1
</p>
<p>In Sect. 2.10 we learned that the append method has O(1) amortized complexity.
</p>
<p>When appending, we will just add one more item to the end of the self.items list if
</p>
<p>there is room. In the description of the constructor we decided the PyList objects
</p>
<p>would contain a list that had room for more elements. When appending we can make
</p>
<p>use of that extra space. Once in a while (i.e. after appending some number of items),
</p>
<p>the internal self.items list will fill up. At that time we must increase the size of the
</p>
<p>items list to make room for the new item we are appending by a size proportional to
</p>
<p>the current length of self.items.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>96 4 Sequences
</p>
<p>As we learned in Chap.2, to make the append operation run in O(1) time we can&rsquo;t
</p>
<p>just add one more location each time we need more space. It turns out that adding
</p>
<p>25% more space each time is enough to guarantee O(1) complexity. The choice of
</p>
<p>25% is not significant. If we added even 10% more space each time we would get
</p>
<p>O(1) complexity. At the other extremewe could double the internal list size each time
</p>
<p>we neededmore room as we did in Sect. 2.10. However, 25% seems like a reasonable
</p>
<p>amount to expand the list without gobbling up too much memory in the computer.
</p>
<p>We just need a few more cyber dollars stored up for each append operation to pay
</p>
<p>for expanding the list when we run out of room. The code in Sect. 4.2.6 implements
</p>
<p>the append operation with an amortized complexity of O(1). Integer division by 4 is
</p>
<p>very quick in a computer because it can be implemented by shifting the bits of the
</p>
<p>integer to the right, so computing our new length, when needed, is relatively quick.
</p>
<p>ThePython interpreter implements append in a similarway.ThePython interpreter
</p>
<p>is implemented in C, so the interpreter uses C code. Python also chooses to increase
</p>
<p>the list size by other values. In Python list sizes increase by 4, 8, 16, 25, and so on.
</p>
<p>The additional space to add to the internal list is calculated from the newly needed
</p>
<p>size of the list and grows by 4, 8, 16, 25, 35, 46, 58, 72, 88, and so on. You can
</p>
<p>see that the amount to add grows as the list grows and that leads to an amortized
</p>
<p>complexity of O(1) for the append operation in the Python interpreter.
</p>
<p>4.2.6 PyList Insert
</p>
<p>1 def insert(self,i,e):
</p>
<p>2     if self.numItems == self.size:
</p>
<p>3         self.__makeroom()
</p>
<p>4
</p>
<p>5     if i &lt; self.numItems:
</p>
<p>6         for j in range(self.numItems-1,i-1,-1):
</p>
<p>7             self.items[j+1] = self.items[j]
</p>
<p>8
</p>
<p>9         self.items[i] = e
</p>
<p>10         self.numItems += 1
</p>
<p>11     else:
</p>
<p>12         self.append(e)
</p>
<p>To insert into this sequential list we must make room for the new element. Given
</p>
<p>the way the list is organized, there is no choice but to copy each element after the
</p>
<p>point where we want to insert the new value to the next location in the list. This
</p>
<p>works best if we start from the right end of the list and work our way back to the
</p>
<p>point where the new value will be inserted. The complexity of this operation is O(n)
</p>
<p>where n is the number of elements in the list after the insertion point.
</p>
<p>The index i is the location where the new value e is to be inserted. If the index pro-
</p>
<p>vided is larger than the size of the list the new item, e, is appended to the end of the list.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>4.2 Lists 97
</p>
<p>4.2.7 PyList Delete
</p>
<p>1 def __delitem__(self,index):
</p>
<p>2     for i in range(index, self.numItems-1):
</p>
<p>3         self.items[i] = self.items[i+1]
</p>
<p>4     self.numItems -= 1 # same as writing self.numItems = self.numItems - 1
</p>
<p>When deleting an item at a specific index in the list, we must move everything
</p>
<p>after the item down to preserve our invariant that there are no holes in the internal list.
</p>
<p>This results in a O(n) implementation in the average and worst case where n is the
</p>
<p>number of items after the index in the list. Here is code that accomplishes deletion.
</p>
<p>In the Python interpreter, to conserve space, if a list reaches a point after deletion
</p>
<p>where less than half of the locations within the internal list are being used, then the
</p>
<p>size of the available space is reduced by one half.
</p>
<p>4.2.8 PyList Equality Test
</p>
<p>1 def __eq__(self,other):
</p>
<p>2     if type(other) != type(self):
</p>
<p>3         return False
</p>
<p>4
</p>
<p>5     if self.numItems != other.numItems:
</p>
<p>6         return False
</p>
<p>7
</p>
<p>8     for i in range(self.numItems):
</p>
<p>9         if self.items[i] != other.items[i]:
</p>
<p>10             return False
</p>
<p>11
</p>
<p>12     return True
</p>
<p>Checking for equality of two lists requires the two lists be of the same type. If
</p>
<p>they are of different types, then we&rsquo;ll say they are not equal. In addition, the two lists
</p>
<p>must have the same length. If they are not the same length, they cannot be equal. If
</p>
<p>these two preconditions are met, then the lists are equal if all the elements in the two
</p>
<p>lists are equal. Here is code that implements equality testing of two PyList objects.
</p>
<p>Equality testing is a O(n) operation.
</p>
<p>4.2.9 PyList Iteration
</p>
<p>1 def __iter__(self):
</p>
<p>2     for i in range(self.numItems):
</p>
<p>3         yield self.items[i]
</p>
<p>The ability to iterate over a sequence is certainly a requirement. Sequences hold
</p>
<p>a collection of similar data items and we frequently want to do something with each
</p>
<p>item in a sequence. Of course, the complexity of iterating over any sequence is O(n)
</p>
<p>where n is the size of the sequence. Here is code that accomplishes this for the PyList
</p>
<p>sequence. The yield call in Python suspends the execution of the __iter__ method
</p>
<p>and returns the yielded item to the iterator.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>98 4 Sequences
</p>
<p>4.2.10 PyList Length
</p>
<p>1 def __len__(self):
</p>
<p>2     return self.numItems
</p>
<p>If the number of itemswere not kept trackofwithin thePyList object, then counting
</p>
<p>the number of items in the list would be a O(n) operation. Instead, if we keep track of
</p>
<p>the number of items in the list as items are appended or deleted from the list, then we
</p>
<p>need only return the value of numItems from the object, resulting inO(1) complexity.
</p>
<p>4.2.11 PyList Membership
</p>
<p>1 def __contains__(self,item):
</p>
<p>2     for i in range(self.numItems):
</p>
<p>3         if self.items[i] == item:
</p>
<p>4             return True
</p>
<p>5
</p>
<p>6     return False
</p>
<p>Testing for membership in a list means checking to see if an item is one of the
</p>
<p>items in the list. The only way to do this is to examine each item in sequence in
</p>
<p>the list. If the item is found then True is returned, otherwise False is returned. This
</p>
<p>results in O(n) complexity.
</p>
<p>This idea of searching for an item in a sequence is so common that computer
</p>
<p>scientists have named it. This is called linear search. It is named this because of its
</p>
<p>O(n) complexity.
</p>
<p>4.2.12 PyList String Conversion
</p>
<p>1 def __str__(self):
</p>
<p>2     s = "["
</p>
<p>3     for i in range(self.numItems):
</p>
<p>4         s = s + repr(self.items[i])
</p>
<p>5         if i &lt; self.numItems - 1:
</p>
<p>6             s = s + ", "
</p>
<p>7     s = s + "]"
</p>
<p>8     return s
</p>
<p>It is convenient to be able to convert a list to a string so it can be printed. Python
</p>
<p>includes two methods that can be used for converting to a string. The first you are
</p>
<p>probably already familiar with. The str function calls the __str__ method on an
</p>
<p>object to create a string representation of itself suitable for printing. Here is code
</p>
<p>that implements the __str__ method for the PyList class.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.2 Lists 99
</p>
<p>4.2.13 PyList String Representation
</p>
<p>1 def __repr__(self):
</p>
<p>2     s = "PyList(["
</p>
<p>3     for i in range(self.numItems):
</p>
<p>4         s = s + repr(self.items[i])
</p>
<p>5         if i &lt; self.numItems - 1:
</p>
<p>6             s = s + ", "
</p>
<p>7     s = s + "])"
</p>
<p>8     return s
</p>
<p>The other method for converting an object to a string has a different purpose.
</p>
<p>Python includes a function called eval that will take a string containing an expres-
</p>
<p>sion and evaluate the expression in the string. For instance, eval(&ldquo;6+5&rdquo;) results in
</p>
<p>11 and eval(&ldquo;[1,2,3]&rdquo;) results in the list [1,2,3]. The repr function in Python calls the
</p>
<p>__repr__ method on a class. This method, if defined, should return a string represen-
</p>
<p>tation of an object that is suitable to be given to the eval function. In the case of the
</p>
<p>PyList class, the repr form of the stringwould be something like &ldquo;PyList([1,2,3])&rdquo; for
</p>
<p>the PyList sequence containing these items. Here is the code that accomplishes this.
</p>
<p>It is nearly identical to the __str__ code, except that PyList prefixes the sequence.
</p>
<p>Notice that in both Sects. 4.2.13 and 4.2.14 that repr is called on the elements
</p>
<p>of the list. Calling repr is necessary because otherwise a list containing strings like
</p>
<p>[&rdquo;hi&rdquo;,&rdquo;there&rdquo;] would be converted to [hi,there] in its str or repr representation.
</p>
<p>4.3 Cloning Objects
</p>
<p>It is interesting to note that we now have a method of making a copy of an object.
</p>
<p>If x is a PyList object, then eval(repr(x)) is a copy or clone of this object. Since all
</p>
<p>the items in the PyList object are also cloned by evaluating the representation of the
</p>
<p>object, cloning an object like this is called a deep clone or deep copy of the object x.
</p>
<p>It is also possible to make what is called a shallow copy of an object. A shallow
</p>
<p>copy occurs when the object is copied, but items in the object are shared with the
</p>
<p>clone. If we wish to create a shallow copy of a PyList object called x, we would write
</p>
<p>the following.
</p>
<p>x = PyList([1,2,3])
</p>
<p>y = PyList(x)
</p>
<p>Here, y is a shallow copy of x because both x and y share the items 1, 2, and 3.
</p>
<p>In most cases whether some items are shared or not probably doesn&rsquo;t matter. In
</p>
<p>this case it doesn&rsquo;t matter if items are shared because 1, 2, and 3 are integers and
</p>
<p>integers are immutable. However, if the shared items are mutable, then you may care
</p>
<p>about shallow or deep clones of objects. When working with a shallow clone of an
</p>
<p>object that contains mutable items the programmer must be aware that the items in
</p>
<p>the collection might change values without any call to a method on the object. This
</p>
<p>won&rsquo;t happen to a deep clone of an object.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>100 4 Sequences
</p>
<p>Which is better, shallow cloning or deep cloning, depends on the application
</p>
<p>being written. One is not necessarily better than the other. There is an additional
</p>
<p>performance and memory hit for making deep clones but they are safer. The type of
</p>
<p>application being developed will probably help determine which type of cloning is
</p>
<p>chosen should clones of objects be useful in the application.
</p>
<p>4.4 ItemOrdering
</p>
<p>Now let us turn our attention to implementing the sort method on our PyList data
</p>
<p>type. To sort a sequence of items, the items in the sequence must be ordered in some
</p>
<p>way. For instance, consider a class that is used to represent Cartesian coordinates
</p>
<p>on a plane. We&rsquo;ll call the class Point and it will contain an (x,y) pair. We&rsquo;ll order
</p>
<p>the point objects by their directed distance from the x axis. In other words, they will
</p>
<p>be ordered by their y-coordinates. Here is our Point class. For reasons that will be
</p>
<p>obvious soon, our Point class will inherit from RawTurtle.
</p>
<p>4.4.1 The Point Class
</p>
<p>1     class Point(turtle.RawTurtle):
</p>
<p>2         def __init__(self, canvas, x, y):
</p>
<p>3             super().__init__(canvas)
</p>
<p>4             canvas.register_shape("dot",((3,0),(2,2),(0,3),(-2,2),(-3,0),(-2,-2),(0,-3), 
</p>
<p>5             (2,-2)))
</p>
<p>6             self.shape("dot")
</p>
<p>7             self.speed(200)
</p>
<p>8             self.penup()
</p>
<p>9             self.goto(x,y)
</p>
<p>10
</p>
<p>11         def __str__(self):
</p>
<p>12             return "("+str(self.xcor())+","+str(self.ycor())+")"
</p>
<p>13
</p>
<p>14         def __lt__(self, other):
</p>
<p>15             return self.ycor() &lt; other.ycor()
</p>
<p>Objects of the Point class have an ordering because we have defined the less than
</p>
<p>operator (i.e. &lt;) by writing an __lt__ method in the class. Once defined, this less
</p>
<p>than operator orders all the elements of the class. Most of the built-in classes or
</p>
<p>types in Python already have an implementation for the __lt__ method so we don&rsquo;t
</p>
<p>have to define this method for types like int, float, and str. Strings are compared
</p>
<p>lexicographically in Python as they are in pretty much every language that supports
</p>
<p>string comparison. Lexicographic ordering means that strings are compared from
</p>
<p>left to right until one character is found to be different than the character at the
</p>
<p>corresponding position in the other string. In other words, sorting a sequence of
</p>
<p>strings means they will end up alphabetized like you would see in a dictionary.
</p>
<p>Under some conditions lists are orderable, too. For lists to have an ordering, the
</p>
<p>elements at corresponding indices within the lists must be orderable. Consider these
</p>
<p>sample comparisons.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.4 Item Ordering 101
</p>
<p>1     Python 3.2 (r32:88452, Feb 20 2011, 10:19:59)
</p>
<p>2     [GCC 4.0.1 (Apple Inc. build 5493)]
</p>
<p>3     Type "help", "copyright", "credits" or "license" for more information.
</p>
<p>4     [evaluate untitled-3.py]
</p>
<p>5     lst = [1,2,3]
</p>
<p>6     lst2 = list("abc")
</p>
<p>7     lst2
</p>
<p>8     [&rsquo;a&rsquo;, &rsquo;b&rsquo;, &rsquo;c&rsquo;]
</p>
<p>9     lst &lt; lst2
</p>
<p>10     Traceback (most recent call last):
</p>
<p>11       File "&lt;string&gt;", line 1, in &lt;fragment&gt;
</p>
<p>12     builtins.TypeError: unorderable types: int() &lt; str()
</p>
<p>13     lst3 = [4,5,6]
</p>
<p>14     lst &lt; lst3
</p>
<p>15     True
</p>
<p>16     lst4 = [1,3,2]
</p>
<p>17     lst &lt; lst4
</p>
<p>18     True
</p>
<p>19     lst5 = [1,2,2]
</p>
<p>20     lst5 &lt; lst
</p>
<p>21     True
</p>
<p>22     lst6 = [1,1,&rsquo;a&rsquo;]
</p>
<p>23     lst6 &lt; lst
</p>
<p>24     True
</p>
<p>Comparing lst and lst2 did not work because the items in the two lists are not
</p>
<p>orderable. You can&rsquo;t compare an integer and a string. However, two lists with
</p>
<p>similar elements can be compared. List comparison is performed lexicographi-
</p>
<p>cally like strings. Note the last example. The two lists [1,2,3] and [1,1,&lsquo;a&rsquo;] can be
</p>
<p>compared because the lexicographical ordering does not require that 3 and &lsquo;a&rsquo; be
</p>
<p>compared.
</p>
<p>There are some types in Python which have no natural ordering. For instance,
</p>
<p>there is no natural ordering for dictionaries in Python. You cannot sort a list of
</p>
<p>dictionaries. Of course, its unclear why you would want to as well. Since there is no
</p>
<p>natural ordering there doesn&rsquo;t seem to be a reason to sort them. However, if there
</p>
<p>were a way to create an ordering on a set of dictionaries you could define it yourself
</p>
<p>by writing your own class that inherited from the dict class and defining its own
</p>
<p>__lt__ method just as we did for the Point class.
</p>
<p>Once we have an ordering of elements in a list, we can sort the elements according
</p>
<p>to that ordering. Lists have a sort method that will sort the items of a list according
</p>
<p>to their ordering. The code in Sect. 4.4.2 illustrates how the items of a list can be
</p>
<p>sorted.
</p>
<p>4.4.2 Calling the Sort Method
</p>
<p>1     def main():
</p>
<p>2         t = turtle.Turtle()
</p>
<p>3         t.ht()
</p>
<p>4         screen = t.getscreen()
</p>
<p>5         lst = []
</p>
<p>6
</p>
<p>7         for i in range(10):
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>102 4 Sequences
</p>
<p>8             for j in range(10):
</p>
<p>9                 pair = Point(screen,i,j)
</p>
<p>10                 lst.append(pair)
</p>
<p>11
</p>
<p>12         lst.sort()
</p>
<p>13
</p>
<p>14         for p in lst:
</p>
<p>15             print(p)
</p>
<p>When the code in Sect. 4.4.2 is called it prints the points in order of their distance
</p>
<p>from the x-axis as follows.
</p>
<p>(0,0)
</p>
<p>(1,0)
</p>
<p>(2,0)
</p>
<p>(3,0)
</p>
<p>(4,0)
</p>
<p>(5,0)
</p>
<p>(6,0)
</p>
<p>(7,0)
</p>
<p>(8,0)
</p>
<p>(9,0)
</p>
<p>(0,1)
</p>
<p>(1,1)
</p>
<p>(2,1)
</p>
<p>(3,1)
</p>
<p>(4,1)
</p>
<p>(5,1)
</p>
<p>(6,1)
</p>
<p>(7,1)
</p>
<p>...
</p>
<p>But, just how does this sort methodwork andwhat is its cost? In other words, what
</p>
<p>kind of sorting algorithm does Python use and what is its computational complexity?
</p>
<p>We explore these questions in the next sections.
</p>
<p>4.5 Selection Sort
</p>
<p>In the last section we learned that we can call a method called sort on a list to sort the
</p>
<p>items in the list in ascending order. Ascending order is determined by the less than
</p>
<p>operator as defined on the items. So how does the sorting algorithm work. One of
</p>
<p>the early sorting algorithms was called Selection Sort and it serves as a good starting
</p>
<p>place to understand sorting algorithms. However, this is not the sorting algorithm
</p>
<p>used by Python. We&rsquo;ll find out why soon.
</p>
<p>The selection sort algorithm is pretty simple to describe. The algorithm begins
</p>
<p>by finding the smallest value to place in the first position in the list. It does this by
</p>
<p>doing a linear search through the list and along the way remembering the index of
</p>
<p>the smallest item it finds. The algorithm uses the guess and check pattern by first
</p>
<p>guessing that the smallest item is the first item in the list and then checking the
</p>
<p>subsequent items to see if it made an incorrect guess. This part of the algorithm is
</p>
<p>the selection part. The select function does this selection.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.5 Selection Sort 103
</p>
<p>4.5.1 Selection Sort&rsquo;s Select Function
</p>
<p>1     def select(seq, start):
</p>
<p>2         minIndex = start
</p>
<p>3
</p>
<p>4         for j in range(start+1, len(seq)):
</p>
<p>5             if seq[minIndex] &gt; seq[j]:
</p>
<p>6                 minIndex = j
</p>
<p>7
</p>
<p>8         return minIndex
</p>
<p>The start argument tells the select function where to start looking for the smallest
</p>
<p>item. It searches from start to the end of the sequence for the smallest item.
</p>
<p>The selection sort algorithm works by finding the smallest item using the select
</p>
<p>function and placing that item into the first position of the sequence. Now the value in
</p>
<p>the first position must be put someplace else. It is simply swapped with the location
</p>
<p>of the value that is being moved. The algorithm proceeds by next looking for the
</p>
<p>second smallest value in the sequence. Since the smallest value is now in the first
</p>
<p>location in the sequence, the selection sort algorithm starts looking from the second
</p>
<p>position in the list for the smallest value. When the smallest value is found (which
</p>
<p>is really the second smallest value for the list) the value in the second position and
</p>
<p>this value are swapped. Then the selection sort algorithm looks for the smallest item
</p>
<p>starting at the third location in the sequence. This pattern repeats until all the items
</p>
<p>in the sequence have been sorted. The selSort function does the actual sorting for
</p>
<p>the algorithm.
</p>
<p>4.5.2 The Selection Sort Code
</p>
<p>1     def selSort(seq):
</p>
<p>2         for i in range(len(seq)-1):
</p>
<p>3             minIndex = select(seq, i)
</p>
<p>4             tmp = seq[i]
</p>
<p>5             seq[i] = seq[minIndex]
</p>
<p>6             seq[minIndex] = tmp
</p>
<p>We can visualize the selection sort algorithm by running an animation of it sorting.
</p>
<p>The animation is pictured in Fig. 4.3 having sorted more than half the values in a
</p>
<p>sequence. The green dots represent items that are now in their proper location in the
</p>
<p>sequence. The height of the dot from the x-axis (i.e. the y-value) is its value. The
</p>
<p>x-axis is the position in the list. In this animation all the values between 0 and 199
</p>
<p>are being sorted into ascending order. The upper-right corner represents those values
</p>
<p>that have not yet been sorted. The algorithm starts looking for the next smallest value
</p>
<p>just to the right of the green diagonal line. It finds the minimum value (i.e. closest
</p>
<p>to the x-axis) by going through all the remaining unsorted dots. Once it finds the
</p>
<p>small, shortest dot, it swaps it with the left-most dot to put it into is sorted position
</p>
<p>in the list. The complete code for this animation is given in Sect. 20.3 and can be
</p>
<p>downloaded from the website accompanying this text. Try it out!
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>104 4 Sequences
</p>
<p>Fig. 4.3 Selection Sort Snapshot
</p>
<p>Consider sorting the list [5 8 2 6 9 1 0 7] as depicted in Fig. 4.4. After each call
</p>
<p>of the select function from the selSort function the next element of the list is placed
</p>
<p>in its final location. Sorting the list leads to the intermediate steps as shown. Each
</p>
<p>time the select function is called the new smallest element is swapped with the first
</p>
<p>location in the rest of the list to move the next smallest element into its location
</p>
<p>within the sorted list.
</p>
<p>To find each new smallest element we call select which must run through the rest
</p>
<p>of the list looking for the minimum element. After each pass the list in Fig. 4.4 is one
</p>
<p>item closer to sorting the whole list. It turns out that this early attempt at writing a
</p>
<p>sorting algorithm is not that great. The complexity of this algorithm is O(n2) because
</p>
<p>each time through the for loop in the selSort function we call the select function
</p>
<p>which has its own for loop. The for i loop is executed n times and each time it is
</p>
<p>executed the for j loop must go through one less item looking for the smallest value
</p>
<p>that is left to be sorted. So, the first time we execute the body of the for j loop n &minus; 1
</p>
<p>times, then n &minus; 2 times the second time select is called, then n &minus; 3 times and so on.
</p>
<p>We have seen this pattern before. The sum of the first n integers has an n2 term in its
</p>
<p>formula. Therefore, selection sort is O(n2). This means as we try to sort some larger
</p>
<p>lists the algorithm will really start to slow down. You should never use this algorithm
</p>
<p>for sorting. Even on small lists we can do much better.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.6 Merge Sort 105
</p>
<p>Fig. 4.4 Selection Sort of a List
</p>
<p>4.6 Merge Sort
</p>
<p>Divide and conquer, as the ancient Romans might have said, is an effective battle
</p>
<p>strategy. It turns out this concept is very important when writing algorithms. The
</p>
<p>Merge Sort algorithm is one instance of a divide and conquer algorithm. Divide and
</p>
<p>conquer algorithms are usually written recursively, but don&rsquo;t necessarily have to be.
</p>
<p>The basic premise is that we divide a problem into two pieces. Each of the two pieces
</p>
<p>is easier to solve than trying to tackle the whole problem at once because the two
</p>
<p>pieces are each smaller.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>106 4 Sequences
</p>
<p>4.6.1 TheMerge Sort Code
</p>
<p>1 def merge(seq, start, mid, stop):
</p>
<p>2     lst = []
</p>
<p>3     i = start
</p>
<p>4     j = mid
</p>
<p>5
</p>
<p>6     # Merge the two lists while each has more elements
</p>
<p>7     while i &lt; mid and j &lt; stop:
</p>
<p>8         if seq[i] &lt; seq[j]:
</p>
<p>9             lst.append(seq[i])
</p>
<p>10             i+=1
</p>
<p>11         else:
</p>
<p>12             lst.append(seq[j])
</p>
<p>13             j+=1
</p>
<p>14
</p>
<p>15     # Copy in the rest of the start to mid sequence
</p>
<p>16     while i &lt; mid:
</p>
<p>17         lst.append(seq[i])
</p>
<p>18         i+=1
</p>
<p>19     # Many merge sort implementations copy the rest
</p>
<p>20     # of the sequence from j to stop at this point.
</p>
<p>21     # This is not necessary since in the next part
</p>
<p>22     # of the code the same part of the sequence would
</p>
<p>23     # be copied right back to the same place.
</p>
<p>24     # while j &lt; stop:
</p>
<p>25     #    lst.append(seq[j])
</p>
<p>26     #    j+=1
</p>
<p>27     # Copy the elements back to the original sequence
</p>
<p>28     for i in range(len(lst)):
</p>
<p>29         seq[start+i]=lst[i]
</p>
<p>30
</p>
<p>31 def mergeSortRecursively(seq, start, stop):
</p>
<p>32     # We must use &gt;= here only when the sequence we are sorting
</p>
<p>33     # is empty. Otherwise start == stop-1 in the base case.
</p>
<p>34     if start &gt;= stop-1:
</p>
<p>35         return
</p>
<p>36
</p>
<p>37     mid = (start + stop) // 2
</p>
<p>38
</p>
<p>39     mergeSortRecursively(seq, start, mid)
</p>
<p>40     mergeSortRecursively(seq, mid, stop)
</p>
<p>41     merge(seq, start, mid, stop)
</p>
<p>42
</p>
<p>43 def mergeSort(seq):
</p>
<p>44     mergeSortRecursively(seq, 0, len(seq))
</p>
<p>The merge sort algorithm takes this divide and conquer strategy to the extreme. It
</p>
<p>divides the list, then divides it again and again, until we are left with lists of size 1.
</p>
<p>A sublist of length 1 is already sorted. Two sorted sublists can be merged into one
</p>
<p>sorted list in O(n) time. A list can be divided into lists of size 1 by repeatedly splitting
</p>
<p>in O(log n) time. Each of the split lists are then merged together in O(n) time. This
</p>
<p>results in a complexity of O(n log n) for merge sort. The merge sort code appears in
</p>
<p>Sect. 4.6.1.
</p>
<p>The merge function takes care of merging two adjacent sublists. The first sublist
</p>
<p>runs from start to mid-1. The second sublist runs from mid to stop-1. The elements
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.6 Merge Sort 107
</p>
<p>of the two sorted sublists are copied, in O(n) time, to a new list. Then the sorted list is
</p>
<p>copied back into the original sequence, again in O(n) time. In the merge function, the
</p>
<p>first while loop takes care of merging the two sublists until one or the other sublist is
</p>
<p>empty. The second and third while loops take care of finishing up whichever sublist
</p>
<p>had the left-over elements. Only one sublist will have left-over elements so only one
</p>
<p>condition on the second and third while loops will ever be true.
</p>
<p>Notice that the third while loop in the code is commented out. Copying elements
</p>
<p>from j to stop in the third while loop is not necessary since they would only be copied
</p>
<p>right back to the same place when the contents of lst are copied back to the seq
</p>
<p>sequence. This optimization speeds up merge sort a little bit. One other optimization
</p>
<p>is to pre-allocate one more list in which to copy values and then alternate between
</p>
<p>merging in the original and the pre-allocated copy. In this way the overhead of
</p>
<p>creating and appending to lists is avoided. Coding either of these two optimizations
</p>
<p>does not improve the computational complexity of the algorithm, but can improve
</p>
<p>its overall performance slightly. One criticism of the merge sort algorithm is that
</p>
<p>the elements of the two sublists cannot be merged without copying to a new list and
</p>
<p>then back again. Other sorting methods, like Quicksort, have the same O(n log n)
</p>
<p>complexity as merge sort and do not require an extra list.
</p>
<p>The mergeSort function calls a helper function to get everything started. It calls
</p>
<p>mergeSortRecursively function with the sequence and the start and stop values which
</p>
<p>indicate the entire list should be sorted. The start and stop parameters are used when
</p>
<p>splitting the list. The list is not physically split when calling mergeSortRecursively.
</p>
<p>Instead, the start and stop values are used to compute themid point between them and
</p>
<p>then the two halves are recursively sorted. Since each sublist is smaller, we can rest
</p>
<p>assured that the recursive call does its job and sorts the two sublists. Then we are left
</p>
<p>to merge the two sorted sublists by calling the merge function. The base case for the
</p>
<p>recursive function is when the sublist size is 1. At that point we have a sorted sublist.
</p>
<p>In Fig. 4.5 the entire left half of the list has been sorted. In addition, three sublists
</p>
<p>in the right half have been sorted and the third and fourth sublist are in the process of
</p>
<p>being merged together. The green dots represent the portions of the sequence that are
</p>
<p>sorted and the black dots indicate the unsorted portion of the original sequence. The
</p>
<p>red lines at the bottom reflect the recursive calls that are currently on the run-time
</p>
<p>stack. The length of the red line shows the portion of the sequence that is being
</p>
<p>sorted by its corresponding recursive call. The blue line underscores the two sublists
</p>
<p>currently being merged together.
</p>
<p>The argument thatmerge sort runs inO(n log n) time needs just a bit of explanation.
</p>
<p>The repetitive splitting of the list results in O(log n) splits. In the end we have lists
</p>
<p>of size 1. If we were to count every merge that occurs there would be n/2 merges at
</p>
<p>the bottom, followed by n/4 merges at the next level, and so on leading to this sum.
</p>
<p>The number of merges &ge;
</p>
<p>&lfloor;log2n&rfloor;&sum;
</p>
<p>i=0
</p>
<p>2i = 2&lfloor;log2n&rfloor; &minus; 1 &asymp; n
</p>
<p>This analysis would seem to suggest that the complexity of the merge sort algorithm
</p>
<p>is O(n2) since there are roughly n merges each of which is O(n) itself. However, the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>108 4 Sequences
</p>
<p>Fig. 4.5 Merge Sort Snapshot
</p>
<p>Fig. 4.6 Merge Sort Merges
</p>
<p>algorithm is not O(n2). To see why, consider sorting the list [5 8 2 6 9 1 0 7]. After
</p>
<p>repeatedly splitting the lists we get down to lists of size one as depicted in the first
</p>
<p>list of Fig. 4.6. The individual items are merged two at a time to form sorted lists of
</p>
<p>two, shown in the second list of items. While there are four merges that take place at
</p>
<p>the lowest level of the merge sort, the four merges are each for lists of two elements
</p>
<p>(i.e. one from each list) and together they form a list of n items. So we can group all
</p>
<p>these four merges together to find that all the merges at that deepest level take O(n)
</p>
<p>time. Not each, but all of the merges at the deepest level when combined are O(n).
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.6 Merge Sort 109
</p>
<p>In the second version of the list, two merges are done for the lists of length two.
</p>
<p>However, each merge is done on one half the list. The purple half is one merge,
</p>
<p>the green half includes the items that are in the second merge. Together, these two
</p>
<p>merges include all n items again. So, at the second deepest level again at most n
</p>
<p>items are merged in O(n) time.
</p>
<p>Finally, the last merge is of all the items in yellow from the two sorted sublists.
</p>
<p>This merge also takes O(n) time since it merges all the items in the list, resulting in
</p>
<p>the sorted list seen in the last version of the list.
</p>
<p>So, while merging is a O(n) operation, the merges take place on sublists of the n
</p>
<p>items in the list which means that we can count the merging at each level as O(n) and
</p>
<p>don&rsquo;t have to count each individual merge operation as O(n). Since there are log n
</p>
<p>levels to the merge sort algorithm and each level takes O(n) to merge, the algorithm
</p>
<p>is O(n log n).
</p>
<p>4.7 Quicksort
</p>
<p>In a sense, the quicksort algorithm is the exact opposite of themerge sort algorithm. It
</p>
<p>is also the most widely used and one of the most efficient sorting algorithms known.
</p>
<p>Quicksort is again a divide and conquer algorithm and is usually written recursively.
</p>
<p>But, where merge sort splits the list until we reach a size of 1 and then merges sorted
</p>
<p>lists, the quicksort algorithm does the merging first and then splits the list. We can&rsquo;t
</p>
<p>merge an unsorted list. Instead, we partition it into two lists. What we want is to
</p>
<p>prepare the list so quicksort can be called recursively. But, if we are to be successful,
</p>
<p>the two sublists must somehow be easier to sort than the original. This preparation
</p>
<p>for splitting is called partitioning. To partition a list we pick a pivot element. Think of
</p>
<p>quicksort partitioning a list into all the items bigger than the pivot and all the elements
</p>
<p>smaller than the pivot. We put all the bigger items to the right of the pivot and all the
</p>
<p>littler items to the left of the pivot. Once we have done this, two things are true:
</p>
<p>&bull; The pivot is in its final location in the list.
</p>
<p>&bull; The two sublists are now smaller and can therefore be quicksorted. Once the two
</p>
<p>sublists are sorted this will cause the entire list to be in sorted order, because the
</p>
<p>left will be the values ascending up to the pivot, the pivot is in the right spot, and
</p>
<p>the values greater than the pivot will all be in their correct locations, too.
</p>
<p>Quicksort is a divide and conquer algorithm. To get the best performance, we
</p>
<p>would like to divide the sequence right down the middle into two equal sized
</p>
<p>sequences. This would mean that we would have to pick the value exactly in the
</p>
<p>middle to be the pivot since the pivot is used to divide the two lists. Unfortunately
</p>
<p>this isn&rsquo;t possible if we are to do it efficiently. For quicksort to have O(n log n) com-
</p>
<p>plexity, like merge sort, it must partition the list in O(n) time.Wemust choose a pivot
</p>
<p>quickly and we must choose it well. If we don&rsquo;t choose a pivot close to the middle,
</p>
<p>we will not get the O(n log n) complexity we hope for. It turns out that choosing a
</p>
<p>random pivot from the list is good enough. One way to guarantee a random choice
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>110 4 Sequences
</p>
<p>of the pivot is to have the quicksort algorithm start by randomizing the sequence.
</p>
<p>The quicksort algorithm is given in Sect. 4.7.1.
</p>
<p>4.7.1 The Quicksort Code
</p>
<p>1 import random
</p>
<p>2
</p>
<p>3 def partition(seq, start, stop):
</p>
<p>4     # pivotIndex comes from the start location in the list.
</p>
<p>5     pivotIndex = start
</p>
<p>6     pivot = seq[pivotIndex]
</p>
<p>7     i = start+1
</p>
<p>8     j = stop-1
</p>
<p>9
</p>
<p>10     while i &lt;= j:
</p>
<p>11         #while i &lt;= j and seq[i] &lt;= pivot:
</p>
<p>12         while i &lt;= j and not pivot &lt; seq[i]:
</p>
<p>13             i+=1
</p>
<p>14         #while i &lt;= j and seq[j] &gt; pivot:
</p>
<p>15         while i &lt;= j and pivot &lt; seq[j]:
</p>
<p>16             j-=1
</p>
<p>17
</p>
<p>18         if i &lt; j:
</p>
<p>19             tmp = seq[i]
</p>
<p>20             seq[i] = seq[j]
</p>
<p>21             seq[j] = tmp
</p>
<p>22             i+=1
</p>
<p>23             j-=1
</p>
<p>24
</p>
<p>25     seq[pivotIndex] = seq[j]
</p>
<p>26     seq[j] = pivot
</p>
<p>27
</p>
<p>28     return j
</p>
<p>29
</p>
<p>30 def quicksortRecursively(seq, start, stop):
</p>
<p>31     if start &gt;= stop-1:
</p>
<p>32         return
</p>
<p>33
</p>
<p>34     # pivotIndex ends up in between the two halves
</p>
<p>35     # where the pivot value is in its final location.
</p>
<p>36     pivotIndex = partition(seq, start, stop)
</p>
<p>37
</p>
<p>38     quicksortRecursively(seq, start, pivotIndex)
</p>
<p>39     quicksortRecursively(seq, pivotIndex+1, stop)
</p>
<p>40
</p>
<p>41 def quicksort(seq):
</p>
<p>42     # randomize the sequence first
</p>
<p>43     for i in range(len(seq)):
</p>
<p>44         j = random.randint(0,len(seq)-1)
</p>
<p>45         tmp = seq[i]
</p>
<p>46         seq[i] = seq[j]
</p>
<p>47         seq[j] = tmp
</p>
<p>48
</p>
<p>49     quicksortRecursively(seq, 0, len(seq))
</p>
<p>Once the list is randomized, picking a random pivot becomes easier. The partition
</p>
<p>function picks the first item in the sequence as the pivot. The partitioning starts from
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.7 Quicksort 111
</p>
<p>both ends and works it way to the middle. Essentially every time a value bigger
</p>
<p>than the pivot is found on the left side and a value smaller than the pivot is found
</p>
<p>on the right side, the two values are swapped. Once we reach the middle from both
</p>
<p>sides, the pivot is swapped into place. Once the sequence is partitioned, the quicksort
</p>
<p>algorithm is called recursively on the two halves. Variables i and j are the indices of
</p>
<p>the left and right values, respectively, during the partitioning process.
</p>
<p>If you look at the partition code, the two commented while loop conditions are
</p>
<p>probably easier to understand than the uncommented code. However, the uncom-
</p>
<p>mented code only uses the less than operator. Quicksort is the sorting algorithm used
</p>
<p>by the sort method on lists. It only requires that the less than operator be defined
</p>
<p>between items in the sequence. By writing the two while loops as we have, the only
</p>
<p>required ordering is defined by the less than operator just as Python requires.
</p>
<p>The snapshot in Fig. 4.7 shows the effect of partitioning on a sequence. In this
</p>
<p>figure, the sequence has been partitioned twice already. The first partitioning picked
</p>
<p>a pivot that was almost dead center. However, the second partitioning picked a pivot
</p>
<p>that was not so good. The red line indicates the part of the sequence that is currently
</p>
<p>being partitioned. See how the left-most value in that sub-sequence is the pivot value.
</p>
<p>The two green dots are the pivot values that are already in their correct locations.
</p>
<p>All values above the pivot will end up in the partition to the right of the pivot and all
</p>
<p>values to the left of the pivot are less than the pivot. This is the nature of quicksort.
</p>
<p>Again, by amortized complexity we can find that the quicksort algorithm runs in
</p>
<p>O(n log n) time.
</p>
<p>Consider sorting the list [5 8 2 6 9 1 0 7] using quicksort. Figure4.8 depicts the
</p>
<p>list after each call to the partition function. The pivot in each call is identified by the
</p>
<p>orange colored item. The partition function partitions the list extending to the right
</p>
<p>of its pivot. After partitioning, the pivot is moved to its final location by swapping
</p>
<p>Fig. 4.7 Quicksort Snapshot
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>112 4 Sequences
</p>
<p>Fig. 4.8 Quicksorting a List
</p>
<p>it with the last item that is less than the pivot. Then partitioning is performed on the
</p>
<p>resulting two sublists.
</p>
<p>The randomization done in the first step of quicksort helps to pick a more random
</p>
<p>pivot value. This has real consequences in the quicksort algorithm, especially when
</p>
<p>the sequence passed to quicksort has a chance of being sorted already. If the sequence
</p>
<p>given to quicksort is sorted, or almost sorted, in either ascending or descending
</p>
<p>order, then quicksort will not achieve O(n log n) complexity. In fact, the worst case
</p>
<p>complexity of the algorithm is O(n2). If the pivot chosen is the next least or greatest
</p>
<p>value, then the partitioning will not divide the problem into to smaller sublists as
</p>
<p>occurred when 9 was chosen as a pivot for a sublist in Fig. 4.8. The algorithm will
</p>
<p>simply put one value in place and end up with one big partition of all the rest of
</p>
<p>the values. If this happened each time a pivot was chosen it would lead to O(n2)
</p>
<p>complexity. Randomizing the list prior to quicksorting it will help to ensure that this
</p>
<p>does not happen.
</p>
<p>Merge sort is not affected by the choice of a pivot, since no choice is necessary.
</p>
<p>Therefore,merge sort does not have aworst case or best case to consider. Itwill always
</p>
<p>achieve O(n log n) complexity. Even so, quicksort performs better in practice than
</p>
<p>merge sort because the quicksort algorithmdoes not need to copy to a new list and then
</p>
<p>back again. The quicksort algorithm is the de facto standard of sorting algorithms.
</p>
<p>4.8 Two-Dimensional Sequences
</p>
<p>Sometimes programmers need to represent two-dimensional sequences in a program.
</p>
<p>This can be done quite easily by creating a list of lists. The main list can represent
</p>
<p>either the columns or the rows of the matrix. If the main list contains references to
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.8 Two-Dimensional Sequences 113
</p>
<p>Fig. 4.9 A 2-Dimensional Matrix
</p>
<p>the rows, then the matrix is said to be in row major form. If the main list contains
</p>
<p>references to the columns of the matrix, then it is in column major form. Most of the
</p>
<p>time, matrices are constructed in row major form. In Fig. 4.9 a matrix is drawn with
</p>
<p>a row major orientation, but the matrix could represent either row major or column
</p>
<p>major form. The actual organization of the data is the same either way. The items
</p>
<p>reference points at the main list. The items list contains references to each of the
</p>
<p>rows of the matrix.
</p>
<p>For example, consider a program that plays tic tac toe against a human opponent.
</p>
<p>Wewouldneed to represent the board that tic tac toe is playedon.Todo so,we&rsquo;ll create
</p>
<p>a Board class that mimics our PyList class in the previous section. The organization
</p>
<p>of our board class is shown graphically in Fig. 4.9. The outline for the Board class is
</p>
<p>given in Sect. 4.8.1.
</p>
<p>4.8.1 The Board Class
</p>
<p>1 class Board:
</p>
<p>2     # When a board is constructed, you may want to make a copy of the board.
</p>
<p>3     # This can be a shallow copy of the board because Turtle objects are
</p>
<p>4     # Immutable from the perspective of a board object.
</p>
<p>5     def __init__(self,board=None):
</p>
<p>6         self.items = []
</p>
<p>7         for i in range(3):
</p>
<p>8             rowlst = []
</p>
<p>9             for j in range(3):
</p>
<p>10                 if board==None:
</p>
<p>11                     rowlst.append(Dummy())
</p>
<p>12                 else:
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>114 4 Sequences
</p>
<p>13                     rowlst.append(board[i][j])
</p>
<p>14
</p>
<p>15             self.items.append(rowlst)
</p>
<p>16
</p>
<p>17     # The getitem method is used to index into the board. It should
</p>
<p>18     # return a row of the board. That row itself is indexable (it is just
</p>
<p>19     # a list) so accessing a row and column in the board can be written
</p>
<p>20     # board[row][column] because of this method.
</p>
<p>21     def __getitem__(self,index):
</p>
<p>22         return self.items[index]
</p>
<p>23
</p>
<p>24     # This method should return true if the two boards, self and other,
</p>
<p>25     # represent exactly the same state.
</p>
<p>26     def __eq__(self,other):
</p>
<p>27         pass
</p>
<p>28
</p>
<p>29     # This method will mutate this board to contain all dummy
</p>
<p>30     # turtles. This way the board can be reset when a new game
</p>
<p>31     # is selected. It should NOT be used except when starting
</p>
<p>32     # a new game.
</p>
<p>33     def reset(self):
</p>
<p>34         screen.tracer(1)
</p>
<p>35         for i in range(3):
</p>
<p>36             for j in range(3):
</p>
<p>37                 self.items[i][j].goto(-100,-100)
</p>
<p>38                 self.items[i][j] = Dummy()
</p>
<p>39
</p>
<p>40         screen.tracer(0)
</p>
<p>41
</p>
<p>42     # This method should return an integer representing the
</p>
<p>43     # state of the board. If the computer has won, return 1.
</p>
<p>44     # If the human has won, return -1. Otherwise, return 0.
</p>
<p>45     def eval(self):
</p>
<p>46         pass
</p>
<p>47
</p>
<p>48     # This method should return True if the board
</p>
<p>49     # is completely filled up (no dummy turtles).
</p>
<p>50     # Otherwise, it should return false.
</p>
<p>51     def full(self):
</p>
<p>52         pass
</p>
<p>53
</p>
<p>54     # This method should draw the X&rsquo;s and O&rsquo;s
</p>
<p>55     # Of this board on the screen.
</p>
<p>56     def drawXOs(self):
</p>
<p>57         for row in range(3):
</p>
<p>58             for col in range(3):
</p>
<p>59                 if self[row][col].eval() != 0:
</p>
<p>60                     self[row][col].st()
</p>
<p>61                     self[row][col].goto(col*100+50,row*100+50)
</p>
<p>62
</p>
<p>63         screen.update()
</p>
<p>Because each row is itself a list in the Board class, we can just use the built-in list
</p>
<p>class for the rows of the matrix. Each location in each row of the matrix can hold
</p>
<p>either an X, an O, or a Dummy object. The Dummy objects are there for convenience
</p>
<p>and represent an open location in the board. The equal, eval, and full methods are
</p>
<p>left as an exercise for the student. The purpose of each will be described in the next
</p>
<p>section.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.8 Two-Dimensional Sequences 115
</p>
<p>Many games, both animated and otherwise, are easy to implement using Tkinter
</p>
<p>and turtle graphics. Animated characters or tokens in a game can be implemented as
</p>
<p>a turtle that moves around on the screen as necessary. For the tic tac toe game the X&rsquo;s
</p>
<p>and O&rsquo;s can be implemented as RawTurtles. A RawTurtle is just like a Turtle object
</p>
<p>except that we must provide the canvas where a RawTurtle moves around. The code
</p>
<p>in Sect. 4.8.2 contains the three classes that define the X&rsquo;s, the O&rsquo;s, and the special
</p>
<p>Dummy class that is a placeholder for open locations in the board.
</p>
<p>4.8.2 The X,O, and Dummy Classes
</p>
<p>1     Human = -1
</p>
<p>2     Computer = 1
</p>
<p>3
</p>
<p>4     # This class is just for placeholder objects when no move has been made
</p>
<p>5     # yet at a position in the board. Having eval() return 0 is convenient when no
</p>
<p>6     # move has been made.
</p>
<p>7     class Dummy:
</p>
<p>8         def __init__(self):
</p>
<p>9             pass
</p>
<p>10
</p>
<p>11         def eval(self):
</p>
<p>12             return 0
</p>
<p>13
</p>
<p>14         def goto(self,x,y):
</p>
<p>15             pass
</p>
<p>16
</p>
<p>17     # In the X and O classes below the constructor begins by initializing the
</p>
<p>18     # RawTurtle part of the object with the call to super().__init__(canvas). The
</p>
<p>19     # super() call returns the class of the superclass (the class above the X or O
</p>
<p>20     # in the class hierarchy). In this case, the superclass is RawTurtle. Then,
</p>
<p>21     # calling __init__ on the superclass initializes the part of the object that is
</p>
<p>22     # a RawTurtle.
</p>
<p>23     class X(RawTurtle):
</p>
<p>24         def __init__(self, canvas):
</p>
<p>25             super().__init__(canvas)
</p>
<p>26             self.ht()
</p>
<p>27             self.getscreen().register_shape("X",((-40,-36),(-40,-44),(0,-4),(40,-44),\
</p>
<p>28              (40,-36), (4,0),(40,36),(40,44),(0,4),(-40,44),(-40,36),(-4,0),(-40,-36)))
</p>
<p>29             self.shape("X")
</p>
<p>30             self.penup()
</p>
<p>31             self.speed(5)
</p>
<p>32             self.goto(-100,-100)
</p>
<p>33
</p>
<p>34         def eval(self):
</p>
<p>35             return Computer
</p>
<p>36
</p>
<p>37     class O(RawTurtle):
</p>
<p>38         def __init__(self, canvas):
</p>
<p>39             super().__init__(canvas)
</p>
<p>40             self.ht()
</p>
<p>41             self.shape("circle")
</p>
<p>42             self.penup()
</p>
<p>43             self.speed(5)
</p>
<p>44             self.goto(-100,-100)
</p>
<p>45
</p>
<p>46         def eval(self):
</p>
<p>47             return Human
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>116 4 Sequences
</p>
<p>4.9 TheMinimax Algorithm
</p>
<p>The Dummy, X, and O classes all have an eval method that returns either a 1 for
</p>
<p>a Computer move, a &minus;1 for a Human move, or a 0 for no move yet. The values
</p>
<p>for these moves are used in an algorithm called minimax. The minimax algorithm
</p>
<p>is a recursive algorithm that is used in two person game playing where one player
</p>
<p>is the computer and each player has a choice of some number of moves that can be
</p>
<p>made while taking turns. The minimax algorithm is simple. The idea is that when
</p>
<p>it is the computer&rsquo;s turn it should pick the move that will be best for the computer.
</p>
<p>Each possible move is analyzed to find the value that would be best for the computer.
</p>
<p>We&rsquo;ll let a 1 represent the best move for the computer. The worst move the computer
</p>
<p>could make will be represented by a &minus;1. Move values can range between 1 and &minus;1.
</p>
<p>When it is the computer&rsquo;s turn it will pick the move that results in the maximum
</p>
<p>move value. That&rsquo;s the max portion of minimax.
</p>
<p>To find the bestmove, the computerwill play out the game, alternating between the
</p>
<p>best move it could make and the best move the human could make. A best move for
</p>
<p>a human would be a&minus;1. When it is the human&rsquo;s turn, the computer will assume that
</p>
<p>the humanwill make the best move he/she canmake. This is themin part of minimax.
</p>
<p>The minimax function is given two arguments, the player (either a&minus;1 for human
</p>
<p>or a 1 for computer) and the board for the game. The base case for this recursive
</p>
<p>function checks to see if one of three things has occurred.
</p>
<p>1. The current board is a win for the computer. In that case minimax returns a 1 for
</p>
<p>a computer win.
</p>
<p>2. The current board is a win for the human. In that case minimax returns a &minus;1 for
</p>
<p>a human win.
</p>
<p>3. The current board is full. In that case, since neither human or computer won,
</p>
<p>minimax returns a 0.
</p>
<p>The recursive part of the minimax function examines the player argument. If the
</p>
<p>player is the computer, then the function tries each possible move in the board by
</p>
<p>making a computer move. It places a computer move in that spot in a copy of the
</p>
<p>board and calls minimax with the human as the next player on that board. The algo-
</p>
<p>rithm uses the guess and check pattern to find themaximum of all possible values that
</p>
<p>come back from the recursive calls to minimax. The minimax function then returns
</p>
<p>that maximum value.
</p>
<p>Whenminimax is called with the human as the next player to make amove, it does
</p>
<p>the same thing as when the computer is called as the player. It makes a human move
</p>
<p>in a copy of the board and recursively calls minimax on the copy of the board with the
</p>
<p>computer as the next player to play. The algorithm uses the guess and check pattern
</p>
<p>to find the minimum of all possible values that come back from calling minimax
</p>
<p>recursively.
</p>
<p>There is one little tricky part to minimax. The minimax algorithm is called with a
</p>
<p>board and the next player to make a move. It returns a number somewhere between
</p>
<p>&minus;1 and 1 indicating how likely it is that the computer or the human will win given
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.9 The Minimax Algorithm 117
</p>
<p>that board. However, it does not tell you which move is the best to make. To deal
</p>
<p>with this we can have the code that executes the computer&rsquo;s turn do a little of the
</p>
<p>work. For the computer turn code to find the best move it makes a move in a copy of
</p>
<p>the board, calls minimax with the human as the next player to make a move, and then
</p>
<p>records the value that comes back from the call to minimax. The computer turn code
</p>
<p>uses the guess and check pattern to find the maximum value for all possible moves
</p>
<p>and the associatedmove which resulted in that value. After finding the best move, the
</p>
<p>computer&rsquo;s turn ends by the computermaking that move in the board and returning so
</p>
<p>the human can make their next move. The tic tac toe code, which can be found on the
</p>
<p>text&rsquo;s accompanying website or in Sect. 20.5, contains the outline for the game. The
</p>
<p>minimax function and the computerTurn code are left as an exercise for the reader.
</p>
<p>Minimax can be used in many two person games of perfect information such as
</p>
<p>checkers and connect four. The term perfect information means that both players
</p>
<p>can see the whole state of the game [3]. Poker is a game of imperfect information so
</p>
<p>would not be suitable for the minimax algorithm. It should be noted that tic tac toe
</p>
<p>has a small enough search space that the computer can solve the game. That means
</p>
<p>it will never lose. Most games however are not solvable, at least with the average
</p>
<p>computer. For instance, connect four has a much larger search space and can&rsquo;t be
</p>
<p>completely solved. Heuristics are applied to games like connect four to estimate how
</p>
<p>good or bad a board is after the minimax algorithm has searched as deep as it can
</p>
<p>given its time constraints. Games like these are often studied in the field of Artificial
</p>
<p>Intelligence [3]. Artificial Intelligence includes the study of search algorithms that
</p>
<p>may be used even when the search space is too large to use an exhaustive search.
</p>
<p>In this text, Chap.12 covers a few heuristic search algorithms along with a heuristic
</p>
<p>applied to the minimax algorithm for the game of connect four.
</p>
<p>4.10 Linked Lists
</p>
<p>Sequences can be organized in several different ways. The PyList sequence was a
</p>
<p>randomly accessible list. Thismeans thatwe can access any element of the list inO(1)
</p>
<p>time to either store or retrieve a value. Appending an item was possible in O(1) time
</p>
<p>using amortized complexity analysis, but inserting an item took O(n) time where n
</p>
<p>was the number of items after the location where the new item was being inserted.
</p>
<p>If a programmer wants to insert a large number of items towards the beginning of
</p>
<p>a list, a different organization for a sequence might be better suited to their needs.
</p>
<p>A linked list is an organization of a list where each item in the list is in a separate
</p>
<p>node. Linked lists look like the links in a chain. Each link is attached to the next
</p>
<p>link by a reference that points to the next link in the chain. When working with a
</p>
<p>linked list, each link in the chain is called a Node. Each node consists of two pieces
</p>
<p>of information, an item, which is the data associated with the node, and a link to the
</p>
<p>next node in the linked list, often called next. The code in Sect. 4.10.1 defines the
</p>
<p>Node class that can be used to create the nodes in a linked list.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
</div>
<div class="page"><p/>
<p>118 4 Sequences
</p>
<p>4.10.1 The Node Class
</p>
<p>1 class Node:
</p>
<p>2     def __init__(self,item,next=None):
</p>
<p>3         self.item = item
</p>
<p>4         self.next = next
</p>
<p>5
</p>
<p>6     def getItem(self):
</p>
<p>7         return self.item
</p>
<p>8
</p>
<p>9     def getNext(self):
</p>
<p>10         return self.next
</p>
<p>11
</p>
<p>12     def setItem(self, item):
</p>
<p>13         self.item = item
</p>
<p>14
</p>
<p>15     def setNext(self,next):
</p>
<p>16         self.next = next
</p>
<p>In the Node class there are two pieces of information: the item is a reference to a
</p>
<p>value in the list, and the next reference which points to the next node in the sequence.
</p>
<p>Figure4.10 is a linked list with three elements added to it. There are four nodes in
</p>
<p>this figure. The first node is a dummy node. Having one extra dummy node at the
</p>
<p>beginning of the sequence eliminates a lot of special cases that must be considered
</p>
<p>whenworkingwith the linked list. An empty sequence still has a dummy node. Nodes
</p>
<p>in linked lists are represented as a rounded rectangle with two halves. The left half
</p>
<p>of a node is a reference to the item or value for that node in the sequence. The right
</p>
<p>half is a reference to the next node in the sequence or to the special value None if it
</p>
<p>is the last node in the sequence.
</p>
<p>Figure4.10 depicts a linked list consisting of three pieces of information. We
</p>
<p>keep a reference to the first node in the sequence so we can traverse the nodes when
</p>
<p>necessary. The reference to the last node in the list makes it possible to append an
</p>
<p>item to the list in O(1) time. We also keep track of the number of items so we don&rsquo;t
</p>
<p>have to count when someone wants to retrieve the list size.
</p>
<p>The table of operations in Fig. 4.11 contains the computational complexity of
</p>
<p>various list operations on the LinkedList datatype presented in this section. Many
</p>
<p>Fig. 4.10 A Sample LinkedList Object
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.10 Linked Lists 119
</p>
<p>Operation Complexity Usage Method
</p>
<p>List creation O(len(y)) x = LinkedList(y) calls __init__(y)
</p>
<p>indexed get O(n) a = x[i] x.__getitem__(i)
</p>
<p>indexed set O(n) x[i] = a x.__setitem__(i,a)
</p>
<p>concatenate O(n) z = x + y z = x.__add__(y)
</p>
<p>append O(1) x.append(a) x.append(a)
</p>
<p>insert O(n) x.insert(i,e) x.insert(i,e))
</p>
<p>delete O(n) del x[i] x.__delitem__(i)
</p>
<p>equality O(n) x == y x.__eq__(y)
</p>
<p>iterate O(n) for a in x: x.__iter__()
</p>
<p>length O(1) len(x) x.__len__()
</p>
<p>membership O(n) a in x x.__contains__(a)
</p>
<p>sort N/A N/A N/A
</p>
<p>Fig. 4.11 Complexity of LinkedList Operations
</p>
<p>of the operations appear to have the same complexity as the list datatype operations
</p>
<p>presented in Fig. 4.11. There are some important differences though. The following
</p>
<p>sections will provide the implementations for some of these operations and point out
</p>
<p>the differences as compared to the list datatype operations given in Fig. 4.11.
</p>
<p>4.10.2 The LinkedList Constructor
</p>
<p>1 class LinkedList:
</p>
<p>2
</p>
<p>3     # This class is used internally by the LinkedList class. It is
</p>
<p>4     # invisible from outside this class due to the two underscores
</p>
<p>5     # that precede the class name. Python mangles names so that they
</p>
<p>6     # are not recognizable outside the class when two underscores
</p>
<p>7     # precede a name but aren&rsquo;t followed by two underscores at the
</p>
<p>8     # end of the name (i.e. an operator name).
</p>
<p>9     class __Node:
</p>
<p>10         def __init__(self,item,next=None):
</p>
<p>11             self.item = item
</p>
<p>12             self.next = next
</p>
<p>13
</p>
<p>14         def getItem(self):
</p>
<p>15             return self.item
</p>
<p>16
</p>
<p>17         def getNext(self):
</p>
<p>18             return self.next
</p>
<p>19
</p>
<p>20         def setItem(self, item):
</p>
<p>21             self.item = item
</p>
<p>22
</p>
<p>23         def setNext(self,next):
</p>
<p>24             self.next = next
</p>
<p>25
</p>
<p>26     def __init__(self,contents=[]):
</p>
<p>27         # Here we keep a reference to the first node in the linked list
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>120 4 Sequences
</p>
<p>28         # and the last item in the linked list. They both point to a
</p>
<p>29         # dummy node to begin with. This dummy node will always be in
</p>
<p>30         # the first position in the list and will never contain an item.
</p>
<p>31         # Its purpose is to eliminate special cases in the code below.
</p>
<p>32         self.first = LinkedList.__Node(None,None)
</p>
<p>33         self.last = self.first
</p>
<p>34         self.numItems = 0
</p>
<p>35
</p>
<p>36         for e in contents:
</p>
<p>37             self.append(e)
</p>
<p>Creating a LinkedList object has exactly the same complexity has constructing
</p>
<p>a list object. If an empty list is created, then the time taken is O(1) and if a list is
</p>
<p>copied, then it is a O(n) operation. A LinkedList object has references to both ends of
</p>
<p>the linked list. The reference to the head of the list points to a dummy node. Having
</p>
<p>a dummy node at the beginning eliminates many special cases that would exist when
</p>
<p>the list was empty if no dummy node were used.
</p>
<p>Declaring the Node class within the LinkedList class, and preceding the name
</p>
<p>with two underscores, hides the __Node class from any code outside the LinkedList
</p>
<p>class. The idea here is that only the LinkedList class needs to know about the __Node
</p>
<p>class. Initially, both the first and the last references point to the dummy node. The
</p>
<p>append method is used to add elements to the LinkedList should a list be passed to
</p>
<p>the constructor.
</p>
<p>4.10.3 LinkedList Get and Set
</p>
<p>1 def __getitem__(self,index):
</p>
<p>2     if index &gt;= 0 and index &lt; self.numItems:
</p>
<p>3         cursor = self.first.getNext()
</p>
<p>4         for i in range(index):
</p>
<p>5             cursor = cursor.getNext()
</p>
<p>6
</p>
<p>7         return cursor.getItem()
</p>
<p>8
</p>
<p>9     raise IndexError("LinkedList index out of range")
</p>
<p>10
</p>
<p>11 def __setitem__(self,index,val):
</p>
<p>12     if index &gt;= 0 and index &lt; self.numItems:
</p>
<p>13         cursor = self.first.getNext()
</p>
<p>14         for i in range(index):
</p>
<p>15             cursor = cursor.getNext()
</p>
<p>16
</p>
<p>17         cursor.setItem(val)
</p>
<p>18         return
</p>
<p>19
</p>
<p>20     raise IndexError("LinkedList assignment index out of range")
</p>
<p>Implementations for the indexed get and set operations are included in Sect. 4.10.4
</p>
<p>largely as an example of traversing a linked list. They are of little practical value.
</p>
<p>If random access to a list is desired, then the list class should be used. Linked lists are
</p>
<p>not randomly accessible. They require linear search through the datatype to access
</p>
<p>a particular location in the list. Each of these operations is O(n) where n is the value
</p>
<p>of the index.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.10 Linked Lists 121
</p>
<p>4.10.4 LinkedList Concatenate
</p>
<p>1 def __add__(self,other):
</p>
<p>2     if type(self) != type(other):
</p>
<p>3         raise TypeError("Concatenate undefined for " + \
</p>
<p>4             str(type(self)) + " + " + str(type(other)))
</p>
<p>5
</p>
<p>6     result = LinkedList()
</p>
<p>7
</p>
<p>8     cursor = self.first.getNext()
</p>
<p>9
</p>
<p>10     while cursor != None:
</p>
<p>11         result.append(cursor.getItem())
</p>
<p>12         cursor = cursor.getNext()
</p>
<p>13
</p>
<p>14     cursor = other.first.getNext()
</p>
<p>15
</p>
<p>16     while cursor != None:
</p>
<p>17         result.append(cursor.getItem())
</p>
<p>18         cursor = cursor.getNext()
</p>
<p>19
</p>
<p>20     return result
</p>
<p>Concatenation is an accessor method that returns a new list comprised of the two
</p>
<p>original lists. The operation is once again O(n) for linked lists as it was for the PyList
</p>
<p>datatype presented in Fig. 4.1. In this concatenation code a variable called cursor
</p>
<p>is used to step through the nodes of the two lists. This is the common method of
</p>
<p>stepping through a linked list. Set the cursor to the first element of the linked list.
</p>
<p>Then use a while loop that terminates when the cursor reaches the end (i.e. the special
</p>
<p>value None). Each time through the while loop the cursor is advanced by setting it
</p>
<p>to the next node in the sequence.
</p>
<p>Notice in the code that the dummy node from both lists (i.e. self and other) is
</p>
<p>skipped when concatenating the two lists. The dummy node in the new list was
</p>
<p>created when the constructor was called.
</p>
<p>4.10.5 LinkedList Append
</p>
<p>1 def append(self,item):
</p>
<p>2     node = LinkedList.__Node(item)
</p>
<p>3     self.last.setNext(node)
</p>
<p>4     self.last = node
</p>
<p>5     self.numItems += 1
</p>
<p>The code in Sect. 4.10.6 is the first time we see a small advantage of a LinkedList
</p>
<p>over a list. The append operation has a complexity of O(1) for LinkedLists where
</p>
<p>with lists the complexitywas an amortizedO(1) complexity. Each appendwill always
</p>
<p>take the same amount of time with a LinkedList. A LinkedList is also never bigger
</p>
<p>than it has to be. However, LinkedLists take up about twice the space of a randomly
</p>
<p>accessible list since there has to be room for both the reference to the item and the
</p>
<p>reference to the next node in the list.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>122 4 Sequences
</p>
<p>The code for the append method is quite simple. Since the self.last reference
</p>
<p>points at the node immediately preceding the place where we want to put the new
</p>
<p>node, we just create a new node and make the last one point at it. Then we make the
</p>
<p>new node the new self.last node and increment the number of items by 1.
</p>
<p>4.10.6 LinkedList Insert
</p>
<p>1 def insert(self,index,item):
</p>
<p>2     cursor = self.first
</p>
<p>3
</p>
<p>4     if index &lt; self.numItems:
</p>
<p>5         for i in range(index):
</p>
<p>6             cursor = cursor.getNext()
</p>
<p>7
</p>
<p>8         node = LinkedList.__Node(item, cursor.getNext())
</p>
<p>9         cursor.setNext(node)
</p>
<p>10         self.numItems += 1
</p>
<p>11     else:
</p>
<p>12         self.append(item)
</p>
<p>The insert operation, while it has the same complexity as insert on a list, is quite
</p>
<p>a bit different for linked lists. Inserting into a list is a O(n) operation where n is the
</p>
<p>number of elements that are in the list after the insertion point since they must all be
</p>
<p>moved down to make room for the new item. When working with a LinkedList the
</p>
<p>n is the number of elements that appear before the insertion point because we must
</p>
<p>search for the correct insertion point.
</p>
<p>This means that while inserting at the beginning of a list is a O(n) operation,
</p>
<p>inserting at the beginning of a LinkedList is a O(1) operation. If you will have to do
</p>
<p>many inserts near the beginning of a list, then a linked list may be better to use than
</p>
<p>a randomly accessible list.
</p>
<p>4.10.7 Other Linked List Operations
</p>
<p>The other linked list operations are left as an exercise for the reader. In many cases,
</p>
<p>the key to working with a linked list is to get a reference to the node that preceds
</p>
<p>the location you want to work with. For instance, to delete a node from a linked list
</p>
<p>you merely want to make the next field of the preceeding node point to the node
</p>
<p>following the node you wish to delete. Consider the sample linked list in Fig. 4.10.
</p>
<p>To delete the second item (i.e. the &ldquo;b&rdquo;) from this list we want to remove the node
</p>
<p>that contains the reference to the &ldquo;b&rdquo;. To do this we can use a cursor to find the node
</p>
<p>preceding the one that references the &ldquo;b&rdquo;. Once found, the next field of the cursor
</p>
<p>can be made to point to the node after the &ldquo;b&rdquo; as shown in Fig. 4.12.
</p>
<p>Changing the next pointer of the cursor&rsquo;s node to point to the node after the &ldquo;b&rdquo;
</p>
<p>results in the node containing the &ldquo;b&rdquo; dropping out of the list. Since there are no
</p>
<p>other references to the node containing the &ldquo;b&rdquo;, and actually to the &ldquo;b&rdquo; itself, the two
</p>
<p>objects are garbage collected.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.10 Linked Lists 123
</p>
<p>Fig. 4.12 Deleting a Node from a Linked List
</p>
<p>Finally, the sort operation is not applicable on linked lists. Efficient sorting algo-
</p>
<p>rithms require random access to a list. Insertion sort, a O(n2) algorithm, would work,
</p>
<p>but it would be highly inefficient. If sorting were required, it would be much more
</p>
<p>efficient to copy the linked list to a randomly accessible list, sort it, and then build a
</p>
<p>new sorted linked list from the sorted list.
</p>
<p>4.11 Stacks and Queues
</p>
<p>There are two other sequential data structures that are very common in computer
</p>
<p>programming. A stack is a data structure where access is only at one end of the
</p>
<p>sequence. New values are pushed onto the stack to add them to the sequence and
</p>
<p>popped off the stack to remove them from the sequence.The run-time stack, described
</p>
<p>in Chap.3, was one such instance of a stack. Stacks are used in many algorithms
</p>
<p>in computer science. Stacks can be used to evaluate numeric expressions. They are
</p>
<p>useful when parsing information. They can be used tomatch parenthesis in programs
</p>
<p>and expressions. The operations on a stack are given in Fig. 4.13.
</p>
<p>Stacks are called Last In/First Out or LIFO data structures. The last item pushed is
</p>
<p>the first item popped. A Stack class can be implemented in at least a couple different
</p>
<p>Operation Complexity Usage Description
</p>
<p>Stack Creation O(1) s=Stack() calls the constructor
</p>
<p>pop O(1) a=s.pop() returns the last item pushed and removes it from s
</p>
<p>push O(1) s.push(a) pushes the item, a, on the stack, s
</p>
<p>top O(1) a=s.top() returns the top item without popping s
</p>
<p>isEmpty O(1) s.isEmpty() returns True if s has no pushed items
</p>
<p>Fig. 4.13 Complexity of Stack Operations
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3">http://dx.doi.org/10.1007/978-3-319-13072-9_3</a></div>
</div>
<div class="page"><p/>
<p>124 4 Sequences
</p>
<p>ways to achieve the computation complexities outlined in this table. Either a list or a
</p>
<p>linked list will suffice. The code in Sect. 4.11.2 is an implementation of a stack with a
</p>
<p>list. The implementation is pretty straight-forward. The main program in Sect. 4.11.2
</p>
<p>tests the stack datatype with a couple tests to make sure the code operates correctly.
</p>
<p>4.11.1 The Stack Class Code
</p>
<p>1     class Stack:
</p>
<p>2         def __init__(self):
</p>
<p>3             self.items = []
</p>
<p>4
</p>
<p>5         def pop(self):
</p>
<p>6             if self.isEmpty():
</p>
<p>7                 raise RuntimeError("Attempt to pop an empty stack")
</p>
<p>8
</p>
<p>9             topIdx = len(self.items)-1
</p>
<p>10             item = self.items[topIdx]
</p>
<p>11             del self.items[topIdx]
</p>
<p>12             return item
</p>
<p>13
</p>
<p>14         def push(self,item):
</p>
<p>15             self.items.append(item)
</p>
<p>16
</p>
<p>17         def top(self):
</p>
<p>18             if self.isEmpty():
</p>
<p>19                 raise RuntimeError("Attempt to get top of empty stack")
</p>
<p>20
</p>
<p>21             topIdx = len(self.items)-1
</p>
<p>22             return self.items[topIdx]
</p>
<p>23
</p>
<p>24         def isEmpty(self):
</p>
<p>25             return len(self.items) == 0
</p>
<p>26
</p>
<p>27     def main():
</p>
<p>28         s = Stack()
</p>
<p>29         lst = list(range(10))
</p>
<p>30         lst2 = []
</p>
<p>31
</p>
<p>32         for k in lst:
</p>
<p>33             s.push(k)
</p>
<p>34
</p>
<p>35         if s.top() == 9:
</p>
<p>36             print("Test 1 Passed")
</p>
<p>37         else:
</p>
<p>38             print("Test 1 Failed")
</p>
<p>39
</p>
<p>40         while not s.isEmpty():
</p>
<p>41             lst2.append(s.pop())
</p>
<p>42
</p>
<p>43         lst2.reverse()
</p>
<p>44
</p>
<p>45         if lst2 != lst:
</p>
<p>46             print("Test 2 Failed")
</p>
<p>47         else:
</p>
<p>48             print("Test 2 Passed")
</p>
<p>49
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.11 Stacks and Queues 125
</p>
<p>50         try:
</p>
<p>51             s.pop()
</p>
<p>52             print("Test 3 Failed")
</p>
<p>53
</p>
<p>54         except RuntimeError:
</p>
<p>55             print("Test 3 Passed")
</p>
<p>56         except:
</p>
<p>57             print("Test 3 Failed")
</p>
<p>58
</p>
<p>59         try:
</p>
<p>60             s.top()
</p>
<p>61             print("Test 4 Failed")
</p>
<p>62
</p>
<p>63         except RuntimeError:
</p>
<p>64             print("Test 4 Passed")
</p>
<p>65         except:
</p>
<p>66             print("Test 4 Failed")
</p>
<p>67
</p>
<p>68     if __name__=="__main__":
</p>
<p>69         main()
</p>
<p>This code, if saved in a file called stack.py can be imported into other modules.
</p>
<p>When this module is run by itself, the test main function will execute. When this
</p>
<p>module is imported into another program, the main function will not execute because
</p>
<p>the __name__ variable will not be equal to &ldquo;__main__&rdquo;.
</p>
<p>A queue is like a stack in many ways except that instead of being a LIFO data
</p>
<p>structure, queues areFIFO orFirst In/First Out data structures. The first item pushed,
</p>
<p>is the first item popped. When we are working with a queue we talk of enqueueing
</p>
<p>an item, instead of pushing it. When removing an item from the queue we talk of
</p>
<p>dequeueing the item instead of popping it aswe did froma stack. The table in Fig. 4.14
</p>
<p>provides details of the queue operations and their complexities.
</p>
<p>Implementing a queue with the complexities given in this table is a bit trickier
</p>
<p>than implementing the stack. To implement a queue with these complexities we need
</p>
<p>to be able to add to one end of a sequence and remove from the other end of the
</p>
<p>sequence in O(1) time. This suggests the use of a linked list. Certainly, a linked list
</p>
<p>would work to get the desired complexities. However, we can still use a list if we
</p>
<p>are willing to accept an amortized complexity of O(1) for the dequeue operation.
</p>
<p>This Queue class code implements a queue with a list and achieves an amortized
</p>
<p>complexity of O(1) for the dequeue operation.
</p>
<p>Operation Complexity Usage Description
</p>
<p>Queue Creation O(1) q=Queue() calls the constructor
</p>
<p>dequeue O(1) a=q.dequeue() returns the first item enqueued and removes it from q
</p>
<p>enqueue O(1) q.enqueue(a) enqueues the item, a, on the queue, q
</p>
<p>front O(1) a=q.front() returns the front item without dequeueing the item
</p>
<p>isEmpty O(1) q.isEmpty() returns True if q has not enqueued items
</p>
<p>Fig. 4.14 Complexity of Queue Operations
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>126 4 Sequences
</p>
<p>1     class Queue:
</p>
<p>2         def __init__(self):
</p>
<p>3             self.items = []
</p>
<p>4             self.frontIdx = 0
</p>
<p>5
</p>
<p>6         def __compress(self):
</p>
<p>7             newlst = []
</p>
<p>8             for i in range(self.frontIdx,len(self.items)):
</p>
<p>9                 newlst.append(self.items[i])
</p>
<p>10
</p>
<p>11             self.items = newlst
</p>
<p>12             self.frontIdx = 0
</p>
<p>13
</p>
<p>14         def dequeue(self):
</p>
<p>15             if self.isEmpty():
</p>
<p>16                 raise RuntimeError("Attempt to dequeue an empty queue")
</p>
<p>17
</p>
<p>18             # When queue is half full, compress it. This
</p>
<p>19             # achieves an amortized complexity of O(1) while
</p>
<p>20             # not letting the list continue to grow unchecked.
</p>
<p>21             if self.frontIdx * 2 &gt; len(self.items):
</p>
<p>22                 self.__compress()
</p>
<p>23
</p>
<p>24             item = self.items[self.frontIdx]
</p>
<p>25             self.frontIdx += 1
</p>
<p>26             return item
</p>
<p>27
</p>
<p>28         def enqueue(self,item):
</p>
<p>29             self.items.append(item)
</p>
<p>30
</p>
<p>31         def front(self):
</p>
<p>32             if self.isEmpty():
</p>
<p>33                 raise RuntimeError("Attempt to access front of empty queue")
</p>
<p>34
</p>
<p>35             return self.items[self.frontIdx]
</p>
<p>36
</p>
<p>37         def isEmpty(self):
</p>
<p>38             return self.frontIdx == len(self.items)
</p>
<p>39
</p>
<p>40     def main():
</p>
<p>41         q = Queue()
</p>
<p>42         lst = list(range(10))
</p>
<p>43         lst2 = []
</p>
<p>44
</p>
<p>45         for k in lst:
</p>
<p>46             q.enqueue(k)
</p>
<p>47
</p>
<p>48         if q.front() == 0:
</p>
<p>49             print("Test 1 Passed")
</p>
<p>50         else:
</p>
<p>51             print("Test 1 Failed")
</p>
<p>52
</p>
<p>53         while not q.isEmpty():
</p>
<p>54             lst2.append(q.dequeue())
</p>
<p>55
</p>
<p>56         if lst2 != lst:
</p>
<p>57             print("Test 2 Failed")
</p>
<p>58         else:
</p>
<p>59             print("Test 2 Passed")
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.11 Stacks and Queues 127
</p>
<p>60
</p>
<p>61         for k in lst:
</p>
<p>62             q.enqueue(k)
</p>
<p>63
</p>
<p>64         lst2 = []
</p>
<p>65
</p>
<p>66         while not q.isEmpty():
</p>
<p>67             lst2.append(q.dequeue())
</p>
<p>68
</p>
<p>69         if lst2 != lst:
</p>
<p>70             print("Test 3 Failed")
</p>
<p>71         else:
</p>
<p>72             print("Test 3 Passed")
</p>
<p>73
</p>
<p>74         try:
</p>
<p>75             q.dequeue()
</p>
<p>76             print("Test 4 Failed")
</p>
<p>77
</p>
<p>78         except RuntimeError:
</p>
<p>79             print("Test 4 Passed")
</p>
<p>80         except:
</p>
<p>81             print("Test 4 Failed")
</p>
<p>82
</p>
<p>83         try:
</p>
<p>84             q.front()
</p>
<p>85             print("Test 5 Failed")
</p>
<p>86
</p>
<p>87         except RuntimeError:
</p>
<p>88             print("Test 5 Passed")
</p>
<p>89         except:
</p>
<p>90             print("Test 5 Failed")
</p>
<p>91
</p>
<p>92     if __name__=="__main__":
</p>
<p>93         main()
</p>
<p>4.11.2 Infix Expression Evaluation
</p>
<p>An infix expression is an expression where operators appear in between their
</p>
<p>operands. For example, (6+ 5) * 4 is an infix expression because+ appears between
</p>
<p>the 6 and 5 and * appears between its operands. Python, being a programming
</p>
<p>language, can evaluate infix expressions. However, let&rsquo;s say we would like to write
</p>
<p>a program that would evaluate expressions entered by the user. Can we do this in a
</p>
<p>Python program? It turns out we can, and very easily. Python includes a function that
</p>
<p>will treat a string like an expression to be evaluated and will return the result of that
</p>
<p>evaluation. The function is called eval. Here is a program that uses the eval function.
</p>
<p>1     def main():
</p>
<p>2         expr = input("Please enter an infix expression: ")
</p>
<p>3         result = eval(expr)
</p>
<p>4         print("The result of",expr,"is",result)
</p>
<p>5
</p>
<p>6     if __name__ == "__main__":
</p>
<p>7         main()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>128 4 Sequences
</p>
<p>This is certainly a very interesting, albeit short, program. The eval function does
</p>
<p>an awful lot of work for us. But, how does it work? It turns out we can write our own
</p>
<p>eval function using a couple of stacks. In this section we describe an infix expression
</p>
<p>evaluator. To make our job a bit easier, we&rsquo;ll insist that the user enter spaces between
</p>
<p>all operators (including parens) and operands. So for instance, the user might interact
</p>
<p>as follows.
</p>
<p>Please enter an infix expression: ( 6 + 5 ) * 4 - 9
</p>
<p>The result of ( 6 + 5 ) * 4 - 9 = 35.0
</p>
<p>The infix evaluator algorithm uses two stacks, an operator stack and an operand
</p>
<p>stack. The operator stack will hold operators and left parens. The operand stack holds
</p>
<p>numbers.
</p>
<p>The algorithm proceeds by scanning the tokens of the infix expression from left
</p>
<p>to right. You can do this quite easily in Python by splitting the input string and then
</p>
<p>iterating over the list of strings from the input. The tokens are operators (including
</p>
<p>parens) and numbers.
</p>
<p>Each operator has a precedence associated with it. Multiplication and division
</p>
<p>operators have the highest precedencewhile addition and subtraction are next. Finally
</p>
<p>the left paren and right paren precedence are the lowest. A function called precedence
</p>
<p>can be written so that given an operator, the precendence function returns the proper
</p>
<p>precedence value. You can decide on your precedence values given the prescribed
</p>
<p>restrictions.
</p>
<p>To begin the operand stack and the operator stack are initialized to empty stacks
</p>
<p>and a left paren is pushed on the operator stack.
</p>
<p>For each token in the input we do the following:
</p>
<p>1. If the token is an operator then we need to operate on the two stacks with the
</p>
<p>given operator. Operating is described in Sect. 4.11.2.1.
</p>
<p>2. If the token is a number then we push it on the number stack.
</p>
<p>After scanning all the input and operating when required we operate on the stacks
</p>
<p>one more time with an extra right paren operator. After operating the final time the
</p>
<p>operator stack should be empty and the operand stack should have one number on it
</p>
<p>which is the result. You pop the operand stack and print the number as your result.
</p>
<p>4.11.2.1 The Operate Procedure
</p>
<p>The operate procedure should be a separate function. The operate procedure is given
</p>
<p>an operator, the operator stack, and operand stack as arguments. To operate we do
</p>
<p>the following:
</p>
<p>&bull; If the given operator is a left paren we push it on the operator stack and return.
</p>
<p>&bull; Otherwise, while the precedence of the given operator is less than or equal to the
</p>
<p>precedence of the top operator on the operator stack proceed as follows:
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.11 Stacks and Queues 129
</p>
<p>1. Pop the top operator from the operator stack. Call this the topOp.
</p>
<p>2. if topOp is a +,&minus;, &lowast;, or / then operate on the number stack by popping the
</p>
<p>operands, doing the operation, and pushing the result.
</p>
<p>3. if topOp is a left paren then the given operator should be a right paren. If so, we
</p>
<p>are done operating and we return immediately.
</p>
<p>When the precedence of the given operator is greater than the precedence of
</p>
<p>topOp we terminate the loop and push the given operator on the operator stack
</p>
<p>before returning from operating.
</p>
<p>4.11.2.2 Example
</p>
<p>To see how this algorithm works it will help to look at an example. In the figures
</p>
<p>the right-most underlined token is the token currently being processed and all tokens
</p>
<p>to the left have already be processed. The operand stack and the operator stack are
</p>
<p>labeled in the diagrams. The topOp operator and the current operator are given
</p>
<p>as well.
</p>
<p>In Fig. 4.15 the tokens ( 6+ 5 have been processed and pushed onto their respective
</p>
<p>stacks. The right paren is now being processed and operate was called to process this
</p>
<p>operator. In the operate procedure the topOp is a &ldquo;+&rdquo; and &ldquo;+&rdquo; has higher precedence
</p>
<p>than &rdquo;)&rdquo; so the right paren cannot be pushed on top of the addition operator. So,we pop
</p>
<p>the operator stack and operate. Since we popped a &ldquo;+&rdquo; we then pop the two numbers
</p>
<p>from the operand stack, add them together, and push the result as shown in Fig. 4.16.
</p>
<p>After pushing the 11 on the stack we found that the top operator was a left paren.
</p>
<p>In that case we popped the left paren and returned immediately leaving just the
</p>
<p>single left paren on the operator stack. Then the evaluator proceeded by finding the
</p>
<p>&ldquo;*&rdquo; operator and pushing it and then finding the 4 and pushing it on the operand
</p>
<p>stack. Next, the &ldquo;&minus;&rdquo; operator cannot be pushed onto the operator stack because its
</p>
<p>precedence is lower then &ldquo;*&rdquo;. Operate is called and the topOp dictates that we pop
</p>
<p>two numbers, multiply them, and push the result as shown in Fig. 4.17. The &ldquo;&minus;&rdquo;
</p>
<p>operator has higher precedence than the &ldquo;(&rdquo; so it is just pushed onto the operator
</p>
<p>stack. The 9 is processed and pushed onto the operand stack as shown in Fig. 4.17.
</p>
<p>To finish up the evaluation of the infix expression, operate is called one more time
</p>
<p>with &rdquo;)&rdquo; as the operator. This forces the 9 to be subtracted from the 44 leaving 35
</p>
<p>on the operand stack and the operator stack empty. The final result is 35 and the
</p>
<p>evaluator pops the result from the operand stack and returns it as the result and that
</p>
<p>is how the Python eval function works. It turns out that the Python eval function is
</p>
<p>a bit more sophisticated than this example. However, the effect of evaluating simple
</p>
<p>infix expressions is the same.
</p>
<p>4.11.3 Radix Sort
</p>
<p>The radix sort algorithm sorts a sequence of strings lexicographically, as they would
</p>
<p>appear in a phonebook or dictionary. To implement this algorithm the strings are
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>130 4 Sequences
</p>
<p>Fig. 4.15 Infix Evaluation Step 1
</p>
<p>Fig. 4.16 Infix Evaluation Step 2
</p>
<p>Fig. 4.17 Infix Evaluation Step 3
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.11 Stacks and Queues 131
</p>
<p>read from the source (e.g. a file or the internet) and they are placed in a queue called
</p>
<p>the mainQueue. As the strings are read and placed in the queue the algorithm keeps
</p>
<p>track of the length of the longest string that will be sorted. We&rsquo;ll call this length
</p>
<p>longest.
</p>
<p>For the radix sort algorithm to work correctly, all the strings in the mainQueue
</p>
<p>need to be the same length, which is not likely of course. If a string is shorter than the
</p>
<p>longest string it can be padded with blanks. To assist, it is handy to have a function
</p>
<p>that returns a character of a string like the charAt function in Sect. 4.11.6.
</p>
<p>4.11.4 The CharAt Function
</p>
<p>1     def charAt(s,i):
</p>
<p>2         if len(s) - 1 &lt; i:
</p>
<p>3             return " "
</p>
<p>4
</p>
<p>5         return s[i]
</p>
<p>The charAt function returns the ith character of the string s and a blank if i is
</p>
<p>greater than or equal to the length of s. With the use of this function the strings in the
</p>
<p>mainQueue can be different lengths and the charAt function will make them look
</p>
<p>like they are the same length.
</p>
<p>In addition to the mainQueue, there are 256 queues created and placed into a list
</p>
<p>of queues, called queueList. There are 256 different possible ASCII values and one
</p>
<p>queue is created for each ASCII letter. Since most ASCII characters are in the range
</p>
<p>of 0&ndash;127 the algorithm probably won&rsquo;t use the queues at indices 128&ndash;255.
</p>
<p>The sorting algorithmworks by removing a string frommainQueue. It looks at the
</p>
<p>last character, starting at longest-1, in each string and placing the string on a queue
</p>
<p>that corresponds to the character&rsquo;s ASCII value. So, all strings ending with &lsquo;a&rsquo; go on
</p>
<p>the &lsquo;a&rsquo; queue and so on. To find the index into queueList the ord function is used.
</p>
<p>For instance, writing ord(&ldquo;a&rdquo;) would return a 65 which is the index to use into the
</p>
<p>queueList for the character &ldquo;a&rdquo;.
</p>
<p>Then, starting with the first queue in the queueList, all strings are dequeued from
</p>
<p>each queue and placed on themain queue.We empty each queue first before proceed-
</p>
<p>ing to the next queue in the queueList. This is repeateduntil all letter queues are empty.
</p>
<p>Then, we go back to removing all elements from the main queue again, this time
</p>
<p>looking at the second to the last letter of each word. Each string is placed on a queue
</p>
<p>in the queueList depending on its second to last letter. The process is repeated until
</p>
<p>we get to the first letter of each string. When we are done, all strings are on the main
</p>
<p>queue in sorted order. To complete the algorithm all strings are removed from the
</p>
<p>mainQueue one more time in sorted order.
</p>
<p>4.11.4.1 Radix Sort Example
</p>
<p>To see how radix sort works we&rsquo;ll consider an example where the words bat, farm,
</p>
<p>barn, car, hat, and cat are sorted alphabetically. In the figures in this section each
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>132 4 Sequences
</p>
<p>queue is drawn vertically with the front of the queue being at the bottom of the box
</p>
<p>and the rear of the queue being at the top of each box. While there are 256 queues
</p>
<p>plus a mainQueue created by radix sort, the example will show just the queues that
</p>
<p>are used while sorting these words. The first queue in the list is the queue for spaces
</p>
<p>in a string. Figure4.18 depicts the strings on the mainQueue after they have been
</p>
<p>read from their source.
</p>
<p>The first step of the algorithmprocesses themainQueue by emptying it and placing
</p>
<p>each string in the queue that corresponds to its fourth letter (the maximum string
</p>
<p>length). This results in farm and barn being placed on the m and n queues. The other
</p>
<p>strings are placed on the space queue as shown in Fig. 4.19.
</p>
<p>Then, all the strings are dequeued from the three non-empty queues and placed
</p>
<p>back on the mainQueue in the order that they were dequeued as shown in Fig. 4.20.
</p>
<p>Once again, the process is repeated for the third letter in each string. This results
</p>
<p>in using the r and t queues as shown in Fig. 4.21.
</p>
<p>Again, the strings are brought back to the mainQueue in the order they were
</p>
<p>dequeued as depicted in Fig. 4.22.
</p>
<p>And the process is repeated again for the second letter in each string. All strings
</p>
<p>have an a as their second character so they all end up on the a queue (Fig. 4.23).
</p>
<p>Fig. 4.18 Radix Sort Step 1
</p>
<p>Fig. 4.19 Radix Sort Step 2&mdash;4th letter
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.11 Stacks and Queues 133
</p>
<p>Fig. 4.20 Radix Sort Step 3
</p>
<p>Fig. 4.21 Radix Sort Step 4&mdash;3rd letter
</p>
<p>Fig. 4.22 Radix Sort Step 5
</p>
<p>And they all go back to the mainQueue as shown in Fig. 4.24. No change from
</p>
<p>step 5 in this case.
</p>
<p>Finally, we look at the first letter in each string and the sort is almost complete as
</p>
<p>shown in Fig. 4.25.
</p>
<p>Bringing all the strings back to themainQueue results in themainQueue containing
</p>
<p>all the strings in sorted order. The mainQueue can be emptied at this point and the
</p>
<p>strings can be processed in sorted order as depicted in Fig. 4.26.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>134 4 Sequences
</p>
<p>Fig. 4.23 Radix Sort Step 6&mdash;2nd letter
</p>
<p>Fig. 4.24 Radix Sort Step 7
</p>
<p>Fig. 4.25 Radix Sort Step 8&mdash;1st letter
</p>
<p>Radix sort is pretty simple. It is called radix sort because a radix is like a decimal
</p>
<p>pointmoving backwards through the string.Wemove the decimal point one character
</p>
<p>at a time until we get to the first character in each string.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.12 Chapter Summary 135
</p>
<p>Fig. 4.26 Radix Sort Step 9
</p>
<p>4.12 Chapter Summary
</p>
<p>This chapter explored the use of linear sequences in computer programming. These
</p>
<p>sequences come in many forms including randomly accessible lists, matrices, linked
</p>
<p>lists, stacks, and queues. We also saw that a two-dimensional matrix is just a list
</p>
<p>of lists. The chapter also explored operations as related to these datatypes and the
</p>
<p>complexity of these operations.
</p>
<p>Algorithms were also an important part of chapter four. The selection sort, merge
</p>
<p>sort, and quicksort algorithms were studied along with their computational complex-
</p>
<p>ities. Minimax was presented as an interesting case study on using two-dimensional
</p>
<p>matrices and recursion in a program. The infix evaluator and radix sort algorithms
</p>
<p>were also presented as examples of using stacks and queues.
</p>
<p>Having read this chapter you should have an understanding of abstract data types
</p>
<p>like lists, stacks, and queues. You should understand how an abstract data type is
</p>
<p>implemented, how the implementation can affect the complexity of its operations,
</p>
<p>and at least a few algorithms that use these data types in their implementations.
</p>
<p>4.13 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. What is the best case, worst case, and average case complexity of selection sort,
</p>
<p>merge sort, and the quicksort algorithms?
</p>
<p>2. How can the append operation achieve O(1) complexity when it sometimes runs
</p>
<p>out of space to append another item?
</p>
<p>3. What is the complexity of the concatenation operator, the + operator, for lists?
</p>
<p>4. What is the complexity of the deletion operator for lists?
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>136 4 Sequences
</p>
<p>5. When sorting items in a list, what method must be defined for those elements?
</p>
<p>Why?
</p>
<p>6. Why does quicksort perform better than merge sort?
</p>
<p>7. Under what conditions would it be possible for merge sort to perform better than
</p>
<p>quicksort?
</p>
<p>8. Summarize what happens when a list is partitioned.
</p>
<p>9. Summarize what happens when two lists are merged in the merge sort algorithm.
</p>
<p>10. What is the purpose of the start parameter to the select function of the selection
</p>
<p>sort algorithm?
</p>
<p>11. What are the advantages of a linked list over a randomly accessible list imple-
</p>
<p>mentation of a list data type?
</p>
<p>12. What are the advantages of a randomly accessible list over a linked list imple-
</p>
<p>mentation of a list data type?
</p>
<p>13. How does a stack differ from a queue in how we access it?
</p>
<p>14. What is the complexity of the radix sort algorithm?
</p>
<p>4.14 Programming Problems
</p>
<p>1. Write a program that times the quicksort, the merge sort, and the built-in sort
</p>
<p>algorithms in Python to discover which one is better and to see their relative
</p>
<p>speeds. To do this you should implement two sequence classes, a QSequence
</p>
<p>and a MSequence. The QSequence can inherit from the PyList class and
</p>
<p>should implement its own sort algorithm using the quicksort code presented
</p>
<p>in this chapter. The MSequence should be a similar class using the merge sort
</p>
<p>algorithm.
</p>
<p>You can sort anything you like. If you choose to sort objects of some class you
</p>
<p>define, remember that you must implement the __lt__ method for that class.
</p>
<p>Be sure to randomize the elements in the sequence prior to sorting them using
</p>
<p>quicksort. Generate an XML file in the plot format to plot three sequences. Plot
</p>
<p>the time it takes to both randomize and quicksort a sequence. Then plot the
</p>
<p>time it takes to merge sort a sequence. Finally, plot the time it takes to sort the
</p>
<p>same sequence using the built-in sort method. The complexity of merge sort and
</p>
<p>quicksort is O(n log n) so by computational complexity the three algorithms are
</p>
<p>equivalent. What does the experimental data reveal about the two algorithms?
</p>
<p>Put a comment at the top of your program giving your answer.
</p>
<p>To effectively test these three sorting algorithms you should sort items up to a
</p>
<p>list size of at least 1000 elements. You can time the sorts in increments of 100.
</p>
<p>Depending on your computer, you may need to play with the exact numbers to
</p>
<p>some degree to get a good looking graph.
</p>
<p>2. The merge sort algorithm is not as commonly used as the quicksort algorithm
</p>
<p>because quicksort is an inplace sort while merge sort requires at least space for
</p>
<p>one extra copy of the list. In fact, merge sort can be implemented with exactly
</p>
<p>one extra copy of the list. In this exercise you are to re-implement the merge sort
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>4.14 Programming Problems 137
</p>
<p>algorithm to use one extra copy of the list instead of allocating a new list each
</p>
<p>time two lists are merged.
</p>
<p>The extra list is allocated prior to calling the recursive part of the merge sort
</p>
<p>algorithm.Then,with each alternating level of recursion themerge sort algorithm
</p>
<p>copies to the other list, flipping between the two lists. To accomplish this, the
</p>
<p>mergeSortRecursively function should be given a new list of lists called lists
</p>
<p>instead of the seq list. At lists [0] is the seq list and at lists [1] is the extra copy of
</p>
<p>the list. One extra parameter is given to the mergeSortRecursively function. The
</p>
<p>index of the list to merge from is also provided. This index will flip back and
</p>
<p>forth between 0 and 1 as each recursive call tomergeSortRecursively occurs. This
</p>
<p>flipping of 0 to 1 to 0 and so on can be accomplished using modular arithmetic
</p>
<p>by writing:
</p>
<p>listToMergeFromIndex = (listToMergeFromIndex + 1) % 2
</p>
<p>The percent sign is the remainder after dividing by 2. Adding 1 and finding the
</p>
<p>remainder after dividing by twomeans that listToMergeFromIndex flips between
</p>
<p>0 and 1. So, the call is made as mergeSortRecursively(listToMergeFromIndex,
</p>
<p>lists, start, stop). The mergeSortRecursively function must return the new index
</p>
<p>of the list to merge from.
</p>
<p>One part of this new mergeSortRecursively function is a little tricky. There may
</p>
<p>be one more level of recursion on the left or right side for the two recursive calls
</p>
<p>to mergeSortRecursively. If this is the case, then the result from either the left
</p>
<p>or right half must be copied into the same list as the other half before the two
</p>
<p>halves can be successfully merged.
</p>
<p>When mergeSortRecursively returns to the mergeSort function the result of sort-
</p>
<p>ing may be in the original sequence or it may be in the copy. If it is in the copy,
</p>
<p>then the result must be copied back to the original sequence before returning.
</p>
<p>Complete this two list version of merge sort as described in this exercise and test
</p>
<p>it thoroughly. Then time this version of merge sort and compare those timings
</p>
<p>with the version of merge sort presented in the chapter and with the quicksort
</p>
<p>implementation presented in this chapter. Construct an XML file in the format
</p>
<p>read by the PlotData.py program and plot their corresponding timing diagrams
</p>
<p>to see how this algorithm performs when compared to the other two.
</p>
<p>3. Complete the tic tac toe program described in the section on 2-dimensional
</p>
<p>matrices. Use the code from Sect. 20.5 as your starting point. Then complete the
</p>
<p>sections that say they are left as an exercise for the student.
</p>
<p>4. Complete the LinkedList datatype by implementing the delete, equality, iterate,
</p>
<p>length, and membership operations. Make sure they have the complexity given
</p>
<p>in the LinkedList complexities table. Then, implement a test program in your
</p>
<p>main function to thorougly test the operations you implemented. Call themodule
</p>
<p>linkedlist.py so that you can import this into other programs that may need it.
</p>
<p>5. Implement a queue data type using a linked list implementation. Create a set of
</p>
<p>test cases to throroughly test your datatype. Place the datatype in a file called
</p>
<p>queue.py and create a main function that runs your test cases.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>138 4 Sequences
</p>
<p>6. Implement a priority queue data type using a linked list implementation. In a
</p>
<p>priority queue, elements on the queue each have a priority where the lower
</p>
<p>the number the higher the priority. The priorities are usually just numbers. The
</p>
<p>priority queue has the usual enqueue, dequeue, and empty methods. When a
</p>
<p>value is enqueued it is compared to the priority of other items and placed in
</p>
<p>front of all items that have lower priority (i.e. a higher priority number).
</p>
<p>7. Implement a stack data type using a linked list implementation. Create a set of
</p>
<p>test cases to throroughly test your datatype. Place the datatype in a file called
</p>
<p>stack.py and create a main function that runs your test cases.
</p>
<p>8. Implement the infix evaluator program described in the chapter. You should
</p>
<p>accept input and produce output as described in that section of the text. The
</p>
<p>input tokens should will all be separated by blanks to make retrieval of the
</p>
<p>tokens easy. Don&rsquo;t forget to convert your number tokens from strings to floats
</p>
<p>when writing the program.
</p>
<p>9. Implement the radix sort algorithm described in the chapter. Use the algorithm to
</p>
<p>sort a list of words you find on the internet or elsewhere. Write a main program
</p>
<p>that tests your radix sort algorithm.
</p>
<p>10. Searching a sequence of items for a particular item takes O(n) time on average
</p>
<p>where n is the number of items in the list. However, if the list is sorted first, then
</p>
<p>searching for an itemwithin the list can be done inO(log n) time by using a divide
</p>
<p>and conquer approach. This type of search is called binary search. The binary
</p>
<p>search algorithm starts by looking for the item in the middle of the sequence. If
</p>
<p>it is not found there then because the list is sorted the binary search algorithm
</p>
<p>knows whether to look in the left or right side of the sequence. Binary search
</p>
<p>reports True or False depending on whether the item is found. It is often written
</p>
<p>recursively being given a sequence and the beginning and ending index values
</p>
<p>in which to search for the item. For instance, to search an entire sequence called
</p>
<p>seq, binary search might be called as binarySearch(seq,0,len(seq)-1). Write a
</p>
<p>program that builds a PyList or just a Python list of values, sorts them, and
</p>
<p>then looks up random values within the list. Compute the lookup times for lists
</p>
<p>of various sizes and record your results in the PlotData.py format so you can
</p>
<p>visualize your results. You should see aO(log n) curve if you implemented binary
</p>
<p>search correctly.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5Sets and Maps
</p>
<p>In the last chapter we studied sequences which are used to keep track of lists of
</p>
<p>things where duplicate values are allowed. For instance, there can be two sixes in a
</p>
<p>sequence or list of integers. In this chapter we look at sets where duplicate values
</p>
<p>are not allowed. After examining sets we&rsquo;ll move on to talk about maps. Maps may
</p>
<p>also be called dictionaries or hash tables.
</p>
<p>The term hash table actually suggests an implementation of a set or map. The
</p>
<p>primary focus of this chapter is in understanding hashing. Hashing is a very important
</p>
<p>concept in Computer Science because it is a very efficient method of searching for a
</p>
<p>value. To begin the chapterwe&rsquo;llmotivate our interest in hashing, thenwe&rsquo;ll develop a
</p>
<p>hashing algorithm for finding values in a set. We&rsquo;ll also apply hashing to the building
</p>
<p>of sets and maps. Then we&rsquo;ll look at an important technique that uses hashing called
</p>
<p>memoization and we&rsquo;ll apply that technique to a couple of problems.
</p>
<p>5.1 Chapter Goals
</p>
<p>In this chapter you learn how to implement a couple of abstract datatypes: sets and
</p>
<p>maps. You will read about the importance of hashing for both of these datatypes.
</p>
<p>You&rsquo;ll also learn about the importance of understanding the difference betweenmuta-
</p>
<p>ble and immutable data. By the end of the chapter you should be able to answer these
</p>
<p>questions.
</p>
<p>&bull; What is the complexity of finding a value in a set?
</p>
<p>&bull; What is the load factor and how does it affect the overall efficiency of lookup in
</p>
<p>a hash table?
</p>
<p>&bull; When would you use an immutable set?
</p>
<p>&bull; When might you want a mutable set?
</p>
<p>&bull; When is there an advantage to using memoization in a problem?
</p>
<p>&bull; Under what circumstances can it be useful to use a map or dictionary?
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_5
</p>
<p>139
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>140 5 Sets and Maps
</p>
<p>Again, there will be some interesting programming problem challenges in this
</p>
<p>chapter including optimization of the tic tac toe game first presented in the last
</p>
<p>chapter and a Sudoku puzzle solver. Read on to discover what you need to know to
</p>
<p>solve these interesting problems.
</p>
<p>5.2 Playing Sudoku
</p>
<p>Many people enjoy solving Sudoku puzzles. To solve a Sudoku puzzle you must find
</p>
<p>the correct numbers to fill a 9 &times; 9 matrix. All numbers must be 1&ndash;9. Each row must
</p>
<p>have one each of 1&ndash;9 in it. The same is true for each column. Finally, there are nine
</p>
<p>3 &times; 3 squares within the 9 &times; 9 matrix that must also have each of 1&ndash;9 in them. To
</p>
<p>begin, you are given a puzzle with some of the locations known as shown in Fig. 5.1.
</p>
<p>Your job is to find the rest of the numbers given the numbers that already appear in
</p>
<p>the puzzle.
</p>
<p>A common way to solve these puzzles is by the process of elimination. It helps to
</p>
<p>write down the possible values for a puzzle and then eliminate the possible values
</p>
<p>one by one. For instance, the puzzle above can be annotated with possible values in
</p>
<p>for the unknowns as shown in Fig. 5.2.
</p>
<p>To begin solving the puzzle, we can immediately eliminate 8, 3 and 9 from the
</p>
<p>second column of the puzzle for those cells that do not contain 8, 3 or 9. None of
</p>
<p>those numbers could appear in any other cell in the second column because they are
</p>
<p>already known. Likewise, the numbers 8, 6 and 4 can be eliminated from some cells
</p>
<p>Fig. 5.1 A Sudoku Puzzle
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.2 Playing Sudoku 141
</p>
<p>Fig. 5.2 Annotated Sudoku Puzzle
</p>
<p>in the third row in the puzzle because those numbers already appear in other cells.
</p>
<p>Applying rules like these reduces the number of possible values for each cell in the
</p>
<p>puzzle. Figure5.3 shows the puzzle after applying some of these rules.
</p>
<p>If we spend some time thinking about Sudoku and how to solve it we can derive
</p>
<p>two rules that can be used to solve many Sudoku puzzles. These two rules can be
</p>
<p>applied to any group within the puzzle. A group is a collection of nine cells that
</p>
<p>appear in a row, column, or square within the puzzle. Within each cell is a set of
</p>
<p>numbers representing the possible values for the cell at some point in the process of
</p>
<p>reducing the puzzle. Here are the two rules.
</p>
<p>&bull; RULE 1. The first rule is a generalization of the process that we used above to
</p>
<p>remove some values from cells. Within a group look for cells that contain the same
</p>
<p>set of possible values. If the cardinality of the set (i.e. the number of items in the
</p>
<p>set) matches the number of duplicate sets found, then the items of the duplicate sets
</p>
<p>may safely be removed from all non-duplicate sets in the group. This rule applies
</p>
<p>even in the degenerative case where the number of duplicate sets is 1 and the size
</p>
<p>of that set is 1. The degenerative case is what we used above to remove single
</p>
<p>items from other sets. This rule can be applied to Fig. 5.3 to remove the 2 from all
</p>
<p>cells in the 7th row of the puzzle except the 7th column where 2 appears by itself.
</p>
<p>&bull; RULE 2. The second rule looks at each cell within a group and throws away all
</p>
<p>items that appear in other cells in the group. If we are left with only one value in the
</p>
<p>chosen cell, then it must appear in this cell and the cell may be updated by throwing
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>142 5 Sets and Maps
</p>
<p>Fig. 5.3 Sudoku Puzzle After One Pass
</p>
<p>away all other values that appear in the chosen cell. Applying this rule to the fifth
</p>
<p>row in Fig. 5.3 results in the fourth column being reduced to containing a 1 because
</p>
<p>1 does not appear in any other cell in the 5th row. This rule also applies in the last
</p>
<p>row of the puzzle where 2 is only possible in the second column after removing
</p>
<p>1, 5 and 6 from that cell because they appear within other cells in that row.
</p>
<p>Note that the puzzle in Fig. 5.3 is not fully reduced. The reduction process can be
</p>
<p>applied iteratively until nomore reductions are possible. TheSudoku solver algorithm
</p>
<p>keeps applying this reduction process until no more changes are made during a pass
</p>
<p>of reductions on all the groups within the puzzle. Applying these two rules in this
</p>
<p>manner will fully reduce many Sudoku puzzles.
</p>
<p>5.3 Sets
</p>
<p>The reduction algorithm for Sudoku puzzles manipulates sets of numbers and elimi-
</p>
<p>nates possible values from those sets as the reduction progresses. A set is a collection
</p>
<p>that does not allow duplicate values. Sets can be composed of any values. Integers,
</p>
<p>employee objects, characters, strings, literally any object in Python could be an ele-
</p>
<p>ment of some set. A set has a cardinality. The cardinality of a set is the number of
</p>
<p>items in it.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.3 Sets 143
</p>
<p>Operation Complexity Usage Description
</p>
<p>Set Creation O(1) s=set([iterable]) Calls the set constructor to create a set.
</p>
<p>Iterable is an optional initial contents in
</p>
<p>which case we have O(n) complexity.
</p>
<p>Set Creation O(1) s=frozenset([iterable]) Calls the frozenset constructor for im-
</p>
<p>mutable set objects to create a frozenset
</p>
<p>object.
</p>
<p>Cardinality O(1) len(s) The number of elements in s is returned.
</p>
<p>Membership O(1) e in s Returns True if e is in s and False other-
</p>
<p>wise.
</p>
<p>non-
</p>
<p>Membership
</p>
<p>O(1) e not in s Returns True if e is not in s and False oth-
</p>
<p>erwise.
</p>
<p>Disjoint O(n) s.isdisjoint(t) Returns True if s and t share no ele-
</p>
<p>ments, and False otherwise.
</p>
<p>Subset O(n) s.issubset(t) Returns True if s is a subset of t, and
</p>
<p>False otherwise.
</p>
<p>Superset O(n) s.issuperset(t) Returns True if s is a superset of t and
</p>
<p>False otherwise.
</p>
<p>Union O(n) s.union(t) Returns a new set which contains all ele-
</p>
<p>ments in s and t.
</p>
<p>Intersection O(n) s.intersection(t) Returns a new set which contains only
</p>
<p>the elements in both s and t.
</p>
<p>Set Difference O(n) s.difference(t) Returns a new set which contains the el-
</p>
<p>ements of s that are not in t.
</p>
<p>Symmetric Dif-
</p>
<p>ference
</p>
<p>O(n) s.symmetric_difference(t) Returns a new set which contains
</p>
<p>s.difference(t).union(t.difference(s)).
</p>
<p>Set Copy O(n) s.copy() Returns a shallow copy of s.
</p>
<p>Fig. 5.4 Set and Frozen Set Operations
</p>
<p>Sets are objects that have several commonly defined operations on them. These
</p>
<p>operations are sometimes binary operations involving more than one set, and some-
</p>
<p>times retrieve information about just one set. The table in Fig. 5.4 describes com-
</p>
<p>monly defined operations on sets and their associated computational complexities.
</p>
<p>Python has built-in support for two types of sets, the set and frozenset classes. The
</p>
<p>frozenset class is immutable. Objects of the set class can be mutated. In Fig. 5.4 the
</p>
<p>variable smust be a set and the variable t must be an iterable sequence, which would
</p>
<p>include sets.
</p>
<p>Infix operators are also defined as syntactic sugar for some of the operations
</p>
<p>defined in Fig. 5.4. For subset containment you can write s &lt;= t. For proper subset
</p>
<p>you can write s &lt; t. A proper subset is a subset that has at least one less element than
</p>
<p>its superset. For superset you can write s &gt;= t or s &gt; t for proper superset. For the
</p>
<p>union operation, writing s | t is equivalent to writing s.union(t). And for intersection,
</p>
<p>s&amp;t is equivalent to writing s.intersection(t). Writing s &minus; t is the same as writing
</p>
<p>s.difference(t) and s^t is equivalent to the symmetric difference operator.
</p>
<p>The operations in Fig. 5.5 are not defined on the frozenset class since they mutate
</p>
<p>the set s. They are only defined on the set class.
</p>
<p>Again, there are operators for some of the methods presented in Fig. 5.5. The
</p>
<p>mutator union method can be written s|=t. Intersection update can be written as
</p>
<p>s&amp;=t. Finally, the symmetric difference update operator is written s^=t. While these
</p>
<p>operators are convenient, they are not well-known and code written by calling the
</p>
<p>methods in the table above will be more descriptive.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>144 5 Sets and Maps
</p>
<p>Operation Complexity Usage Description
</p>
<p>Union O(n) s.update(t) Adds the contents of t to s.
</p>
<p>Intersection O(n) s.intersection_update(t) Updates s to contain only the intersection
</p>
<p>of the elements from s and t.
</p>
<p>Set Difference O(n) s.difference_update(t) Subtracts from s the elements of t.
</p>
<p>Symmetric Dif-
</p>
<p>ference
</p>
<p>O(n) s.symmetric_difference
</p>
<p>_update(t)
</p>
<p>Updates s with the symmetric difference
</p>
<p>of s and t.
</p>
<p>Add O(1) s.add(e) Add the element e to the set s.
</p>
<p>Remove O(1) s.remove(e) Remove the element e from the set s.
</p>
<p>This raises KeyError if e does not exist
</p>
<p>in s.
</p>
<p>Discard O(1) s.discard(e) Remove the element e if it exists in s and
</p>
<p>ignore it otherwise.
</p>
<p>Pop O(1) s.pop() Remove an arbitrary element of s.
</p>
<p>Clear O(1) s.clear() Remove all the elements of s leaving the
</p>
<p>set empty.
</p>
<p>Fig. 5.5 Mutable Set Operations
</p>
<p>The computational complexities presented above are surprising! How can set
</p>
<p>membership be tested in O(1) time? From what has been presented so far, it should
</p>
<p>take O(n) time to test set membership. After all, we would have to look at all the
</p>
<p>elements in the set, or at least half on average, to know if an item was in the set. How
</p>
<p>can the union of two sets be computed in O(n) time if we are to insure there are no
</p>
<p>duplicates in the set? It would seem that the union of two sets would take O(n2) time
</p>
<p>to compute unless the set could be sorted in some way. But sorting elements of a set
</p>
<p>is not always possible since not all elements of sets have an ordering.
</p>
<p>5.4 Hashing
</p>
<p>If it is possible to implement a set membership test in O(1) time, then we can imple-
</p>
<p>ment the other operations above with the complexities we have indicated. Without a
</p>
<p>O(1) membership test, taking the union of two sets would take a lot longer as indi-
</p>
<p>cated above. Testing set membership in O(1) time is accomplished using hashing.
</p>
<p>Hashing is an extremely important concept in Computer Science and is related to ran-
</p>
<p>dom access in a computer. As we saw back in Chap.2, accessing any location within
</p>
<p>a list can be accomplished inO(1) time. This is the principle of random access. A ran-
</p>
<p>domly accessible list means any location within the list can be accessed in O(1) time.
</p>
<p>To access a location in a list we need the index of the location we wish to access. The
</p>
<p>index serves as the address of an item in the list.Oncewehave stored an item in the list,
</p>
<p>wemust remember its index ifwewish to retrieve it inO(1) time.Without the indexwe
</p>
<p>would have to search for the item in the listwhichwould takeO(n) time, notO(1) time.
</p>
<p>So, if we wanted to implement a set where we could test membership in O(1) time
</p>
<p>we might think of storing the items of the set in a list. We would somehow have to
</p>
<p>remember the index where each item was stored to find it again in O(1) time. This
</p>
<p>seems improbable at first. However, what if the item could be used to figure out its
</p>
<p>address? This is the insight that led to hashing. Each object in the computer must
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>5.4 Hashing 145
</p>
<p>be stored as a string of zeroes and ones since computers speak binary. These zeroes
</p>
<p>and ones can be interpreted however we like, including as the index into a list. This
</p>
<p>concept is so important that Python (andmany other modern languages) has included
</p>
<p>a function called hash that can be called on any object to return an integer value for
</p>
<p>an object. We&rsquo;ll call this value the object&rsquo;s hash code or hash value. Consider these
</p>
<p>calls to the hash function.
</p>
<p>Python 3.2 (r32:88452, Feb 20 2011, 10:19:59)
</p>
<p>[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
</p>
<p>Type "help", "copyright", "credits" or "license" for more information.
</p>
<p>&gt;&gt;&gt; hash("abc")
</p>
<p>-1600925533
</p>
<p>&gt;&gt;&gt; hash("123")
</p>
<p>1911471187
</p>
<p>&gt;&gt;&gt; hash(45)
</p>
<p>45
</p>
<p>&gt;&gt;&gt; hash(45.0)
</p>
<p>45
</p>
<p>&gt;&gt;&gt; hash(45.3)
</p>
<p>1503225491
</p>
<p>&gt;&gt;&gt; hash(True)
</p>
<p>1
</p>
<p>&gt;&gt;&gt; hash(False)
</p>
<p>0
</p>
<p>&gt;&gt;&gt; hash([1,2,3])
</p>
<p>Traceback (most recent call last):
</p>
<p>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</p>
<p>TypeError: unhashable type: &rsquo;list&rsquo;
</p>
<p>&gt;&gt;&gt;
</p>
<p>While most objects are hashable, not every object is. In particular, mutable objects
</p>
<p>like lists may not be hashable because when an object is mutated its hash value may
</p>
<p>also change. This has consequenceswhen using hash values in data structures aswe&rsquo;ll
</p>
<p>see later in this chapter. In addition to built-in types, Python let&rsquo;s the programmer
</p>
<p>have some control over hash codes by implementing a __hash__method on a class. If
</p>
<p>you write a __hash__method for a class you can return whatever hash value integer
</p>
<p>you like for instances of that class.
</p>
<p>Notice that calling hash on the string &ldquo;abc&rdquo; returned a negative value while other
</p>
<p>calls to hash returned extremely large integers. Clearly some work has to be done
</p>
<p>to convert this hash integer into an acceptable index into a list. Read on to discover
</p>
<p>how hash values are converted into list indices.
</p>
<p>5.5 The HashSet Class
</p>
<p>We can use a hash value to compute an index into a list to obtain O(1) item lookup
</p>
<p>complexity. To hide the details of the list and the calling of the hash function to find
</p>
<p>the index of the item, a set class can be written. We&rsquo;ll call our set class HashSet,
</p>
<p>not to be confused with the built-in set class of Python. The built-in set class uses
</p>
<p>hashing, too. The HashSet class presented in this section shows you how the set
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>146 5 Sets and Maps
</p>
<p>class is implemented. To begin, HashSet objects will contain a list and the number
</p>
<p>of items in the list. Initially the list will contain a bunch of None values. The list
</p>
<p>must be built with some kind of value in it. None serves as a null value for places
</p>
<p>in the list where no value has been stored. The list isn&rsquo;t nearly big enough to have
</p>
<p>a location for every possible hash value. Yet, the list can&rsquo;t possibly be big enough
</p>
<p>for all possible hash values anyway. In fact, as we saw in the last section, some hash
</p>
<p>values are negative and clearly indices into a list are not negative. The conversion
</p>
<p>of a hash value to a list index is explained in more detail in Sect. 5.5.2. The HashSet
</p>
<p>constructor is given in Sect. 5.5.1.
</p>
<p>5.5.1 The HashSet Constructor
</p>
<p>1 class HashSet:
</p>
<p>2     def __init__(self,contents=[]):
</p>
<p>3         self.items = [None] * 10
</p>
<p>4         self.numItems = 0
</p>
<p>5
</p>
<p>6         for item in contents:
</p>
<p>7             self.add(item)
</p>
<p>5.5.2 Storing an Item
</p>
<p>To store an item in a hash set we first compute its index using the hash function.
</p>
<p>There are two problems that must be dealt with. First, the list that items are stored
</p>
<p>in must be finite in length and definitely cannot be as long as the unique hash values
</p>
<p>we would generate by calling the hash function. Since the list must be shorter than
</p>
<p>the maximum hash value, we pick a size for our list and then divide hash values by
</p>
<p>the length of this list. The remainder (i.e. the result of the % operator, called themod
</p>
<p>operator) is used as the index into the list. The remainder after dividing by the length
</p>
<p>of the list will always be between 0 and the length of the list minus one even if the
</p>
<p>hash value is a negative integer. Using the mod operator will give us valid indices
</p>
<p>into a list of whatever size we choose.
</p>
<p>There is another problem we must deal with. Hash values are not necessarily
</p>
<p>unique. Hash values are integers and there are only finitely many integers possible
</p>
<p>in a computer. In addition, because we divide hash values by the length of the list,
</p>
<p>the remainders, or list indices, will be even less unique than the original hash values.
</p>
<p>If the list length is 10, then a hash value of 44 and &minus;6 will both result in trying to
</p>
<p>store a value at index 4 in the list. This isn&rsquo;t possible of course.
</p>
<p>5.5.3 Collision Resolution
</p>
<p>Consider trying to store both &ldquo;Cow&rdquo; and &ldquo;Fox&rdquo; using hashing in a list whose length
</p>
<p>is 10. The hash value of &ldquo;Cow&rdquo; is &minus;1432160826 and the hash value of &ldquo;Fox&rdquo; is
</p>
<p>1462539404. When we mod both values by 10 the remainder is 4 for both hash
</p>
<p>values indicating they should both be stored at the fifth location in a list.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5 The HashSet Class 147
</p>
<p>When two objects need to be stored at the same index within the hash set list,
</p>
<p>because their computed indices are identical, we call this a collision. It is necessary
</p>
<p>to define a collision resolution scheme to deal with this. There are many different
</p>
<p>schemes that are possible. We&rsquo;ll explore a scheme called Linear Probing. When a
</p>
<p>collision occurs while using linear probing, we advance to the next location in the
</p>
<p>list to see if that location might be available. We can tell if a location is available if
</p>
<p>we find a None value in that spot in the list. It turns out that there is one other value
</p>
<p>we might find in the list that means that location is available. A special type of object
</p>
<p>called a __Placeholder objectmight also be stored in the list. The reason for this class
</p>
<p>will become evident in the next section. For now, a None or a __Placeholder object
</p>
<p>indicates an open locationwithin the hash set list. The code in Sect. 5.5.4 takes care of
</p>
<p>adding an item into theHashSet list and is a helper function for the actual addmethod.
</p>
<p>5.5.4 HashSet Add Helper Function
</p>
<p>1 def __add(item,items):
</p>
<p>2     idx = hash(item) % len(items)
</p>
<p>3     loc = -1
</p>
<p>4
</p>
<p>5     while items[idx] != None:
</p>
<p>6         if items[idx] == item:
</p>
<p>7             # item already in set
</p>
<p>8             return False
</p>
<p>9
</p>
<p>10
</p>
<p>11         if loc &lt; 0 and type(items[idx]) == HashSet.__Placeholder:
</p>
<p>12             loc = idx
</p>
<p>13
</p>
<p>14         idx = (idx + 1) % len(items)
</p>
<p>15
</p>
<p>16     if loc &lt; 0:
</p>
<p>17         loc = idx
</p>
<p>18
</p>
<p>19     items[loc] = item
</p>
<p>20
</p>
<p>21     return True
</p>
<p>The code in Sect. 5.5.4 does not add an item that is already in the list. The while
</p>
<p>loop is the linear probing part of the code. The index idx is incremented, mod the
</p>
<p>length of the list, until either the item is found or aNone value is encountered. Finding
</p>
<p>a None value indicates the end of the linear chain and hence the end of any linear
</p>
<p>searching that must be done to determine if the item is already in the set. If the item is
</p>
<p>not in the list, then the item is added either at the location of the first __Placeholder
</p>
<p>object found in the search, or at the location of theNone value at the end of the chain.
</p>
<p>There is one more issue that must be dealt with when adding a value. Imagine
</p>
<p>that only one position was open in the hash set list. What would happen in the code
</p>
<p>above? The linear search would result in searching the entire list. If the list were full,
</p>
<p>the result would be an infinite loop. We don&rsquo;t want either to happen. In fact, we want
</p>
<p>to be able to add an item in amortized O(1) time. To insure that we get an amortized
</p>
<p>complexity of O(1), the list must never be full or almost full.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>148 5 Sets and Maps
</p>
<p>5.5.5 The Load Factor
</p>
<p>The fullness of the hash set list is called its load factor.We can find the load factor of a
</p>
<p>hash set by dividing the number of items stored in the list by its length. A really small
</p>
<p>load factor means the list is much bigger than the number of items stored in it and
</p>
<p>the chance there is a collision is small. A high load factor means more efficient space
</p>
<p>utilization, but higher chance of a collision. Experimentation can help to determine
</p>
<p>optimal load factors, but a reasonablemaximum load factor is 75% full.When adding
</p>
<p>a value into the list, if the resulting load factor is greater than 75% then all the values
</p>
<p>in the list must be transferred to a new list. To transfer the values to a new list the
</p>
<p>values must be hashed again because the new list is a different length. This process
</p>
<p>is called rehashing. In the hash set implementation we chose to double the size of
</p>
<p>the list when rehashing was necessary.
</p>
<p>The code in Sect. 5.5.6 calls the __add function from Sect. 5.5.4. This code and
</p>
<p>the __add method are in the HashSet class. The __add and __rehash functions are
</p>
<p>hidden helper functions used by the publicly accessible add method.
</p>
<p>5.5.6 HashSet Add
</p>
<p>1 def __rehash(oldList, newList):
</p>
<p>2     for x in oldList:
</p>
<p>3         if x != None and type(x) != HashSet.__Placeholder:
</p>
<p>4             HashSet.__add(x,newList)
</p>
<p>5
</p>
<p>6     return newList
</p>
<p>7
</p>
<p>8 def add(self, item):
</p>
<p>9     if HashSet.__add(item,self.items):
</p>
<p>10         self.numItems += 1
</p>
<p>11         load = self.numItems / len(self.items)
</p>
<p>12         if load &gt;= 0.75:
</p>
<p>13             self.items = HashSet.__rehash(self.items,[None]*2*len(self.items))
</p>
<p>Since the load factor is managed, the amortized complexity of adding a value to
</p>
<p>the list is O(1). This means the length of any chain within the list will be a finite
</p>
<p>length independent of the number of items in the hash set.
</p>
<p>5.5.7 Deleting an Item
</p>
<p>Deleting a value from a hash setmeans first finding the item. Thismay involve doing a
</p>
<p>linear search in the chain of values that reside at a location in the list. If the value to be
</p>
<p>deleted is the last in a chain then it can be replacedwith aNone. If it is in themiddle of
</p>
<p>a chain thenwe cannot replace itwithNone because thiswould cut the chain of values.
</p>
<p>Instead, the item is replaced with a __Placeholder object. A place holder object does
</p>
<p>not break a chain and a linear probe continues to search skipping over placeholder
</p>
<p>objects when necessary. The remove helper function is given in Sect. 5.5.8.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5 The HashSet Class 149
</p>
<p>5.5.8 HashSet Remove Helper Function
</p>
<p>1 class __Placeholder:
</p>
<p>2     def __init__(self):
</p>
<p>3         pass
</p>
<p>4
</p>
<p>5     def __eq__(self,other):
</p>
<p>6         return False
</p>
<p>7
</p>
<p>8 def __remove(item,items):
</p>
<p>9     idx = hash(item) % len(items)
</p>
<p>10
</p>
<p>11     while items[idx] != None:
</p>
<p>12         if items[idx] == item:
</p>
<p>13             nextIdx = (idx + 1) % len(items)
</p>
<p>14             if items[nextIdx] == None:
</p>
<p>15                 items[idx] = None
</p>
<p>16             else:
</p>
<p>17                 items[idx] = HashSet.__Placeholder()
</p>
<p>18             return True
</p>
<p>19
</p>
<p>20         idx = (idx + 1) % len(items)
</p>
<p>21
</p>
<p>22     return False
</p>
<p>When removing an item, the load factor may get too low to be efficiently using
</p>
<p>space in memory. When the load factor dips below 25%, the list is again rehashed
</p>
<p>to decrease the list size by one half to increase the load factor. The remove method
</p>
<p>is provided in Sect. 5.5.9.
</p>
<p>5.5.9 HashSet Remove
</p>
<p>1 def remove(self, item):
</p>
<p>2     if HashSet.__remove(item,self.items):
</p>
<p>3         self.numItems -= 1
</p>
<p>4         load = max(self.numItems, 10) / len(self.items)
</p>
<p>5         if load &lt;= 0.25:
</p>
<p>6             self.items = HashSet.__rehash(self.items,[None]*int(len(self.items)/2))
</p>
<p>7     else:
</p>
<p>8         raise KeyError("Item not in HashSet")
</p>
<p>For the same reason that adding a value can be done in O(1) time, deleting a value
</p>
<p>can also be donewith an amortized complexity of O(1). The discardmethod is nearly
</p>
<p>the same of the remove method presented in Sect. 5.5.9 except that no exception is
</p>
<p>raised if the item is not in the set when it is discarded.
</p>
<p>5.5.10 Finding an Item
</p>
<p>To find an item in a hash set involves hashing the item to find its address and then
</p>
<p>searching the possible chain of values. The chain terminates with a None. If the item
</p>
<p>is in the chain somewhere then the __contains__ method will return True and False
</p>
<p>will be returned otherwise. The method in Sect. 5.5.11 is called when item in set is
</p>
<p>written in a program.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>150 5 Sets and Maps
</p>
<p>5.5.11 HashSet Membership
</p>
<p>1 def __contains__(self, item):
</p>
<p>2     idx = hash(item) % len(self.items)
</p>
<p>3     while self.items[idx] != None:
</p>
<p>4         if self.items[idx] == item:
</p>
<p>5             return True
</p>
<p>6
</p>
<p>7         idx = (idx + 1) % len(self.items)
</p>
<p>8
</p>
<p>9     return False
</p>
<p>Finding an item results in O(1) amortized complexity as well. The chains are kept
</p>
<p>short as long as most hash values are evenly distributed and the load factor is kept
</p>
<p>from approaching 1.
</p>
<p>5.5.12 Iterating Over a Set
</p>
<p>To iterate over the items of a set we need to define the __iter__ method to yield
</p>
<p>the elements of the HashSet. The method traverses the list of items skipping over
</p>
<p>placeholder elements and None references. Here is the code for the iterator.
</p>
<p>1 def __iter__(self):
</p>
<p>2     for i in range(len(self.items)):
</p>
<p>3         if self.items[i] != None and type(self.items[i]) != HashSet.__Placeholder:
</p>
<p>4             yield self.items[i]
</p>
<p>5.5.13 Other Set Operations
</p>
<p>Many of the other set operations on the HashSet are left as an exercise for the reader.
</p>
<p>However,most of themcanbe implemented in termsof themethods alreadypresented
</p>
<p>in this chapter. Consider the difference_updatemethod. It can be implemented using
</p>
<p>the iterator, the membership test, and the discard method. The code in Sect. 5.5.14
</p>
<p>provides the implementation for the difference_update method.
</p>
<p>5.5.14 HashSet Difference Update
</p>
<p>1 def difference_update(self, other):
</p>
<p>2     for item in other:
</p>
<p>3         self.discard(item)
</p>
<p>The difference_update method presented in Sect. 5.5.14 is a mutator method
</p>
<p>because it alters the sequence referenced by self. Compare that with the difference
</p>
<p>method in Sect. 5.5.15 which does not mutate the object referenced by self. Instead,
</p>
<p>the difference method returns a new set which consists of the difference of self and
</p>
<p>the other set.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.5 The HashSet Class 151
</p>
<p>5.5.15 HashSet Difference
</p>
<p>1 def difference(self, other):
</p>
<p>2     result = HashSet(self)
</p>
<p>3     result.difference_update(other)
</p>
<p>4     return result
</p>
<p>The differencemethod is implemented using the difference_updatemethod on the
</p>
<p>result HashSet. Notice that a new set is returned. The hash set referenced by self is
</p>
<p>not updated. The code is simple and it has the added benefit that if difference_update
</p>
<p>is correctly written, so will this method. Programmers should always avoid writing
</p>
<p>duplicate code when possible and difference and difference_udpate are nearly identi-
</p>
<p>cal except that the differencemethod performs the difference on a newly constructed
</p>
<p>set instead of the set that self references.
</p>
<p>5.6 Solving Sudoku
</p>
<p>Using a set or a HashSet datatype, we now have the tools to solve most Sudoku
</p>
<p>puzzles. A puzzle can be read from a file where known values are represented by
</p>
<p>their digit and unknown values are X&rsquo;s as in the puzzle below.
</p>
<p>x x x x x x x x x
</p>
<p>x x x x 1 x x 9 2
</p>
<p>x 8 6 x x x x 4 x
</p>
<p>x x 1 5 6 x x x x
</p>
<p>x x x x x 3 6 2 x
</p>
<p>x x x x x x 5 x 7
</p>
<p>x 3 x x x x x 8 x
</p>
<p>x 9 x 8 x 2 x x x
</p>
<p>x x 7 x x 4 3 x x
</p>
<p>Reading the dateable can be done a line at a time. Splitting the line will provide
</p>
<p>a string with each known and unknown value as a separate item in the list. When
</p>
<p>an X is encountered a set containing all values 1&ndash;9 can be constructed, just as you
</p>
<p>would if solving Sudoku by hand.When a known value is found a set with the known
</p>
<p>number in it can be constructed.
</p>
<p>The sets are added to a two-dimensional matrix. The matrix is a list of lists. So
</p>
<p>reading a line corresponds to reading a row of the matrix. Each line becomes a list
</p>
<p>of sets. Each list of sets is added to a list we&rsquo;ll call the matrix. So, matrix[row][col]
</p>
<p>is one set within the Sudoku puzzle.
</p>
<p>There are 81 sets within a Sudoku puzzle. However, each set is a member of three
</p>
<p>groups: the row, the column, and the square in which it resides. The rules presented
</p>
<p>in the Sudoku puzzle description above each deal with reducing a set within one of
</p>
<p>these groups. After reading the input from the file and forming the matrix with the
</p>
<p>81 sets, 27 groups are formed by creating a list of groups.
</p>
<p>A shallow copy of each row is first appended to the list of groups. A shallow copy
</p>
<p>means that each of the sets is the same set that was created when the puzzle was read.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>152 5 Sets and Maps
</p>
<p>A deep copy would create a copy of each of the 81 sets. A shallow copy of a list does
</p>
<p>not copy the sets within the list. Calling list on a list will make a shallow copy.
</p>
<p>Another group is formed for each column and those groups are appended to
</p>
<p>the list of groups. Finally, a group is formed for each square and those groups are
</p>
<p>appended to the list of groups. When all done, there is one groups list with 27 groups
</p>
<p>in it. When forming these groups it is critical that the same set appears in each of
</p>
<p>three groups. This is because when a row is reduced, we want the changes in that
</p>
<p>row to be reflected in the columns and squares where the elements of the row also
</p>
<p>appear.
</p>
<p>Solving a Sudoku puzzle means reducing the number of items in each set of
</p>
<p>a group according to the two rules presented in Sect. 5.2. Writing a function called
</p>
<p>reduceGroup that is given a list of 9 sets to reduce can help. The function reduceGroup
</p>
<p>should return True if it was able to reduce the group and False if it was not. Given
</p>
<p>this reduceGroup function, the reduce function is as defined in Sect. 5.6.1.
</p>
<p>5.6.1 The Sudoku Reduce Function
</p>
<p>1     def reduce(matrix):
</p>
<p>2       changed = True
</p>
<p>3       groups = getGroups(matrix)
</p>
<p>4
</p>
<p>5       while changed:
</p>
<p>6         changed = reduceGroups(groups)
</p>
<p>This algorithm is quite simple, and yet very powerful. It is different than any
</p>
<p>other algorithms that have been presented so far in this text. The concept is quite
</p>
<p>simple: keep reducing until no more reductions are possible. We are guaranteed that
</p>
<p>it will terminate since each iteration of the algorithm reduces the number of items in
</p>
<p>some of the sets of the puzzle. We never increase the size of any of these sets. Once
</p>
<p>we return from this function we may or may not have a solution. There are some
</p>
<p>puzzles that will not be solved by this Sudoku solver because the two rules that are
</p>
<p>presented above are not powerful enough for all puzzles. There are some situations
</p>
<p>where the number of items in a set cannot be reduced by looking at just one group.
</p>
<p>You would have to look at more than one group at the same time to figure out how
</p>
<p>to reduce the number of sets. Hold on, you don&rsquo;t need to figure out any more rules.
</p>
<p>The next chapter will present an algorithm for solving all Sudoku puzzles, even the
</p>
<p>very hardest of them.
</p>
<p>The rules presented in this chapter will solve the Sudoku puzzle given in this
</p>
<p>section andmany others. Sudoku puzzles one through six on the text&rsquo;s website can be
</p>
<p>solved by this Sudoku solver. The reduceGroups function above would presumably
</p>
<p>call reduceGroup on each of the groups in its list and it would return True if any of
</p>
<p>the groups are reduced and False otherwise.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.7 Maps 153
</p>
<p>5.7 Maps
</p>
<p>Amap in computer science is not like themap you used to readwhen going someplace
</p>
<p>in your car. The term map is a more mathematical term referring to a function that
</p>
<p>maps a domain to a range. You may have already used a map in Python. Maps are
</p>
<p>called by many names including dictionaries, hash tables, and hash maps. They are
</p>
<p>all the same data structure.
</p>
<p>A map or dictionary maps a set of unique keys to their associated values much the
</p>
<p>way a function maps a value in the domain to the range. A key is what we provide
</p>
<p>to a map when we want to look for the key/value pair. The keys of a map are unique.
</p>
<p>There can only be one copy of a specific key value in the dictionary at a time. As
</p>
<p>we saw in chapter one, Python has built-in support for dictionaries or maps. Here is
</p>
<p>some sample interaction with a dictionary in the Python shell.
</p>
<p>Python 3.2 (r32:88452, Feb 20 2011, 10:19:59)
</p>
<p>[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
</p>
<p>Type "help", "copyright", "credits" or "license" for more information.
</p>
<p>&gt;&gt;&gt; d = {}
</p>
<p>&gt;&gt;&gt; d["dog"] = "cat"
</p>
<p>&gt;&gt;&gt; d["batman"] = "joker"
</p>
<p>&gt;&gt;&gt; d["superman"] = "lex luther"
</p>
<p>&gt;&gt;&gt; for key in d:
</p>
<p>...     print(key)
</p>
<p>...
</p>
<p>batman
</p>
<p>dog
</p>
<p>superman
</p>
<p>&gt;&gt;&gt; for key in d:
</p>
<p>...     print(key,d[key])
</p>
<p>...
</p>
<p>batman joker
</p>
<p>dog cat
</p>
<p>superman lex luther
</p>
<p>&gt;&gt;&gt; len(d)
</p>
<p>3
</p>
<p>&gt;&gt;&gt; d["dog"] = "skunk"
</p>
<p>&gt;&gt;&gt; d["dog"]
</p>
<p>&rsquo;skunk&rsquo;
</p>
<p>&gt;&gt;&gt;
</p>
<p>Amap, or dictionary, is a lot like a set. A set and a dictionary both contain unique
</p>
<p>values. The set datatype contains a group of unique values. A map contains a set of
</p>
<p>unique keys that map to associated values. Like sets, we can look up a key in the
</p>
<p>map, and its associated value, in O(1) time. As you might expect, maps, like sets, are
</p>
<p>implemented using hashing.While the underlying implementation is the same, maps
</p>
<p>and sets are used differently. The table below provides the methods and operators of
</p>
<p>maps or dictionaries and their associated complexities.
</p>
<p>The operations in the table above have the expected complexities given a hash-
</p>
<p>ing implementation as was presented in Sect. 5.5. The interesting difference is that
</p>
<p>key/value pairs are stored in the dictionary as opposed to just the items of a set. The
</p>
<p>key part of the key/value pair is used to determine if a key is in the dictionary as you
</p>
<p>might expect. The value is returned when appropriate.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>154 5 Sets and Maps
</p>
<p>5.7.1 The HashMap Class
</p>
<p>AHashMap class, like the dict class in Python, uses hashing to achieve the complex-
</p>
<p>ities outlined in the table in Fig. 5.6. A private __KVPair class is defined. Instances
</p>
<p>of __KVPair hold the key/value pairs as they are added to theHashMap object. With
</p>
<p>the addition of a __getitem__method on the HashSet class, the HashSet class could
</p>
<p>be used for the HashMap class implementation. The additional __getitem__method
</p>
<p>for the HashSet is given in Sect. 5.7.3.
</p>
<p>5.7.2 HashSet Get Item
</p>
<p>1 # One extra HashSet method for use with the HashMap class.
</p>
<p>2 def __getitem__(self, item):
</p>
<p>3     idx = hash(item) % len(self.items)
</p>
<p>4     while self.items[idx] != None:
</p>
<p>5         if self.items[idx] == item:
</p>
<p>6             return self.items[idx]
</p>
<p>7
</p>
<p>8         idx = (idx + 1) % len(self.items)
</p>
<p>9
</p>
<p>10     return None
</p>
<p>Operation Complexity Usage Description
</p>
<p>Dictionary Cre-
</p>
<p>ation
</p>
<p>O(1) d = {[iterable]} Calls the constructor to create a dictionary. Iter-
</p>
<p>able is an optional initial contents in which case it
</p>
<p>is O(n) complexity.
</p>
<p>Size O(1) len(d) The number of key/value pairs in the dictionary.
</p>
<p>Membership O(1) k in d Returns True if k is a key in d and False other-
</p>
<p>wise.
</p>
<p>non-
</p>
<p>Membership
</p>
<p>O(1) k not in d Returns True if k is not a key in d and False oth-
</p>
<p>erwise.
</p>
<p>Add O(1) d[k] = v Adds (k,v) as a key/value pair in d.
</p>
<p>Lookup O(1) d[k] Returns the value associated with the key, k. A
</p>
<p>KeyError exception is raised if k is not in d.
</p>
<p>Lookup O(1) d.get(k[,default]) Returns v for the key/value pair (k,v). If k is not in
</p>
<p>d returns default or None if not specified.
</p>
<p>Remove Key/-
</p>
<p>Value Pair
</p>
<p>O(1) del d[k] Removes the (k,v) key value pair from d. Raises
</p>
<p>KeyError if k is not in d.
</p>
<p>Items O(1) d.items() Returns a view of the key/value pairs in d. The
</p>
<p>view updates as d changes.
</p>
<p>Keys O(1) d.keys() Returns a view of the keys in d. The view updates
</p>
<p>as d changes.
</p>
<p>Values O(1) d.values() Returns a view of the values in d. The view up-
</p>
<p>dates as d changes.
</p>
<p>Pop O(1) d.pop(k) Returns the value associated with key k and
</p>
<p>deletes the item. Raises KeyError if k is not in
</p>
<p>d.
</p>
<p>Pop Item O(1) d.popitem() Return an abritrary key/value pair, (k,v), from d.
</p>
<p>Set Default O(1) d.setdefault(k[,
</p>
<p>default])
</p>
<p>Sets k as a key in d and maps k to default or
</p>
<p>None if not specified.
</p>
<p>Update O(n) d.update(e) Updates the dictionary, d, with the contents of dic-
</p>
<p>tionary e.
</p>
<p>Clear O(1) d.clear() Removes all key/value pairs from d.
</p>
<p>Dictionary Copy O(n) d.copy() Returns a shallow copy of d.
</p>
<p>Fig. 5.6 Dictionary Operations
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.7 Maps 155
</p>
<p>Then, to implement theHashMapwe can use aHashSet as shown in Sect. 5.7.3. In
</p>
<p>the __KVPair class definition it is necessary to define the __eq__method so that keys
</p>
<p>are compared when comparing two items in the hash map. The __hash__ method
</p>
<p>of __KVPair hashes only the key value since keys are used to look up key/value
</p>
<p>pairs in the hash map. The implementation provided in Sect. 5.7.3 is partial. The
</p>
<p>other methods are left as an exercise for the reader.
</p>
<p>5.7.3 The HashMap Class
</p>
<p>1     class HashMap:
</p>
<p>2         class __KVPair:
</p>
<p>3             def __init__(self,key,value):
</p>
<p>4                 self.key = key
</p>
<p>5                 self.value = value
</p>
<p>6
</p>
<p>7             def __eq__(self,other):
</p>
<p>8                 if type(self) != type(other):
</p>
<p>9                     return False
</p>
<p>10
</p>
<p>11                 return self.key == other.key
</p>
<p>12
</p>
<p>13             def getKey(self):
</p>
<p>14                 return self.key
</p>
<p>15
</p>
<p>16             def getValue(self):
</p>
<p>17                 return self.value
</p>
<p>18
</p>
<p>19             def __hash__(self):
</p>
<p>20                 return hash(self.key)
</p>
<p>21
</p>
<p>22         def __init__(self):
</p>
<p>23             self.hSet = hashset.HashSet()
</p>
<p>24
</p>
<p>25         def __len__(self):
</p>
<p>26             return len(self.hSet)
</p>
<p>27
</p>
<p>28         def __contains__(self,item):
</p>
<p>29             return HashSet.__KVPair(item,None) in self.hSet
</p>
<p>30
</p>
<p>31         def not__contains__(self,item):
</p>
<p>32             return item not in self.hSet
</p>
<p>33
</p>
<p>34         def __setitem__(self,key,value):
</p>
<p>35             self.hSet.add(HashMap.__KVPair(key,value))
</p>
<p>36
</p>
<p>37         def __getitem__(self,key):
</p>
<p>38             if HashMap.__KVPair(key,None) in self.hSet:
</p>
<p>39                 val = self.hSet[HashMap.__KVPair(key,None)].getValue()
</p>
<p>40                 return val
</p>
<p>41
</p>
<p>42             raise KeyError("Key " + str(key) + " not in HashMap")
</p>
<p>43
</p>
<p>44         def __iter__(self):
</p>
<p>45             for x in self.hSet:
</p>
<p>46                 yield x.getKey()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>156 5 Sets and Maps
</p>
<p>The provided implementation in Sect. 5.7.3 helps to demonstrate the similarities
</p>
<p>between the implementation of theHashSet class and theHashMap class, or between
</p>
<p>the set and dict classes in Python. The two types of data structures are both imple-
</p>
<p>mented using hashing. Both rely heavily on a O(1) membership test. While under-
</p>
<p>standing how the HashMap class is implemented is important, most programming
</p>
<p>languages include some sort of hash map in their library of built-in types, as does
</p>
<p>Python. It is important to understand the complexity of the methods on a hash map,
</p>
<p>but just as important is understanding when to use a hashmap and how it can be used.
</p>
<p>Read on to see howyou can use a hashmap in code youwrite tomake itmore efficient.
</p>
<p>5.8 Memoization
</p>
<p>Memoization is an interesting programming technique that can be employed when
</p>
<p>you write functions that may get called more than once with the same arguments.
</p>
<p>The idea behind memoization is to do the work of computing a value in a function
</p>
<p>once. Then, we make a note to ourselves so when the function is called with the same
</p>
<p>arguments again, we return the value we just computed again. This avoids going to
</p>
<p>the work of computing the value all over again.
</p>
<p>A powerful example of this is the recursive Fibonacci function. The Fibonacci
</p>
<p>sequence is defined as follows.
</p>
<p>&bull; Fib(0) = 0
</p>
<p>&bull; Fib(1) = 1
</p>
<p>&bull; Fib(n) = Fib(n&minus;1) + Fib(n&minus;2)
</p>
<p>This sequence can be computed recursively by writing a Python function as
</p>
<p>follows.
</p>
<p>def fib(n):
</p>
<p>    if n == 0:
</p>
<p>        return 0
</p>
<p>    if n == 1:
</p>
<p>        return 1
</p>
<p>    return fib(n-1) + fib(n-2)
</p>
<p>However, we would never want to use this function for anything but a simple
</p>
<p>demonstration of a small Fibonacci number. The function cannot be used to com-
</p>
<p>puting something as big as fib(100) even. Running the function with an argument
</p>
<p>of 100 will take a very long time on even the fastest computers. Consider what hap-
</p>
<p>pens to compute fib(5). To do that fib(4) and fib(3) must first be computed. Then the
</p>
<p>two results can be added together to find fib(5). But, to compute fib(4) the values
</p>
<p>fib(3) and fib(2) must be computed. Now we are computing fib(3) twice to compute
</p>
<p>fib(5), But to compute fib(3) we must compute fib(2) and fib(1). But, fib(2) must be
</p>
<p>computed to find fib(4) as well. Figure5.7 shows all the calls to fib to compute fib(5).
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.8 Memoization 157
</p>
<p>Fig. 5.7 Computing fib(5)
</p>
<p>As you can see from Fig. 5.7, it takes a lot of calls to the fib function to compute
</p>
<p>fib(5). Now imagine how many calls it would take to compute fib(6). To compute
</p>
<p>fib(6) we first have to compute fib(5) and then compute fib(4). It took 15 calls to fib to
</p>
<p>compute fib(5) and from the figure we can see that it takes 9 calls to compute fib(4).
</p>
<p>Including the call to fib(6) it will take 25 calls to fib to compute fib(6). Computing
</p>
<p>fib(7) will take 15 + 25 + 1 calls or 41 calls. Computing fib(n) this way more than
</p>
<p>doubles the number of calls to compute fib(n&minus;2). This is called exponential growth.
</p>
<p>The complexity of the fib function is O(2n). A function with exponential complexity
</p>
<p>is worthless except for very small values of n.
</p>
<p>All is not lost. There are better ways of computing the Fibonacci sequence. The
</p>
<p>way to improve the efficiency is to avoid all that unnecessary work. Once fib(2) has
</p>
<p>been computed, we shouldn&rsquo;t compute it again. We already did that work. There are
</p>
<p>at least a couple of ways of improving the efficiency. One method involves removing
</p>
<p>the recursion and computing fib(n) with a loop, which is probably the best option.
</p>
<p>However, the recursive function is closer to the original definition. We can improve
</p>
<p>the recursive version of the function with memoization. In Sect. 5.8.1, the memo
</p>
<p>dictionary serves as our mapping from values of n to their fib(n) result.
</p>
<p>5.8.1 A Memoized Fibonacci Function
</p>
<p>1 memo = {}
</p>
<p>2
</p>
<p>3 def fib(n):
</p>
<p>4     if n in memo:
</p>
<p>5         return memo[n]
</p>
<p>6
</p>
<p>7     if n == 0:
</p>
<p>8         memo[0] = 0
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>158 5 Sets and Maps
</p>
<p>9         return 0
</p>
<p>10
</p>
<p>11     if n == 1:
</p>
<p>12         memo[1] = 1
</p>
<p>13         return 1
</p>
<p>14
</p>
<p>15     val = fib(n-1) + fib(n-2)
</p>
<p>16
</p>
<p>17     memo[n] = val
</p>
<p>18
</p>
<p>19     return val
</p>
<p>20
</p>
<p>21 def main():
</p>
<p>22     print(fib(100))
</p>
<p>23
</p>
<p>24 if __name__ == "__main__":
</p>
<p>25     main()
</p>
<p>Thememoizedfib function in Sect. 5.8.1 records any value returned by the function
</p>
<p>in its memo. The memo variable is accessed from the enclosing scope. The memo
</p>
<p>is not created locally because we want it to persist from one call of fib to the next.
</p>
<p>Each time fib is called with a new value of n the answer is recorded in the memo.
</p>
<p>When fib(n) is called a subsequent time for some n, the memoized result is looked
</p>
<p>up and returned. The result: the memoized fib function now has O(n) complex-
</p>
<p>ity and it can compute fib(100) almost instantly. Without memoization, it would
</p>
<p>take 1,146,295,688,027,634,168,201 calls to the fib function to compute fib(100).
</p>
<p>Assuming each function call completed in 10 microseconds, it would take roughly
</p>
<p>363 million years to compute fib(100). With memoization it takes 100 calls to fib and
</p>
<p>assuming 10 microseconds per call, that&rsquo;s 1000 microseconds or 1/1000 of a second.
</p>
<p>This is an extreme example of the benefit ofmemoization, but it can come in handy
</p>
<p>in many situations. For instance, in the tic tac toe problem of Chap.4 the minimax
</p>
<p>function is called on many boards that are identical. The minimax function does not
</p>
<p>care if anX is placed in the upper-right corner first followed by the lower-left corner or
</p>
<p>vice-versa.Yet, thewayminimax iswritten itwill be called to compute the value of the
</p>
<p>same board multiple times. Memoizing minimax speeds up the playing of tic tac toe.
</p>
<p>5.9 Correlating Two Sources of Information
</p>
<p>Another use of a map or dictionary is in correlating data from different sources.
</p>
<p>Assume you are given a list of cities and the zip code or codes within those cities.
</p>
<p>You want to provide a service where people can look up the zip code for a city in the
</p>
<p>USA. So, you&rsquo;ll be given a city by the web page that provides you the information.
</p>
<p>You have to use that city to find a list of possible zip codes. You could search the list of
</p>
<p>cities to find the corresponding list of zip codes.Or, you could create a dictionary from
</p>
<p>city name to zip code list. Then when given a city name you check to see if it is in the
</p>
<p>dictionary and if so, you can look up the corresponding list of zip codes in O(1) time.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
</div>
<div class="page"><p/>
<p>5.10 Chapter Summary 159
</p>
<p>5.10 Chapter Summary
</p>
<p>In this chapter we explored the implementation and some uses of sets and maps in
</p>
<p>Python.Hashing is an important concept.Hashing data structuresmust be able to han-
</p>
<p>dle collisions within the hash table by a collision resolution strategy. The resolution
</p>
<p>strategy explored in this chapter was linear probing. There are other collision resolu-
</p>
<p>tion strategies possible.Any collision resolution strategymust have away of handling
</p>
<p>new values being added to a chain and existing values being deleted from a chain.
</p>
<p>The key feature of hashing is the amortized O(1) complexity for membership
</p>
<p>testing and lookup within the table. The ability to test membership or lookup a value
</p>
<p>in O(1) timemakesmany algorithms efficient that otherwise might not run efficiently
</p>
<p>on large data sets.
</p>
<p>Memoization is one important use of a dictionary ormap.Bymemoizing a function
</p>
<p>we avoid doing any redundant work. Another important use of maps or dictionaries
</p>
<p>is in correlating sources of information. When we are given information from two
</p>
<p>different sources and must match those two sources, a map or dictionary will make
</p>
<p>that correlation efficient.
</p>
<p>5.11 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. What type of value is a hash code?
</p>
<p>2. Hash codes can be both positive and negative. How does a hash code get con-
</p>
<p>verted into a value that can be used in a hash table?
</p>
<p>3. Once you find the proper location with a hash table, how do you know if the item
</p>
<p>you are looking for is in the table or not? Be careful to answer this completely.
</p>
<p>4. Why is a collision resolution strategy needed when working with a hash table?
</p>
<p>5. What is the difference between a map and a set?
</p>
<p>6. In this chapter the HashSet was used to implement the HashMap class. What if
</p>
<p>we turned things around?Howcould a dictionary in Python be used to implement
</p>
<p>a set? Describe how this might be done by describing the add and membership
</p>
<p>methods of a set and how they would be implemented if internally the set used
</p>
<p>a dictionary.
</p>
<p>7. How does the load factor affect the complexity of the membership test on the
</p>
<p>set datatype?
</p>
<p>8. What is rehashing?
</p>
<p>9. When is memoization an effective programming technique?
</p>
<p>10. True or False: Memoization would help make the factorial function run faster?
</p>
<p>Justify your answer.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>160 5 Sets and Maps
</p>
<p>def fact(n):
</p>
<p>    if n == 0:
</p>
<p>        return 1
</p>
<p>    return n * fact(n-1)
</p>
<p>def main():
</p>
<p>    x = fact(10)
</p>
<p>    print("10! is",x)
</p>
<p>if __name__ == "__main__":
</p>
<p>    main()
</p>
<p>5.12 Programming Problems
</p>
<p>1. Complete the Sudoku puzzle as described in the chapter. The program should read
</p>
<p>a text file. Prompt the user for the name of the text file. The text file should be
</p>
<p>placed in the same directory or folder as the program so it can easily be found by
</p>
<p>your program. There are six sample Sudoku puzzles that you can solve available
</p>
<p>on the text&rsquo;s website. Write the program to read a text file like those you find on
</p>
<p>the text&rsquo;s website. Print both the unsolved and solved problem to the screen as
</p>
<p>shown below.
</p>
<p>Please enter a Sudoku puzzle file name: sudoku2.txt
</p>
<p>Solving this puzzle
</p>
<p>-----------------
</p>
<p>x x x x x x x x x
</p>
<p>x x x x 1 x x 9 2
</p>
<p>x 8 6 x x x x 4 x
</p>
<p>x x 1 5 6 x x x x
</p>
<p>x x x x x 3 6 2 x
</p>
<p>x x x x x x 5 x 7
</p>
<p>x 3 x x x x x 8 x
</p>
<p>x 9 x 8 x 2 x x x
</p>
<p>x x 7 x x 4 3 x x
</p>
<p>Solution
</p>
<p>-----------------
</p>
<p>4 1 2 9 8 5 7 6 3
</p>
<p>7 5 3 4 1 6 8 9 2
</p>
<p>9 8 6 3 2 7 1 4 5
</p>
<p>2 7 1 5 6 8 9 3 4
</p>
<p>5 4 9 1 7 3 6 2 8
</p>
<p>3 6 8 2 4 9 5 1 7
</p>
<p>6 3 4 7 5 1 2 8 9
</p>
<p>1 9 5 8 3 2 4 7 6
</p>
<p>8 2 7 6 9 4 3 5 1
</p>
<p>Valid Solution!
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>5.12 Programming Problems 161
</p>
<p>2. Complete the HashSet class found in the chapter by implementing the methods
</p>
<p>described in the two tables of set operations. Then, write a main function to test
</p>
<p>these operations. Save the class in a file called hashset.py so it can be imported into
</p>
<p>other programs. If you call yourmain function in hashset.py with the if __name__
</p>
<p>== &ldquo;__main__&rdquo; statement, then when you import it into another program your
</p>
<p>hashset.py main function will not be executed, but when you run hashset.py on
</p>
<p>its own, its main function will run to test your HashSet class.
</p>
<p>3. Memoize the tic tac toe program from Chap.3 to improve its performance. To do
</p>
<p>this each boardmust have a hash value.You should implement a __hash__method
</p>
<p>for the Board class. The hash value should be unique to a board&rsquo;s configuration.
</p>
<p>In other words, the X&rsquo;s, O&rsquo;s, and Dummy objects should factor into the hash
</p>
<p>value for the board so that each board has its own unique hash value. Then
</p>
<p>memoize the minimax function to remember the value found for a particular
</p>
<p>board&rsquo;s configuration. The minimax function should start by checking whether
</p>
<p>or not the value for this board has already been computed and the function should
</p>
<p>return it if it has.
</p>
<p>4. Write a version of theHashSet class that allows you to specify the maximum and
</p>
<p>minimum allowable load factor. Then run a number of tests where you plot the
</p>
<p>average time taken to add an item to a set given different maximum load factors.
</p>
<p>Also gather information about the average time it takes to test the membership of
</p>
<p>an item in a set for different maximum load factors. From this information you
</p>
<p>should be able to see some of the space/time trade-off in hash tables. Generate
</p>
<p>XML data in the plot format from these experimental results and plot the data to
</p>
<p>see what it tells you. From the gathered information, express your opinion about
</p>
<p>the optimal load factor for theHashSet class. Comment on the optimal maximum
</p>
<p>load factor at the top of the program that performs your tests.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_3">http://dx.doi.org/10.1007/978-3-319-13072-9_3</a></div>
</div>
<div class="page"><p/>
<p>6Trees
</p>
<p>When we see a tree in our everyday lives the roots are generally in the ground and
</p>
<p>the leaves are up in the air. The branches of a tree spread out from the roots in a more
</p>
<p>or less organized fashion. The word tree is used in Computer Science when talking
</p>
<p>about a way data may be organized. Trees have some similarities to the linked list
</p>
<p>organization found in Chap. 4. In a tree there are nodes which have links to other
</p>
<p>nodes. In a linked list each node has one link, to the next node in the list. In a tree
</p>
<p>each node may have two or more links to other nodes. A tree is not a sequential
</p>
<p>data structure. It is organized like a tree, except the root is at the top of tree data
</p>
<p>structures and the leaves are at the bottom. A tree in computer science is usually
</p>
<p>drawn inverted when compared to the trees we see in nature. There are many uses for
</p>
<p>trees in computer science. Sometimes they show the structure of a bunch of function
</p>
<p>calls as we saw when examining the Fibonacci function as depicted in Fig. 6.1.
</p>
<p>Figure 6.1 depicts a call tree of the fib function for computing fib(5). Unlike real
</p>
<p>trees it has a root (at the top) and leaves at the bottom. There are relationships between
</p>
<p>the nodes in this tree. The fib(5) call has a left sub-tree and a right sub-tree. The fib(4)
</p>
<p>node is a child of the fib(5) node. The fib(4) node is a sibling to the fib(3) node to
</p>
<p>the right of it. A leaf node is a node with no children. The leaf nodes in Fig. 6.1
</p>
<p>represent calls to the fib function which matched the base cases of the function.
</p>
<p>In this chapter we&rsquo;ll explore trees and when it makes sense to build and or use a tree
</p>
<p>in a program. Not every program will need a tree data structure. Nevertheless, trees
</p>
<p>are used in many types of programs. A knowledge of them is not only a necessity,
</p>
<p>proper use of them can greatly simplify some types of programs.
</p>
<p>6.1 Chapter Goals
</p>
<p>This chapter introduces trees and some algorithms that use trees. By the end of the
</p>
<p>chapter you should be able to answer these questions.
</p>
<p>&bull; How are trees constructed?
</p>
<p>&bull; How can we traverse a tree?
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_6
</p>
<p>163
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
</div>
<div class="page"><p/>
<p>164 6 Trees
</p>
<p>Fig. 6.1 The Call Tree for Computing fib(5)
</p>
<p>&bull; How are expressions and trees related?
</p>
<p>&bull; What is a binary search tree?
</p>
<p>&bull; Under what conditions is a binary search tree useful?
</p>
<p>&bull; What is depth first search and how does it relate to trees and search problems?
</p>
<p>&bull; What are the three types of tree traversals we can do on binary trees?
</p>
<p>&bull; What is a grammar and what can we do with a grammar?
</p>
<p>Read on to discover trees and their uses in Computer Science.
</p>
<p>6.2 Abstract Syntax Trees and Expressions
</p>
<p>Trees have many applications in Computer Science. They are used in many different
</p>
<p>types of algorithms. For instance, every Python program you write is converted to a
</p>
<p>tree, at least for a little while, before it is executed by the Python interpreter. Internally,
</p>
<p>a Python program is converted to a tree-like structure called an Abstract Syntax Tree,
</p>
<p>often abbreviated AST, before it is executed. We can build our own abstract syntax
</p>
<p>trees for expressions so we can see how a tree might be evaluated and why we would
</p>
<p>want to evaluate a tree.
</p>
<p>In Chap. 4 linked lists were presented as a way of organizing a list. Trees may be
</p>
<p>stored using a similar kind of structure. If a node in a tree has two children, then that
</p>
<p>node would have two links to its children as opposed to a linked list which has one
</p>
<p>link to the next node in the sequence.
</p>
<p>Consider the expression (5+4) * 6+3. We can construct an abstract syntax tree
</p>
<p>for this expression as shown in Fig. 6.2. Since the + operation is the last operation
</p>
<p>performed when evaluating this function, the + node will be at the root of the tree. It
</p>
<p>has two subtrees, the expression to the left of the + and then 3 to the right of the +.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
</div>
<div class="page"><p/>
<p>6.2 Abstract Syntax Trees and Expressions 165
</p>
<p>Fig. 6.2 The AST for (5+4) * 6+3
</p>
<p>Similarly, nodes for the other operators and operands can be constructed to yield the
</p>
<p>tree shown in Fig. 6.2.
</p>
<p>To represent this in the computer, we could define one class for each type of node.
</p>
<p>We&rsquo;ll define a TimesNode, a PlusNode, and a NumNode class. So we can evaluate
</p>
<p>the abstract syntax tree, each node in the tree will have one eval method defined on it.
</p>
<p>The code in Sect. 6.2.1 defines these classes, the eval methods, and a main function
</p>
<p>that builds the example tree in Fig. 6.2.
</p>
<p>6.2.1 Constructing ASTs
</p>
<p>1 class TimesNode:
</p>
<p>2     def __init__(self, left, right):
</p>
<p>3         self.left = left
</p>
<p>4         self.right = right
</p>
<p>5
</p>
<p>6     def eval(self):
</p>
<p>7         return self.left.eval() * self.right.eval()
</p>
<p>8
</p>
<p>9 class PlusNode:
</p>
<p>10     def __init__(self, left, right):
</p>
<p>11         self.left = left
</p>
<p>12         self.right = right
</p>
<p>13
</p>
<p>14     def eval(self):
</p>
<p>15         return self.left.eval() + self.right.eval()
</p>
<p>16
</p>
<p>17 class NumNode:
</p>
<p>18     def __init__(self, num):
</p>
<p>19         self.num = num
</p>
<p>20
</p>
<p>21     def eval(self):
</p>
<p>22         return self.num
</p>
<p>23
</p>
<p>24 def main():
</p>
<p>25     x = NumNode(5)
</p>
<p>26     y = NumNode(4)
</p>
<p>27     p = PlusNode(x,y)
</p>
<p>28     t = TimesNode(p, NumNode(6))
</p>
<p>29     root = PlusNode(t, NumNode(3))
</p>
<p>30
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>166 6 Trees
</p>
<p>31     print(root.eval())
</p>
<p>32
</p>
<p>33 if __name__ == "__main__":
</p>
<p>34     main()
</p>
<p>In Sect. 6.2.1 the tree is built from the bottom (i.e. the leaves) up to the root. The
</p>
<p>code above contains an eval function for each node. Calling eval on the root node will
</p>
<p>recursively call eval on every node in the tree, causing the result, 57, to be printed
</p>
<p>to the screen.
</p>
<p>Once an AST is built, evaluating such a tree is accomplished by doing a recursive
</p>
<p>traversal of the tree. The eval methods together are the recursive function in this
</p>
<p>example. We say that the eval methods are mutually recursive since all the eval
</p>
<p>methods together form the recursive function.
</p>
<p>6.3 Prefix and Postfix Expressions
</p>
<p>Expressions, as we normally write them, are said to be in infix form. An infix expres-
</p>
<p>sion is an expression written with the binary operators in between their operands.
</p>
<p>Expressions can be written in other forms though. Another form for expressions is
</p>
<p>postfix. In a postfix expression the binary operators are written after their operands.
</p>
<p>The infix expression (5 + 4) * 6 + 3 can be written in postfix form as 5 4 + 6 * 3 +.
</p>
<p>Postfix expressions are well-suited for evaluation with a stack. When we come to an
</p>
<p>operand we push the value on the stack. When we come to an operator, we pop the
</p>
<p>operands from the stack, do the operation, and push the result. Evaluating expressions
</p>
<p>in this manner is quite easy for humans to do with a little practice. Hewlett-Packard
</p>
<p>has designed many calculators that use this postfix evaluation method. In fact, in the
</p>
<p>early years of computing, Hewlett-Packard manufactured a whole line of computers
</p>
<p>that used a stack to evaluate expressions in the same way. The HP 2000 was one
</p>
<p>such computer. In more recent times many virtual machines are implemented as
</p>
<p>stack machines including the Java Virtual Machine, or JVM, and the Python virtual
</p>
<p>machine.
</p>
<p>As another example of a tree traversal, consider writing a method that returns a
</p>
<p>string representation of an expression. The string is built as the result of a traversal of
</p>
<p>the abstract syntax tree. To get a string representing an infix version of the expression,
</p>
<p>you perform an inorder traversal of the AST. To get a postfix expression you would
</p>
<p>do a postfix traversal of the tree. The inorder methods in Sect. 6.3.1 perform an
</p>
<p>inorder traversal of an AST.
</p>
<p>6.3.1 AST Tree Traversal
</p>
<p>1 class TimesNode:
</p>
<p>2     def __init__(self, left, right):
</p>
<p>3         self.left = left
</p>
<p>4         self.right = right
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.3 Prefix and Postfix Expressions 167
</p>
<p>5
</p>
<p>6     def eval(self):
</p>
<p>7         return self.left.eval() * self.right.eval()
</p>
<p>8
</p>
<p>9     def inorder(self):
</p>
<p>10         return "(" + self.left.inorder() + " * " + self.right.inorder() + ")"
</p>
<p>11
</p>
<p>12 class PlusNode:
</p>
<p>13     def __init__(self, left, right):
</p>
<p>14         self.left = left
</p>
<p>15         self.right = right
</p>
<p>16
</p>
<p>17     def eval(self):
</p>
<p>18         return self.left.eval() + self.right.eval()
</p>
<p>19
</p>
<p>20
</p>
<p>21     def inorder(self):
</p>
<p>22         return "(" + self.left.inorder() + " + " + self.right.inorder() + ")"
</p>
<p>23
</p>
<p>24 class NumNode:
</p>
<p>25     def __init__(self, num):
</p>
<p>26         self.num = num
</p>
<p>27
</p>
<p>28     def eval(self):
</p>
<p>29         return self.num
</p>
<p>30
</p>
<p>31     def inorder(self):
</p>
<p>32         return str(self.num)
</p>
<p>The inorder methods in Sect. 6.3.1 provide for an inorder traversal because each
</p>
<p>binary operator is added to the string in between the two operands. To do a postorder
</p>
<p>traversal of the tree we would write a postorder method that would add each binary
</p>
<p>operator to the string after postorder traversing the two operands. Note that because
</p>
<p>of the way a postorder traversal is written, parentheses are never needed in postfix
</p>
<p>expressions.
</p>
<p>One other traversal is possible, called a preorder traversal. In a preorder traversal,
</p>
<p>each binary operator is added to the string before its two operands. Given the infix
</p>
<p>expression (5 + 4) * 6 + 3 the prefix equivalent is + * + 5 4 6 3. Again, because
</p>
<p>of the way a prefix expression is written, parentheses are never needed in prefix
</p>
<p>expressions.
</p>
<p>6.4 Parsing Prefix Expressions
</p>
<p>Abstract syntax trees are almost never constructed by hand. They are often built
</p>
<p>automatically by an interpreter or a compiler. When a Python program is executed
</p>
<p>the Python interpreter scans it and builds an abstract syntax tree of the program.
</p>
<p>This part of the Python interpreter is called a parser. A parser is a program, or part
</p>
<p>of a program, that reads a file and automatically builds an abstract syntax tree of
</p>
<p>the expression (i.e. a source program), and reports a syntax error if the program or
</p>
<p>expression is not properly formed. The exact details of how this is accomplished
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>168 6 Trees
</p>
<p>is beyond the scope of this text. However, for some simple expressions, like prefix
</p>
<p>expressions, it is relatively easy to build a parser ourselves.
</p>
<p>In middle school we learned when checking to see if a sentence is properly formed
</p>
<p>we should use the English grammar. A grammar is a set of rules that dictate how
</p>
<p>a sentence in a language can be put together. In Computer Science we have many
</p>
<p>different languages and each language has its own grammar. Prefix expressions make
</p>
<p>up a language. We call them the language of prefix expressions and they have their
</p>
<p>own grammar, called a context-free grammar. A context-free grammar for prefix
</p>
<p>expressions is given in Sect. 6.4.1.
</p>
<p>6.4.1 The Prefix Expression Grammar
</p>
<p>G = (N ,T ,P,E) where
</p>
<p>N = {E}
</p>
<p>T = {identifier, number,+, &lowast;}
</p>
<p>P is defined by the set of productions
</p>
<p>E &rarr; + E E | &lowast; E E | number
</p>
<p>A grammar, G, consists of three sets: a set of non-terminals symbols denoted by
</p>
<p>N , a set of terminals or tokens called T , and a set, P, of productions. One of the non-
</p>
<p>terminals is designated the start symbol of the grammar. For this grammar, the special
</p>
<p>symbol E is the start symbol and only non-terminal of the grammar. The symbol E
</p>
<p>stands for any prefix expression. In this grammar there are three productions that
</p>
<p>provide the rules for how prefix expressions can be constructed. The productions
</p>
<p>state that any prefix expression is composed of (you can read &rarr; as is composed of )
</p>
<p>a plus sign followed by two prefix expressions, a multiplication symbol followed by
</p>
<p>two prefix expressions, or just a number. The grammar is recursive so every time you
</p>
<p>see E in the grammar, it can be replaced by another prefix expression. This grammar
</p>
<p>is very easy to convert to a function that given a queue of tokens will build an abstract
</p>
<p>syntax tree of a prefix expression. A function, like the E function in Sect. 6.4.2, that
</p>
<p>reads tokens and returns an abstract syntax tree is called a parser. Since the grammar
</p>
<p>is recursive, the parsing function is recursive as well. It has a base case first, followed
</p>
<p>by the recursive cases. The code in Sect. 6.4.2 provides that function.
</p>
<p>6.4.2 A Prefix Expression Parser
</p>
<p>1 import queue
</p>
<p>2
</p>
<p>3 def E(q):
</p>
<p>4     if q.isEmpty():
</p>
<p>5         raise ValueError("Invalid Prefix Expression")
</p>
<p>6
</p>
<p>7     token = q.dequeue()
</p>
<p>8
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.4 Parsing Prefix Expressions 169
</p>
<p>9     if token == "+":
</p>
<p>10         return PlusNode(E(q),E(q))
</p>
<p>11
</p>
<p>12     if token == "*":
</p>
<p>13         return TimesNode(E(q),E(q))
</p>
<p>14
</p>
<p>15     return NumNode(float(token))
</p>
<p>16
</p>
<p>17 def main():
</p>
<p>18     x = input("Please enter a prefix expression: ")
</p>
<p>19
</p>
<p>20     lst = x.split()
</p>
<p>21     q = queue.Queue()
</p>
<p>22
</p>
<p>23     for token in lst:
</p>
<p>24         q.enqueue(token)
</p>
<p>25
</p>
<p>26     root = E(q)
</p>
<p>27
</p>
<p>28     print(root.eval())
</p>
<p>29     print(root.inorder())
</p>
<p>30
</p>
<p>31 if __name__ == "__main__":
</p>
<p>32     main()
</p>
<p>In Sect. 6.4.2 the parameter q is a queue of the tokens read from the file or string.
</p>
<p>Code to call this function is provided in the main function of Sect. 6.4.2. The main
</p>
<p>function gets a string from the user and enqueues all the tokens in the string (tokens
</p>
<p>must be separated by spaces) on a queue of tokens. Then the queue is passed to the
</p>
<p>function E. This function is based on the grammar given above. The function looks
</p>
<p>at the next token and decides which rule to apply. Each call to the E function returns
</p>
<p>an abstract syntax tree. Calling E from the main function results in parsing the pre-
</p>
<p>fix expression and building its corresponding tree. This example gives you a little
</p>
<p>insight into how Python reads a program and constructs an abstract syntax tree for
</p>
<p>it. A Python program is parsed according to a grammar and an abstract syntax tree
</p>
<p>is constructed from the program. The Python interpreter then interprets the program
</p>
<p>by traversing the tree.
</p>
<p>This parser in Sect. 6.4.2 is called a top-down parser. Not all parsers are constructed
</p>
<p>this way. The prefix grammar presented in this text is a grammar where the top-down
</p>
<p>parser construction will work. In particular, a grammar cannot have any left-recursive
</p>
<p>rules if we are to create a top-down parser for it. Left recursive rules occur in the
</p>
<p>postfix grammar given in Sect. 6.4.3.
</p>
<p>6.4.3 The Postfix Expression Grammar
</p>
<p>G = (N ,T ,P,E) where
</p>
<p>N = {E}
</p>
<p>T = {identifier, number,+, &lowast;}
</p>
<p>P is defined by the set of productions
</p>
<p>E &rarr; E E + | E E &lowast; | number
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>170 6 Trees
</p>
<p>In this grammar the first and second productions have an expression composed
</p>
<p>of an expression, followed by another expression, followed by an addition or mul-
</p>
<p>tiplication token. If we tried to write a recursive function for this grammar, the
</p>
<p>base case would not come first. The recursive case would come first and hence the
</p>
<p>function would not be written correctly since the base case must come first in a
</p>
<p>recursive function. This type of production is called a left-recursive rule. Grammars
</p>
<p>with left-recursive rules are not suitable for top-down construction of a parser. There
</p>
<p>are other ways to construct parsers that are beyond the scope of this text. You can
</p>
<p>learn more about parser construction by studying a book on compiler construction
</p>
<p>or programming language implementation.
</p>
<p>6.5 Binary Search Trees
</p>
<p>A binary search tree is a tree where each node has up to two children. In addition, all
</p>
<p>values in the left subtree of a node are less than the value at the root of the tree and
</p>
<p>all values in the right subtree of a node are greater than or equal to the value at the
</p>
<p>root of the tree. Finally, the left and right subtrees must also be binary search trees.
</p>
<p>This definition makes it possible to write a class where values may be inserted into
</p>
<p>the tree while maintaining the definition. The code in Sect. 6.5.1 accomplishes this.
</p>
<p>6.5.1 The BinarySearchTree Class
</p>
<p>1 class BinarySearchTree:
</p>
<p>2     # This is a Node class that is internal to the BinarySearchTree class.
</p>
<p>3     class __Node:
</p>
<p>4         def __init__(self,val,left=None,right=None):
</p>
<p>5             self.val = val
</p>
<p>6             self.left = left
</p>
<p>7             self.right = right
</p>
<p>8
</p>
<p>9         def getVal(self):
</p>
<p>10             return self.val
</p>
<p>11
</p>
<p>12         def setVal(self,newval):
</p>
<p>13             self.val = newval
</p>
<p>14
</p>
<p>15         def getLeft(self):
</p>
<p>16             return self.left
</p>
<p>17
</p>
<p>18         def getRight(self):
</p>
<p>19             return self.right
</p>
<p>20
</p>
<p>21         def setLeft(self,newleft):
</p>
<p>22             self.left = newleft
</p>
<p>23
</p>
<p>24         def setRight(self,newright):
</p>
<p>25             self.right = newright
</p>
<p>26
</p>
<p>27         # This method deserves a little explanation. It does an inorder traversal
</p>
<p>28         # of the nodes of the tree yielding all the values. In this way, we get
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.5 Binary Search Trees 171
</p>
<p>29         # the values in ascending order.
</p>
<p>30         def __iter__(self):
</p>
<p>31             if self.left != None:
</p>
<p>32                 for elem in self.left:
</p>
<p>33                     yield elem
</p>
<p>34
</p>
<p>35             yield self.val
</p>
<p>36
</p>
<p>37             if self.right != None:
</p>
<p>38                 for elem in self.right:
</p>
<p>39                     yield elem
</p>
<p>40
</p>
<p>41     # Below are the methods of the BinarySearchTree class.
</p>
<p>42     def __init__(self):
</p>
<p>43         self.root = None
</p>
<p>44
</p>
<p>45     def insert(self,val):
</p>
<p>46
</p>
<p>47             # The __insert function is recursive and is not a passed a self parameter. It is a
</p>
<p>48             # static function (not a method of the class) but is hidden inside the insert
</p>
<p>49             # function so users of the class will not know it exists.
</p>
<p>50
</p>
<p>51             def __insert(root,val):
</p>
<p>52                 if root == None:
</p>
<p>53                     return BinarySearchTree.__Node(val)
</p>
<p>54
</p>
<p>55                 if val &lt; root.getVal():
</p>
<p>56                     root.setLeft(__insert(root.getLeft(),val))
</p>
<p>57                 else:
</p>
<p>58                     root.setRight(__insert(root.getRight(),val))
</p>
<p>59
</p>
<p>60                 return root
</p>
<p>61
</p>
<p>62         self.root = __insert(self.root,val)
</p>
<p>63
</p>
<p>64     def __iter__(self):
</p>
<p>65         if self.root != None:
</p>
<p>66             return self.root.__iter__()
</p>
<p>67         else:
</p>
<p>68             return [].__iter__()
</p>
<p>69
</p>
<p>70 def main():
</p>
<p>71     s = input("Enter a list of numbers: ")
</p>
<p>72     lst = s.split()
</p>
<p>73
</p>
<p>74     tree = BinarySearchTree()
</p>
<p>75
</p>
<p>76     for x in lst:
</p>
<p>77         tree.insert(float(x))
</p>
<p>78
</p>
<p>79     for x in tree:
</p>
<p>80         print(x)
</p>
<p>81
</p>
<p>82 if __name__ == "__main__":
</p>
<p>83     main()
</p>
<p>When the program in Sect. 6.5.1 is run with a list of values (they must have an
</p>
<p>ordering) it will print the values in ascending order. For instance, if 5 8 2 1 4 9 6 7
</p>
<p>is entered at the keyboard, the program behaves as follows.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>172 6 Trees
</p>
<p>Enter a list of numbers: 5 8 2 1 4 9 6 7
</p>
<p>1.0
</p>
<p>2.0
</p>
<p>4.0
</p>
<p>5.0
</p>
<p>6.0
</p>
<p>7.0
</p>
<p>8.0
</p>
<p>9.0
</p>
<p>From this example it appears that a binary search tree can produce a sorted list
</p>
<p>of values when traversed. How? Let&rsquo;s examine how this program behaves with this
</p>
<p>input. Initially, the tree reference points to a BinarySearchTree object where the root
</p>
<p>pointer points to None as shown in Fig. 6.3.
</p>
<p>Into the tree in Fig. 6.3 we insert the 5. The insert method is called which imme-
</p>
<p>diately calls the __insert function on the root of the tree. The __insert function is
</p>
<p>given a tree, which in this case is None (i.e. an empty tree) and the __insert function
</p>
<p>returns a new tree with the value inserted. The root instance variable is set equal to
</p>
<p>this new tree as shown in Fig. 6.4 which is the consequence of line 62 of the code in
</p>
<p>Sect. 6.5.1. In the following figures the dashed line indicates the new reference that
</p>
<p>is assigned to point to the new node. Each time the __insert function is called a new
</p>
<p>tree is returned and the root instance variable is re-assigned on line 62. Most of the
</p>
<p>time it is re-assigned to point to the same node.
</p>
<p>Now, the next value to be inserted is the 8. Inserting the 8 calls __insert on the root
</p>
<p>node containing 5. When this is done, it recursively calls __insert on the right subtree,
</p>
<p>which is None (and not pictured). The result is a new right subtree is created and the
</p>
<p>right subtree link of the node containing 5 is made to point to it as shown in Fig. 6.5
</p>
<p>which is the consequence of line 58 in Sect. 6.5.1. Again the dashed arrows indicate
</p>
<p>the new references that are assigned during the insert. It doesn&rsquo;t hurt anything to
</p>
<p>reassign the references and the code works very nicely. In the recursive __insert we
</p>
<p>always reassign the reference on lines 56 and 58 after inserting a new value into the
</p>
<p>tree. Likewise, after inserting a new value, the root reference is reassigned to the
</p>
<p>new tree after inserting the new value on line 62 of the code in Sect. 6.5.1.
</p>
<p>Fig. 6.3 An empty BinarySearchTree object
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.5 Binary Search Trees 173
</p>
<p>Fig. 6.4 The Tree After Inserting 5
</p>
<p>Fig. 6.5 The Tree After Inserting 8
</p>
<p>Fig. 6.6 The Tree After Inserting 2
</p>
<p>Next, the 2 is inserted into the tree as shown in Fig. 6.6. The 8 ended up to the
</p>
<p>right of the 5 to preserve the binary search tree property. The 2 is inserted into the
</p>
<p>left subtree of the 5 because 2 is less than 5.
</p>
<p>The 1 is inserted next and because it is less than the 5, it is inserted into the left
</p>
<p>subtree of the node containing 5. Because that subtree contains 2 the 1 is inserted
</p>
<p>into the left subtree of the node containing 2. This is depicted in Fig. 6.7.
</p>
<p>Inserting the 4 next means the value is inserted to the left of the 5 and to the right
</p>
<p>of the 2. This preserves the binary search tree property as shown in Fig. 6.8.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>174 6 Trees
</p>
<p>Fig. 6.7 The Tree After Inserting 1
</p>
<p>Fig. 6.8 The Tree After Inserting 4
</p>
<p>To insert the 9 it must go to the right of all nodes inserted so far since it is greater
</p>
<p>than all nodes in the tree. This is depicted in Fig. 6.9.
</p>
<p>The 6 goes to the right of the 5 and to the left of the 8 in Fig. 6.10.
</p>
<p>The only place the 7 can go is to the right of the 5, left of the 8, and right of the 6
</p>
<p>in Fig. 6.11.
</p>
<p>The final tree is pictured in Fig. 6.12. This is a binary search tree since all nodes
</p>
<p>with subtrees have values less than the node in the left subtree and values greater
</p>
<p>than or equal to the node in the right subtree while both subtrees also conform to the
</p>
<p>binary search tree property.
</p>
<p>The final part of the program in Sect. 6.5.1 iterates over the tree in the main
</p>
<p>function. This calls the __iter__ method of the BinarySearchTree class. This __iter__
</p>
<p>method returns an iterator over the root&rsquo;s __Node object. The __Node&lsquo;s __iter__
</p>
<p>method is interesting because it is a recursive traversal of the tree. When for elem
</p>
<p>in self.left is written, this calls the __iter__ method on the left subtree. After all the
</p>
<p>elements in the left subtree are yielded, the value at the root of the tree is yielded,
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.5 Binary Search Trees 175
</p>
<p>Fig. 6.9 The Tree After Inserting 9
</p>
<p>Fig. 6.10 The Tree After Inserting 6
</p>
<p>Fig. 6.11 The Tree After Inserting 7
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>176 6 Trees
</p>
<p>Fig. 6.12 The Final BinarySearchTree Object Contents
</p>
<p>then the values in the right subtree are yielded by writing for elem in self.right. The
</p>
<p>result of this recursive function is an inorder traversal of the tree.
</p>
<p>Binary search trees are of some academic interest. However, they are not used
</p>
<p>much in practice. In the average case, inserting into a binary search tree takes O(log n)
</p>
<p>time. To insert n items into a binary search tree would take O(n log n) time. So, in
</p>
<p>the average case we have an algorithm for sorting a sequence of ordered items.
</p>
<p>However, it takes more space than a list and the quicksort algorithm can sort a list
</p>
<p>with the same big-Oh complexity. In the worst case, binary search trees suffer from
</p>
<p>the same problem that quicksort suffers from. When the items are already sorted,
</p>
<p>both quicksort and binary search trees perform poorly. The complexity of inserting
</p>
<p>n items into a binary search tree becomes O(n2) in the worst case. The tree becomes
</p>
<p>a stick if the values are already sorted and essentially becomes a linked list.
</p>
<p>There are a couple of nice properties of binary search trees that a random access
</p>
<p>list does not have. Inserting into a tree can be done in O(log n) time in the average case
</p>
<p>while inserting into a list would take O(n) time. Deleting from a binary search tree
</p>
<p>can also be done in O(log n) time in the average case. Looking up a value in a binary
</p>
<p>search tree can also be done in O(log n) time in the average case. If we have lots of
</p>
<p>insert, delete, and lookup operations for some algorithm, a tree-like structure may be
</p>
<p>useful. But, binary search trees cannot guarantee the O(log n) complexity. It turns out
</p>
<p>that there are implementations of search tree structures that can guarantee O(log n)
</p>
<p>complexity or better for inserting, deleting, and searching for values. A few examples
</p>
<p>are Splay Trees, AVL-Trees, and B-Trees which are all studied later in this text.
</p>
<p>6.6 Search Spaces
</p>
<p>Sometimes we have a problem that may consist of many different states. We may
</p>
<p>want to find a particular state of the problem which we&rsquo;ll call the goal. Consider
</p>
<p>Sudoku puzzles. A Sudoku puzzle has a state, reflecting how much of it we have
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.6 Search Spaces 177
</p>
<p>solved. We are seeking a goal which is the solution of the puzzle. We could randomly
</p>
<p>try a value in a cell of the puzzle and try to solve the puzzle after having made that
</p>
<p>guess. The guess would lead to a new state of the puzzle. But, if the guess were wrong
</p>
<p>we may have to go back and undo our guess. A wrong guess could lead to a dead end.
</p>
<p>This process of guessing, trying to finish the puzzle, and undoing bad guesses is
</p>
<p>called depth first search. Looking for a goal by making guesses is called a depth first
</p>
<p>search of a problem space. When a dead end is found we may have to backtrack.
</p>
<p>Backtracking involves undoing bad guesses and then trying the next guess to see if
</p>
<p>the problem can be solved by making the new guess. The description here leads to
</p>
<p>the depth first search algorithm in Sect. 12.2.1.
</p>
<p>6.6.1 Depth-First Search Algorithm
</p>
<p>1 def dfs(current, goal):
</p>
<p>2   if current == goal:
</p>
<p>3     return [current]
</p>
<p>4
</p>
<p>5   for next in adjacent(current):
</p>
<p>6     result = dfs(next)
</p>
<p>7     if result != None:
</p>
<p>8       return [current] + result
</p>
<p>9
</p>
<p>10   return None
</p>
<p>The depth first search algorithm may be written recursively. In this code the depth
</p>
<p>first search algorithm returns the path from the current node to the goal node. The
</p>
<p>backtracking occurs if the for loop completes without finding an appropriate adjacent
</p>
<p>node. In that case, None is returned and the previous recursive call of dfs goes on to
</p>
<p>the next adjacent node to look for the goal on that path.
</p>
<p>In the last chapter an algorithm was presented for solving Sudoku puzzles that
</p>
<p>works for many puzzles, but not all. In these cases, depth first search can be applied
</p>
<p>to the puzzle after reducing the problem as far as possible. It is important to first
</p>
<p>apply the rules of the last chapter to reduce the puzzle because otherwise the search
</p>
<p>space is too big to search in a reasonable amount of time. The solve function in
</p>
<p>Sect. 6.6.2 includes a depth first search that will solve any Sudoku puzzle assuming
</p>
<p>that the reduce function applies the rules of the last chapter to all the groups within
</p>
<p>a puzzle. The copy module must be imported for this code to run correctly.
</p>
<p>6.6.2 Sudoku Depth-First Search
</p>
<p>1 def solutionViable(matrix):
</p>
<p>2   # Check that no set is empty
</p>
<p>3   for i in range(9):
</p>
<p>4     for j in range(9):
</p>
<p>5       if len(matrix[i][j]) == 0:
</p>
<p>6         return False
</p>
<p>7
</p>
<p>8   return True
</p>
<p>9
</p>
<p>10 def solve(matrix):
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_12">http://dx.doi.org/10.1007/978-3-319-13072-9_12</a></div>
</div>
<div class="page"><p/>
<p>178 6 Trees
</p>
<p>11
</p>
<p>12     reduce(matrix)
</p>
<p>13
</p>
<p>14     if not solutionViable(matrix):
</p>
<p>15       return None
</p>
<p>16
</p>
<p>17     if solutionOK(matrix):
</p>
<p>18       return matrix
</p>
<p>19
</p>
<p>20     print("Searching...")
</p>
<p>21
</p>
<p>22     for i in range(9):
</p>
<p>23       for j in range(9):
</p>
<p>24         if len(matrix[i][j]) &gt; 1:
</p>
<p>25           for k in matrix[i][j]:
</p>
<p>26             mcopy = copy.deepcopy(matrix)
</p>
<p>27             mcopy[i][j] = set([k])
</p>
<p>28
</p>
<p>29             result = solve(mcopy)
</p>
<p>30
</p>
<p>31             if result != None:
</p>
<p>32               return result
</p>
<p>33
</p>
<p>34     return None
</p>
<p>In the solve function of Sect. 6.6.2, reduce is called to try to solve the puzzle with
</p>
<p>the rules of the last chapter. After calling reduce we check to see if the puzzle is
</p>
<p>still solvable (i.e. no empty sets). If not, the solve function returns None. The search
</p>
<p>proceeds by examining each location within the matrix and each possible value that
</p>
<p>the location could hold. The for k loop tries all possible values for a cell with more
</p>
<p>than one possibility. If the call to reduce solves the puzzle, the solutionOK function
</p>
<p>will return True and the solve function will return the matrix. Otherwise, the depth
</p>
<p>first search proceeds by looking for a cell in the matrix with more than one choice.
</p>
<p>The function makes a copy of the matrix called mcopy and makes a guess as to the
</p>
<p>value in that location in mcopy. It then recursively calls solve on mcopy.
</p>
<p>The solve function returns None if no solution is found and the solved puzzle
</p>
<p>if a solution is found. So, when solve is called recursively, if None is returned, the
</p>
<p>function continues to search by trying another possible value. Initially calling solve
</p>
<p>can be accomplished as shown in Sect. 6.6.3 assuming that matrix is a 9&times; 9 matrix
</p>
<p>of sets representing a Sudoku puzzle.
</p>
<p>6.6.3 Calling Sudoku&rsquo;s Solve Function
</p>
<p>1   print("Begin Solving")
</p>
<p>2
</p>
<p>3   matrix = solve(matrix)
</p>
<p>4
</p>
<p>5   if matrix == None:
</p>
<p>6     print("No Solution Found!!!")
</p>
<p>7     return
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.6 Search Spaces 179
</p>
<p>If a non-None matrix is returned, then the puzzle is solved and the solution may be
</p>
<p>printed. This is one example where no tree is ever constructed, yet the search space
</p>
<p>is shaped like a tree and depth first search can be used to search the problem space.
</p>
<p>6.7 Chapter Summary
</p>
<p>Tree-like structures appear in many problems in Computer Science. A tree datatype
</p>
<p>can hold information and allow quick insert, delete, and search times. While binary
</p>
<p>search trees are not used in practice, the principles governing them are used in many
</p>
<p>advanced data structures like B-trees, AVL-trees, and Splay Trees. Understanding
</p>
<p>how references point to objects and how this can be used to build a datatype like a
</p>
<p>tree is an important concept for computer programmers to understand.
</p>
<p>Search spaces are often tree-like when making a decision between several choices
</p>
<p>leads to another decision. A search space is not a datatype, so in this case no tree
</p>
<p>is built. However, the space that is searched has a tree-like structure. The key to
</p>
<p>doing a depth first search of a space is to remember where you were so you can
</p>
<p>backtrack when a choice leads to a dead end. Backtracking is often accomplished
</p>
<p>using recursion.
</p>
<p>Many algorithms that deal with trees are naturally recursive. Depth first search,
</p>
<p>tree traversals, parsing, and abstract syntax evaluation may all be recursively imple-
</p>
<p>mented. Recursion is a powerful mechanism to have in your toolbox for solving
</p>
<p>problems.
</p>
<p>6.8 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. Is the root of a tree in Computer Science at the top or bottom of a tree?
</p>
<p>2. How many roots can a tree have?
</p>
<p>3. A full binary tree is a tree that is full at each level of the tree, meaning there is no
</p>
<p>room for another node at any level of the tree, except at the leaves. How many
</p>
<p>nodes are in a full binary tree with three levels? How about 4 levels? How about
</p>
<p>5 levels?
</p>
<p>4. In a full binary tree, what is the a relationship between the number of leaves in
</p>
<p>the tree and the total number of nodes in the tree?
</p>
<p>5. When constructing a tree, for which is it easiest to write code, a bottom-up or
</p>
<p>top-down construction of the tree?
</p>
<p>6. What term is used when a wrong choice is made and another choice must be
</p>
<p>attempted when searching for a value in a tree?
</p>
<p>7. How does a search space differ from a tree datatype?
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>180 6 Trees
</p>
<p>8. Describe a non-recursive algorithm for doing an inorder traversal of a tree. HINT:
</p>
<p>Your algorithm will need a stack to get this to work.
</p>
<p>9. Write some code to build a tree for the infix expression 5 * 4 + 3 * 2. Be sure
</p>
<p>to follow the precedence of operators and in your tree. You may assume the
</p>
<p>PlusNode and TimesNode classes from the chapter are already defined.
</p>
<p>10. Provide the prefix and postfix forms of 5 * 4 + 3 * 2.
</p>
<p>6.9 Programming Problems
</p>
<p>1. Write a program that asks the user to enter a prefix expression. Then, the program
</p>
<p>should print out the infix and postfix forms of that expression. Finally, it should
</p>
<p>print the result of evaluating the expression. Interacting with the program should
</p>
<p>look like this.
</p>
<p>Please enter a prefix expression: + + * 4 5 6 7
</p>
<p>The infix form is: (((4 * 5) + 6) + 7)
</p>
<p>The postfix form is: 4 5 * 6 + 7 +
</p>
<p>The result is: 33
</p>
<p>If the prefix expression is malformed, the program should print that the expression
</p>
<p>is malformed and it should quit. It should not try to print the infix or postfix forms
</p>
<p>of the expression in this case.
</p>
<p>2. Write a program that reads a list of numbers from the user and lets the user
</p>
<p>insert, delete, and search for values in the tree. The program should be menu
</p>
<p>driven allowing for inserting, searching, and deleting from a binary search tree.
</p>
<p>Inserting into the tree should allow for multiple inserts as follows.
</p>
<p>Binary Search Tree Program
</p>
<p>--------------------------
</p>
<p>Make a choice...
</p>
<p>1. Insert into tree.
</p>
<p>2. Delete from tree.
</p>
<p>3. Lookup Value.
</p>
<p>Choice? 1
</p>
<p>insert? 5
</p>
<p>insert? 2
</p>
<p>insert? 8
</p>
<p>insert? 6
</p>
<p>insert? 7
</p>
<p>insert? 9
</p>
<p>insert? 4
</p>
<p>insert? 1
</p>
<p>insert?
</p>
<p>Make a choice...
</p>
<p>1. Insert into tree.
</p>
<p>2. Delete from tree.
</p>
<p>3. Lookup Value.
</p>
<p>Choice? 3
</p>
<p>Value? 8
</p>
<p>Yes, 8 is in the tree.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.9 Programming Problems 181
</p>
<p>Make a choice...
</p>
<p>1. Insert into tree.
</p>
<p>2. Delete from tree.
</p>
<p>3. Lookup Value.
</p>
<p>Choice? 2
</p>
<p>Value? 5
</p>
<p>5 has been deleted from the tree.
</p>
<p>Make a choice...
</p>
<p>1. Insert into tree.
</p>
<p>2. Delete from tree.
</p>
<p>3. Lookup Value.
</p>
<p>Choice? 2
</p>
<p>Value? 3
</p>
<p>3 was not in the tree.
</p>
<p>The hardest part of this program is deleting from the tree. You can write a recursive
</p>
<p>function to delete a value. In some ways, the delete from tree function is like the
</p>
<p>insert function given in the chapter. You will want to write two functions, one that
</p>
<p>is a method to call on a binary search tree to delete a value, the other would be a
</p>
<p>hidden recursive delete from tree function. The recursive function should be given
</p>
<p>a tree and a value to delete. It should return the tree after deleting the value from
</p>
<p>the tree. The recursive delete function must be handled in three cases as follows.
</p>
<p>&bull; Case 1. The value to delete is in a node that has no children. In this case, the
</p>
<p>recursive function can return an empty tree (i.e. None) because that is the tree
</p>
<p>after deleting the value from it. This would be the case if the 9 were deleted
</p>
<p>from the binary search tree in Fig. 6.12. In Fig. 6.13 the right subtree of the
</p>
<p>node containing 8 is now None and therefore the node containing 9 is gone
</p>
<p>from the tree.
</p>
<p>&bull; Case 2. The value to delete is in a node that has one child. In this case, the
</p>
<p>recursive function can return the child as the tree after deleting the value. This
</p>
<p>would be the case if deleting 6 from the tree in Fig. 6.13. In this case, to delete
</p>
<p>Fig. 6.13 The Tree After Deleting 9
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>182 6 Trees
</p>
<p>Fig. 6.14 The Tree After Deleting 6
</p>
<p>the node containing 6 from the tree you simply return the tree for the node
</p>
<p>containing 7 so it ends up being linked to the node containing 8. In Fig. 6.14
</p>
<p>the node containing 6 is eliminated by making the left subtree of the node
</p>
<p>containing 8 point at the right subtree of the node containing 6.
</p>
<p>&bull; Case 3. This is is hardest case to implement. When the value to delete is in
</p>
<p>a node that has two children, then to delete the node we want to use another
</p>
<p>function, call it getRightMost, to get the right-most value of a tree. Then you
</p>
<p>use this function to get the right-most value of the left subtree of the node to
</p>
<p>delete. Instead of deleting the node, you replace the value of the node with the
</p>
<p>right-most value of the left subtree. Then you delete the right-most value of
</p>
<p>the left subtree from the left subtree. In Fig. 6.15 the 5 is eliminated by setting
</p>
<p>the node containing 5 to 4, the right-most value of the left subtree. Then 4 is
</p>
<p>deleted from the left subtree.
</p>
<p>Fig. 6.15 The Tree After Deleting 5
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>6.9 Programming Problems 183
</p>
<p>3. Complete the Sudoku program as described in Chap. 5 and augment it with the
</p>
<p>depth first search described in Sect. 6.6.2 to complete a Sudoku program that
</p>
<p>is capable of solving any Sudoku puzzle. It should solve these puzzles almost
</p>
<p>instantly. If it is taking a long time to solve a puzzle it is likely because your
</p>
<p>reduce function is not reducing the puzzle as described in Chap. 5.
</p>
<p>To complete this exercise you will need two functions, the solutionOK func-
</p>
<p>tion and the solutionViable function. The solutionViable function is given in the
</p>
<p>chapter and returns True if none of the sets in the matrix are empty. The solutionOK
</p>
<p>function returns True if the solution is a valid solution. This can be checked very
</p>
<p>easily. If any of the sets in the matrix do not contain contain exactly 1 element
</p>
<p>then the solution is not okay and False should be returned. If the union of any
</p>
<p>group within a Sudoku puzzle does not contain 9 elements then the solution is
</p>
<p>not okay and False should be returned. Otherwise, the solution is okay and True
</p>
<p>should be returned.
</p>
<p>After completing this program you should be able to solve Sudoku problems like
</p>
<p>sudoku7.txt or sudoku8.txt which are available for download on the text&rsquo;s website.
</p>
<p>4. Design an OrderedTreeSet class which can be used to insert items, delete items,
</p>
<p>and lookup items in an average case of O(log n) time. Implement the in operator
</p>
<p>on this class for set containment. Also implement an iterator that returns the items
</p>
<p>of the set in ascending order. The design of this set should allow items of any
</p>
<p>type to be added to the set as long as they implement the __lt__ operator. This
</p>
<p>OrderedTreeSet class should be written in a file called orderedtreeset.py. The main
</p>
<p>function of this module should consist of a test program for your OrderedTreeSet
</p>
<p>class that thoroughly tests your code. The main function should be called using
</p>
<p>the standard if statement that distinguishes between the module being imported
</p>
<p>or run itself.
</p>
<p>5. Design an OrderedTreeMap class which uses an OrderedTreeSet class in its
</p>
<p>implementation. To organize this correctly you should create two modules: an
</p>
<p>orderedtreeset.py module and an orderedtreemap.py module. Have the Ordered
</p>
<p>TreeMap class use the OrderedTreeSet class in its implementation the way Hash-
</p>
<p>Set and HashMap were implemented in Chap. 5. Design test cases to thoroughly
</p>
<p>test your OrderedTreeMap class.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
</div>
<div class="page"><p/>
<p>7Graphs
</p>
<p>Many problems in Computer Science and Mathematics can be reduced to a set of
</p>
<p>states and a set of transitions between these states. A graph is a mathematical repre-
</p>
<p>sentation of problems like these. In the last chapter we saw that trees serve a variety of
</p>
<p>purposes in Computer Science. Trees are graphs. However, graphs are more general
</p>
<p>than trees. Abstracting away the details of a problem and studying it in its simplest
</p>
<p>form often leads to new insight. As a result, many algorithms have come out of the
</p>
<p>research in graph theory. Graph theory was first studied by mathematicians. Many
</p>
<p>of the algorithms in graph theory are named for the mathematician that developed or
</p>
<p>discovered them. Dijkstra and Kruskal are two such mathematicians and this chapter
</p>
<p>covers algorithms developed by them.
</p>
<p>Representing a graph can be done one of several different ways. The correct way
</p>
<p>to represent a graph depends on the algorithm being implemented. Graph theory
</p>
<p>problems include graph coloring, finding a path between two states or nodes in a
</p>
<p>graph, or finding a shortest path through a graph among many others. There are many
</p>
<p>algorithms that have come from the study of graphs. To understand the formulation
</p>
<p>of these problems it is good to learn a little graph notation which is presented in this
</p>
<p>chapter as well.
</p>
<p>7.1 Chapter Goals
</p>
<p>This chapter covers the representation of graphs. It also covers a few graph algo-
</p>
<p>rithms. Depth first search of a graph is presented, along with breadth first search.
</p>
<p>Dijkstra&rsquo;s algorithm is famous in Computer Science and has many applications from
</p>
<p>networking to construction planning. Kruskal&rsquo;s algorithm is another famous algo-
</p>
<p>rithm used to find a minimum weighted spanning tree. By the end of the chapter
</p>
<p>you should have a basic understanding of graph theory and how many problems in
</p>
<p>Computer Science can be posed in the form of graphs.
</p>
<p>To begin we&rsquo;ll study some notation and depth first search of a graph. Then we&rsquo;ll
</p>
<p>examine a couple of Greedy Algorithms that answer some interesting questions about
</p>
<p>graphs. Greedy algorithms are algorithms that never make a wrong choice in finding
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_7
</p>
<p>185
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>186 7 Graphs
</p>
<p>a solution. We&rsquo;ll examine two of these algorithms called Kruskal&rsquo;s Algorithm and
</p>
<p>Dijkstra&rsquo;s Algorithm, both named for the people that formulated the algorithm to
</p>
<p>solve their respective problems.
</p>
<p>7.2 Graph Notation
</p>
<p>A little notation will help in the graph definitions in this chapter. A set is an unordered
</p>
<p>collection of items. For instance, V = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} is the set
</p>
<p>of the first 13 natural numbers. A subset of a set is some collection, possibly empty,
</p>
<p>of items from its superset. The set U = {5, 8, 2} is a subset of V. The cardinality of
</p>
<p>a set is its size or number of elements. The cardinality of the set V is written as |V |.
</p>
<p>The cardinality of V is 13 and U is 3, so |V | = 13 and |U | = 3.
</p>
<p>A graph G= (V,E) is defined by a set of vertices, named V, and a set of edges, named
</p>
<p>E. The set of edges are subsets of V where each member of E has cardinality 2. In
</p>
<p>other words, edges are denoted by pairs of vertices. Consider the simple, undirected
</p>
<p>graph given in Fig. 7.1. The sets V = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} and E =
</p>
<p>{{0, 1},{0, 3},{0, 10},{1, 10},{1, 4},{2, 3},{2, 8},{2, 6},{3, 9},{5, 4},{5, 12},{5,
</p>
<p>7},{11, 12},{11, 10},{9, 10}} define this graph. Since each edge is itself a set of
</p>
<p>cardinality 2, the order of the vertices in each edge set does not matter. For instance,
</p>
<p>{1, 4} is the same edge as {4, 1}.
</p>
<p>Many problems can be formulated in terms of a graph. For instance, we might ask
</p>
<p>how many colors it would take to color a map so that no two countries that shared a
</p>
<p>border were colored the same. In this problem the vertices in Fig. 7.1 would represent
</p>
<p>countries and two countries that share a border would have an edge between them.
</p>
<p>The problem can then be restated as finding the minimum number of colors required
</p>
<p>to color each vertex in the graph so that no two vertices that share an edge have the
</p>
<p>same color.
</p>
<p>A directed graph G = (V,E) is defined in the same way as an undirected graph
</p>
<p>except that the set of edges, E, is a set of tuples instead of subsets. By defining
</p>
<p>E = {(vi, vj) where vi, vj &isin; V } means that edges can be traversed in one direction
</p>
<p>Fig. 7.1 An Undirected Graph
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.2 Graph Notation 187
</p>
<p>Fig. 7.2 A Directed Graph
</p>
<p>only. In Fig. 7.2 we can move from vertex 10 to vertex 0 along the edge (10,0), but
</p>
<p>we cannot move from vertex 0 to 10, at least not without going through some other
</p>
<p>vertices, because the edge (0,10) is not in the set E.
</p>
<p>A path in a graph is a series of edges, none repeated, that can be traversed in order
</p>
<p>to travel from one vertex to another in a graph. A cycle in a graph is a path which
</p>
<p>begins and ends with the same vertex. The last chapter covered trees in computer
</p>
<p>science. Now armed with some notation from graph theory we can give a formal
</p>
<p>definition of a tree. A tree is a directed, connected acyclic graph. An acyclic graph
</p>
<p>is a graph without any cycles.
</p>
<p>Sometimes in graph theory a tree is defined as an acyclic connected graph dropping
</p>
<p>the requirement that it be a directed graph. In this case, a tree may be defined as a
</p>
<p>graph which is fully connected, but has only one path between any two vertices.
</p>
<p>Both directed and undirected graphs can be used to model many different kinds
</p>
<p>of problems. The graph in Fig. 7.1 might represent register allocation in a CPU. The
</p>
<p>vertices could represent symbolically named registers and two registers that were
</p>
<p>both in use at the same time would have an edge between them. The question that
</p>
<p>might be asked is, &ldquo;How many physical registers of the machine are required for the
</p>
<p>symbolic registers of this computation?&rdquo;.
</p>
<p>It turns out that register allocation and map coloring represent the same problem.
</p>
<p>When we abstract away the details, the problem boils down to a graph coloring prob-
</p>
<p>lem. An answer to &ldquo;How many colors are required to color the map?&rdquo; would answer
</p>
<p>&ldquo;How many physical registers are required for this computation?&rdquo; and vice-versa.
</p>
<p>A weighted graph is a graph where every edge has a weight assigned to it. More
</p>
<p>formally, a weighted graph G = (V,E,w) is a graph with the given set of vertices,
</p>
<p>V, and edges, E. In addition, a weighted graph has a weight function, w, that maps
</p>
<p>edges to real numbers. So the signature of w is given by w: E &rarr; Real. Weighted
</p>
<p>graphs can be used to represent the state of many different problems. For instance, a
</p>
<p>weighted graph might provide information about roads and intersections. Cost/bene-
</p>
<p>fit analysis can sometimes be expressed in terms of a weighted graph. The weights can
</p>
<p>represent the available capacity of network connections between nodes in a network.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>188 7 Graphs
</p>
<p>Fig. 7.3 A Weighted, Undirected Graph
</p>
<p>A weighted graph can be used to represent the state of many different kinds of prob-
</p>
<p>lems. Figure 7.3 depicts a weighted graph which represents roads and intersections.
</p>
<p>7.3 Searching a Graph
</p>
<p>Many problems have been formulated in terms of graph theory. One of the more
</p>
<p>common problems is discovering a path from one vertex to another in a graph. The
</p>
<p>question might be, does a path exist from vertex vi to vj and if so, what edges must
</p>
<p>you traverse to get there? Performing depth first search on a graph is similar to the
</p>
<p>algorithm first presented in Chap. 6, but we must be wary of getting stuck in a cycle
</p>
<p>within a graph.
</p>
<p>Consider searching for a path from vertex 0 to vertex 1 in the directed graph of
</p>
<p>Fig. 7.2. The blue lines in Fig. 7.4 highlight the path between these vertices. In the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>7.3 Searching a Graph 189
</p>
<p>Fig. 7.4 A Path from Vertex 0 to Vertex 1
</p>
<p>graph, there seems to be only one choice in most cases. However, when the search
</p>
<p>reaches vertex 10 we must choose between two edges. One edge takes us back to
</p>
<p>vertex 0 which we have already visited. The other edge takes us closer to the final
</p>
<p>path. Another choice is made at vertex 5. If the edge to 7 is wrongly examined, we
</p>
<p>must have a way of backing up and trying the other edge to vertex 4.
</p>
<p>Searching a graph in this manner is also called depth first search, as first discussed
</p>
<p>in Chap. 6, and requires the ability to backtrack. Consider when vertex 5 is encoun-
</p>
<p>tered. If a choice is made to go to vertex 7, we must be able to back up to fix that
</p>
<p>choice and go to vertex 4 instead. A stack data structure or recursion handles the
</p>
<p>backtracking.
</p>
<p>Depth first search must also avoid possible cycles within the graph. The avoidance
</p>
<p>of cycles is accomplished by maintaining a set of visited vertices. When a vertex is
</p>
<p>visited, it is added to the visited set. If a vertex is in the visited set, then it is not exam-
</p>
<p>ined again later in the search should a cycle take the search back to the same vertex.
</p>
<p>An iterative (i.e. non-recursive) graph depth first search algorithm begins by ini-
</p>
<p>tializing the visited set to the empty set and by creating a stack for backtracking.
</p>
<p>The start vertex is pushed onto the stack to begin the algorithm. Steps similar to
</p>
<p>those taken in Sect. 7.3.1 are executed to find the goal. This code is pseudo-code, but
</p>
<p>presents the necessary details.
</p>
<p>7.3.1 Iterative Depth First Search of a Graph
</p>
<p>1 def graphDFS(G, start, goal):
</p>
<p>2   # G = (V,E) is the graph with vertices, V, and edges, E.
</p>
<p>3   V,E = G
</p>
<p>4   stack = Stack()
</p>
<p>5   visited = Set()
</p>
<p>6   stack.push(start)
</p>
<p>7
</p>
<p>8   while not stack.isEmpty():
</p>
<p>9     # A vertex is popped from the stack. This is called the current vertex.
</p>
<p>10     current = stack.pop()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>190 7 Graphs
</p>
<p>11     # The current vertex is added to the visited set.
</p>
<p>12     visited.add(current)
</p>
<p>13
</p>
<p>14     # If the current vertex is the goal vertex, then we discontinue the
</p>
<p>15     # search reporting that we found the goal.
</p>
<p>16     if current == goal:
</p>
<p>17       return True # or return path to goal perhaps
</p>
<p>18
</p>
<p>19     # Otherwise, for every adjacent vertex, v, to the current vertex
</p>
<p>20     # in the graph, v is pushed on the stack of vertices yet to search
</p>
<p>21     # unless v is already in the visited set in which case the edge
</p>
<p>22     # leading to v is ignored.
</p>
<p>23     for v in adjacent(current,E):
</p>
<p>24       if not v in visited:
</p>
<p>25         stack.push(v)
</p>
<p>26
</p>
<p>27   # If we get this far, then we did not find the goal.
</p>
<p>28   return False # or return an empty path
</p>
<p>If the while loop in Sect. 7.3.1 terminates the stack was empty and therefore no
</p>
<p>path to the goal exists. This algorithm implements depth first search of a graph.
</p>
<p>It can also be implemented recursively if pushing on the stack is replaced with a
</p>
<p>recursive call to depth first search. When implemented recursively, the depth first
</p>
<p>search function is passed the current vertex and a mutable visited set and it returns
</p>
<p>either the path to the goal or alternatively a boolean value indicating that the goal or
</p>
<p>target was found. Given the graph in Fig. 7.4 the search returned True.
</p>
<p>The iterative version of depth first search can be modified to do a breadth first
</p>
<p>search of a graph if the stack is replaced with a queue. Breadth first search is an
</p>
<p>exhaustive search, meaning that it looks at all paths at the same time, but will also
</p>
<p>find the shortest path, with the least number of edges, between any two vertices in
</p>
<p>a graph. Performing breadth first search on large graphs may take too long to be of
</p>
<p>practical use.
</p>
<p>7.4 Kruskal&rsquo;s Algorithm
</p>
<p>Consider for a moment a county which is responsible for plowing roads in the winter
</p>
<p>but is running out of money due to an unexpected amount of snow. The county
</p>
<p>supervisor has been told to reduce costs by plowing only the necessary roads for the
</p>
<p>rest of the winter. The supervisor wants to find the shortest number of total miles
</p>
<p>that must be plowed so any person can travel from one point to any other point in
</p>
<p>the county, but not necessarily by the shortest route. The county supervisor wants to
</p>
<p>minimize the miles of plowed roads, while guaranteeing you can still get anywhere
</p>
<p>you need to in the county.
</p>
<p>Joseph Kruskal was an American computer scientist and mathematician who
</p>
<p>lived from 1928 to 2010. He imagined this problem, formalized it in terms of a
</p>
<p>weighted graph, and devised an algorithm to solve this problem. His algorithm was
</p>
<p>first published in the Proceedings of the American Mathematical Society [5] and is
</p>
<p>commonly called Kruskal&rsquo;s Algorithm.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4 Kruskal&rsquo;s Algorithm 191
</p>
<p>Fig. 7.5 A Minimum Weighted Spanning Tree
</p>
<p>The last chapter introduced trees by using them in various algorithms like binary
</p>
<p>search. The definition doesn&rsquo;t change from the last chapter. But trees, in the context
</p>
<p>of graph theory, are a subset of the set of all possible graphs. A tree is just a graph
</p>
<p>without any cycles. In addition, it is relatively easy to prove that a tree must contain
</p>
<p>one less edge than its number of vertices. Otherwise, it would not be a tree.
</p>
<p>Clearly the graph in Fig. 7.3 is not a tree. There are many cycles within the graph.
</p>
<p>Kruskal&rsquo;s paper presented an algorithm to find a minimum weighted spanning tree for
</p>
<p>such a graph. Figure 7.5 contains a minimum weighted spanning tree for the graph
</p>
<p>in Fig. 7.3 with the tree edges highlighted in orange. We don&rsquo;t say the minimum
</p>
<p>weighted spanning tree because in general there could be more than one minimum
</p>
<p>weighted spanning tree. In this case, there is likely only one possible.
</p>
<p>Kruskal&rsquo;s algorithm is a greedy algorithm. The designation greedy means that the
</p>
<p>algorithm always chooses the first alternative when presented with a list of alterna-
</p>
<p>tives and never makes a mistake, or wrong choice, when choosing. In other words,
</p>
<p>no backtracking is required in Kruskal&rsquo;s algorithm.
</p>
<p>The algorithm begins by sorting all the edges in ascending order of their weights.
</p>
<p>Assuming that the graph is fully connected, the spanning tree will contain |V |&minus;1
</p>
<p>edges. The algorithm forms sets of all the vertices in the graph, one set for each
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>192 7 Graphs
</p>
<p>vertex, initially containing just that vertex that corresponds to the set. In the example
</p>
<p>in Fig. 7.3 there are initially 30 sets each containing one vertex.
</p>
<p>The algorithm proceeds as follows until |V |&minus;1 edges have been added to the set
</p>
<p>of spanning tree edges.
</p>
<p>1. The next shortest edge is examined. If the two vertex end points of the edge are
</p>
<p>in different sets, then the edge may be safely added to the set of spanning tree
</p>
<p>edges. A new set is formed from the union of the two vertex sets and the two
</p>
<p>previous sets are dropped from the list of vertex sets.
</p>
<p>2. If the two vertex endpoints of the edge are already in the same set, the edge is
</p>
<p>ignored.
</p>
<p>That&rsquo;s the entire algorithm. The algorithm is greedy because it always chooses the
</p>
<p>next smallest edge unless doing so would form a cycle. If a cycle would be formed
</p>
<p>by adding an edge, it is known right away without having to undo any mistake or
</p>
<p>backtrack.
</p>
<p>Consider Fig. 7.6. In this snapshot the algorithm has already formed a forest of
</p>
<p>trees, but not a spanning tree yet. The edges in orange are part the spanning tree.
</p>
<p>Fig. 7.6 Kruskal&rsquo;s: Snapshot 1
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.4 Kruskal&rsquo;s Algorithm 193
</p>
<p>The next shortest edge, the edge from vertex 3 to vertex 9 is currently being
</p>
<p>considered. The set containing 3 and 9 is the set {3, 0, 1, 4, 5, 12, 11, 10, 9}.
</p>
<p>Adding the edge with end points 3 and 9 cannot be done because vertices 3 and 9 are
</p>
<p>already in the same set. So, this edge is skipped. It cannot be a part of the minimum
</p>
<p>weighted spanning tree.
</p>
<p>The next shortest edge is the edge between vertices 2 and 3. Since 2 is a member
</p>
<p>of {8, 2, 6} and 3 is a member of its set in the previous paragraph, the edge {2, 3}
</p>
<p>is added to the minimum weighted spanning tree edges and the new set {8, 2, 6, 3,
</p>
<p>0, 1, 4, 5, 12, 11, 10, 9} is formed replacing its previous two subsets as depicted in
</p>
<p>Fig. 7.7.
</p>
<p>The next shortest edge is the edge between vertices 1 and 10. This edge again
</p>
<p>cannot be added since 1 and 10 are in the same set and therefore adding the edge
</p>
<p>would form a cycle. The next shortest edge is the edge between vertices 18 and 25,
</p>
<p>but again adding it would form a cycle so it is skipped. The algorithm proceeds in
</p>
<p>this manner until the resulting spanning tree is formed with |V |&minus;1 edges (assuming
</p>
<p>the graph is fully connected).
</p>
<p>Fig. 7.7 Kruskal&rsquo;s: Snapshot 2
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>194 7 Graphs
</p>
<p>7.4.1 Proof of Correctness
</p>
<p>Proving Kruskal&rsquo;s algorithm correctly finds a minimum weighted spanning tree can
</p>
<p>be done with a proof by contradiction. The proof starts by recognizing that there must
</p>
<p>be |V |&minus;1 edges in the spanning tree. Then we assume that some other edge would
</p>
<p>be better to add to the spanning tree than the edges picked by the algorithm. The
</p>
<p>new edge must be a part of one and only one cycle. If adding the new edge formed
</p>
<p>two or more cycles then there would have had to be a cycle in the tree before adding
</p>
<p>the new edge. One of the edges in this newly formed cycle must be deleted from the
</p>
<p>minimum weighted spanning tree to once again make it a tree. And, the deleted edge
</p>
<p>must have weight greater than the newly added edge. This is only possible if the new
</p>
<p>edge and the deleted old edge have exactly the same weight since all the old edges
</p>
<p>in the cycle were chosen before the new edge and the new edge was skipped because
</p>
<p>choosing it would have formed a cycle. So dropping the same weighted edge of the
</p>
<p>older edges will result in a minimum weighted spanning tree with the same weight.
</p>
<p>Therefore, the new spanning tree has the same weight as the original spanning tree
</p>
<p>and that contradicts our assumption that a better edge could be found.
</p>
<p>7.4.2 Kruskal&rsquo;s Complexity Analysis
</p>
<p>The complexity of Kruskal&rsquo;s algorithm depends on sorting the list of edges and then
</p>
<p>forming the union of sets as the algorithm proceeds. Sorting a list, as was shown in
</p>
<p>Chap. 4 when we looked at the complexity of quicksort, is O(|E|log|E|).
</p>
<p>Sorting the list is one half of Kruskal&rsquo;s algorithm. The other half is choosing the
</p>
<p>correct edges. Recall that each edge starts in a set by itself and that an edge belongs
</p>
<p>to the minimum weighted spanning tree if the two endpoint vertices are in separate
</p>
<p>sets. If so, then the union is formed for the two sets containing the endpoints and this
</p>
<p>union of two sets replaces the previous two sets going forward.
</p>
<p>Three operations are required to implement this part of the algorithm.
</p>
<p>1. First we must discover the set for each endpoint of the edge being considered for
</p>
<p>addition to the spanning tree.
</p>
<p>2. Then the two sets must be compared for equality.
</p>
<p>3. Finally, the union of the two sets must be formed and any necessary updates must
</p>
<p>be performed so the two endpoint vertices now refer to the union of the two sets
</p>
<p>instead of their original sets.
</p>
<p>One way to implement these operations would be to create a list of sets where
</p>
<p>each position in the list corresponded to one vertex in the graph. The vertices are
</p>
<p>conveniently numbered 0&ndash;29 in the example in the text but vertices can be reas-
</p>
<p>signed integer identifiers starting at 0 otherwise. The set corresponding to a vertex
</p>
<p>can be determined in O(1) time since indexed lookup in a list is a constant time
</p>
<p>operation.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
</div>
<div class="page"><p/>
<p>7.4 Kruskal&rsquo;s Algorithm 195
</p>
<p>If we make sure there is only one copy of each set, we can determine if two sets
</p>
<p>are the same or not in O(1) time as well. We can just compare their references to see
</p>
<p>whether they are the same set or not. The keyword is in Python will accomplish this.
</p>
<p>So if we want to know that x and y refer to the same set we can write x is y and this
</p>
<p>operation is O(1).
</p>
<p>The third operation requires forming a new set from the previous two. This oper-
</p>
<p>ation will be performed |V |&minus;1 times. In the worst case the first time this operation
</p>
<p>occurs 1 vertex will be added to an existing set. The second time, two vertices will be
</p>
<p>added to an existing set, and so on. So in the end, the overall worst case complexity
</p>
<p>of this operation is O(|V |2) assuming once again that the graph is connected. Clearly,
</p>
<p>this is the expensive operation of this algorithm. The next section presents a data
</p>
<p>structure that improves on this considerably.
</p>
<p>7.4.3 The Partition Data Structure
</p>
<p>To improve on the third required operation, the merging of two sets into one set, a
</p>
<p>specialized data structure called a Partition may be used. The partition data structure
</p>
<p>contains a list of integers with one entry for each vertex. Initially, the list simply
</p>
<p>contains a list of integers which match their indices:
</p>
<p>  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
</p>
<p>[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]
</p>
<p>Think of this list as a list of trees, representing the sets of connected edges in
</p>
<p>the spanning forest constructed so far. A tree&rsquo;s root is indicated when the value at a
</p>
<p>location within the list matches its index. Initially, each vertex within the partition is
</p>
<p>in its own set because each vertex is the root of its own tree.
</p>
<p>Discovering the set for a vertex means tracing a tree back to its root. Consider
</p>
<p>what happens when the edge from vertex 3 to vertex 9 is considered for adding to the
</p>
<p>minimum weighted spanning tree as pictured in Fig. 7.6. The partition at that time
</p>
<p>looks like this.
</p>
<p>  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
</p>
<p>[ 4, 4, 2, 7, 5,11, 2, 7, 2,11,11, 7,11,16,16,16,16,19,19,19,19,22,22,24,26,26,19,26,29,29]
</p>
<p>Vertex 3 is not the root of its own tree at this time. Since 7 is found at index 3 we
</p>
<p>next look at index 7 of the partition list. That position in the partition list matches
</p>
<p>its value. The 3 is in the set (i.e. tree) rooted at location 7. Looking at vertex 9 next,
</p>
<p>index 9 in the list contains 11. Index 11 in the list contains 7. Vertex 9 is also in the
</p>
<p>set (i.e. tree) rooted at index 7. Therefore vertex 3 and 9 are already in the same set
</p>
<p>and the edge from 3 to 9 cannot be added to the minimum spanning tree since a cycle
</p>
<p>would be formed.
</p>
<p>The next edge to be considered is the edge between vertices 2 and 3. The root of
</p>
<p>the tree containing 2 is at index 2 of the partition. The root of the vertex containing
</p>
<p>3 is at index 7 as we just saw. These two vertices are not in the same set so the edge
</p>
<p>from 2 to 3 is added to the minimum spanning tree edges.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>196 7 Graphs
</p>
<p>The third operation that must be performed is the merging of the sets containing
</p>
<p>2 and 3. This is where the partition comes in handy. Having found the root of the
</p>
<p>two trees, we simply make the root of one of the trees point to the root of the other
</p>
<p>tree. We end up with this partition after merging these two sets.
</p>
<p>  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
</p>
<p>[ 4, 4, 2, 7, 5,11, 2, 2, 2,11,11, 7,11,16,16,16,16,19,19,19,19,22,22,24,26,26,19,26,29,29]
</p>
<p>At this point in the algorithm, the tree rooted at 7 has been altered to be rooted at
</p>
<p>2 instead. That&rsquo;s all that was needed to merge the two sets containing vertex 2 and
</p>
<p>3! The root of one tree can be made to point to the root of the other tree when two
</p>
<p>sets are merged into one.
</p>
<p>The partition data structure combines the three required operations from Sect. 7.4.2
</p>
<p>into one method called sameSetAndUnion. This method is given two vertex numbers.
</p>
<p>The method returns true if the two vertices are in the same set (i.e. have the same
</p>
<p>root). If they do not have the same root, then the root of one tree is made to point to
</p>
<p>the other and the method returns false.
</p>
<p>The sameSetAndUnion method first finds the roots of the two vertices given to
</p>
<p>it. In the worst case this could take O(|V |) time leading to an overall complexity of
</p>
<p>O(|V |2). However, in practice these set trees are very flat. For instance, in the exam-
</p>
<p>ple presented in this chapter, the average depth of the set trees is 1.7428, meaning
</p>
<p>that on average it takes 1.7428 comparisons to find the root of a set tree in a graph
</p>
<p>with 30 vertices and 45 edges to consider adding to the minimum weighted spanning
</p>
<p>tree. Another example containing 133 vertices and 8778 edges had an average set
</p>
<p>tree depth of 7.5656. The average complexity of this sameSetAndUnion method is
</p>
<p>much better than the solution considered in Sect. 7.4.2. The average case complex-
</p>
<p>ity of sameSetAndUnion is much closer to O(log|V |). This means that the second
</p>
<p>part of Kruskal&rsquo;s algorithm, using this partition data structure, exhibits O(|E|log|V |)
</p>
<p>complexity in the average case.
</p>
<p>In a connected graph the number of edges must be no less than one less than the
</p>
<p>total number of vertices. Sorting the edges takes O(|E|log|E|) time and the second
</p>
<p>part of Kruskal&rsquo;s algorithm takes O(|E|log|V |) time. Since the number of edges is at
</p>
<p>least on the same order as the number of vertices in a connected graph the complexity
</p>
<p>O(|E|log|V |) &le; O(|E|log|E|). So we can say that the overall average complexity of
</p>
<p>Kruskal&rsquo;s algorithm is O(|E|log|E|). In practice, Kruskal&rsquo;s algorithm is very efficient
</p>
<p>and finds a minimum weighted spanning tree quickly even for large graphs with
</p>
<p>many edges.
</p>
<p>7.5 Dijkstra&rsquo;s Algorithm
</p>
<p>Edsger Dijkstra was a Dutch computer scientist who lived from 1930 to 2002. In
</p>
<p>1959 he published a short paper [4] that commented on Kruskal&rsquo;s solution to the
</p>
<p>minimum spanning tree problem and provided an alternative that might in some
</p>
<p>cases be more efficient. More importantly, he provided an algorithm for finding the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5 Dijkstra&rsquo;s Algorithm 197
</p>
<p>Fig. 7.8 Minimum Cost Paths and Total Cost from Source Vertex 0
</p>
<p>minimum cost path between any two vertices in a weighted graph. This algorithm
</p>
<p>can be, and sometimes is, generalized to find the minimum cost path between a
</p>
<p>source vertex and all other vertices in a graph. This algorithm is known as Dijkstra&rsquo;s
</p>
<p>algorithm. Figure 7.8 shows the result of running Dijkstra&rsquo;s algorithm on the graph
</p>
<p>first presented in Fig. 7.3. The purple edges show the minimum cost paths from
</p>
<p>source vertex 0 to all other vertices in the graph. The orange values are the minimum
</p>
<p>cost of reaching each vertex from source vertex 0.
</p>
<p>Efficiently finding a minimum cost path from one vertex to another is used in
</p>
<p>all kinds of problems including network routing, trip planning, and other planning
</p>
<p>problems where vertices represent intermediate goals and edges represent the cost of
</p>
<p>transitioning between intermediate goals. These kind of planning problems are very
</p>
<p>common.
</p>
<p>Dijkstra&rsquo;s algorithm proceeds in a greedy fashion from the single source vertex.
</p>
<p>Each vertex, v, in the graph is assigned a cost which is the sum of the weighted edges
</p>
<p>on the path from the source to v. Initially the source vertex is assigned cost 0. All
</p>
<p>other vertices are initially assigned infinite cost. Anything greater than the sum of
</p>
<p>all weights in the graph can serve as an infinite value.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>198 7 Graphs
</p>
<p>Dijkstra&rsquo;s algorithm shares some commonality with depth first search. The
</p>
<p>algorithm proceeds as depth first search proceeds, but starts with a single source
</p>
<p>eventually visiting every node within the graph. There are two sets that Dijkstra&rsquo;s
</p>
<p>algorithm maintains. The first is an unvisited set. This is a set of vertices that yet need
</p>
<p>to be considered while looking for minimum cost paths. The unvisited set serves the
</p>
<p>same purpose as the stack when performing depth first search on a graph. The visited
</p>
<p>set is the other set used by the algorithm. The visited set contains all vertices which
</p>
<p>already have their minimum cost and path computed. The visited set serves the same
</p>
<p>purpose as the visited set in depth first search of a graph.
</p>
<p>To keep track of the minimum cost path from the source to a vertex, v, it is only
</p>
<p>necessary to keep track of the previous vertex on the path to v. For each vertex, v,
</p>
<p>we keep track of the previous vertex on its path from the source.
</p>
<p>Initially the source vertex, with its cost of 0, is added to the unvisited set. Then the
</p>
<p>algorithm proceeds as follows as long as there is at least one vertex in the unvisited set.
</p>
<p>1. Remove the vertex we&rsquo;ll call current from the unvisited set with the least cost. All
</p>
<p>other paths to this vertex must have greater cost because otherwise they would
</p>
<p>have been in the unvisited set with smaller cost.
</p>
<p>2. Add current to the visited set.
</p>
<p>3. For every vertex, adjacent, that is adjacent to current, check to see if adjacent
</p>
<p>is in the visited set or not. If adjacent is in the visited set, then we know the
</p>
<p>minimum cost of reaching this vertex from the source so don&rsquo;t do anything.
</p>
<p>4. If adjacent is not in the visited set, compute a new cost for arriving at adjacent by
</p>
<p>traversing the edge, e, from current to adjacent. A new cost can be found by adding
</p>
<p>the cost of getting to current and e&lsquo;s weight. If this new cost is better than the
</p>
<p>current cost of getting to adjacent, then update adjacent&lsquo;s cost and remember that
</p>
<p>current is the previous vertex of adjacent. Also, add adjacent to the unvisited set.
</p>
<p>When this algorithm terminates the cost of reaching all vertices in the graph has
</p>
<p>been computed assuming that all vertices are reachable from the source vertex. In
</p>
<p>addition, the minimum cost path to each vertex can be determined from the previous
</p>
<p>vertex information that was maintained as the algorithm executed.
</p>
<p>7.5.1 Dijkstra&rsquo;s Complexity Analysis
</p>
<p>In the first step of Dijkstra&rsquo;s algorithm, the next current vertex is always the unvisited
</p>
<p>vertex with smallest cost. By always picking the vertex with smallest cost so far, we
</p>
<p>can be guaranteed that no other cheaper path exists to this vertex since we always
</p>
<p>proceed by considering the next cheapest vertex on our search to find cheapest paths
</p>
<p>in the graph.
</p>
<p>The number of edges of any vertex in a simple, undirected graph will always be
</p>
<p>less than the number of total vertices in the graph. Each vertex becomes the current
</p>
<p>vertex exactly once in the algorithm in step 1. Assume finding the next current takes
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.5 Dijkstra&rsquo;s Algorithm 199
</p>
<p>O(|V |) time. Since this happens |V | times, the complexity of the first step is O(|V |2)
</p>
<p>over the course of running the algorithm. The rest of the steps consider those edges
</p>
<p>adjacent to current. Since the number of edges of any vertex in a simple, undirected
</p>
<p>graph will always be less than |V |, the rest of the algorithm runs in less than O(|V |2)
</p>
<p>time. So, the complexity of Dijkstra&rsquo;s Algorithm is O(|V |2) assuming that the first
</p>
<p>step takes O(|V |) to find the next current vertex.
</p>
<p>It turns out that selecting the next current can be done in O(log|V |) time if we
</p>
<p>use a priority queue for our unvisited set. Priority queues and their implementation
</p>
<p>are discussed in Chap. 9. Using a priority queue, Dijkstra&rsquo;s Algorithm will run in
</p>
<p>O(|V |log|V |) time.
</p>
<p>7.6 Graph Representations
</p>
<p>How a graph, G = (V,E), is represented within a program depends on what the
</p>
<p>program needs to do. Consider the directed graph in Fig. 7.2. The graph itself can
</p>
<p>be stored in an XML file containing vertices and edges as shown in Sect. 7.6.1. A
</p>
<p>weighted graph would include a weight attribute for each edge in the graph. In this
</p>
<p>XML file format the vertexId is used by the edges to indicate which vertices they
</p>
<p>are attached to. The labels, which appear in Fig. 7.2 are only labels and are not used
</p>
<p>within the XML file to associate edges with vertices.
</p>
<p>7.6.1 A Graph XML File
</p>
<p>1 &lt;?xml version="1.0" encoding="UTF-8"?&gt;
</p>
<p>2 &lt;Graph width="595.80" height="229.20" directed="True" weighted="False"&gt;
</p>
<p>3   &lt;Vertices&gt;
</p>
<p>4     &lt;Vertex vertexId="12" x="343.15" y="156.10" label="10"/&gt;
</p>
<p>5     &lt;Vertex vertexId="11" x="246.15" y="161.10" label="9"/&gt;
</p>
<p>6     &lt;Vertex vertexId="10" x="288.15" y="58.10" label="0"/&gt;
</p>
<p>7     &lt;Vertex vertexId="9" x="374.15" y="58.10" label="1"/&gt;
</p>
<p>8     &lt;Vertex vertexId="8" x="135.15" y="156.10" label="6"/&gt;
</p>
<p>9     &lt;Vertex vertexId="7" x="49.65" y="83.10" label="2"/&gt;
</p>
<p>10     &lt;Vertex vertexId="6" x="167.15" y="83.05" label="3"/&gt;
</p>
<p>11     &lt;Vertex vertexId="5" x="121.15" y="19.10" label="8"/&gt;
</p>
<p>12     &lt;Vertex vertexId="4" x="419.15" y="204.10" label="11"/&gt;
</p>
<p>13     &lt;Vertex vertexId="3" x="426.15" y="87.10" label="4"/&gt;
</p>
<p>14     &lt;Vertex vertexId="2" x="546.15" y="96.10" label="5"/&gt;
</p>
<p>15     &lt;Vertex vertexId="1" x="546.15" y="210.10" label="7"/&gt;
</p>
<p>16     &lt;Vertex vertexId="0" x="485.15" y="161.10" label="12"/&gt;
</p>
<p>17   &lt;/Vertices&gt;
</p>
<p>18   &lt;Edges&gt;
</p>
<p>19     &lt;Edge tail="12" head="10"/&gt;
</p>
<p>20     &lt;Edge tail="10" head="6"/&gt;
</p>
<p>21     &lt;Edge tail="6" head="11"/&gt;
</p>
<p>22     &lt;Edge tail="7" head="6"/&gt;
</p>
<p>23     &lt;Edge tail="7" head="8"/&gt;
</p>
<p>24     &lt;Edge tail="7" head="5"/&gt;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_9">http://dx.doi.org/10.1007/978-3-319-13072-9_9</a></div>
</div>
<div class="page"><p/>
<p>200 7 Graphs
</p>
<p>25     &lt;Edge tail="11" head="12"/&gt;
</p>
<p>26     &lt;Edge tail="12" head="4"/&gt;
</p>
<p>27     &lt;Edge tail="4" head="0"/&gt;
</p>
<p>28     &lt;Edge tail="0" head="2"/&gt;
</p>
<p>29     &lt;Edge tail="2" head="1"/&gt;
</p>
<p>30     &lt;Edge tail="2" head="3"/&gt;
</p>
<p>31     &lt;Edge tail="3" head="9"/&gt;
</p>
<p>32     &lt;Edge tail="9" head="10"/&gt;
</p>
<p>33     &lt;Edge tail="9" head="12"/&gt;
</p>
<p>34   &lt;/Edges&gt;
</p>
<p>35 &lt;/Graph&gt;
</p>
<p>The x and y vertex attributes are not required in any graph representation, but
</p>
<p>to draw a graph it is nice to have location information for the vertices. All this
</p>
<p>information is stored in the XML file, but what about the three algorithms presented
</p>
<p>in this chapter? What information is actually needed by each algorithm.
</p>
<p>When searching a graph by depth first search vertices are pushed onto a stack
</p>
<p>as the search proceeds. In that case the vertex information must be stored for use
</p>
<p>by the search. In this case, since edges have the vertexId of their edge endpoints, it
</p>
<p>would be nice to have a method to quickly lookup vertices within the graph. A map
</p>
<p>or dictionary from vertexId to vertices would be convenient. It makes sense to create
</p>
<p>a class to hold the vertex information like the class definition of Sect. 7.6.2.
</p>
<p>7.6.2 A Vertex Class
</p>
<p>1 class Vertex:
</p>
<p>2     def __init__(self,vertexId,x,y,label):
</p>
<p>3         self.vertexId = vertexId
</p>
<p>4         self.x = x
</p>
<p>5         self.y = y
</p>
<p>6         self.label = label
</p>
<p>7         self.adjacent = []
</p>
<p>8         self.previous = None
</p>
<p>In this Vertex class definition for directed graphs it makes sense to store the
</p>
<p>edges with the vertex since edges connect vertices. The adjacent list can hold the
</p>
<p>list of adjacent vertices. When running depth first search a map of vertexId to Ver-
</p>
<p>tex for each of the vertices in the graph provides the needed information for the
</p>
<p>algorithm.
</p>
<p>When implementing Kruskal&rsquo;s algorithm, a list of edges is the important feature
</p>
<p>of the graph. The class definition of Sect. 7.6.3 provides a less-than method which
</p>
<p>allows edge objects to be sorted, which is crucial for Kruskal&rsquo;s algorithm. The vertices
</p>
<p>themselves are not needed by the algorithm. A list of edges and the partition data
</p>
<p>structure suffice for running Kruskal&rsquo;s algorithm.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.6 Graph Representations 201
</p>
<p>7.6.3 An Edge Class
</p>
<p>1 class Edge:
</p>
<p>2     def __init__(self,v1,v2,weight=0):
</p>
<p>3         self.v1 = v1
</p>
<p>4         self.v2 = v2
</p>
<p>5         self.weight = weight
</p>
<p>6
</p>
<p>7     def __lt__(self,other):
</p>
<p>8         return self.weight &lt; other.weight
</p>
<p>Running Dijkstra&rsquo;s algorithm benefits from having both the edge and vertex
</p>
<p>objects. The weight of each edge is needed by the algorithm so storing the weight in
</p>
<p>the edge and associating vertices and edges is useful.
</p>
<p>There are other potential representations for graphs. For instance, a two-
</p>
<p>dimensional matrix could be used to represent edges between vertices. The rows
</p>
<p>and columns of the matrix represent the vertices. The weight of an edge from vertex
</p>
<p>vi to vertex vj would be recorded at matrix[i][j]. Such a representation is called an
</p>
<p>adjacency matrix. Adjacency matrices tend to be sparsely populated and are not used
</p>
<p>much in practice due to their wasted space.
</p>
<p>The chosen graph representation depends on the work being done. Vertices with
</p>
<p>adjacency information may be enough. An edge list is enough for the Kruskal&rsquo;s
</p>
<p>algorithm. Vertex and edge information is required for Dijskstra&rsquo;s algorithm. An
</p>
<p>adjacency matrix may be required for some situations. As programmers we need to
</p>
<p>be mindful about wasted space, algorithm needs, and efficiency of our algorithms
</p>
<p>and the implications that the choice of data representation has on our programs.
</p>
<p>7.7 Chapter Summary
</p>
<p>Graph notation was covered in this chapter. Several terms and definitions were given
</p>
<p>for various types of graphs including weighted and directed graphs. The chapter
</p>
<p>presented three graph theory algorithms: depth first search, Kruskal&rsquo;s algorithm, and
</p>
<p>Dijkstra&rsquo;s algorithm. Through looking at those algorithms we also explored graph
</p>
<p>representations and their use in these various algorithms.
</p>
<p>After reading this chapter you should know the following.
</p>
<p>&bull; A graph is composed of vertices and edges.
</p>
<p>&bull; A graph may be directed or undirected.
</p>
<p>&bull; A tree is a graph where one path exists between any two vertices.
</p>
<p>&bull; A spanning tree is a subset of a graph which includes all the vertices in a connected
</p>
<p>graph.
</p>
<p>&bull; A minimum weighted spanning tree is found by running Kruskal&rsquo;s algorithm.
</p>
<p>&bull; Dijkstra&rsquo;s algorithm finds the minimum cost of reaching all vertices in a graph
</p>
<p>from a given source vertex.
</p>
<p>&bull; Choosing a graph representation depends on the work to be done.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>202 7 Graphs
</p>
<p>&bull; Some typical graph representations are a vertex list with adjacency information,
</p>
<p>an edge list, or an adjacency matrix.
</p>
<p>7.8 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. In the definition of a graph, G = (V, E), what does the V and the E stand for?
</p>
<p>2. What is the difference in the definition of E in directed and undirected graphs?
</p>
<p>3. In depth first search, what is the purpose of the visited set?
</p>
<p>4. How is backtracking accomplished in depth first search of a graph? Explain how
</p>
<p>the backtracking happens.
</p>
<p>5. What is a path in a graph and how does that differ from a cycle?
</p>
<p>6. What is a tree? For the graph in Fig. 7.2 provide three trees that include the
</p>
<p>vertices 0, 1, and 10.
</p>
<p>7. Why does Kruskal&rsquo;s algorithm never make a mistake when selecting edges for
</p>
<p>the minimum weighted spanning tree?
</p>
<p>8. Why does Dijkstra&rsquo;s algorithm never make a mistake when computing the cost
</p>
<p>of paths to vertices?
</p>
<p>9. What graph representation is best for Kruskal&rsquo;s algorithm? Why?
</p>
<p>10. Why is the previous vertex stored by Dijkstra&rsquo;s algorithm? What purpose does
</p>
<p>the previous vertex have and why is it stored?
</p>
<p>7.9 Programming Problems
</p>
<p>1. Write a program to find a path between vertex 9 and 29 in the graph shown in
</p>
<p>Fig. 7.9. Be sure to print the path (i.e. the sequence of vertices) that must be
</p>
<p>traversed in the path between the two vertices. An XML file describing this graph
</p>
<p>can be found on the text website.
</p>
<p>2. Modify the first problem to find the shortest path between vertices 9 and 29 in
</p>
<p>terms of the number of edges traversed. In other words, ignore the weights in this
</p>
<p>problem. Use breadth first search to find this solution.
</p>
<p>3. Write the code and perform Dijkstra&rsquo;s algorithm on the graph in Fig. 7.9 to find
</p>
<p>the minimum cost of visiting all other vertices from vertex 9 of the graph.
</p>
<p>4. Write the code and perform Kruskal&rsquo;s algorithm on either the directed graph in
</p>
<p>Fig. 7.9 or the undirected example found in the chapter. XML files for both graphs
</p>
<p>can be found on the text website.
</p>
<p>5. Not every graph must be represented explicitly. Sometimes it is just as easy to
</p>
<p>write a function that given a vertex, will compute the vertices that are adjacent
</p>
<p>to it (that have edges between them). For instance, consider the water bucket
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>7.9 Programming Problems 203
</p>
<p>Fig. 7.9 A Sample Weighted, Directed Graph
</p>
<p>problem. There are two buckets in this problem: a 3 gallon bucket and a 5 gallon
</p>
<p>bucket. Your job is to put exactly 4 gallons in the 5 gallon bucket. The rules of
</p>
<p>the game say that you can completely fill a bucket of water, you can pour one
</p>
<p>bucket into another, and you can completely dump a bucket out on the ground.
</p>
<p>You cannot partially fill up a bucket, but you can pour one bucket into another.
</p>
<p>You are to write a program that tells you how to start with two empty buckets and
</p>
<p>end with 4 gallons in the 5 gallon bucket.
</p>
<p>To complete this problem you must implement depth first search of a graph.
</p>
<p>The vertices in this problem consist of the state of the problem which is given
</p>
<p>by the amount of water in each bucket. Along with the search algorithm you
</p>
<p>must also implement an adjacent function that given a vertex containing this state
</p>
<p>information will return a list of states that may be adjacent to it. It may be easier
</p>
<p>to generate some extra adjacent states and then filter out the unreasonable ones
</p>
<p>before returning the list from adjacent. For instance, it may be easier to generate
</p>
<p>a state with 6 gallons in the 5 gallon bucket and then throw that state out later
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>204 7 Graphs
</p>
<p>by removing states from the list which have more gallons than allowed in that
</p>
<p>bucket.
</p>
<p>The program should print out the list of actions to take to get from no water in
</p>
<p>either bucket to four gallons in the five gallon pail. The solution may not be the
</p>
<p>absolute best solution, but it should be a valid solution that is printed when the
</p>
<p>program is completed.
</p>
<p>6. A bipartite graph is a graph where the vertices may be divided into two sets such
</p>
<p>that no two vertices in the same set have an edge between them. All edges in the
</p>
<p>graph go between vertices that appear in different sets. A program can test to see
</p>
<p>if a graph is bipartite by doing a traversal of the graph, like a depth first search,
</p>
<p>and looking for odd cycles. A graph is bipartite if and only if it does not contain
</p>
<p>an odd cycle. Write a program that given a graph decides if it is bipartite or not.
</p>
<p>The program need only print Yes, it is bipartite, or No, it is not bipartite.
</p>
<p>7. Extend the program from the previous exercise to print the set of vertices in each
</p>
<p>of the two bipartite sets if the graph is found to be bipartite.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8Membership Structures
</p>
<p>In Chap. 5 we covered data structures that support insertion, deletion, membership
</p>
<p>testing, and iteration. For some applications testing membership may be enough.
</p>
<p>Iteration and deletion may not be necessary. The classic example is that of a spell
</p>
<p>checker. Consider the job of a spell checker. A simple one may detect errors in
</p>
<p>spelling while a more advanced spell checker may suggest alternatives of correctly
</p>
<p>spelled words.
</p>
<p>Clearly a spell checker is provided with a large dictionary of words. Using the list
</p>
<p>of words the spell checker determines whether a word you have is in the dictionary
</p>
<p>and therefore a correct word. If the word does not appear in the dictionary the word
</p>
<p>processor or editor may underline the word indicating it may be incorrectly spelled.
</p>
<p>In some cases the word processor may suggest an alternative, correctly spelled word.
</p>
<p>In some cases, the word processor may simply correct the misspelling. How do these
</p>
<p>spell checkers/correctors work? What kind of data structures do they use?
</p>
<p>8.1 Chapter Goals
</p>
<p>At first glance, a hash set (i.e. a Python dictionary) might seem an appropriate data
</p>
<p>structure for spell checking. Lookup time within the set could be done in O(1) time.
</p>
<p>However, the tradeoff is in the size of this hash map. A typical English dictionary
</p>
<p>might contain over 100,000 words. The amount of space required to store that many
</p>
<p>words would be quite large.
</p>
<p>In this chapter we&rsquo;ll cover two data structures that are designed to test membership
</p>
<p>within a set. The first, a bloom filter, has significantly smaller space requirements
</p>
<p>and provides a very fast membership test. The other is a trie (pronounced try) data
</p>
<p>structure which has features that would not be readily available to a hash set imple-
</p>
<p>mentation and may take up less space than a hash set.
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_8
</p>
<p>205
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_5">http://dx.doi.org/10.1007/978-3-319-13072-9_5</a></div>
</div>
<div class="page"><p/>
<p>206 8 Membership Structures
</p>
<p>8.2 Bloom Filters
</p>
<p>Bloom filters are named for their creator, Burton Howard Bloom, who originally
</p>
<p>proposed this idea in 1970. Since then many authors have covered the implemen-
</p>
<p>tations of bloom filters including Alan Tharp [7]. Wikipedia, while not always the
</p>
<p>authoritative source, has a very good discussion of bloom filters as well [8].
</p>
<p>A bloom filter shares some ideas with hash sets while using considerably less
</p>
<p>space. A bloom filter is a data structure employing statistical probability to determine
</p>
<p>if an item is a member of a set of values. Bloom filters are not 100 % accurate. A
</p>
<p>bloom filter will never report a false negative for set membership, meaning that they
</p>
<p>will never report that an item doesn&rsquo;t belong to a set when it actually does. However,
</p>
<p>a bloom filter will sometimes report a false positive. It may report an item is in a set
</p>
<p>when it is actually not.
</p>
<p>Consider the problem of spell checking. A spell checker needs to know if a typed
</p>
<p>word is correctly typed by looking it up in the dictionary. With a bloom filter, the
</p>
<p>typed word can be given to the bloom filter which will report that it is or is not a
</p>
<p>correctly typed word. In some cases it may report a word is correct when it is not.
</p>
<p>A bloom filter is an array of bits along with a set of hashing functions. The number
</p>
<p>of bits in the filter and the number of hashing functions influences the accuracy of
</p>
<p>the bloom filter. The exact number of bits and hash functions will be discussed later.
</p>
<p>Consider a bloom filter with 20 bits and 3 independent hash functions. Initially all
</p>
<p>the bits in the filter are set to 0 as shown in Fig. 8.1.
</p>
<p>Consider adding the word cow to the bloom filter. Assume that three independent
</p>
<p>hash functions hash the word cow, modulo 20, to 18, 9, and 3 respectively. The bits
</p>
<p>at indices 18, 9, and 3 are set to 1 to remember that cow has been added to the filter
</p>
<p>as shown in Fig. 8.2.
</p>
<p>Now consider adding the word cat to the same filter. Assume the hash values
</p>
<p>from the three hash functions, modulo 20, are 0, 3, and 9. Inserting cat into the filter
</p>
<p>results in setting the bit at index 0 to a 1. The other two were already set by inserting
</p>
<p>cow. Finally, inserting dog into the filter results in the bloom filter shown in Fig. 8.3.
</p>
<p>The hash values for dog are 10, 9, and 8.
</p>
<p>Fig. 8.1 An Empty Bloom Filter
</p>
<p>Fig. 8.2 After Inserting cow into the Bloom Filter
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2 Bloom Filters 207
</p>
<p>Fig. 8.3 After Inserting cow, cat, and dog into the Bloom Filter
</p>
<p>Looking up an item in a bloom filter requires hashing the value again with the same
</p>
<p>hash functions generating the indices into the bit array. If the value at all indices in
</p>
<p>the bit array are one, then the lookup function reports success and otherwise failure.
</p>
<p>Consider looking up a value that is not in the bloom filter of Fig. 8.3. If we look
</p>
<p>up fox the three hash function calls return 3, 12, and 18. The digit at indices 3 and
</p>
<p>18 is a 1. However, the digit at index 12 is a 0 and the lookup function reports that
</p>
<p>fox is not in the bloom filter.
</p>
<p>Consider looking up the value rabbit in the same bloom filter. Hashing rabbit
</p>
<p>with the three hash functions results in values 8, 9, and 18. All three of the digits at
</p>
<p>these locations within the bloom filter contain a 1 and the bloom filter incorrectly
</p>
<p>reports that rabbit has been added to the filter. This is a false positive and while not
</p>
<p>desirable, must be acceptable if a bloom filter is to be used.
</p>
<p>If a bloom filter is to be useful, it must never report a false negative. From these
</p>
<p>examples it should be clear that false negatives are impossible. False positives must
</p>
<p>be kept to a minimum. In fact, it is possible to determine on average how often a
</p>
<p>bloom filter will report a false positive. The probability calculation depends on three
</p>
<p>factors: the hashing functions, the number of items added to the bloom filter, and the
</p>
<p>number of bits used in the bloom filter. The analysis of these factors are covered in
</p>
<p>the next sections.
</p>
<p>8.2.1 The Hashing Functions
</p>
<p>Each item added to a bloom filter must be hashed by some number of hash functions
</p>
<p>which are completely independent of each other. Each hashing function must also be
</p>
<p>evenly distributed over the range of bit indices in the bit array. This second require-
</p>
<p>ment is true of hashing functions for hash sets and hash tables as well. Uniform distrib-
</p>
<p>ution is guaranteed by the built-in hash functions of Python and most other languages.
</p>
<p>In the examples above, three hashing functions were required. Sometimes the
</p>
<p>required number of hashing functions can be much higher, depending on the number
</p>
<p>of items being inserted and the number of bits in the bit array. Creating the required
</p>
<p>number of independent, uniformly distributed hashing functions might seem like a
</p>
<p>daunting problem, but it can be solved in at least a couple of ways. Some hashing
</p>
<p>functions allow a seed value to be provided. In this case, different seed values could
</p>
<p>be used to create different hashing functions.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>208 8 Membership Structures
</p>
<p>Another equally effective way of generating independent hashing functions is to
</p>
<p>append some known value to the end of each item before it is hashed. For instance,
</p>
<p>a 0 might be appended to the item before hashing it to get the first hash function.
</p>
<p>A 1 could be appended to the item before hashing to get the second hash function.
</p>
<p>Likewise, a 2 might be appended to get the third hash function value. So looking
</p>
<p>up rabbit in the bloom filter is accomplished by first hashing rabbit0, rabbit1, and
</p>
<p>rabbit2 with the same hashing function. Since the hashing function is uniformly
</p>
<p>distributed, the values returned by the three hashed values will be independent of
</p>
<p>each other. And, all items with 0 appended will themselves be uniformly distributed.
</p>
<p>Likewise for items with 1 appended and with 2 appended.
</p>
<p>8.2.2 The Bloom Filter Size
</p>
<p>It is possible to find the required bloom filter size given a number of items to insert
</p>
<p>and a desired false positive probability. The probability of any one location within a
</p>
<p>bloom filter not being set by a hash function while inserting an item is given by the
</p>
<p>following formula where the filter consists of m bits.
</p>
<p>1 &minus;
1
</p>
<p>m
</p>
<p>If the bloom filter uses k hash functions, then the probability that a bit in the bit array
</p>
<p>is not set by any of the hash functions required for inserting an item is given by this
</p>
<p>formula.
(
</p>
<p>1 &minus;
1
</p>
<p>m
</p>
<p>)k
</p>
<p>If n items are inserted into the bloom filter then raising this formula to n will provide
</p>
<p>the probability that a bit within the bloom filter&rsquo;s bit array is still a zero after inserting
</p>
<p>all n items. So we have
(
</p>
<p>1 &minus;
1
</p>
<p>m
</p>
<p>)nk
</p>
<p>So, the probability that a bit in the bloom filter is a 1 after inserting n items while
</p>
<p>using k hashing functions is given by this formula.
</p>
<p>1 &minus;
</p>
<p>(
</p>
<p>1 &minus;
1
</p>
<p>m
</p>
<p>)nk
</p>
<p>Now consider looking up an item that was not added to the bloom filter. The prob-
</p>
<p>ability that it will report a false positive can be found by computing the likelihood
</p>
<p>that each location within the bloom filter is a 1 for all k hashing functions. This is
</p>
<p>expressed as follows.
</p>
<p>p =
</p>
<p>(
</p>
<p>1 &minus;
</p>
<p>(
</p>
<p>1 &minus;
1
</p>
<p>m
</p>
<p>)nk
)k
</p>
<p>This formula contains a sequence that can be approximated using the natural log
</p>
<p>[8] as
</p>
<p>p =
(
</p>
<p>1 &minus; ekn/m
)k
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8.2 Bloom Filters 209
</p>
<p>Using this formula it is possible to solve for m given an n and desired probability, p,
</p>
<p>of false positives. The formula is as follows.
</p>
<p>m = &minus;
n ln p
</p>
<p>(ln 2)2
</p>
<p>Finally, solving for k above results in the following formula.
</p>
<p>k =
m
</p>
<p>n
ln 2
</p>
<p>These two formulas tell us how many bits are required in our filter to guarantee a
</p>
<p>maximum specified rate of false positives. We can also compute the required num-
</p>
<p>ber of hash functions. For instance, for an English dictionary containing 109,583
</p>
<p>words and a desired false postive percentage of no more than 1 % (expressed
</p>
<p>as 0.01 in the formula) requires a bit array of 1,050,360 bits and seven hashing
</p>
<p>functions.
</p>
<p>The number of bits in this example may seem excessive. However, recall that
</p>
<p>they are bits. An efficient implementation requires roughly 128 KB of storage. The
</p>
<p>number of characters in the English dictionary used in these examples totals 935,171.
</p>
<p>Assuming 1 byte per character, storing all these words would require a minimum
</p>
<p>of 914 KB. The bloom filter represents quite a savings in space. In addition, during
</p>
<p>experiments the lookup time using the bloom filter never took longer than 160&micro;s.
</p>
<p>The lookup time is bounded by the number and efficiency of the hash functions
</p>
<p>used to compute the desired values. Assuming that the hash functions are dependent
</p>
<p>on the length of the string being hashed, then the lookup time is O(lk) where l
</p>
<p>is given by the length of the item being looked up and k is the number of hash
</p>
<p>functions.
</p>
<p>8.2.3 Drawbacks of a Bloom Filter
</p>
<p>Besides the obvious false positive potential, the bloom filter can only report yes or no.
</p>
<p>It can&rsquo;t suggest alternatives for items that might be close to being spelled correctly.
</p>
<p>A bloom filter has no memory of which bits were set by which items so a yes or
</p>
<p>no answer is the best we can get with even a yes answer not being correct in some
</p>
<p>circumstances. The next section presents a Trie data structure that will not report
</p>
<p>false positives and can be used to find alternatives for incorrectly spelled words.
</p>
<p>8.3 The Trie Datatype
</p>
<p>A trie is a data structure that is designed for reTRIEval. The data structure is pro-
</p>
<p>nounced like the word try. A trie is not meant to be used when deleting values from a
</p>
<p>data structure is required. It is meant only for retrieval of items based on a key value.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>210 8 Membership Structures
</p>
<p>Fig. 8.4 After Inserting cow, cat, rat, rabbit, and dog into a Trie
</p>
<p>Tries are appropriate when key values are made up of more than one unit and
</p>
<p>when the individual units of a key may overlap with other item keys. In fact, the
</p>
<p>more overlap the key units have, the more compact the trie data structure.
</p>
<p>In the problem of spell checking, words are made up of characters. These charac-
</p>
<p>ters are the individual units of the keys. Many words overlap in a dictionary like a,
</p>
<p>an, and ant. A trie may be implemented in several different ways. In this text we&rsquo;ll
</p>
<p>concentrate on the linked trie which is a series of link lists making up a matrix. Matrix
</p>
<p>implementations lead to sparsely populated arrays which take up much more room
</p>
<p>with empty locations. A linked trie has overhead for pointers, but is not sparsely
</p>
<p>populated.
</p>
<p>The trie data structure begins with an empty linked list. Each node in the linked
</p>
<p>trie list contains three values: a unit of the key (in the spellchecker instance this is a
</p>
<p>character of the word), a next pointer that points to the next node in the list which
</p>
<p>would contain some other unit (i.e. character) appearing at the same position within
</p>
<p>a key (i.e. word), and a follows pointer which points at a node that contains the next
</p>
<p>unit within the same key. In Fig. 8.4 the follows pointer is in yellow while the next
</p>
<p>pointer field is in red.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8.3 The Trie Datatype 211
</p>
<p>When items are inserted into the trie a sentinel unit is added. In the case of the
</p>
<p>spell checker, a &lsquo;$&rsquo; character is appended to the end of every word. The sentinel is
</p>
<p>needed because words like rat are prefixes to words like ratchet. Without the sentinel
</p>
<p>character it would be unclear whether a word ended or was only a prefix of some
</p>
<p>other word.
</p>
<p>In a trie keys with a common prefix share that prefix and are not repeated. The
</p>
<p>next pointer is used when more than one possible next character is possible. This
</p>
<p>saves space in the data structure. The trade-off is that the next and follows pointers
</p>
<p>take extra space in each node.
</p>
<p>8.3.1 The Trie Class
</p>
<p>1 class Trie:
</p>
<p>2 def __insert(node,item):
</p>
<p>3 # This is the recursive insert function.
</p>
<p>4
</p>
<p>5 def __contains(node,item):
</p>
<p>6 # This is the recursive membership test.
</p>
<p>7
</p>
<p>8
</p>
<p>9 class TrieNode:
</p>
<p>10 def __init__(self,item,next = None, follows = None):
</p>
<p>11 self.item = item
</p>
<p>12 self.next = next
</p>
<p>13 self.follows = follows
</p>
<p>14
</p>
<p>15 def __init__(self):
</p>
<p>16 self.start = None
</p>
<p>17
</p>
<p>18 def insert(self,item):
</p>
<p>19 self.start = Trie.__insert(self.start,item)
</p>
<p>20
</p>
<p>21 def __contains__(self,item):
</p>
<p>22 return Trie.__contains(self.start,item)
</p>
<p>8.3.2 Inserting into a Trie
</p>
<p>Inserting values into a trie can be done either iteratively, with a loop, or recursively.
</p>
<p>To recursively insert into a trie the insert method can call an __insert function. It is
</p>
<p>easier to write the recursive code as a function and not a method of the Trie class
</p>
<p>because the node value passed to the function may be None. To insert into the trie,
</p>
<p>the __insert function operates as follows.
</p>
<p>1. If the key is empty (i.e. no units are left in the key), return None as the empty
</p>
<p>node.
</p>
<p>2. If the node is None then a new node is created with the next unit of the key and
</p>
<p>the rest of the key is inserted and added to the follows link.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>212 8 Membership Structures
</p>
<p>3. If the first unit of the key matches the unit of the current node, then the rest of the
</p>
<p>key is inserted into the follows link of the node.
</p>
<p>4. Otherwise, the key is inserted into the next link of the node.
</p>
<p>Building the trie recursively is simple. However, an iterative version would work
</p>
<p>just as well. The iterative version would require a loop and a pointer to the cur-
</p>
<p>rent node along with remaining key to insert. The iterative insert algorithm would
</p>
<p>behave in a similar fashion to the step outlined above but would need to keep
</p>
<p>track of the previous node as well as the current node so that links could be set
</p>
<p>correctly.
</p>
<p>8.3.3 Membership in a Trie
</p>
<p>Checking membership in a trie can also be accomplished recursively. The steps
</p>
<p>include a base case which might not be completely intuitive at first. The empty key is
</p>
<p>reported as a member of any trie because it works when checking membership. With
</p>
<p>the sentinel unit added to the trie, returning True for an empty key is completely safe
</p>
<p>because any real key will at least consist of the sentinel character. In the algorithm
</p>
<p>outlined here the sentinel is assumed to have already been added to the key. The steps
</p>
<p>for membership testing are as follows.
</p>
<p>1. If the length of the key is 0, then report success by returning True.
</p>
<p>2. If the node we are looking at is None then report failure by returning False.
</p>
<p>3. If the first unit of the key matches the unit in the current node, then check mem-
</p>
<p>bership of the rest of the key starting with the follows node.
</p>
<p>4. Otherwise, check membership of the key starting with the next node in the trie.
</p>
<p>Again, this code might be implemented iteratively with a while loop keeping
</p>
<p>track of the current node and the remainder of the key. Either a recursive or iterative
</p>
<p>implementation will work equally well.
</p>
<p>8.3.4 Comparing Tries and Bloom Filters
</p>
<p>Bloom filters are clearly faster for testing membership than a trie. However, the
</p>
<p>trie works acceptably well. While the longest bloom filter lookup time in a simple
</p>
<p>experiment was 160&micro;s, the longest trie lookup was 217&micro;s. Of course the trie takes
</p>
<p>more space, but common prefixes share nodes in a trie saving some space over storing
</p>
<p>each word distinctly in a data structure, as in a hash set.
</p>
<p>For purposes of spell checking a trie has distinct advantages, since spelling alter-
</p>
<p>natives can be easily found. Common typographical errors fall into one of four
</p>
<p>categories.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>8.3 The Trie Datatype 213
</p>
<p>&bull; Transposition of characters like teh instead of the
</p>
<p>&bull; Dropped characters like thei instead of their
</p>
<p>&bull; Extra characters like thre instead of the
</p>
<p>&bull; Incorrect characters like thare instead of there
</p>
<p>If in searching in a trie a word is not found, these alternatives can also be searched
</p>
<p>for to find a selection of alternative spellings. What&rsquo;s more, these alternative spellings
</p>
<p>can be searched in parallel in a trie to quickly put together a list of alternatives. A
</p>
<p>bloom filter cannot be used to find alternative spellings since that information is lost
</p>
<p>once entered into the filter. Of course, a trie will never report a false positive either
</p>
<p>as is possible with a bloom filter.
</p>
<p>8.4 Chapter Summary
</p>
<p>Tries and bloom filters are two data structures for testing membership. Bloom filters
</p>
<p>are relatively small and will produce false positives some percentage of the time.
</p>
<p>Tries are larger, don&rsquo;t produce false positives, and can be used to find alternative key
</p>
<p>values that are close to the key being sought. While either data structure will work
</p>
<p>for spell checking, spelling correction would be aided by a trie while a bloom filter
</p>
<p>would not help.
</p>
<p>As far as efficiency goes, bloom filters more efficiently test set membership,
</p>
<p>subject to the false positives that are sometimes produced. However, a trie also
</p>
<p>operates efficiently while also taking more space than a bloom filter. Both the bloom
</p>
<p>filter and the trie tested membership of words in the dictionary in microseconds. The
</p>
<p>bloom filter&rsquo;s worst time was 160&micro;s while the trie&rsquo;s worst time was 217&micro;s for the
</p>
<p>informal test performed on both.
</p>
<p>Size requirements are also a concern of course. The example dictionary used in the
</p>
<p>development of both the bloom filter and the trie in this chapter contained 109,583
</p>
<p>words. The bloom filter for this dictionary of words was approximately 128 KB in
</p>
<p>size. Assuming that the next and follows pointers take 4 bytes each and the key units
</p>
<p>(i.e. word characters) take 1 byte each, the size of the trie is roughly 3.1 MB in size.
</p>
<p>While the bloom filter is much smaller than the trie, both are well within the limits
</p>
<p>of what computers are capable of storing.
</p>
<p>8.5 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. Which datatype, the trie or the bloom filter, is susceptible to false positives?
</p>
<p>2. What is a false positive in this context?
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>214 8 Membership Structures
</p>
<p>3. A bloom filter requires more or less storage than a trie?
</p>
<p>4. When spell checking, which data type can be used for spelling correction?
</p>
<p>5. How can you generate more than one hashing function for use in a bloom filter?
</p>
<p>6. Add the words &ldquo;a&rdquo;, &ldquo;an&rdquo;, &ldquo;ant&rdquo;, &ldquo;bat&rdquo;, and &ldquo;batter&rdquo; to a trie. Draw the trie data
</p>
<p>structure showing its structure after inserting the words in the order given here.
</p>
<p>7. Why is a sentinel needed in a trie?
</p>
<p>8. Why is a sentinel not needed in a bloom filter?
</p>
<p>9. What must be true of keys to be able to store them in a trie?
</p>
<p>10. Which datatype, trie or bloom filter, is more efficient in terms of space? Which
</p>
<p>is more efficient in terms of speed?
</p>
<p>8.6 Programming Problems
</p>
<p>1. Go to the text website and download the dictionary of words. Build a bloom filter
</p>
<p>for this list of words and use it to spellcheck the declaration of independence,
</p>
<p>printing all the misspelled words to the screen.
</p>
<p>2. Go to the text website and download the dictionary of words. Build a trie datatype
</p>
<p>for this list of words and use it to spellcheck the declaration of independence,
</p>
<p>printing all misspelled words to the screen.
</p>
<p>3. Create a trie as in the previous exercise, but also print suggested replacements for
</p>
<p>all misspelled words. This is a tough assignment. Suggested replacements should
</p>
<p>not differ from the original in more than one of the ways suggested in the chapter.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9Heaps
</p>
<p>The word heap is used in a couple of different contexts in Computer Science. A heap
</p>
<p>sometimes refers to an area of memory used for dynamic (i.e. run-time) memory
</p>
<p>allocation. Another meaning, and the topic of this chapter, is a data structure that is
</p>
<p>conceptually a complete binary tree. Heaps are used in implementing priority queues,
</p>
<p>the heapsort algorithm, and some graph algorithms. Heaps are somewhat like binary
</p>
<p>search trees in that they maintain an ordering of the items within the tree. However, a
</p>
<p>heap does not maintain a complete ordering of its items. This has some implications
</p>
<p>for how a heap may be used.
</p>
<p>9.1 Chapter Goals
</p>
<p>By the end of this chapter you should be able to answer the following questions:
</p>
<p>&bull; What is a heap and how is it used?
</p>
<p>&bull; What is the computational complexity of adding and deleting items from a heap?
</p>
<p>&bull; Would you use a heap to look up items or not?
</p>
<p>&bull; When would you use a heap?
</p>
<p>&bull; In the heapsort algorithm, why is it advantageous to construct a largest-on-top
</p>
<p>heap?
</p>
<p>9.2 Key Ideas
</p>
<p>To understand heaps we&rsquo;ll start with a definition. A largest-on-top heap is a complete
</p>
<p>ordered tree such that every node is &ge; all of its children (if it has any). An example
</p>
<p>will help illustrate this definition. Conceptually, a heap is a tree that is full on all
</p>
<p>levels except possibly the lowest level which is filled in from left to right. It takes
</p>
<p>the general shape shown in Fig. 9.1.
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_9
</p>
<p>215
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>216 9 Heaps
</p>
<p>Fig. 9.1 Heap Shape
</p>
<p>Conceptually a heap is a tree, but heaps are generally not stored as trees.
</p>
<p>A complete tree is a tree that is full on all levels except the lowest level which
</p>
<p>is filled in from left to right. Because heaps are complete trees, they may be stored
</p>
<p>in an array. An example will help in understanding heaps and the complete property
</p>
<p>better. Consider a largest on top heap with the root node stored at index 0 in an array.
</p>
<p>Conceptually, Fig. 9.2 is a heap containing integers.
</p>
<p>The data in this conceptual version is stored in an array by traversing the tree
</p>
<p>level by level starting from the root node to the heap. The conceptual heap in Fig. 9.2
</p>
<p>would be stored in an array as organized in Fig. 9.3.
</p>
<p>There are two properties that a heap exhibits. They are:
</p>
<p>&bull; Heap Structure Property: The elements of the heap form a complete ordered tree.
</p>
<p>&bull; Heap Order Property: Every parent &ge; all children (including all descendants).
</p>
<p>The heap in Fig. 9.2 maintains these two properties. The array implementation of
</p>
<p>this heap in Fig. 9.3 also maintains these properties. To see how the properties are
</p>
<p>maintained in the array implementation we need to be able to compute the location
</p>
<p>Fig. 9.2 Sample Heap
</p>
<p>Fig. 9.3 Heap Organization
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.2 Key Ideas 217
</p>
<p>of children and parents. The children of any element of the array can be calculated
</p>
<p>from the index of the parent.
</p>
<p>leftChildIndex = 2 &lowast; parentIndex + 1
</p>
<p>rightChildIndex = 2 &lowast; parentIndex + 2
</p>
<p>Using these formulae on Fig. 9.3 we can see that the children of the root node (i.e.
</p>
<p>index 0) are 98 (at index 1) and 85 (at index 2). Likewise, the children of 85 are
</p>
<p>located at index 5 and 6 which are the values 27 and 78, which we can verify are the
</p>
<p>same children as in the conceptual model.
</p>
<p>Of course, not every node has a child or even two children. If the computed
</p>
<p>leftChildIndex or rightChildIndex are greater than or equal to the number of values
</p>
<p>in the heap, then the node in question is a leaf node.
</p>
<p>It is also possible to go in the other direction. Given a child&rsquo;s index, we can
</p>
<p>discover where the parent is located.
</p>
<p>parentIndex = (childIndex &minus; 1)//2
</p>
<p>The // in the previous formula represents integer division. It means that the result is
</p>
<p>always an integer. If there were a fractional part we round down to the next lower
</p>
<p>integer. So, the index of the parent of the 34 in Fig. 9.3 is computed as
</p>
<p>parentIndex = (8&minus; 1)//2 = 3
</p>
<p>Consulting the conceptual model in Fig. 9.2, we see that the value at index 3 in the
</p>
<p>array, the 58, is indeed the parent of the 34. It should be noted that not every node in
</p>
<p>a heap has a parent. In particular, the root node, at index 0, does not have a parent.
</p>
<p>All other nodes in a heap have parents.
</p>
<p>9.3 Building a Heap
</p>
<p>Now that we&rsquo;ve seen what a heap looks like, we&rsquo;ll investigate building a heap. Heaps
</p>
<p>can be built either largest on top or smallest on top.We&rsquo;ll build a largest on top heap.A
</p>
<p>Heap classwill encapsulate the data andmethods needed to build a heap.Heapobjects
</p>
<p>contain a list and count of the number of items currently stored in the heap.We&rsquo;ll call
</p>
<p>this count the size of the heap. To encapsulate the data we&rsquo;ll want a method that will
</p>
<p>take a sequence of values andbuild a heap from it.We&rsquo;ll call thismethodbuildFrom. A
</p>
<p>privatemethodwill also be useful. ThebuildFrommethodwill call the_siftUpFrom to
</p>
<p>get each successive element of the sequence into its correct position within the heap.
</p>
<p>9.3.1 The buildFrom Method
</p>
<p>1 def buildFrom(self, aSequence):
</p>
<p>2         &rsquo;&rsquo;&rsquo;aSequence is an instance of a sequence collection which
</p>
<p>3         understands the comparison operators. The elements of
</p>
<p>4         aSequence are copied into the heap and ordered to build
</p>
<p>5         a heap. &rsquo;&rsquo;&rsquo;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>218 9 Heaps
</p>
<p>6 def __siftUpFrom(self, childIndex):
</p>
<p>7         &rsquo;&rsquo;&rsquo;childIndex is the index of a node in the heap. This method sifts
</p>
<p>8         that node up as far as necessary to ensure that the path to the root
</p>
<p>9         satisfies the heap condition. &rsquo;&rsquo;&rsquo;
</p>
<p>The sequence of values passed to the buildFrom method will be copied into the
</p>
<p>heap. Then, each subsequent value in the list will be sifted up into its final location
</p>
<p>in the heap. Consider the list of values [71, 15, 36, 57, 101]. We&rsquo;ll trace this through
</p>
<p>showing the resulting heap at each stage. To begin the list is copied into the heap
</p>
<p>object in the order given here. Then siftUpFrom is called on each subsequent element.
</p>
<p>To begin, siftUpFrom is called on the second element, the 57 in this case. Calling
</p>
<p>siftUpFrom on the root of the heap would have no effect. Normally, the parent index
</p>
<p>of the node is computed. The parent will already be greater than the other child (if
</p>
<p>there is one). If the value at the current child index is greater than the value at the
</p>
<p>parent index, then the two are swapped and the process repeats. This process repeats
</p>
<p>as many times as are necessary: either until the root node is reached (i.e. index 0 of
</p>
<p>the list) or until the new node is in the proper location to maintain the heap property.
</p>
<p>The first time some movement occurs is when 57 is added to the heap. The 57 is
</p>
<p>swapped with the 15 to arrive at its final location resulting in the heap in Fig. 9.4.
</p>
<p>The first four elements of the list now make up a heap. But, the 101 is not in its
</p>
<p>final position. We need to sift it up in the heap to get it to its final position. Looking
</p>
<p>at the conceptual view of the heap (i.e. the tree), you can see that 101 is a child of
</p>
<p>the node containing 57. Clearly, that violates the heap property. So, 101 and 57 are
</p>
<p>swapped to sift the 101 up as shown in Fig. 9.5.
</p>
<p>Without looking at the conceptual model you can still compute the parent of the
</p>
<p>node containing 101 in part one of Fig. 9.5. When 101 was at index 4 in the list, the
</p>
<p>parent index was computered as follows.
</p>
<p>parentIndex = (4&minus; 1)//2 = 1
</p>
<p>So, the 101 is compared to the 57 at index 1 in part one above. Then, the swap is
</p>
<p>made because 101 is greater than 57 in part two. However, the 101 is still not in the
</p>
<p>Fig. 9.4 Building a Heap Part One
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.3 Building a Heap 219
</p>
<p>Fig. 9.5 Building a Heap Part Two
</p>
<p>Fig. 9.6 Building a Heap Part Three
</p>
<p>right place.
</p>
<p>parentIndex = (1&minus; 1)//2 = 0
</p>
<p>We compare 101 with the 71 and swap the two elements. This is the last iteration
</p>
<p>of sifting up because 101 has now reached the root (i.e. index 0) of the heap. After
</p>
<p>swapping the two values we get the heap in Fig. 9.6.
</p>
<p>9.4 The Heapsort Algorithm Version 1
</p>
<p>Heaps have two basic operations. You can add a value to a heap. You can also delete,
</p>
<p>and retrieve, the maximum value from a heap if the heap is a largest on top heap.
</p>
<p>Using these two operations, or variations of them, we can devise a sorting algorithm
</p>
<p>by building a heap with a list of values and then removing the values one by one in
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>220 9 Heaps
</p>
<p>descending order. We&rsquo;ll call these two parts of the algorithm phase I and phase II.
</p>
<p>To implement phase I we&rsquo;ll need one new method in our Heap class.
</p>
<p>9.4.1 The addToHeap Method
</p>
<p>1 def addToHeap(self,newObject):
</p>
<p>2 &rsquo;&rsquo;&rsquo;If the heap is full, double its current capacity.
</p>
<p>3    Add the newObject to the heap, maintaining it as a
</p>
<p>4    heap of the same type.  Answer newObject.&rsquo;&rsquo;&rsquo;
</p>
<p>This newmethod can use the __siftUpFrom private method to get the new element
</p>
<p>to its final destination within the heap. Version 1 of Phase I calls addToHeap n times.
</p>
<p>This results in O(n log n) complexity. The specific steps of phase I include:
</p>
<p>1. double the capacity of the heap if necessary.
</p>
<p>2. data[size] = newObject
</p>
<p>3. __siftUpFrom(size)
</p>
<p>4. size + = 1.
</p>
<p>As you can see, __siftUpFrom will be called n times, once for each element of
</p>
<p>the heap. Each time __siftUpFrom is called, the heap will have grown by 1 element.
</p>
<p>Consider the heap in Fig. 9.7 just before pass #9.
</p>
<p>We are about to sift the 98 up to its rightful location within the heap. Conceptually
</p>
<p>we have the picture of the heap shown in Fig. 9.8.
</p>
<p>To move the 98 to the correct location we must compute the parent index from
</p>
<p>the child indices as shown in Table9.1.
</p>
<p>Fig. 9.7 Adding 98 to the Heap
</p>
<p>Fig. 9.8 Conceptual View While Adding 98 to the Heap
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.4 The Heapsort Algorithm Version 1 221
</p>
<p>Table 9.1 Child and Parent Indices
</p>
<p>childIndex parentIndex = (childIndex &minus; 1)//2
</p>
<p>8 3 (swap)
</p>
<p>3 1 (swap)
</p>
<p>1 0 (stop)
</p>
<p>Fig. 9.9 Heap After Moving 98 to Correct Location
</p>
<p>Sifting up the 98 in the heap&rsquo;s list results in two swaps before it reaches its final
</p>
<p>location. Figure9.9 shows the 98 is swappedwith the 34 at index 3. Then it is swapped
</p>
<p>again with the 58 at index 1. At this point no more swaps are done because 101 is
</p>
<p>greater than 98. The 98 has reached its proper position within the heap.
</p>
<p>9.5 Analysis of Version 1 Phase I
</p>
<p>The approach taken in version 1 of phase I is slow as we shall see. Consider a perfect
</p>
<p>complete binary tree. One which is completely full on all levels with h levels as
</p>
<p>shown in Fig. 9.10.
</p>
<p>Consider the relationship between the number of levels and the number of items
</p>
<p>in the heap as shown in Table9.2.
</p>
<p>Fig. 9.10 A Perfect Binary Tree
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>222 9 Heaps
</p>
<p>Table 9.2 Heap levels versus Heap size
</p>
<p>Level # of nodes at level
</p>
<p>1 (21&minus;1 = 1)
</p>
<p>2 (22&minus;1 = 2)
</p>
<p>3 (23&minus;1 = 4)
</p>
<p>... ...
</p>
<p>h (2h&minus;1)
</p>
<p>For a heap with n items in it, the value of n can be computed by adding up all the
</p>
<p>nodes at each level in the heap&rsquo;s tree. To simplify our argument we&rsquo;ll assume that
</p>
<p>the heap is a full binary tree.
</p>
<p>n = 1+ 21 + 22 + &middot; &middot; &middot; + 2h&minus;1for some h
</p>
<p>This is the sum of a geometric sequence. The sum of a geometric sequence can be
</p>
<p>computed as follows.
</p>
<p>1+ r + r2 + r3 + &middot; &middot; &middot; + rm =
rm+1 &minus; 1
</p>
<p>r &minus; 1
if r ï¿½= 1
</p>
<p>Applying this formula to our equation above the number of nodes in a complete
</p>
<p>binary tree (i.e. a full binary heap) with h levels is given by this formula below.
</p>
<p>n = 1+ 21 + 22 + &middot; &middot; &middot; + 2h&minus;1 =
2h &minus; 1
</p>
<p>2&minus; 1
= 2h &minus; 1
</p>
<p>This implies that n + 1 = 2h. We can solve this equation for h. Doing so we get
</p>
<p>h = &lceil;log2(n + 1)&rceil;
</p>
<p>The brackets above are the ceiling operator and it simplymeans that we should round
</p>
<p>up to the next highest integer. Rounding up takes into account that not every heap
</p>
<p>tree is completely full so there may be some values of n that won&rsquo;t give us an integer
</p>
<p>for h if we didn&rsquo;t round up. The following inequality will be useful in determining
</p>
<p>the computational complexity of phase I of the heapsort algorithm.
</p>
<p>log2 I &le; &lceil;log2(I + 1)&rceil; &le; log2 I + 1 &forall;I &ge; 2
</p>
<p>So far we have been able to determine that the height of a complete binary tree (i.e.
</p>
<p>the number of levels) is equivalent to the ceiling of the log, base 2, of the number of
</p>
<p>elements in the tree +1. Phase I of our algorithm appends each value to the end of
</p>
<p>the list where it is sifted up to its final location within the heap. Since sifting up will
</p>
<p>go through at most h levels and since the heap grows by one each time, the following
</p>
<p>summation describes an upper limit of a value that is proportional to the amount of
</p>
<p>work that must be done in Phase I.
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>&lceil;log2(I + 1)&rceil;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.5 Analysis of Version 1 Phase I 223
</p>
<p>But applying the inequality presented above we have the following. The N&minus; 1 term
</p>
<p>comes from the last summation from 2 to N. From the inequality above there are
</p>
<p>N &minus; 1 ones that are a part of the summation. These can be factored out as N &minus; 1.
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>log2 I &le;
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>&lceil;log2(I + 1)&rceil; &le;
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>(log2 I + 1) = (
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>log2 I)+ (N &minus; 1)
</p>
<p>We now have a lower and upper bound for our sum. The same summation appears in
</p>
<p>both the lower and upper bound. But what does
&sum;N
</p>
<p>I=2 log2 I equal? The following
</p>
<p>equivalences will help in determining this summation.
</p>
<p>y = log2 x &hArr; 2
y = x &hArr; y ln 2 = ln x &hArr; log2 x = y =
</p>
<p>1
</p>
<p>ln 2
ln x
</p>
<p>To determine what the summation above is equal to we can establish a couple of
</p>
<p>inequalities that bound the sum from above and below. In Fig. 9.11, the summation
</p>
<p>can be visualized as the green area. The first term in the summation would provide
</p>
<p>the first green rectangle, the second green rectangle corresponds to the second term
</p>
<p>in the summation and so on. The black line in the figure is the plot of the log base 2
</p>
<p>of x. Clearly the area covered by the green rectangles is bigger than the area under
</p>
<p>Fig. 9.11 Plot of log(n)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>224 9 Heaps
</p>
<p>the curve of the log. The area under the curve can be found by taking the definite
</p>
<p>integral from 1 to N, which in the picture is 9 but in general would be N. From this
</p>
<p>we get the following inequality.
</p>
<p>N
&int;
</p>
<p>1
</p>
<p>log2 x dx &le;
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>log2 I
</p>
<p>Now, consider shifting the entire green area to the right by one. In the figure above,
</p>
<p>that&rsquo;s the orange area. The orange and green areas are exactly the same size. The
</p>
<p>orange is just shifted right by one. Now look at the plot of the log base 2 of x.
</p>
<p>The area below the curve is now clearly bigger than the orange area. If we imag-
</p>
<p>ine this graph going out to N, then we&rsquo;ll have to include N+1 in our definite
</p>
<p>integral (since we shifted the orange area to the right). So we get the following
</p>
<p>inequality.
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>log2 I &le;
</p>
<p>N+1
&int;
</p>
<p>2
</p>
<p>log2 x dx
</p>
<p>Putting the two inequalities together we have a lower and upper bound for our
</p>
<p>summation.
N
</p>
<p>&int;
</p>
<p>1
</p>
<p>log2 x dx &le;
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>log2 I &le;
</p>
<p>N+1
&int;
</p>
<p>2
</p>
<p>log2 x dx
</p>
<p>It is easier to integrate using natural log so we&rsquo;ll rewrite the integral as fol-
</p>
<p>lows.
N
</p>
<p>&int;
</p>
<p>1
</p>
<p>log2 x dx =
</p>
<p>N
&int;
</p>
<p>1
</p>
<p>1
</p>
<p>ln 2
ln x dx
</p>
<p>The constant term in the integral can be factored out. So we&rsquo;ll look at the following
</p>
<p>integral.
N
</p>
<p>&int;
</p>
<p>1
</p>
<p>ln x dx
</p>
<p>We can find the result of the definite integral that appears above by doing integration
</p>
<p>by parts. The integration by parts rule is as follows.
</p>
<p>b
&int;
</p>
<p>a
</p>
<p>u dv = uv
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>b
</p>
<p>a
&minus;
</p>
<p>b
&int;
</p>
<p>a
</p>
<p>v du
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.5 Analysis of Version 1 Phase I 225
</p>
<p>Applying this to our integral we have the following
</p>
<p>u = ln x and dv = dx
</p>
<p>du =
1
</p>
<p>x
dx and v = x
</p>
<p>&rArr;
</p>
<p>N
&int;
</p>
<p>1
</p>
<p>ln x dx = x ln x
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>N
</p>
<p>1
&minus;
</p>
<p>N
&int;
</p>
<p>1
</p>
<p>x
1
</p>
<p>x
dx
</p>
<p>= x ln x
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>N
</p>
<p>1
&minus;
</p>
<p>N
&int;
</p>
<p>1
</p>
<p>1dx = x ln x
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>N
</p>
<p>1
&minus;x
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>âˆ£
</p>
<p>N
</p>
<p>1
</p>
<p>= N ln N &minus; (N &minus; 1)
</p>
<p>We have proved that the lower bound is proportional to N log N. Similarly, we could
</p>
<p>prove that the upper bound is also proportional to N log N. Therefore the work
</p>
<p>done by inserting N elements into a heap using the __siftUpFrom method is Î¸ (N log
</p>
<p>N). We can do better! If the values in the heap were in the correct order we could
</p>
<p>achieveO(N) complexity. Using a different approach wewill be able to achieveO(N)
</p>
<p>complexity in all cases.
</p>
<p>9.6 Phase II
</p>
<p>Later, we will investigate how to improve the performance of phase I. Recall that
</p>
<p>phase I of the heapsort algorithm builds a heap from a list of values. Phase II takes
</p>
<p>the elements out of the heap, one at a time, and places them in a list. To save space,
</p>
<p>the same list that was used for the heap may be used for the list of values to be
</p>
<p>returned. Each pass of phase II takes one item from the list and places it where it
</p>
<p>belongs and the size of the heap is decremented by one. The key operation is the
</p>
<p>__siftDownFromTo method (Fig. 9.12).
</p>
<p>9.6.1 The siftDownFromTo Method
</p>
<p>1 def __siftDownFromTo(self, fromIndex, lastIndex):
</p>
<p>2         &rsquo;&rsquo;&rsquo;fromIndex is the index of an element in the heap.
</p>
<p>3         Pre: data[fromIndex..lastIndex] satisfies the heap condition,
</p>
<p>4         except perhaps for the element data[fromIndex].
</p>
<p>5         Post:  That element is sifted down as far as neccessary to
</p>
<p>6         maintain the heap structure for data[fromIndex..lastIndex].&rsquo;&rsquo;&rsquo;
</p>
<p>To illustrate this method, let&rsquo;s take our small heap example and start extracting
</p>
<p>the values from it. Consider the heap in Fig. 9.13 where both the conceptual view
</p>
<p>and the organization of that heap are shown. 101 is at the top of the heap and is also
</p>
<p>the largest value.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>226 9 Heaps
</p>
<p>Fig. 9.12 Just Before Phase II
</p>
<p>Fig. 9.13 After Swapping First and Last Values
</p>
<p>If sorted, the 101 would go at the end of the list. Since there are 5 elements in
</p>
<p>the heap, we&rsquo;ll swap the 57 and the 101. By doing this, 101 is at its final position
</p>
<p>within a sorted list. The 57 is not in the correct location within the heap. So, we call
</p>
<p>the __siftDownFromTo method to sift the 57 down from the 0 position within the
</p>
<p>heap to at most the size-1 location.
</p>
<p>The __siftDownFromTo method does its work and swaps the 57 with the bigger
</p>
<p>of the two children, the 71. The 57 does not need to sift down any further since it is
</p>
<p>bigger than the 15. So we have the view of the heap in Fig. 9.14 after the first pass
</p>
<p>of Phase II.
</p>
<p>The second pass of Phase II swaps the 15 and the 71, moving the 71 to its final
</p>
<p>location in the sorted list. It then sifts the 15 down to its rightful location within the
</p>
<p>heap, producing the picture you see in Fig. 9.15.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.6 Phase II 227
</p>
<p>Fig. 9.14 After the First Pass of Phase II
</p>
<p>Fig. 9.15 After the Second Pass of Phase II
</p>
<p>During the third pass of Phase II the 57 is put in its final location and swappedwith
</p>
<p>the 36 to make room for it. Although __siftDownFromTo is called, no movement of
</p>
<p>values within the heap occurs because the 36 is at the top and is the largest value in
</p>
<p>the heap (Fig. 9.16).
</p>
<p>During the fourth and final pass, the 36 is swapped with the 15. No call to _sift-
</p>
<p>DownFromTo is necessary this time since the heap is only of size 1 after the swap.
</p>
<p>Since a heap of size 1 is already sorted and in the right place, we can decrement the
</p>
<p>size to 0. The list is now sorted in place without using an additional array as shown
</p>
<p>in Fig. 9.17.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>228 9 Heaps
</p>
<p>Fig. 9.16 After the Third Pass of Phase II
</p>
<p>Fig. 9.17 After the Fourth and Final Pass of Phase II
</p>
<p>9.7 Analysis of Phase II
</p>
<p>The work of Phase II is in the calls to the __siftDownFromTo method which is called
</p>
<p>N&minus;1 times. Each call must sift down an element in a tree that shrinks by one element
</p>
<p>each time. Earlier in this chapter we did the analysis to determine that the amount of
</p>
<p>work in the average and worst case is proportional to
</p>
<p>N
&sum;
</p>
<p>I=2
</p>
<p>&lceil;log2(I + 1)&rceil; &equiv; Î¸(NlogN)
</p>
<p>The best case of Phase II would require that all values in the heap are identical. In
</p>
<p>that case the computational complexity would be O(N) since the values would never
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.7 Analysis of Phase II 229
</p>
<p>sift down. This best case scenario brings up a good point. If we could limit how far
</p>
<p>down the value is sifted, we might be able to speed up Phase I. That&rsquo;s the topic or
</p>
<p>our next section.
</p>
<p>9.8 The Heapsort Algorithm Version 2
</p>
<p>In version one, the heapsort algorithm attained O(N log N) complexity during Phase
</p>
<p>I and Phase II. In version two, we will be able to speed up Phase I of the heapsort
</p>
<p>algorithm up to O(N) complexity. We do this by limiting how far each newly inserted
</p>
<p>value must be sifted down. The idea is pretty simple, but yet a powerful technique.
</p>
<p>Rather than inserting each element at the top of the heap, we&rsquo;ll build the heap, or
</p>
<p>heaps, from the bottomup. Thismeans thatwe&rsquo;ll approach the building of our heap by
</p>
<p>starting at the end of the list rather than the beginning. An examplewill helpmake this
</p>
<p>more clear. Consider the list of values in Fig. 9.18 that we wish to sort using heapsort.
</p>
<p>Rather than starting from the first element of the list, we&rsquo;ll start from the other
</p>
<p>end of the list. There is no need to start with the last element as we will see. We
</p>
<p>need to pick a node that is a parent of some node in the tree. Since the final heap is
</p>
<p>a binary heap, the property we have is that half the nodes of the tree are leaf nodes
</p>
<p>and cannot be parents of any node within the heap. We can compute the first parent
</p>
<p>index as follows.
</p>
<p>parentIndex = (size &minus; 2)//2
</p>
<p>The size above is the size of the list to be sorted. Note that because the list has
</p>
<p>indices 0 to size-1 we must subtract two to compute the proper parentIndex in all
</p>
<p>cases. In this case, that parentIndex is 2. We need to start with index 2 in the list to
</p>
<p>start building our heaps from the bottom up. Index 2 will be the first parent and we&rsquo;ll
</p>
<p>sift it down as far as necessary.
</p>
<p>Fig. 9.18 A List to be Heapsorted
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>230 9 Heaps
</p>
<p>childIndex1 = 2 &lowast; parentIndex + 1 = 2 &lowast; 2+ 1 = 5
</p>
<p>childIndex2 = 2 &lowast; parentIndex + 2 = 2 &lowast; 2+ 2 = 6
</p>
<p>Since the second of these indices is beyond the last index of the list, the __siftDown-
</p>
<p>FromTo method will not consider childIndex2. After considering the 20 and the 23
</p>
<p>we see that those two nodes do in fact form a heap as shown in Fig. 9.19. We will
</p>
<p>show this in the following figures by joining them with an arrow. We now have 5
</p>
<p>heaps, one less than we started with. More importantly, we only had to sift the parent
</p>
<p>down one position at the most.
</p>
<p>Next, we move back one more in the list to index 1. We call __siftDownFromTo
</p>
<p>specifying to start from this node. Doing so causes the sift down method to pick the
</p>
<p>larger of the two children to swap with, forming a heap out of the three values &minus;34,
</p>
<p>46, and 24 as a result. This is depicted in Fig. 9.20.
</p>
<p>Fig. 9.19 After Forming a Sub-Heap
</p>
<p>Fig. 9.20 After Forming a Second Sub-Heap
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.8 The Heapsort Algorithm Version 2 231
</p>
<p>Finally, we move backward in the list one more element to index 0. This time
</p>
<p>we only need to look at the values of the two children because they will already be
</p>
<p>the largest values in their respective heaps. Calling __siftDownFromTo on the first
</p>
<p>element of the list will pick the maximum value from 15, 46, and 23 and will swap
</p>
<p>the 15 with that value resulting in the situation in Fig. 9.21.
</p>
<p>This doesn&rsquo;t form a complete heap yet. We still need to move the 15 down again
</p>
<p>and __siftDownFromTo takes care of moving the 15 to the bottom of the heap as
</p>
<p>shown in Fig. 9.22.
</p>
<p>Fig. 9.21 Sifting the 15 Down
</p>
<p>Fig. 9.22 The Final Heap using Version 2 of Phase I
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>232 9 Heaps
</p>
<p>9.9 Analysis of Heapsort Version 2
</p>
<p>Recall that Phase II is when the values are in a heap and extracted one at a time
</p>
<p>to form the sorted list. Version 2 Phase II of the heapsort algorithm is identical to
</p>
<p>version 1 and has the same complexity, O(N log N).
</p>
<p>Version 2 Phase I on the other hand has changed from a top down approach to
</p>
<p>building the heap in version 1 to building the heap from the bottom up in version 2.
</p>
<p>We claimed that the complexity of this new phase I is O(N) where N is the number
</p>
<p>of nodes in the list. Stated more formally we have this claim. For a perfect binary
</p>
<p>tree of height h, containing (2h&minus;1) nodes, the sums of the lengths of its maximum
</p>
<p>comparison paths is (2h &minus; 1&minus;h).
</p>
<p>Consider binary heaps of heights 1, 2, etc. up to height h. From the example for
</p>
<p>version 2 of the algorithm it should be clear the maximum path length for any call
</p>
<p>to __siftDownFromTo will be determined as shown in Table9.3).
</p>
<p>Notice that (2h&minus;1) represents half the nodes in the final heap (the leaf nodes)
</p>
<p>and that the max path length for half the nodes in the heap will be 0. It is this
</p>
<p>observation that leads to a more efficient algorithm for building a heap from the
</p>
<p>bottom up. If we could add up all these maximum path lengths, then we would have
</p>
<p>an upper bound for the amount of work to be done during phase I of version 2 of this
</p>
<p>algorithm.
</p>
<p>S = 1 &lowast; (h &minus; 1)+ 2 &lowast; (h &minus; 2)+ 22 &lowast; (h &minus; 3)+ &middot; &middot; &middot; + 2h&minus;3 &lowast; 2+ 2h&minus;2 &lowast; 1
</p>
<p>The value S would be an upper bound of the work to be done, the sum of the max-
</p>
<p>imum path lengths. We can eliminate most of the terms in this sum with a little
</p>
<p>manipulation of the formula. The value of S could be computed as 2S &minus; S = S.
</p>
<p>Using this formula we can write it as
</p>
<p>S = 2 &lowast; S &minus; S = 2 &lowast; (h &minus; 1)+ 22 &lowast; (h &minus; 2)+ &middot; &middot; &middot; + 2h&minus;2 &lowast; 2+ 2h&minus;1 &lowast; 1
</p>
<p>&minus; [(h &minus; 1)+ 2 &lowast; (h &minus; 2)+ 22 &lowast; (h &minus; 3)+ &middot; &middot; &middot; + 2h&minus;2 &lowast; 1]
</p>
<p>If we line up the terms in the equation above (as they are lined up right now), we can
</p>
<p>subtract like terms. In the first like term we see h &minus; 1 &minus; (h &minus; 2). This simplifies to
</p>
<p>Table 9.3 Maximum path length for __siftDownFromTo
</p>
<p>Level Max path length # of nodes at level
</p>
<p>1 h &minus; 1 1
</p>
<p>2 h &minus; 2 2
</p>
<p>3 h &minus; 3 4
</p>
<p>... ... ...
</p>
<p>h &minus; 2 2 2h&minus;3
</p>
<p>h &minus; 1 1 2h&minus;2
</p>
<p>h 0 2h&minus;1
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.9 Analysis of Heapsort Version 2 233
</p>
<p>Fig. 9.23 A Binary Heap of Height 4
</p>
<p>h &minus; h &minus; 1 + 2 = 1. Similarly, the other like terms simplify so we end up with the
</p>
<p>following formula for S.
</p>
<p>S = 2 &lowast; S &minus; S = 2+ 22 + &middot; &middot; &middot; + 2h&minus;2 + 2h&minus;1 &minus; (h &minus; 1)
</p>
<p>= 1+ 2+ 22 + &middot; &middot; &middot; + 2h&minus;2 + 2h&minus;1 &minus; h
</p>
<p>= 2h &minus; 1&minus; h &equiv; O(N) where N = 2h &minus; 1 nodes.
</p>
<p>In the last step of the simplification above we have the sum of the first h&minus;1 powers
</p>
<p>of 2, also known as the sum of a geometric sequence. This sum is equal to 2 raised to
</p>
<p>the h power, minus one. This can be proven with a simple proof by induction. So, we
</p>
<p>have just proved that version 2 of phase I is O(N). Phase II is still O(N log N) so the
</p>
<p>overall complexity of heap sort is O(N logN).
</p>
<p>Consider a binary heap of height 4 (Fig. 9.23).
</p>
<p>In such a heap, using the sift down method the first sifting occurs at height 2 in
</p>
<p>the tree where we have four nodes that may travel down one level in the tree. At
</p>
<p>height 3 we have two nodes that may travel down two levels. Finally, the root
</p>
<p>node may travel down three levels. We have the following sum of maximum path
</p>
<p>lengths.
</p>
<p>1+ 1+ 1+ 1+ 2+ 2+ 3 =
</p>
<p>11 =
</p>
<p>24 &minus; 1&minus; 4 =
</p>
<p>2h &minus; 1&minus; h
</p>
<p>9.10 Comparison to Other Sorting Algorithms
</p>
<p>The heapsort algorithm operates in O(N logN) time, the same complexity as the
</p>
<p>quicksort algorithm. A key difference is in the movement of individual values. In
</p>
<p>quicksort, values are always moved toward their final location. Heapsort moves
</p>
<p>values first to form a heap, then moves them again to arrive at their final location
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>234 9 Heaps
</p>
<p>Fig. 9.24 Comparison of Several Sorting Algorithms
</p>
<p>within a sorted list. Quicksort is more efficient than heapsort even though they have
</p>
<p>the same computational complexity.
</p>
<p>Examining Fig. 9.24we see selection sort operatingwith Î¸ (N2) complexity, which
</p>
<p>is not acceptable except for very short lists. The quicksort algorithm behaves more
</p>
<p>favorably than the heapsort algorithm as is expected. The built-in sort, which is
</p>
<p>quicksort implemented in C, runs the fastest, due to being implemented in C.
</p>
<p>9.11 Chapter Summary
</p>
<p>This chapter introduced heaps and the heapsort algorithm. Building a heap can be
</p>
<p>done efficiently in O(N) time complexity. A heap guarantees the top element will
</p>
<p>be either the biggest or smallest element of an ordered collection of values. Using
</p>
<p>this principle we can implement many algorithms and datatypes using heaps. The
</p>
<p>heapsort algorithm was presented in this chapter as one example of a use for heaps.
</p>
<p>Heaps are not good for looking up values. Looking up a value in a heap would
</p>
<p>take O(N) time and would be no better than linear search of a list for a value. This is
</p>
<p>because there is no ordering of the elements within a heap except that the largest (or
</p>
<p>smallest) value is on top. You cannot determine where in a heap a value is located
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>9.11 Chapter Summary 235
</p>
<p>without searching the entire heap, unless it happens to be equal or greater to the
</p>
<p>largest value and you have a largest on top heap. Likewise, if you have a smallest on
</p>
<p>top heap and are looking for a value, you would have to look at all values unless the
</p>
<p>value you are searching for is equal or smaller than the smallest value.
</p>
<p>Commonly, heaps are used to implement priority queues where the elements of
</p>
<p>a queue are ordered according to some kind of priority value. An element can be
</p>
<p>added to an existing heap in O(log N) time. An element can be removed from a
</p>
<p>heap in O(log N) time as well. This makes a heap the logical choice for a priority
</p>
<p>queue implementation. Priority queues are useful in message passing frameworks
</p>
<p>and especially in some graph algorithms and heuristic search algorithms.
</p>
<p>9.12 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. State the heap property for a largest on top heap.
</p>
<p>2. When removing a value from a heap, which value are you likely to remove?
</p>
<p>Why?
</p>
<p>3. After removing a value from a heap, what steps do you have to take to ensure
</p>
<p>you still have a heap?
</p>
<p>4. If you had a heap of height 6, what would be the total maximum travel distance
</p>
<p>for all nodes in the heap as you built it using version 2, phase I of the heapsort
</p>
<p>algorithm.
</p>
<p>5. Use __siftUpFrom() from version 1 of the heapsort algorithm, adding a new
</p>
<p>element to a growing heap on each pass to construct a largest-on-top heap from
</p>
<p>the following integers:
</p>
<p>70, 30, 25, 90, 15, 85, 35, 87, 100
</p>
<p>Sketch a new picture of the binary heap each time the structure changes.
</p>
<p>6. Use __siftDownFromTo() from version 2 of the heapsort algorithm on the same
</p>
<p>data as in the previous problem, sketching a new picture of the binary tree each
</p>
<p>time the structure changes.
</p>
<p>7. Using the final heap from problem 6, execute phase II version 2 of the heapsort
</p>
<p>algorithm, using __siftDownFromTo to sort the data in increasing order. Sketch
</p>
<p>a new picture of the binary tree each time the structure changes.
</p>
<p>8. Redo problems 6 and 7, this time showing the data in arrays (i.e. lists) with
</p>
<p>starting index 0, rather than drawing the tree structures. Show the new values of
</p>
<p>the structure after each pass. Use the following data:
</p>
<p>37, 45, 91, 5, 57, 74, 83, 45, 99
</p>
<p>9. Why does heapsort operate less efficiently than quicksort?
</p>
<p>10. When is a heap commonly used?
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>236 9 Heaps
</p>
<p>9.13 Programming Problems
</p>
<p>1. Implement version 2 of the heapsort algorithm. Run your own tests using heapsort
</p>
<p>and quicksort to compare the execution time of the two sorting algorithms. Output
</p>
<p>your data in the plot format and plot your data using the PlotData.py program
</p>
<p>provided on the text website.
</p>
<p>2. Implement version 1 and version 2 of the program and compare the execution
</p>
<p>times of the two heapsort variations. Gather experimental data in the XML format
</p>
<p>accepted by the PlotData.py program and plot that data to see the difference
</p>
<p>between using version 1 and version 2 of the heap sort algorithm.
</p>
<p>3. Implement a smallest on top heap and use it in implementing a priority queue. A
</p>
<p>priority queue has enqueue and dequeue methods. When enqueueing an item on
</p>
<p>a priority queue, a priority is provided. Elements enqueued on the queue include
</p>
<p>both the data item and the priority.Write a test program to test your priority queue
</p>
<p>data structure.
</p>
<p>4. Use the priority queue from the last exercise to implement Dijkstra&rsquo;s algorithm
</p>
<p>from Chap.7. The priority queue implementation of Dijkstra&rsquo;s algorithm is more
</p>
<p>efficient. The priority of each element is the cost so far of each vertex added
</p>
<p>to the priority queue. By dequeueing from the priority queue we automatically
</p>
<p>get the next lowest cost vertex from the queue without searching, resulting in a
</p>
<p>O(|V |log|V |) complexity instead of O(|V |2).
</p>
<p>5. Use the heapsort algorithm, either version 1 or version 2, to implement Kruskal&rsquo;s
</p>
<p>algorithm from Chap.7. Use one of the sample graph XML files found on the text
</p>
<p>website as your input data to test your program.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
</div>
<div class="page"><p/>
<p>10Balanced Binary Search Trees
</p>
<p>In Chap. 6 binary search trees were defined along with a recursive insert algorithm.
</p>
<p>The discussion of binary search trees pointed out they have problems in some cases.
</p>
<p>Binary search trees can become unbalanced, actually quite often. When a tree is
</p>
<p>unbalanced the complexity of insert, delete, and lookup operations can get as bad
</p>
<p>as ï¿½(n). This problem with unbalanced binary search trees was the motivation for
</p>
<p>the development of height-balanced AVL trees by G.M. Adelson-Velskii and E.M.
</p>
<p>Landis, two Soviet computer scientists, in 1962. AVL trees were named for these two
</p>
<p>inventors. Their paper on AVL trees [1] described the first algorithm for maintaining
</p>
<p>balanced binary search trees.
</p>
<p>Balanced binary search trees provide ï¿½(log n) insert, delete, and lookup opera-
</p>
<p>tions. In addition, a balanced binary search tree maintains its items in sorted order.
</p>
<p>An infix traversal of a binary search tree will yield its items in ascending order
</p>
<p>and this traversal can be accomplished in ï¿½(n) time assuming the tree is already
</p>
<p>built.
</p>
<p>The HashSet and HashMap classes provide very efficient insert, delete, and lookup
</p>
<p>operations as well, more efficient than the corresponding binary search tree opera-
</p>
<p>tions. Heaps also provide ï¿½(log n) insert and delete operations. But neither hash
</p>
<p>tables nor heaps maintain their elements as an ordered sequence. If you want to
</p>
<p>perform many insert and delete operations and need to iterate over a sequence in
</p>
<p>ascending or descending order, perhaps many times, then a balanced binary search
</p>
<p>tree data structure may be more appropriate.
</p>
<p>10.1 Chapter Goals
</p>
<p>This chapter describes why binary search trees can become unbalanced. Then it goes
</p>
<p>on to describe several implementations of two types of height-balanced trees, AVL
</p>
<p>trees and splay trees. By the end of this chapter you should be able to implement your
</p>
<p>own AVL or splay tree datatype, with either iteratively or recursively implemented
</p>
<p>operations.
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_10
</p>
<p>237
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>238 10 Balanced Binary Search Trees
</p>
<p>10.2 Binary Search Trees
</p>
<p>A binary search tree comes in handy when a large number of insert, delete, and lookup
</p>
<p>operations are required by an application while at times it is necessary to traverse
</p>
<p>the items in ascending or descending order. Consider a website like Wikipedia that
</p>
<p>provides access to a large set of online materials. Imagine the designers of the website
</p>
<p>want to keep a log of all the users that have accessed the website within the last hour.
</p>
<p>The website might operate as follows.
</p>
<p>&bull; Each visitor accesses the website with a unique cookie.
</p>
<p>&bull; When a visitor accesses the site their cookie along with a date and time is recorded
</p>
<p>in a log on the site&rsquo;s server.
</p>
<p>&bull; If they have accessed the site within the last two hours their cookie and access time
</p>
<p>may already be recorded. In that case, their last access date and time is updated.
</p>
<p>&bull; Every hour a snapshot is generated as to who is currently accessing the site.
</p>
<p>&bull; The snapshot is to be generated in ascending order of the unique cookie numbers.
</p>
<p>&bull; After a patron has been inactive for at least an hour, according to the snapshot,
</p>
<p>their information is deleted from the record of website activity log.
</p>
<p>Since the site is quite large with thousands, if not tens of thousands or more,
</p>
<p>people accessing it every hour, the data structure to hold this information must be
</p>
<p>fast. It must be fast to insert, lookup, and delete entries. It must also be quick to take
</p>
<p>snapshot since the website will hold up all requests while the snapshot is taken.
</p>
<p>If the number of users that come and go during an hour on a site like Wikipedia is
</p>
<p>typically higher than the number that stay around for long periods of time, if may be
</p>
<p>most efficient to rebuild the tree from the activity log rather than delete each entry
</p>
<p>after it has been inactive for at least an hour. This would be true if the number of
</p>
<p>people still active on the site is much smaller than the number of inactive entries in
</p>
<p>the snapshot of the log. In this case, rebuilding the log after deleting inactive patrons
</p>
<p>must be fast as well.
</p>
<p>A binary search tree is a logical choice for the organization of this log if we could
</p>
<p>guaranteeï¿½(log n) lookup, insert, and delete along withï¿½(n) time to take a snapshot.
</p>
<p>However, a binary search tree has one big problem. Recall that as the snapshot is
</p>
<p>taken the log may be rebuilt with only the recently active users and furthermore the
</p>
<p>cookies will be accessed in ascending order while rebuilding the log.
</p>
<p>Consider the insert operation on binary search trees shown in Sect. 10.2.1. When
</p>
<p>the binary search tree is rebuilt the items to insert into the new tree will be added in
</p>
<p>ascending order. The result is an unbalanced tree.
</p>
<p>10.2.1 Binary Search Tree Insert
</p>
<p>1 def __insert(root,val):
</p>
<p>2     if root == None:
</p>
<p>3         return BinarySearchTree.__Node(val)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.2 Binary Search Trees 239
</p>
<p>4     if val &lt; root.getVal():
</p>
<p>5         root.setLeft(BinarySearchTree.__insert(root.getLeft(),val))
</p>
<p>6     else:
</p>
<p>7         root.setRight(BinarySearchTree.__insert(root.getRight(),val))
</p>
<p>8     return root
</p>
<p>If items are inserted into a binary search tree in ascending order the effect is that
</p>
<p>execution always progresses from line 2 to 4, 6, 7 and 8. The result on line 7 puts
</p>
<p>the new value in the right most location of the binary search tree, since it is the
</p>
<p>largest value inserted so far. The resulting tree is a stick extending down and to the
</p>
<p>right. Without any balance to the tree, inserting the next bigger value will result in
</p>
<p>traversing each and every value that has already been inserted to find the location
</p>
<p>of the new value. This means that the first value takes zero comparisons to insert,
</p>
<p>while the second requires one comparison to find its final location, the third value
</p>
<p>requires two comparisons, and so on. The total number of comparisons to build the
</p>
<p>tree is ï¿½(n2) as proved in Chap. 2. This complexity will be much too slow for any
</p>
<p>site getting a reasonable amount of activity in an hour. In addition, when the height
</p>
<p>of the binary search tree is n, where n is the number of values in the tree, the look
</p>
<p>up, insert, and delete times are ï¿½(n) for both the worst and average cases. When the
</p>
<p>tree is a stick or even close to being a stick the efficiency characteristics of a binary
</p>
<p>search tree are no better than that of a linked list.
</p>
<p>10.3 AVL Trees
</p>
<p>A binary search tree that stays balanced would provide everything that is required
</p>
<p>by the website log described in the last section. AVL trees are binary search trees
</p>
<p>with additional information to maintain their balance. The height of an AVL tree is
</p>
<p>guaranteed to be ï¿½(log n) thus guaranteeing that lookup, insert, and delete opera-
</p>
<p>tions will all complete in ï¿½(log n) time. With these guarantees, an AVL tree can
</p>
<p>be built in ï¿½(n log n) time from a sequence of n items. Moreover, AVL trees, like
</p>
<p>binary search trees, can be traversed using an inorder traversal, yielding their items
</p>
<p>in ascending order in ï¿½(n) time.
</p>
<p>10.3.1 Definitions
</p>
<p>To understand how AVL trees work, a few definitions are in order.
</p>
<p>Height(Tree): The height of a tree is one plus the maximum height of its subtrees.
</p>
<p>The height of a leaf node is one.
</p>
<p>Balance(Tree): The balance of a node in a binary tree is height(right subtree)&mdash;
</p>
<p>height(left subtree).
</p>
<p>AVL Tree: An AVL tree is a binary tree in which the balance of every node in the tree
</p>
<p>is &minus;1, 0 or 1.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>240 10 Balanced Binary Search Trees
</p>
<p>10.3.2 Implementation Alternatives
</p>
<p>Looking back at Chap. 6 and the implementation of binary search trees, inserting a
</p>
<p>value into a tree can be written recursively. Inserting into an AVL tree can also be
</p>
<p>implemented recursively. It is also possible to implement inserting a value into an
</p>
<p>AVL tree iteratively, using a loop and a stack. This chapter explores both alternatives.
</p>
<p>Additionally, the balance of an AVL tree can be maintained using either the height
</p>
<p>of each node in the tree or the balance of each node in the tree. Implementations of
</p>
<p>AVL tree nodes store either their balance or their height. As values are inserted into
</p>
<p>the tree, the balance or height values of affected nodes are updated to reflect the
</p>
<p>addition of the new item in the tree.
</p>
<p>10.3.3 AVLNode with Stored Balance
</p>
<p>1 class AVLTree:
</p>
<p>2     class AVLNode:
</p>
<p>3         def __init__(self,item,balance=0,left=None,right=None):
</p>
<p>4             self.item = item
</p>
<p>5             self.left = left
</p>
<p>6             self.right = right
</p>
<p>7             self.balance = balance
</p>
<p>8
</p>
<p>9         def __repr__(self):
</p>
<p>10             return "AVLTree.AVLNode("+repr(self.item)+",balance="+
</p>
<p>11                    repr(self.balance)+",left="+repr(self.left)+
</p>
<p>12                    ",right="+repr(self.right)+")"
</p>
<p>Whether implementing insert recursively or iteratively, the Node class of Chap. 6
</p>
<p>must be extended slightly to accommodate either the balance or the height of the node.
</p>
<p>Consider the code fragment in Sect. 10.3.3. The first implementation of AVLTree that
</p>
<p>we&rsquo;ll explore is a balance storing iterative version of the algorithm. Notice that the
</p>
<p>AVLNode implementation is buried inside the AVLTree class to hide it from users of
</p>
<p>the AVLTree class. While Python does not actually prevent access to the AVLNode
</p>
<p>class from outside the AVLTree class, by convention users of the AVLTree data
</p>
<p>structure should know to leave the internals of the tree alone. AVL trees are created
</p>
<p>by users of this data structure, but not AVL nodes. The creation of nodes is handled
</p>
<p>by the ALVTree class.
</p>
<p>The AVLNode constructor has default values for balance, left, and right which
</p>
<p>makes it easy to construct AVLTrees when debugging code. The __repr__ function
</p>
<p>prints the AVLNode in a form that can be used to construct such a node. Calling
</p>
<p>print(repr(node)) will print a node so it can be provided to Python to construct a
</p>
<p>sample tree. The repr(self.left) and repr(self.right) are recursive calls to the __repr__
</p>
<p>function, so the entire tree is printed rooted at self. From Chap. 6 the same __iter__
</p>
<p>function will work to traverse an AVLTree. The iterator function will yield all the
</p>
<p>values of the tree in ascending order.
</p>
<p>Examples in this chapter will refer to balance of nodes in an AVL Tree. It turns out
</p>
<p>that storing the balance of a node is sufficient to correctly implement height balanced
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>10.3 AVL Trees 241
</p>
<p>AVL Trees, but perhaps a bit more difficult to maintain than maintaining the height
</p>
<p>of each node in the tree. Later in the chapter modifications to these algorithms are
</p>
<p>discussed that maintain the height of each node. Whether storing height or balance
</p>
<p>in AVL Trees, the complexity of the tree operations is not affected.
</p>
<p>10.3.4 AVL Tree Iterative Insert
</p>
<p>As described in the last section, there are two variants to the insert algorithm for height
</p>
<p>balanced AVL trees. Insert can be performed iteratively or recursively. The balance
</p>
<p>can also be stored explicitly or it can be computed from the height of each subtree.
</p>
<p>This section describes how to maintain the balance explicitly without maintaining
</p>
<p>the height of each node.
</p>
<p>Iteratively inserting a new value in a height balanced AVL tree requires keeping
</p>
<p>track of the path to the newly inserted value. To maintain that path, a stack is used.
</p>
<p>We&rsquo;ll call this stack the path stack in the algorithm. To insert a new node, we follow
</p>
<p>the unique search path from the root to the new node&rsquo;s location, pushing each node
</p>
<p>on the path stack as we proceed, just as if we were adding it to a binary search tree.
</p>
<p>As we proceed along the path to the new node&rsquo;s destination, we push all the nodes
</p>
<p>we encounter onto the path stack. We insert the new item where it should be according
</p>
<p>to the binary search tree property. Then, the algorithm proceeds popping values from
</p>
<p>the path stack and adjusting their balances until a node is found that has a balance
</p>
<p>not equal to zero before being adjusted. This node, which is the closest ancestor with
</p>
<p>non-zero balance, is called the pivot. Based on the pivot and the location of the new
</p>
<p>value there are three mutually exclusive cases to consider which are described below.
</p>
<p>After making the adjustments in case 3 below there may be a new root node for the
</p>
<p>subtree rooted at the pivot. If this is the case, the parent of the pivot is the next node
</p>
<p>on the path stack and can be linked to the new subtree. If the path stack is empty after
</p>
<p>popping the pivot, then the root of the tree was the pivot. In this case, the root node
</p>
<p>of the AVL tree can be made to point to the new root node in the tree. As mentioned
</p>
<p>above, one of three cases will arise when inserting a new value into the tree.
</p>
<p>Case 1: No Pivot There is no pivot node. In other words the balance of each node
</p>
<p>along the path was 0. In this case just adjust the balance of each node on the search
</p>
<p>path based on the relative value of the new key with respect to the key of each node.
</p>
<p>You can use the path stack to examine the path to the new node.
</p>
<p>This case is depicted in Fig. 10.1 where 39 is to be added to the AVL tree. In
</p>
<p>each node the value is on the left and the balance is given on the right. Each of the
</p>
<p>nodes containing 10, 18, and 40 are pushed onto the path stack. The balance of the
</p>
<p>new node containing 39 is set to 0. The new balance of the node containing 40 is
</p>
<p>&minus;1. The node containing 18 has a new balance of 1. The balance of the root node
</p>
<p>after the insert is 1 because 39 is inserted to the right of it and therefore its balance
</p>
<p>increases by one. The new value is inserted to the left of the node containing 40,
</p>
<p>so its balance decreases by one. Figure 10.2 depicts the tree after inserting the new
</p>
<p>value.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>242 10 Balanced Binary Search Trees
</p>
<p>Fig. 10.1 AVL Tree Case 1&mdash;No Pivot Node
</p>
<p>Fig. 10.2 AVL Tree Case 2&mdash;No Rotate
</p>
<p>Case 2: Adjust Balances The pivot node exists. Further, the subtree of the pivot node
</p>
<p>in which the new node was added has the smaller height. In this case, just change the
</p>
<p>balance of the nodes along the search path from the new node up to the pivot node.
</p>
<p>The balances of the nodes above the pivot node are unaffected. This is true because
</p>
<p>the height of the subtree rooted at the pivot node is not changed by the insertion of
</p>
<p>the new node.
</p>
<p>Figure 10.2 depicts this case. The item with key 12 is about to be added to the AVL
</p>
<p>tree. The node containing the 18 is the pivot node. Since the value to be inserted is
</p>
<p>less than 18 and the balance of the node containing 18 is 1, the new node could
</p>
<p>possibly help to better balance the tree. The AVL tree remains an AVL tree. The
</p>
<p>balance of nodes up to the pivot must be adjusted. Balances above the pivot need not
</p>
<p>be adjusted because they are unaffected. Figure 10.3 depicts what the tree looks like
</p>
<p>after inserting 12 into the tree.
</p>
<p>Case 3: The pivot node exists. This time, however, the new node is added to the
</p>
<p>subtree of the pivot of larger height (the subtree in the direction of the imbalance).
</p>
<p>This will cause the pivot node to have a balance of &minus;2 or 2 after inserting the new
</p>
<p>node, so the tree will no longer be an AVL tree. There are two subcases here, requiring
</p>
<p>either a single rotation or a double rotation to restore the tree to AVL status. Call the
</p>
<p>child of the pivot node in the direction of the imbalance the bad child.
</p>
<p>Subcase A: Single Rotation This subcase occurs when the new node is added to the
</p>
<p>subtree of the bad child which is also in the direction of the imbalance. The solution
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 AVL Trees 243
</p>
<p>Fig. 10.3 AVL Tree Case 3A&mdash;Single Rotation
</p>
<p>is a rotation at the pivot node in the opposite direction of the imbalance. After the
</p>
<p>rotation the tree is still a binary search tree. In addition, the subtree rooted at the
</p>
<p>pivot will be balanced once again, decreasing its overall height by one.
</p>
<p>Figure 10.3 illustrates this subcase. The value 38 is to be inserted into the tree to
</p>
<p>the left of the node containing 39. However, doing so would result in the balance of
</p>
<p>the node containing 40 to decrease to&minus;2, which is the closest ancestor with improper
</p>
<p>balance and the pivot node. The yellow node is the bad child. In addition, the 38 is
</p>
<p>being inserted in the same direction as the imbalance. The imbalance is on the left
</p>
<p>and new new value is being inserted on the left. The solution is to rotate the subtree
</p>
<p>rooted at 40 to the right, resulting in the tree pictured in Fig. 10.4.
</p>
<p>Subcase B: Double Rotation This subcase occurs when the new node is added to
</p>
<p>the subtree of the bad child which is in the opposite direction of the imbalance. For
</p>
<p>this subcase, call the child node of the bad child which lies on the search path the
</p>
<p>bad grandchild. In some cases, there may not be a bad grandchild. In Fig. 10.4 the
</p>
<p>bad grandchild is the purple node. The solution is as follows:
</p>
<p>1. Perform a single rotation at the bad child in the direction of the imbalance.
</p>
<p>2. Perform a single rotation at the pivot away from the imbalance.
</p>
<p>Fig. 10.4 AVL Tree Case 3B&mdash;Double Rotation
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>244 10 Balanced Binary Search Trees
</p>
<p>Fig. 10.5 AVL Tree Case 3B Step 1 Rotate Toward
</p>
<p>Again, the tree is still a binary search tree and the height of the subtree in the
</p>
<p>position of the original pivot node is not changed by the double rotation. Figure 10.4
</p>
<p>illustrates this situation. The pivot in this case is the root of the tree. The node con-
</p>
<p>taining 18 is the bad child. The bad grandchild is the node containing 13 (Fig. 10.5).
</p>
<p>The imbalance in the tree is to the right of the pivot. Yet the 11 is being inserted
</p>
<p>to the left of the bad child. The first step is a rotation to the right at the bad child.
</p>
<p>This brings the 11 up, somewhat helping to balance the right side of the tree. The
</p>
<p>second step, depicted in Fig. 10.6 rotates to the left at the pivot bringing the whole
</p>
<p>tree into balance again.
</p>
<p>The trickiest part of this algorithm is updating the balances correctly. First, the
</p>
<p>pivot, bad child, and bad grandchild contain the balances that may change. If there is
</p>
<p>no bad grandchild then the pivot&rsquo;s and bad child&rsquo;s balances will be zero. If there is a
</p>
<p>bad grandchild, as is the case here, then there is a little more work to determining the
</p>
<p>balances of the pivot and the bad child. When the bad grandchild exists, its balance
</p>
<p>is 0 after the double rotation. The balances of the bad child and pivot depend on
</p>
<p>the direction of the rotation and the value of the new item and the bad grandchild&rsquo;s
</p>
<p>item. This can be analyzed on a case by case basis to determine the balances of both
</p>
<p>the pivot and bad grandchild in these cases. In the next section we examine how the
</p>
<p>balances are calculated.
</p>
<p>Fig. 10.6 AVL Tree Case 3B Step 2 Rotate Away
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 AVL Trees 245
</p>
<p>10.3.5 Rotations
</p>
<p>Both cases 1 and 2 are trivial to implement as they simply adjust balances. Case 3
</p>
<p>is by far the hardest of the cases to implement. Rotating a subtree is the operation
</p>
<p>that keeps the tree balanced as new nodes are inserted into it. For case 3 A the tree
</p>
<p>is in a state where a new node is going to be added to the tree causing an imbalance
</p>
<p>that must be dealt with. There are two possibilities. Figure 10.7 depicts the first of
</p>
<p>these possible situations. The new node may be inserted to the left of the bad child,
</p>
<p>A, when the subtree anchored at the pivot node is already weighted to the left. The
</p>
<p>pivot node, B, is the nearest ancestor with a non-zero balance. For node B to have
</p>
<p>balance &minus;1 before inserting the new node its right subtree must have height h while
</p>
<p>its left subtree has height h + 1. Adding the new node into the subtree of the bad child
</p>
<p>would result in the pivot having balance &minus;2 which is not allowed. The right rotation
</p>
<p>resolves the problem and maintains the binary search tree property. The subtree T2
</p>
<p>moves in the rotation but before the rotation all values in T2 must have been less
</p>
<p>then B and greater than A. After the rotation this would also be true which means it
</p>
<p>remains a binary search tree.
</p>
<p>Inserting a value to the right of the bad child when the imbalance is to the right
</p>
<p>results in an analogous situation requiring a left rotation. Notice that in either rotation
</p>
<p>the balance of nodes A and B are zero. This only applies to case 3 A and does not
</p>
<p>hold in the case of a double rotation (Fig. 10.8).
</p>
<p>Again, the balance of both nodes, the pivot and the bad child, become zero after the
</p>
<p>rotation in either direction. Case 3 A is not possible under any other circumstances.
</p>
<p>For case 3B we must deal not only with a pivot and bad child, but also a bad
</p>
<p>grandchild. As described in the previous section, this case occurs when inserting a
</p>
<p>Fig. 10.7 AVL Tree Case 3A Right Rotation
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>246 10 Balanced Binary Search Trees
</p>
<p>Fig. 10.8 AVL Tree Case 3A Left Rotation
</p>
<p>new value under a bad child in the opposite direction of the imbalance. For instance,
</p>
<p>the subtree in Fig. 10.9 is weighted to the left and the new node is inserted to the
</p>
<p>right of the bad child. An analogous situation occurs when the subtree is weighted
</p>
<p>to the right and the new node is inserted into the left subtree of the bad child. When
</p>
<p>either situation occurs a double rotation is needed to bring it back into balance.
</p>
<p>Figure 10.9 show that there are two possible subcases. There are actually three
</p>
<p>possible subcases. It is possible there is no bad grandchild. In that case, the newly
</p>
<p>inserted node will end up in the location that would have been occupied by the bad
</p>
<p>grandchild. Otherwise the new node might be inserted to the left or right of the bad
</p>
<p>grandchild, which is node C in Fig. 10.9. Either way, the first step in Fig. 10.9 is
</p>
<p>to rotate left at the bad child, node A. Then a right rotation at the pivot, node B,
</p>
<p>completes the rebalancing of the tree.
</p>
<p>Again, the trickiest part of this implementation is the calculation of the balance of
</p>
<p>each node. The bad grandchild and new pivot node, node C in Fig. 10.9, always has
</p>
<p>a balance of 0. If there is no bad grandchild, then the new pivot node is the newly
</p>
<p>inserted value. If there was a bad grandchild, and if the new item was less than the
</p>
<p>bad grandchild&rsquo;s item, the balance of the bad child is 0 and the balance of the old
</p>
<p>pivot is 1. If the new item was inserted to the right of the bad grandchild then the
</p>
<p>balance of the bad child is &minus;1 and the balance of the old pivot is 0. All other balances
</p>
<p>remain the same including balances above the pivot because the overall height of the
</p>
<p>tree before inserting the new value and after inserting the new value has not changed.
</p>
<p>Again, an analogous situation occurs in the mirror image of Fig. 10.9. When a
</p>
<p>new value is inserted into a left subtree of a bad child which is in the right subtree
</p>
<p>of the pivot and which is already weighted more heavily to the right, then a double
</p>
<p>rotation is also required, rotating first right at the bad child and then left at the pivot.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 AVL Trees 247
</p>
<p>Fig. 10.9 AVL Tree Case 3B Steps 1 and 2
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>248 10 Balanced Binary Search Trees
</p>
<p>10.3.6 AVL Tree Recursive Insert
</p>
<p>When implementing a recursive function it is much easier to write as a stand-alone
</p>
<p>function as opposed to a method of a class. This is because a stand-alone method
</p>
<p>may be called on nothing (i.e. None in the case of Python) while a method must
</p>
<p>always have a non-null self reference. Writing recursive functions as methods leads
</p>
<p>to special cases for self. For instance, the insert method, if written recursively, is easier
</p>
<p>to implement if it calls __insert as its recursive function. The __insert function of
</p>
<p>Sect. 10.2.1 won&rsquo;t suffice for height balanced AVL trees. The insert algorithm must
</p>
<p>take into account the current balance of the tree and operate to maintain the balance
</p>
<p>as we discussed in the three cases presented in the previous section.
</p>
<p>10.3.7 The Recursive Insert AVL Tree Class Declaration
</p>
<p>1 class AVLTree:
</p>
<p>2     class AVLNode:
</p>
<p>3         def __init__(self,item,balance=0,left=None,right=None):
</p>
<p>4             self.item = item
</p>
<p>5             self.left = left
</p>
<p>6             self.right = right
</p>
<p>7             self.balance = balance
</p>
<p>8
</p>
<p>9         # Other methods to be written here like __iter__ and
</p>
<p>10         # __repr__. See Chap. 6
</p>
<p>11
</p>
<p>12     def __init__(self,root=None):
</p>
<p>13         self.root = root
</p>
<p>14
</p>
<p>15     def insert(self, item):
</p>
<p>16
</p>
<p>17         def __insert(root,item):
</p>
<p>18             ... # Code to be written here
</p>
<p>19
</p>
<p>20             return root
</p>
<p>21
</p>
<p>22         self.pivotFound = False
</p>
<p>23         self.root = __insert(self.root,item)
</p>
<p>24
</p>
<p>25     def __repr__(self):
</p>
<p>26         return "AVLTree(" + repr(self.root) + ")"
</p>
<p>27
</p>
<p>28     def __iter__(self):
</p>
<p>29         return iter(self.root)
</p>
<p>The shell of the recursive implementation is given in Sect. 10.3.7. The algorithm
</p>
<p>proceeds much like a combination of the three cases presented above along with
</p>
<p>the implementation of insert presented in Sect. 10.2.1. There is no path stack in the
</p>
<p>recursive implementation. Instead, the run-time stack serves that purpose. Between
</p>
<p>lines 5 and 6 or lines 7 and 8 of Sect. 10.2.1 there is an opportunity to rebalance
</p>
<p>the tree as the code returns and works its way back up from the recursive calls. As
</p>
<p>each call returns, the balances of each node can be adjusted accordingly. Adjusting
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.3 AVL Trees 249
</p>
<p>balances before returning implements cases one and two as described earlier in the
</p>
<p>chapter. Case three is detected when a balance of &minus;2 or 2 results from rebalancing.
</p>
<p>In that case the pivot is found and rebalancing according to case 3 can occur.
</p>
<p>Should a pivot be found, no balancing need occur above the pivot. This is the use of
</p>
<p>the self.pivotFound variable initialized on line 22 of the code in Sect. 10.3.7. This flag
</p>
<p>can be set to True to avoid any balancing above the pivot node, should it be found. Bal-
</p>
<p>ances are adjusted just as described in the case by case analysis earlier in the chapter.
</p>
<p>In the worst case the balances of the pivot and bad child will need to be adjusted.
</p>
<p>Implementing both the iterative and the recursive versions of insert into AVL trees
</p>
<p>helps illustrate the special cases that must be handled in the iterative version, while
</p>
<p>the recursive version will not need special cases. The recursive version does not need
</p>
<p>special case handling because of the way the __insert works. The function always is
</p>
<p>given the root node of a tree in which to insert the new item and returns the root node
</p>
<p>of the tree after inserting that item. Since it works in such a regular way, special case
</p>
<p>handling is not necessary.
</p>
<p>10.3.8 Maintaining Balance Versus Height
</p>
<p>The two implementations presented in this chapter, the recursive and iterative insert
</p>
<p>algorithms for AVL trees, maintained the balance of each node. As an alternative,
</p>
<p>the height of each node could be maintained. In this case, the height of a leaf node
</p>
<p>is 1. The height of any other node is 1 plus the maximum height of its two subtrees.
</p>
<p>The height of an empty tree or None is 0.
</p>
<p>10.3.9 AVLNode with Stored Height
</p>
<p>1 class AVLNode:
</p>
<p>2     def __init__(self,item,height=1,left=None,right=None):
</p>
<p>3         self.item = item
</p>
<p>4         self.left = left
</p>
<p>5         self.right = right
</p>
<p>6         self.height = height
</p>
<p>7
</p>
<p>8     def balance(self):
</p>
<p>9         return AVLTree.height(self.right) - AVLTree.height(self.left)
</p>
<p>If the height of nodes is maintained instead of balances, all heights on the path to
</p>
<p>the new item&rsquo;s inserted location must be adjusted on the way back up the tree. Unlike
</p>
<p>balances, it is not possible to stop adjusting heights at the pivot node. After rotation
</p>
<p>the height of the pivot and bad child must also be recomputed as the rotation may
</p>
<p>change their height. Since heights are computed bottom-up, all heights on the path,
</p>
<p>including the heights of the pivot and bad child should be recomputed in a bottom-
</p>
<p>up fashion. The code in Sect. 10.3.9 provides a partial declaration of an AVLNode
</p>
<p>storing the height of the tree tree rooted at the node. In this implementation the
</p>
<p>balance of any node can be computed from the heights of the two subtrees.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>250 10 Balanced Binary Search Trees
</p>
<p>10.3.10 Deleting an Item from an AVL Tree
</p>
<p>Deleting a value from an AVL tree can be accomplished in the same way as described
</p>
<p>in programming problem 2 from Chap. 6. However, it is necessary to adjust balances
</p>
<p>on the way back from deleting the final leaf node. This can be done either by maintain-
</p>
<p>ing a path stack if delete is implemented iteratively or by adjusting balances or heights
</p>
<p>while returning from the recursive calls in a recursive implementation of delete.
</p>
<p>In either case, when adjusted balance of a node on the path reaches 2, a left rotation
</p>
<p>is required to rebalance the tree. If the adjusted balance of a node on the path results
</p>
<p>in &minus;2, then a right rotation is required. These rotations may cascade back up the path
</p>
<p>to the root of the tree.
</p>
<p>10.4 Splay Trees
</p>
<p>AVL trees are always balanced since the balance of each node is computed and
</p>
<p>maintained to be either&minus;1, 1 or 0. Because they are balanced they guaranteeï¿½(log n)
</p>
<p>lookup, insert, and delete time. An AVL tree is a binary search tree so it also maintains
</p>
<p>its items in sorted order allowing iteration from the smallest to largest item in ï¿½(n)
</p>
<p>time. While there doesn&rsquo;t seem to be many downsides to this data structure there is
</p>
<p>a possible improvement in the form of splay trees.
</p>
<p>One of the criticisms of AVL trees is that each node must maintain its balance.
</p>
<p>The extra work and extra space that are required for this balance maintenance might
</p>
<p>be unnecessary. What if a binary search tree could maintain its balance good enough
</p>
<p>without storing the balance in each node. Storing the balance of each node or the
</p>
<p>height of each node increases the size of the data in memory. This was a bigger
</p>
<p>concern when memory sizes were smaller. But, maintaining the extra information
</p>
<p>takes extra time as well. What if we could not only reduce the overall data size but
</p>
<p>eliminate some of the work in maintaining the balance of a binary search tree.
</p>
<p>The improvement to AVL trees incorporates the concept of spatial locality. This
</p>
<p>idea reflects the nature of interaction with large data sets. Access to a large data set
</p>
<p>is often localized, meaning that the same piece or several pieces of data might be
</p>
<p>accessed several times over a short period of time and then may not be accessed
</p>
<p>for some time while some other relatively small subset of the data is accessed by
</p>
<p>either inserting new values or looking up old values. Spatial Locality means that a
</p>
<p>relatively small subset of data is accessed over a short period of time.
</p>
<p>In terms of our example at the beginning of this chapter, a tree containing cookies
</p>
<p>may have cookies that are assigned when a user first visits a website. A user coming
</p>
<p>into the website will interact for a while and then leave, probably not coming back
</p>
<p>soon again. The set of users who are interacting with the web server will change
</p>
<p>over time but it is always a relatively small subset compared to the overall number of
</p>
<p>entries in the tree. If we could store the cookies of the recent users closer to the top
</p>
<p>of the tree, we might be able to improve the overall time for looking up and inserting
</p>
<p>a new value in the tree. The complexity won&rsquo;t improve. Inserting an item will still
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>10.4 Splay Trees 251
</p>
<p>take ï¿½(log n) time. But the overall time to insert or lookup an item might improve
</p>
<p>a little bit. This is the motivation for a splay tree.
</p>
<p>In a splay tree, each insert or lookup moves the inserted or looked up value to
</p>
<p>the root of the tree through a process called splaying. When deleting a value, the
</p>
<p>parent may be splayed to the root of the tree. A splay tree is still a binary search tree.
</p>
<p>Splay trees usually remain well-balanced but unlike an AVL tree, a splay tree does
</p>
<p>not contain any balance or height information. Splaying a node to the root involves
</p>
<p>a series of rotates, much like the rotates of AVL trees, but with a slight difference.
</p>
<p>It is interesting to note that while splay trees are designed to exploit spatial locality
</p>
<p>in the data, they are not dependent on spatial locality to perform well. Splay trees
</p>
<p>function as well or better than AVL trees in practice on completely random data sets.
</p>
<p>There are several things that are interesting about splay trees.
</p>
<p>&bull; First, the splaying process does not require the balance or any other information
</p>
<p>about the height of subtrees. The binary search tree structure is good enough.
</p>
<p>&bull; Splay trees don&rsquo;t stay perfectly balanced all the time. However, because they stay
</p>
<p>relatively balanced, they are balanced enough to get an average case complexity
</p>
<p>of ï¿½(log n) for insert, lookup, and delete operations. This idea that they are good
</p>
<p>enough is the basis for what is called amortized complexity which is discussed
</p>
<p>later in Chap. 2 and later in this chapter.
</p>
<p>&bull; Splaying is relatively simple to implement.
</p>
<p>In this text we cover two bottom-up splay tree implementations. Splay trees can be
</p>
<p>implemented either iteratively or recursively and we examine both implementations.
</p>
<p>In Chap. 6 binary search tree insert was implemented recursively. If splaying is to be
</p>
<p>done recursively, the splay can be part of the insert function. If written iteratively,
</p>
<p>a stack can be used in the splaying process. The following sections cover both the
</p>
<p>iterative and recursive implementations. But first we examine the rotations that are
</p>
<p>used in splaying.
</p>
<p>10.4.1 Splay Rotations
</p>
<p>Each time a value is inserted or looked up the node containing that value is splayed to
</p>
<p>the top through a series of rotate operations. Unlike AVL trees, a splay tree employs
</p>
<p>a double rotation to move a node up to the level of its grandparent if a grandparent
</p>
<p>exists. Through a series of double rotations the node will either make it to the root or
</p>
<p>to the child of the root. If the splayed node makes it to the child of the root, a single
</p>
<p>rotation is used to bring it to the root.
</p>
<p>The single rotate functions are often labelled a zig or a zag while the double
</p>
<p>rotations are called zig-zig or zig-zag operations depending on the direction of the
</p>
<p>movement of the splayed node. Sometimes the node moves with a zig-zag motion
</p>
<p>while other times it moves with a zig-zig motion.
</p>
<p>Splaying happens when a value is inserted into, looked up, or deleted from a splay
</p>
<p>tree. When a value is looked up either the searched value is splayed to the top or the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>252 10 Balanced Binary Search Trees
</p>
<p>would-be parent of the value if the value is not found in the tree. Deletion from the
</p>
<p>tree can be implemented like delete from any other binary search tree as described
</p>
<p>in problem 2 of Chap. 6. When a value is deleted from a binary search tree the parent
</p>
<p>of the deleted node is splayed to the root of the tree.
</p>
<p>The example in Fig. 10.14 depicts the splay operations that result from inserting
</p>
<p>the green nodes into a splay tree. When 30 is inserted, it is splayed to the root of the
</p>
<p>tree as appears in the second version of the tree (the red nodes). When 5 is inserted, it
</p>
<p>is splayed to the root as well. Moving 5 to the root is accomplished through a zig-zig
</p>
<p>rotation called a double-right rotation. Splaying the 8 to the root is the result of a
</p>
<p>zig-zag rotation called a right-left rotation. When the 42 is splayed to the root it is a
</p>
<p>double-left rotation followed by a single left rotation.
</p>
<p>Splaying the 15 to the root is accomplished by doing a double-right rotation
</p>
<p>followed by a left-right rotation. The double-right is often called a zig-zig rotation
</p>
<p>as is the double-left rotation. The left-right and right-left rotations are often called
</p>
<p>zig-zag rotations. The end result in each case has the newly inserted node, or looked
</p>
<p>up node, splayed to the root of the tree.
</p>
<p>Figures 10.10, 10.11, 10.12 and 10.13 depict these splay operations. Figures 10.12
</p>
<p>and 10.13 give some intuitive understanding of why splay trees work as well as they
</p>
<p>Fig. 10.10 Splay Tree Double-Right Rotate
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
</div>
<div class="page"><p/>
<p>10.4 Splay Trees 253
</p>
<p>Fig. 10.11 Splay Tree Double-Left Rotate
</p>
<p>Fig. 10.12 Splay Tree Right-Left Rotate
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>254 10 Balanced Binary Search Trees
</p>
<p>Fig. 10.13 Splay Tree Left-Right Rotate
</p>
<p>do. After the rotate operations depicted in Figs. 10.12 and 10.13 the subtree rooted
</p>
<p>at the child appears to be more balanced than before those rotations.
</p>
<p>Notice that doing a left-right rotation is not the same as doing a left rotation
</p>
<p>followed by a right rotation. The splay left-right rotate yields a different result. Like-
</p>
<p>wise, the splay right-left rotate yields a different result than a right followed by a
</p>
<p>left rotation. Splay zig-zag rotates are designed this way to help balance they tree.
</p>
<p>Figures 10.12 and 10.13 depict trees that might be slightly out of balance before the
</p>
<p>rotation, brought into much better balance by the right-left rotation or the left-right
</p>
<p>rotation.
</p>
<p>10.5 Iterative Splaying
</p>
<p>Each time a value is inserted or looked up it is splayed to the root of the splay tree
</p>
<p>through a series of rotations as described in the previous section. The double rotation
</p>
<p>operations will either move the value to the root or the child of the root of the tree.
</p>
<p>If the double rotates result in the newly inserted value at the child of the root of the
</p>
<p>tree, a single rotate is used to move the newly inserted value to the root as depicted
</p>
<p>in Fig. 10.14 when 30 and 15 are inserted into the splay tree.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.5 Iterative Splaying 255
</p>
<p>Fig. 10.14 Splay Tree Example
</p>
<p>Inserting a new value into a binary search tree without recursion is possible using
</p>
<p>a while loop. The while loop moves from the root of the tree to the leaf node which
</p>
<p>will become the new node&rsquo;s parent at which point the loop terminates, the new node
</p>
<p>is created, and the parent is hooked up to its new child.
</p>
<p>After inserting the new node, it must be splayed to the top. To splay it is necessary
</p>
<p>to know the path that was taken through the tree to the newly inserted node. This
</p>
<p>path can be recorded using a stack. As the insert loop passes through another node
</p>
<p>in the tree, it is pushed onto the stack. The end result is that all nodes, from the root
</p>
<p>to the new child, on the path to the new child are pushed onto this path stack.
</p>
<p>Finally, splaying can occur by emptying this path stack. First the child is popped
</p>
<p>from the stack. Then, the rest of the stack is emptied as follows.
</p>
<p>&bull; If two more nodes are available on the stack they are the parent and grandparent of
</p>
<p>the newly inserted node. In that case a double rotate can be performed resulting in
</p>
<p>the root of the newly rotated subtree being the newly inserted node. Which double
</p>
<p>rotation is required can be determined from the values of the grandparent, parent,
</p>
<p>and child.
</p>
<p>&bull; If only one node remains on the stack it is the parent of the newly inserted node.
</p>
<p>A single rotation will bring the newly inserted node to the root of the splay tree.
</p>
<p>Implementing splay in the manner described here works well when looking up a
</p>
<p>value in the tree, whether it is found or not. When a value is found it will be added
</p>
<p>to the path stack. When a value is not found, the parent should be splayed to the top,
</p>
<p>which naturally occurs when the looked up value is not found because the parent
</p>
<p>will be left on the top of the path stack when splaying is performed.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>256 10 Balanced Binary Search Trees
</p>
<p>One method of deleting a node from a splay tree is accomplished by deleting just
</p>
<p>as you would in a binary search tree. If the node to delete has zero or one child it
</p>
<p>is trivial to delete the node. If the node to delete has two children, then the leftmost
</p>
<p>value in its right subtree can replace the value in the node to delete and the leftmost
</p>
<p>value can be deleted from the right subtree. The parent of the deleted node is splayed
</p>
<p>to the top of the tree.
</p>
<p>Another method of deletion requires splaying the deleted node to the root of the
</p>
<p>tree first. Then the rightmost value of the left subtree is splayed to the root. After
</p>
<p>splaying the left subtree, its root node&rsquo;s right subtree is empty and the original right
</p>
<p>subtree can be added to it. The original left subtree becomes the root of the newly
</p>
<p>constructed splay tree.
</p>
<p>10.6 Recursive Splaying
</p>
<p>Implementing splaying recursively follows the recursive insert operation on binary
</p>
<p>search trees. The splaying is combined with this recursive insert function. As the
</p>
<p>recursive insert follows the path down the tree it builds a rotate string of &ldquo;R&rdquo; and
</p>
<p>&ldquo;L&rdquo;. If the new item is inserted to the right of the current root node, then a left rotate
</p>
<p>will be required to splay the newly inserted node up the tree and an &ldquo;L&rdquo; is added to
</p>
<p>the rotate string. Otherwise, a right rotate will be required and an &ldquo;R&rdquo; is added to the
</p>
<p>rotate string.
</p>
<p>As the recursive insert function returns, the path to the newly inserted node is
</p>
<p>retraced by the returning function. The last two characters in the rotate string dictate
</p>
<p>what double rotation is required. A dictionary or hash table takes care of mapping
</p>
<p>&ldquo;RR&rdquo;, &ldquo;RL&rdquo;, &ldquo;LR&rdquo;, and &ldquo;LL&rdquo; to the appropriate rotate functions. The hash table
</p>
<p>lookup is used to call the appropriate rotation and the rotate string is truncated (or
</p>
<p>re-initialized to the empty string depending on when &ldquo;R&rdquo; and &ldquo;L&rdquo; are added to the
</p>
<p>rotate string). When the recursive insert is finished, any required single rotation will
</p>
<p>be recorded in the rotate string and can be performed.
</p>
<p>It should be noted that implementing splaying using a rotate string and hash table
</p>
<p>like this requires about one half the conditional statements to determine the required
</p>
<p>rotations as compared to the iterative algorithm described above. When inserting a
</p>
<p>new node the path must be determined by comparing the value to insert to each node
</p>
<p>on the path to its location in the tree. In the iterative description above, the values
</p>
<p>on the path are again compared during splaying. In this recursive description the
</p>
<p>new item is only compared to each item on the path once. This has an impact on
</p>
<p>performance as shown later in the chapter.
</p>
<p>Looking up a value using this recursive implementation works similarly to insert
</p>
<p>either splaying the found value or its parent if it is not found to the root of the tree.
</p>
<p>Deleting a value again can be done recursively by first looking up the value to delete
</p>
<p>resulting in it being splayed to the root of the tree and then performing the method
</p>
<p>of root removal described in the previous section.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.7 Performance Analysis 257
</p>
<p>10.7 Performance Analysis
</p>
<p>In the worst case a splay tree may become a stick resulting in ï¿½(n) complexity for
</p>
<p>each lookup, insert, and delete operation while AVL trees guarantee ï¿½(log n) time
</p>
<p>for lookup, insert, and delete operations. It would appear that AVL trees might have
</p>
<p>better performance. However, this does not seem to be the case in practice. Close to
</p>
<p>100,000 insert and 900,000 random lookups were performed in an experiment using a
</p>
<p>pre-generated dataset. The insert and lookup operations were identified in the dataset
</p>
<p>with all looked up values being found in the tree. The average combined insert and
</p>
<p>lookup time were recorded in Fig. 10.15 for an AVL tree, a splay tree implemented
</p>
<p>iteratively, and the recursive implementation of splay tree insert and lookup. The
</p>
<p>results show that the recursive splay tree implementation performs better on a random
</p>
<p>set of values than the AVL tree implementation. The experiment suggests that splay
</p>
<p>trees also exhibit ï¿½(log n) complexity in practice for insert and lookup operations.
</p>
<p>In Figs. 10.13 and 10.12 we got an intuitive understanding of how splay trees
</p>
<p>maintain balance through their specialized double rotations. However, it is not a very
</p>
<p>convincing argument to say that the double rotations appear to make the tree more
</p>
<p>balanced. This idea is formalized using amortized complexity. Amortization, first
</p>
<p>encountered in Chap. 2, is an accounting term used when an expense is spread over a
</p>
<p>number of years as opposed to expensing it all in one year. This same principle can be
</p>
<p>applied to the expense in finding or inserting a value in a Splay Tree. The complete
</p>
<p>Fig. 10.15 Average Insert/Lookup Time
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_2">http://dx.doi.org/10.1007/978-3-319-13072-9_2</a></div>
</div>
<div class="page"><p/>
<p>258 10 Balanced Binary Search Trees
</p>
<p>analysis of this is done on a case by case basis and is not present in this text but
</p>
<p>may be found in texts on-line. These proofs show that splay trees do indeed operate
</p>
<p>as efficiently as AVL trees on randomly accessed data. In addition, the splaying
</p>
<p>operation used when inserting or looking up a value exploits spatial locality in the
</p>
<p>data. Data values that are frequently looked up will make their way toward the top of
</p>
<p>the tree so as to be more efficiently looked up in the future. While taking advantage
</p>
<p>of spatial locality is certainly desirable if present in the data, it does not improve the
</p>
<p>overall computational complexity of splay tree insert and lookup operations.
</p>
<p>However, this does not happen in the average case on randomly inserted and
</p>
<p>looked up values. In fact, the recursive implementation of splay trees presented in
</p>
<p>the previous section exhibits ï¿½(log n) average insert and lookup time on a randomly
</p>
<p>distributed set of values and performs better in a random sample than the AVL tree
</p>
<p>implementation.
</p>
<p>Insert, lookup, and delete operations on an AVL tree can be completed inï¿½(log n)
</p>
<p>time. In the average case this holds for splay trees as well. Traversal of an AVL
</p>
<p>or splay tree runs in ï¿½(n) time and yields its items in ascending or descending
</p>
<p>order (depending on how the iterator is written). While the quicksort algorithm can
</p>
<p>sort the items of a list just as efficiently, AVL and splay trees are data structures
</p>
<p>that allow many insert and delete operations while still maintaining the ordering of
</p>
<p>their elements. An AVL or splay tree may be a practical choice if a data structure
</p>
<p>is needed that efficiently implements lookup, delete, and insert operations while
</p>
<p>also allowing the sequence of values to be iterated over in ascending or descending
</p>
<p>order. The advantage of AVL trees lies in their ability to maintain the ordering of
</p>
<p>elements while guaranteeing efficient lookup, insert, and delete complexity. Splay
</p>
<p>trees work just as well in almost all cases and in the case of the recursive splay
</p>
<p>tree implementation described in this chapter it performs even better than the AVL
</p>
<p>Tree implementation on random data sets. The difference in performance between
</p>
<p>the AVL tree and the recursive splay tree performance numbers is the difference
</p>
<p>between maintaining the balance explicitly in the AVL tree and getting good enough
</p>
<p>balance in the splay tree.
</p>
<p>10.8 Chapter Summary
</p>
<p>This chapter presented several implementations of height-balanced AVL trees and
</p>
<p>splay trees. Recursive and iterative insert algorithms were presented. Both balance
</p>
<p>maintaining and height maintaining AVL nodes were discussed. The recursive insert
</p>
<p>algorithms for both AVL and splay trees result in very clean code without many spe-
</p>
<p>cial cases, while the iterative versions needs a few more if statements to handle some
</p>
<p>conditions. In some instance the iterative version may be slightly more efficient than
</p>
<p>the recursive version since there is a cost associated with function calls in any lan-
</p>
<p>guage, but the experimental results obtained from the experiments performed in this
</p>
<p>chapter seem to suggest that the recursive implementations operate very efficiently
</p>
<p>when written in Python.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>10.9 Review Questions 259
</p>
<p>10.9 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. What is the balance of a node in an AVL tree?
</p>
<p>2. How does the balance of a node relate to its height?
</p>
<p>3. How does an AVL tree make use of the balance of a node?
</p>
<p>4. What is a pivot node?
</p>
<p>5. What is a bad child in relationship to AVL trees?
</p>
<p>6. What is the path stack and when is it necessary?
</p>
<p>7. After doing a right rotation, where is the pivot node and the bad child in the
</p>
<p>subtree that was originally rooted at the pivot?
</p>
<p>8. Why is the balance of the root of a subtree always 0 after code for case 3 is
</p>
<p>executed?
</p>
<p>9. In the two subcases for case 3, what node becomes the root node of the subtree
</p>
<p>rooted at the pivot after executing the algorithm on each of the subcases?
</p>
<p>10. Why does the AVL tree insert algorithm always completes in ï¿½(log n) time?
</p>
<p>Do a case by case analysis to justify your answer for each of the three cases
</p>
<p>involved in inserting a value.
</p>
<p>11. What is the purpose of the rotate string in the recursive insert splay tree imple-
</p>
<p>mentation?
</p>
<p>12. Why does it seem that the recursive splay tree insert and lookup implementation
</p>
<p>operates faster than the AVL tree implementation?
</p>
<p>10.10 Programming Problems
</p>
<p>1. Write an AVL tree implementation that maintains balances in each node and
</p>
<p>implements insert iteratively. Write a test program to thoroughly test your program
</p>
<p>on some randomly generated data.
</p>
<p>2. Write an AVL tree implementation that maintains balances in each node and
</p>
<p>implements insert recursively. Write a test program to thoroughly test your pro-
</p>
<p>gram on some randomly generated data.
</p>
<p>3. Write an AVL tree implementation that maintains heights in each node and imple-
</p>
<p>ments insert recursively. Write a test program to thoroughly test your program on
</p>
<p>some randomly generated data.
</p>
<p>4. Write an AVL tree implementation that maintains heights in each node and imple-
</p>
<p>ments insert iteratively. Write a test program to thoroughly test your program on
</p>
<p>some randomly generated data.
</p>
<p>5. Complete programming problem 3. Then implement the delete operation for AVL
</p>
<p>Trees. Finally, write a test program to thoroughly test your data structure. As
</p>
<p>values are inserted and deleted from your tree you should test your code to make
</p>
<p>sure it maintains all heights correctly and the ordering of all values in the tree.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>260 10 Balanced Binary Search Trees
</p>
<p>6. Implement two of the programming problems 1&ndash;4 in this chapter and then write
</p>
<p>a test program that generates a random list of integers. Time inserting the values
</p>
<p>into the first implementation and then time inserting each value into the second
</p>
<p>implementation. Record all times in the XML format needed by the PlotData.py
</p>
<p>program from chapter two. Plot the timing of the two algorithms to compare their
</p>
<p>relative efficiency.
</p>
<p>7. Write a splay tree implementation with recursive insert and lookup functions.
</p>
<p>Implement an AVL tree either iteratively or recursively where the height of each
</p>
<p>node is maintained. Run a test where trees are built from the same list of values.
</p>
<p>When you generate the list of values, duplicate values should be considered a
</p>
<p>lookup. Write the data file with an L or an I followed by a value which indicates
</p>
<p>either a lookup or insert operation should be performed. Generate an XML file in
</p>
<p>the format used by the PlotData.py program to compare your performance results.
</p>
<p>8. Write a splay tree implementation with recursive insert and lookup functions.
</p>
<p>Compare it to one of the other balanced binary tree implementations detailed in
</p>
<p>this chapter. Run a test where trees are built from the same list of values. When
</p>
<p>you generate the list of values, duplicate values should be considered a lookup.
</p>
<p>Write the data file with an L or an I followed by a value which indicates either
</p>
<p>a lookup or insert operation should be performed. Generate an XML file in the
</p>
<p>format used by the PlotData.py program to compare your performance results.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11B-Trees
</p>
<p>This chapter covers one of the more important data structures of the last thirty years.
</p>
<p>B-Trees are primarily used by relational databases to efficiently implement an oper-
</p>
<p>ation called join. B-Trees have other properties that are also useful for databases
</p>
<p>including ordering of rows within a table, fast delete capability, and sequential access.
</p>
<p>11.1 Chapter Goals
</p>
<p>This chapter introduces some terminology from relational databases to motivate the
</p>
<p>need for B-Trees. The chapter goes on to introduce the B-Tree data structure and
</p>
<p>its implementation. By the end of this chapter you should have an understanding
</p>
<p>of B-Trees, their advantages over other data structures, and you should be able
</p>
<p>to demonstrate your understanding by implementing a B-Tree that can be used to
</p>
<p>efficiently process joins in relational databases.
</p>
<p>11.2 Relational Databases
</p>
<p>While this is not a database text we will cover a bit of database terminology to
</p>
<p>demonstrate the need for a B-Tree and its use in a relational database. A relational
</p>
<p>database consists of entities and relationships between these entities. A database
</p>
<p>schema is a collection of entities and their relationships. A schema is specified by
</p>
<p>a Entity Relationship diagram, often abbreviated ER-diagram, or a Logical Data
</p>
<p>Structure [2]. Figure 11.1 provides an ER-diagram for a database called the Dairy
</p>
<p>Database. It is used to formulate rations for dairy cattle to maximize milk production.
</p>
<p>Each box in Fig. 11.1 represents an entity in the database. Of particular interest
</p>
<p>in this text are the Feed, FeedAttribute, and FeedAttribType entities. A feed, like
</p>
<p>corn silage or alfalfa, is composed of many different nutrients. Nutrients are things
</p>
<p>like calcium, iron, phosphorus, protein, sugar, and so on. In the Dairy Database
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_11
</p>
<p>261
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>262 11 B-Trees
</p>
<p>Fig. 11.1 Dairy Database Entity Relationship Diagram
</p>
<p>these nutrients are called FeedAttribTypes. There is a many-to-many relationship
</p>
<p>between Feeds and FeedAttribTypes. A feed has many feed attributes, or nutrients.
</p>
<p>Each nutrient or feed attribute type appears in more than one feed. This relationship
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2 Relational Databases 263
</p>
<p>Fig. 11.2 A Many to Many Relationship
</p>
<p>is depicted in Fig. 11.2. The forks on the two ends of the line represent the many-
</p>
<p>to-many relationship between feeds and feed attribute types.
</p>
<p>Many-to-Many relationships cannot be represented in a relational database with-
</p>
<p>out going through a process called reification. Reification introduces new entities that
</p>
<p>remove many-to-many relationships. When a many-to-many relationship appears
</p>
<p>within a logical data structure it indicates there may be missing attributes. In this
</p>
<p>case, the quantity of each nutrient within a feed was missing. The new FeedAttribute
</p>
<p>entity eliminates the many-to-many relationship by introducing two one-to-many
</p>
<p>relationships. One-to-many relationships can be represented in relational databases.
</p>
<p>Every entity in a relational database must have a unique identifier. In Fig. 11.3 the
</p>
<p>Feed entities are uniquely identified by their FeedID attribute. The other attributes are
</p>
<p>important, but do not have to be unique. Each FeedID must be unique and it cannot
</p>
<p>be null or empty for any feed. Likewise, a FeedAttribTypeID field uniquely identifies
</p>
<p>each feed nutrient. There is a unique FeedAttribTypeID for calcium, iron, and so on.
</p>
<p>The FeedAttribute entity has a unique id made up of two fields. Together, the FeedID
</p>
<p>and the FeedAttribTypeID identify a unique instance of a nutrient for a particular
</p>
<p>feed. The Value was the missing attribute in Fig. 11.2 that was introduced by reifying
</p>
<p>the many-to-many relationship as depicted in Fig. 11.3. The Logical Data Structure
</p>
<p>in Fig. 11.3 describes the schema for feeds and nutrients in the Dairy Database.
</p>
<p>A relational database is composed of tables and the shema provides the definition
</p>
<p>of these tables. The Feed table consists of rows and columns. Each row in the Feed
</p>
<p>table describes one feed. The columns of the Feed table are each of the attributes of a
</p>
<p>feed provided in Fig. 11.3. The example in Sect. 11.2.1 provides a subset of this table
</p>
<p>Fig. 11.3 Logical Data Structure
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>264 11 B-Trees
</p>
<p>with a subset of the columns of this table. The ellipses (i.e. the &hellip;) indicate omitted
</p>
<p>rows within the database. The full table is available as Feed.tbl on the text website.
</p>
<p>11.2.1 The Feed Table
</p>
<p>1 ...
</p>
<p>2 1316 512 10&rsquo;Corn Silag&rsquo; 2/28/2002 12:00:00 AM
</p>
<p>3 1317 512 11&rsquo;Almond Hul&rsquo; 7/15/1989 12:00:00 AM
</p>
<p>4 1318 512 12&rsquo;MolassWet&rsquo; 5/19/1989 12:00:00 AM
</p>
<p>5 1319 512 13&rsquo;LIQ CIT PL&rsquo; 3/2/2002 12:00:00 AM
</p>
<p>6 1320 512 14&rsquo;Whey&rsquo; 9/4/1997 12:00:00 AM
</p>
<p>7 1321 512 16&rsquo;SF CORN&rsquo; 9/29/1998 12:00:00 AM
</p>
<p>8 1322 512 18&rsquo;Dry Min&rsquo; 10/17/2002 12:00:00 AM
</p>
<p>9 1323 512 19&rsquo;Min Plts&rsquo; 11/17/2002 12:00:00 AM
</p>
<p>10 1324 512 20&rsquo;Mineral&rsquo; 2/28/2002 12:00:00 AM
</p>
<p>11 1372 525 1&rsquo;Hay lact&rsquo; 9/15/2003 12:00:00 AM
</p>
<p>12 1373 525 2&rsquo;DRY HAY&rsquo; 11/30/1999 12:00:00 AM
</p>
<p>13 1374 525 3&rsquo;Oat hay&rsquo; 11/10/1998 12:00:00 AM
</p>
<p>14 1375 525 4&rsquo;Hlg&rsquo; 4/12/2004 12:00:00 AM
</p>
<p>15 1376 525 5&rsquo;CUPHay&rsquo; 9/17/2003 12:00:00 AM
</p>
<p>16 1377 525 6&rsquo;Hay #1&rsquo; 3/27/2001 12:00:00 AM
</p>
<p>17 1378 525 8&rsquo;BMR CSilage&rsquo; 4/1/2004 12:00:00 AM
</p>
<p>18 1379 525 9&rsquo;Wheat Sil&rsquo; 9/15/2003 12:00:00 AM
</p>
<p>19 1380 525 10&rsquo;Corn Silag&rsquo; 10/30/2003 12:00:00 AM
</p>
<p>20 1381 525 11&rsquo;Almond Hul&rsquo; 7/10/2000 12:00:00 AM
</p>
<p>21 1382 525 14&rsquo;ClosePlt&rsquo; 1/13/2003 12:00:00 AM
</p>
<p>22 1383 525 16&rsquo;Corn1%fat&rsquo; 9/3/2002 12:00:00 AM
</p>
<p>23 1384 525 18&rsquo;Dry Min&rsquo; 7/12/2000 12:00:00 AM
</p>
<p>24 1385 525 19&rsquo;Comm Mix&rsquo; 12/13/2003 12:00:00 AM
</p>
<p>25 1386 525 20&rsquo;On Farm&rsquo; 10/30/2003 12:00:00 AM
</p>
<p>26 1438 529 1&rsquo;Big Sq155&rsquo; 6/21/1999 12:00:00 AM
</p>
<p>27 1439 529 2&rsquo;Hay#1-200&rsquo; 2/1/2000 12:00:00 AM
</p>
<p>28 1440 529 3&rsquo;Hay#2-145&rsquo; 2/1/2000 12:00:00 AM
</p>
<p>29 ...
</p>
<p>Normally a relational database would store a table like the Feed table in a binary
</p>
<p>format that would be unreadable except by a computer. The Feed.tbl file is written in
</p>
<p>ASCII format to be human readable with a simple text editor, but the principles are
</p>
<p>the same. Each row within the table represents one record of the table which is one
</p>
<p>instance of a feed in this case. The records are each the same size to make reading
</p>
<p>the table easy. Within any record we can find the name of the feed by going to the
</p>
<p>correct column for feed name, which is the fourth field within each record and starts
</p>
<p>30 bytes or characters into each record. Ten bytes or characters are allocated to each
</p>
<p>integer field (the first column was edited to better fit on the page). There are 107
</p>
<p>records or feeds within the sample Feed.tbl table provided on the text website.
</p>
<p>11.2.2 The FeedAttribType Table
</p>
<p>1 ...
</p>
<p>2 10&rsquo;P&rsquo; &rsquo;Phosphorus as % of DM&rsquo; 15
</p>
<p>3 11&rsquo;Ca&rsquo; &rsquo;Calcium as % of DM&rsquo; 16
</p>
<p>4 12&rsquo;RFV&rsquo; &rsquo;Relative Feed Value (calculated)&rsquo; 17
</p>
<p>5 13&rsquo;S&rsquo; &rsquo;Sulfur as % of DM&rsquo; 18
</p>
<p>6 14&rsquo;K&rsquo; &rsquo;Potassium as % of DM&rsquo; 19
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2 Relational Databases 265
</p>
<p>7 15&rsquo;Mg&rsquo; &rsquo;Magnesium as % of DM&rsquo; 20
</p>
<p>8 16&rsquo;Fat&rsquo; &rsquo;Fat as % of DM&rsquo; 14
</p>
<p>9 ...
</p>
<p>The table in Sect. 11.2.2 contains a subset of the records in the FeedAttrib-
</p>
<p>Type table, available as FeedAttribType.tbl on the text website. The full table has
</p>
<p>57 different rows each containing 7 fields. As with the Feed table, the FeedAttrib-
</p>
<p>Type table is organized into rows and columns.
</p>
<p>A subset of the FeedAttribute table is provided in Sect. 11.2.3. Each feed attribute
</p>
<p>is comprised of the corresponding FeedID, the FeedAttribTypeID, and the amount
</p>
<p>of that nutrient for the given feed which is called the Value column within the table.
</p>
<p>11.2.3 The FeedAttribute Table
</p>
<p>1 ...
</p>
<p>2 1316 10 0.250000
</p>
<p>3 1316 11 0.210000
</p>
<p>4 1316 12 128.000000
</p>
<p>5 1316 13 0.150000
</p>
<p>6 1316 14 1.200000
</p>
<p>7 1316 15 0.200000
</p>
<p>8 1316 16 3.000000
</p>
<p>9 ...
</p>
<p>10 1317 10 0.110000
</p>
<p>11 1317 11 0.220000
</p>
<p>12 1317 12 129.000000
</p>
<p>13 1317 13 0.110000
</p>
<p>14 1317 14 0.530000
</p>
<p>15 1317 15 0.130000
</p>
<p>16 1317 16 2.000000
</p>
<p>17 ...
</p>
<p>Storing the feed data this way is flexible. New nutrients can easily be added.
</p>
<p>Feeds can be added as well. Feed attributes can be stored if available or omitted.
</p>
<p>Occasionally, programs that use relational databases need access to data from more
</p>
<p>than one table but need to correlate the data between the tables. For instance, it may
</p>
<p>be convenient to temporarily construct a table that contains the feed number, feed
</p>
<p>name, nutrient name, and value of that nutrient for the corresponding feed into a
</p>
<p>table like that in Sect. 11.2.4. We may want to compute the average phosphorous
</p>
<p>content within all feeds. In fact, we may wish to calculate the average content for
</p>
<p>each nutrient type within the database. In that case a table like the one in Sect. 11.2.4
</p>
<p>would be very useful.
</p>
<p>11.2.4 A Temporary Table
</p>
<p>1 ...
</p>
<p>2 10 Corn Silag P 0.25
</p>
<p>3 10 Corn Silag Ca 0.21
</p>
<p>4 10 Corn Silag RFV 128.0
</p>
<p>5 10 Corn Silag S 0.15
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>266 11 B-Trees
</p>
<p>6 10 Corn Silag K 1.2
</p>
<p>7 10 Corn Silag Mg 0.2
</p>
<p>8 10 Corn Silag Fat 3.0
</p>
<p>9 ...
</p>
<p>10 11 Almond Hul P 0.11
</p>
<p>11 11 Almond Hul Ca 0.22
</p>
<p>12 11 Almond Hul RFV 129.0
</p>
<p>13 11 Almond Hul S 0.11
</p>
<p>14 11 Almond Hul K 0.53
</p>
<p>15 11 Almond Hul Mg 0.13
</p>
<p>16 11 Almond Hul Fat 2.0
</p>
<p>17 ...
</p>
<p>Relational databases are often called SQL databases. SQL stands for System Query
</p>
<p>Language. SQL is a language for querying relational databases. SQL can be used to
</p>
<p>build temporary tables like the one in Sect. 11.2.4. The SQL statement to build this
</p>
<p>table would be written as
</p>
<p>SELECT Feed.FeedNum, Feed.Name, FeedAttribType.Name, FeedAttribute.Value WHERE
</p>
<p>Feed.FeedID = FeedAttribute.FeedID AND
</p>
<p>FeedAttribute.FeedAttribTypeID = FeedAttribType.FeedAttribTypeID
</p>
<p>This SQL statement is known as a join of three tables because three tables will
</p>
<p>be joined together to form the result. It is up to the relational database to translate
</p>
<p>this query into commands that read the three tables and efficiently construct a new
</p>
<p>temporary table as the result of the join.
</p>
<p>If we were to implement our own relational database, the join operation for these
</p>
<p>three tables might be programmed similarly to the code appearing in Sect. 11.2.5.
</p>
<p>Don&rsquo;t be misled. Relational databases don&rsquo;t program specific joins like this one, but
</p>
<p>the joining of the three tables might be functionally equivalent to this code. The entire
</p>
<p>program is available as joinquery.py on the text&rsquo;s website. The readField function
</p>
<p>here in the text is abbreviated for space, but reads any type of field from a table file.
</p>
<p>The join algorithm picks one of the tables and read it from beginning to end. In this
</p>
<p>case, the FeedAttribute table is read from beginning to end. For each feed attribute,
</p>
<p>the matching feed id from the feed table must be located. In the code in Sect. 11.2.5
</p>
<p>this involves reading, on average, half the feed table to supply the feed number and
</p>
<p>feed name for each line of the query. Likewise, to supply the feed attribute name, on
</p>
<p>average half the FeedAttribType table is read to supply the feed attribute name for
</p>
<p>each line of the query output.
</p>
<p>The complexity of this operation is O(n*m) where n is the number of records
</p>
<p>in FeedAttribute.tbl and m is the maximum of the number of records in FeedAt-
</p>
<p>tribType.tbl and Feed.tbl. This is O(n2) performance if n is roughly equivalent to m.
</p>
<p>Whether the two are roughly equivalent or not, the performance of this query, even on
</p>
<p>our small sample table, is not great. It takes about 4.993 s to run the query as written
</p>
<p>on a 2.66 GHz Intel Core i7 processor with 8 GB of RAM and a solid state hard drive.
</p>
<p>11.2.5 Programming the Joining of Tables
</p>
<p>1 import datetime
</p>
<p>2 def readField(record,colTypes,fieldNum):
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2 Relational Databases 267
</p>
<p>3 # fieldNum is zero based
</p>
<p>4 # record is a string containing the record
</p>
<p>5 # colTypes is the types for each of the columns in the record
</p>
<p>6 offset = 0
</p>
<p>7 for i in range(fieldNum):
</p>
<p>8 colType = colTypes[i]
</p>
<p>9
</p>
<p>10 if colType == "int":
</p>
<p>11 offset+=10
</p>
<p>12 elif colType[:4] == "char":
</p>
<p>13 size = int(colType[4:])
</p>
<p>14 offset += size
</p>
<p>15 elif colType == "float":
</p>
<p>16 offset+=20
</p>
<p>17 ...
</p>
<p>18 return val
</p>
<p>19 def main():
</p>
<p>20 # SELECT Feed.FeedNum, Feed.Name, FeedAttribType.Name, FeedAttribute.Value WHERE
</p>
<p>21 # Feed.FeedID = FeedAttribute.FeedID AND
</p>
<p>22 # FeedAttribute.FeedAttribTypeID = FeedAttribType.FeedAttribTypeID
</p>
<p>23 attribTypeCols = ["int","char20","char60","int","int","int","int"]
</p>
<p>24 feedCols = ["int","int","int","char50","datetime","float","float","int","char50","int"]
</p>
<p>25 feedAttributeCols = ["int","int","float"]
</p>
<p>26 before = datetime.datetime.now()
</p>
<p>27 feedAttributeTable = open("FeedAttribute.tbl","r")
</p>
<p>28 for record in feedAttributeTable:
</p>
<p>29 feedID = readField(record,feedAttributeCols,0)
</p>
<p>30 feedAttribTypeID = readField(record,feedAttributeCols,1)
</p>
<p>31 value = readField(record,feedAttributeCols,2)
</p>
<p>32 feedTable = open("Feed.tbl","r")
</p>
<p>33 feedFeedID = -1
</p>
<p>34 while feedFeedID != feedID:
</p>
<p>35 feedRecord = feedTable.readline()
</p>
<p>36 feedFeedID = readField(feedRecord,feedCols,0)
</p>
<p>37 feedNum = readField(feedRecord,feedCols,2)
</p>
<p>38 feedName = readField(feedRecord,feedCols,3)
</p>
<p>39 feedAttribTypeTable = open("FeedAttribType.tbl", "r")
</p>
<p>40 feedAttribTypeIDID = -1
</p>
<p>41 while feedAttribTypeIDID != feedAttribTypeID:
</p>
<p>42 feedAttribTypeRecord = feedAttribTypeTable.readline()
</p>
<p>43 feedAttribTypeIDID = readField(feedAttribTypeRecord,attribTypeCols,0)
</p>
<p>44 feedAttribTypeName = readField(feedAttribTypeRecord,attribTypeCols,1)
</p>
<p>45 print(feedNum,feedName,feedAttribTypeName,value)
</p>
<p>46 after = datetime.datetime.now()
</p>
<p>47 deltaT = after - before
</p>
<p>48 milliseconds = deltaT.total_seconds() * 1000
</p>
<p>49 print("Time for the query without indexing was",milliseconds,"milliseconds.")
</p>
<p>50
</p>
<p>51 if __name__ == "__main__":
</p>
<p>52 main()
</p>
<p>The code in Sect. 11.2.5 suffers because the two tables, Feed.tbl and FeedAttrib-
</p>
<p>Type.tbl are read sequentially each time through the outer loop to find the matching
</p>
<p>feed and feed attribute type, respectively. We can improve the efficiency of this query
</p>
<p>if we recognize that disk drives are random access devices. That means that we can
</p>
<p>position the read head of a disk drive anywhere within a file. We don&rsquo;t have to start at
</p>
<p>the beginning of a table to begin looking for a matching feed or feed attribute type.
</p>
<p>We can jump around within the table to find the matching record.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>268 11 B-Trees
</p>
<p>11.2.6 The readRecord Function
</p>
<p>1 def readRecord(file,recNum,recSize):
</p>
<p>2 file.seek(recNum*recSize)
</p>
<p>3 record = file.read(recSize)
</p>
<p>4 return record
</p>
<p>Python includes a seek method on files to position the read head of a disk to a
</p>
<p>byte offset within a file. The read method on files reads a given number of bytes
</p>
<p>and returns them as a string. To test this readRecord function, and the functionality
</p>
<p>of the seek method, a program was written to randomly access the records in the
</p>
<p>FeedAttribute.tbl file. The results of that experiment are shown in Fig. 11.4. The data
</p>
<p>shows that accessing any record within the file took about the same amount of time
</p>
<p>regardless of its position within the file. As with any experiment, there were a few
</p>
<p>anomalies. But, the vast majority of records were accessed in the same amount of
</p>
<p>time or nearly the same amount of time.
</p>
<p>Let&rsquo;s say we were to organize the Feed.tbl and the FeedAttribType.tbl files so that
</p>
<p>the records were sorted in increasing order by their keys. The Feed.tbl file would be
</p>
<p>sorted by FeedID and the FeedAttribType.tbl would be sorted by FeedAttribTypeID.
</p>
<p>Then we could use binary search on these two files to find the matching records
</p>
<p>for each feed attribute in the code of Sect. 11.2.5. Since the tables are randomly
</p>
<p>accessible, the query time could be reduced from O(n*m) to O(n log m). However,
</p>
<p>Fig. 11.4 Access Time for Randomly Read Records in a File
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.2 Relational Databases 269
</p>
<p>we can&rsquo;t assume that a database table will always, or ever, be sorted according to one
</p>
<p>field. Databases can have new records added and old records deleted at any time.
</p>
<p>This is where the need for a B-Tree comes from. A B-Tree is a tree structure that
</p>
<p>is built over the top, so to speak, of a database table to provide O(log n) lookup time
</p>
<p>to any record within the database table. While the records themselves may be in any
</p>
<p>order, the B-Tree provides the O(log n) search complexity into the table.
</p>
<p>A B-Tree is built by inserting records or items into the tree. Once built, the index
</p>
<p>provides the efficient lookup of any record based on the key value stored in the
</p>
<p>B-Tree. Consider the code in Sect. 11.2.7. Lines 18&ndash;23 build the Feed.tbl index and
</p>
<p>lines 39&ndash;44 build the FeedAttribType.tbl index. Once built, the indices are used when
</p>
<p>programming the query. The loop beginning on line 55 no longer contains two while
</p>
<p>loops to lookup the corresponding records in the two tables. Instead, the B-Trees are
</p>
<p>consulted to find the corresponding records in the two tables. When programmed this
</p>
<p>way, the query in Sect. 11.2.7 runs in approximately 1.628 s, three times faster than
</p>
<p>the original, non-indexed query. The sample query here uses relatively small tables.
</p>
<p>Imagine the speed up possible when either of the Feed.tbl or FeedAttribType.tbl tables
</p>
<p>contained millions of records. In that case, the original query would not have com-
</p>
<p>pleted in an acceptable amount of time while the indexed query given here would
</p>
<p>have completed in roughly the same amount of time or perhaps a second longer
</p>
<p>at worst.
</p>
<p>11.2.7 Efficient Join
</p>
<p>1 def main():
</p>
<p>2 # Select Feed.FeedNum, Feed.Name, FeedAttribType.Name, FeedAttribute.Value where
</p>
<p>3 # Feed.FeedID = FeedAttribute.FeedID and FeedAttribute.FeedAtribTypeID = FeedAttribType.ID
</p>
<p>4 attribTypeCols = ["int","char20","char60","int","int","int","int"]
</p>
<p>5 feedCols = ["int","int","int","char50","datetime","float","float","int","char50","int"]
</p>
<p>6 feedAttributeCols = ["int","int","float"]
</p>
<p>7
</p>
<p>8 feedAttributeTable = open("FeedAttribute.tbl","r")
</p>
<p>9
</p>
<p>10 if os.path.isfile("Feed.idx"):
</p>
<p>11 indexFile = open("Feed.idx","r")
</p>
<p>12 feedTableRecLength = int(indexFile.readline())
</p>
<p>13 feedIndex = eval(indexFile.readline())
</p>
<p>14 else:
</p>
<p>15 feedIndex = BTree(3)
</p>
<p>16 feedTable = open("Feed.tbl","r")
</p>
<p>17 offset = 0
</p>
<p>18 for record in feedTable:
</p>
<p>19 feedID = readField(record,feedCols,0)
</p>
<p>20 anItem = Item(feedID,offset)
</p>
<p>21 feedIndex.insert(anItem)
</p>
<p>22 offset+=1
</p>
<p>23 feedTableRecLength = len(record)
</p>
<p>24
</p>
<p>25 print("Feed Table Index Created")
</p>
<p>26 indexFile = open("Feed.idx","w")
</p>
<p>27 indexFile.write(str(feedTableRecLength)+"\n")
</p>
<p>28 indexFile.write(repr(feedIndex)+"\n")
</p>
<p>29 indexFile.close()
</p>
<p>30
</p>
<p>31 if os.path.isfile("FeedAttribType.idx"):
</p>
<p>32 indexFile = open("FeedAttribType.idx","r")
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>270 11 B-Trees
</p>
<p>33 attribTypeTableRecLength = int(indexFile.readline())
</p>
<p>34 attribTypeIndex = eval(indexFile.readline())
</p>
<p>35 else:
</p>
<p>36 attribTypeIndex = BTree(3)
</p>
<p>37 attribTable = open("FeedAttribType.tbl","r")
</p>
<p>38 offset = 0
</p>
<p>39 for record in attribTable:
</p>
<p>40 feedAttribTypeID = readField(record,attribTypeCols,0)
</p>
<p>41 anItem = Item(feedAttribTypeID,offset)
</p>
<p>42 attribTypeIndex.insert(anItem)
</p>
<p>43 offset+=1
</p>
<p>44 attribTypeTableRecLength = len(record)
</p>
<p>45
</p>
<p>46 print("Attrib Type Table Index Created")
</p>
<p>47 indexFile = open("FeedAttribType.idx","w")
</p>
<p>48 indexFile.write(str(attribTypeTableRecLength)+"\n")
</p>
<p>49 indexFile.write(repr(attribTypeIndex)+"\n")
</p>
<p>50 indexFile.close()
</p>
<p>51
</p>
<p>52 feedTable = open("Feed.tbl","rb")
</p>
<p>53 feedAttribTypeTable = open("FeedAttribType.tbl", "rb")
</p>
<p>54 before = datetime.datetime.now()
</p>
<p>55 for record in feedAttributeTable:
</p>
<p>56
</p>
<p>57 feedID = readField(record,feedAttributeCols,0)
</p>
<p>58 feedAttribTypeID = readField(record,feedAttributeCols,1)
</p>
<p>59 value = readField(record,feedAttributeCols,2)
</p>
<p>60
</p>
<p>61 lookupItem = Item(feedID,None)
</p>
<p>62 item = feedIndex.retrieve(lookupItem)
</p>
<p>63 offset = item.getValue()
</p>
<p>64 feedRecord = readRecord(feedTable,offset,feedTableRecLength)
</p>
<p>65 feedNum = readField(feedRecord,feedCols,2)
</p>
<p>66 feedName = readField(feedRecord,feedCols,3)
</p>
<p>67
</p>
<p>68 lookupItem = Item(feedAttribTypeID,None)
</p>
<p>69 item = attribTypeIndex.retrieve(lookupItem)
</p>
<p>70 offset = item.getValue()
</p>
<p>71 feedAttribTypeRecord = readRecord(feedAttribTypeTable,offset,attribTypeTableRecLength)
</p>
<p>72 feedAttribTypeName = readField(feedAttribTypeRecord,attribTypeCols,1)
</p>
<p>73
</p>
<p>74 print(feedNum,feedName,feedAttribTypeName,value)
</p>
<p>75 after = datetime.datetime.now()
</p>
<p>76 deltaT = after - before
</p>
<p>77 milliseconds = deltaT.total_seconds() * 1000
</p>
<p>78 print("Time for the query with indexing was",milliseconds,"milliseconds.")
</p>
<p>Clearly we need the functionality of a B-Tree to make queries possible and efficient
</p>
<p>in relational database joins. The next section goes on to explain the organization of
</p>
<p>a B-Tree, the advantages of B-Trees, and how they are implemented.
</p>
<p>11.3 B-Tree Organization
</p>
<p>A B-Tree is a balanced tree. Each node in a B-Tree consists of alternating pointers
</p>
<p>and items as shown in Fig. 11.5. B-Trees consist of nodes. Each node in a B-Tree
</p>
<p>contains pointers to other nodes and items in an alternating sequence. The items in a
</p>
<p>node are arranged sequentially in order of their keys. In Fig. 11.5 the key is the first
</p>
<p>value in each tuple. A pointer to the left of an item points to another B-Tree node
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.3 B-Tree Organization 271
</p>
<p>Fig. 11.5 A Sample B-Tree
</p>
<p>that contains items that are all less than the item to the right of the pointer. A pointer
</p>
<p>to the right of an item points to a node where all the items are greater than the item.
</p>
<p>In Fig. 11.5 the items in node 1 are all less than 12 while the items in node 2 are all
</p>
<p>greater than 12.
</p>
<p>B-Trees are always balanced, meaning that all the leaf nodes appear on the same
</p>
<p>level of the tree. A B-Tree may contain as many items and pointers as desired in each
</p>
<p>node. There will always be one more pointer than items in a node. B-Trees don&rsquo;t
</p>
<p>have to fill each node. The degree of a B-Tree is the minimum number of items that a
</p>
<p>B-Tree node may contain, except for the root node. The capacity of a node is always
</p>
<p>twice its degree. In Fig. 11.5 the degree is 2 and the capacity is 4.
</p>
<p>The requirements of a B-Tree are as follows:
</p>
<p>1. Every node except the root node must contain between degree and 2*degree items.
</p>
<p>2. Every node contains one more pointer than the number of items in the node.
</p>
<p>3. All leaf nodes are at the same level within a B-Tree.
</p>
<p>4. The items within a B-Tree node are ordered in ascending (or descending) order.
</p>
<p>All nodes have their items in the same order, either ascending or descending.
</p>
<p>5. The items in the subtree to the left of an item are all less than that item.
</p>
<p>6. The items in the subtree to the right of an item are all greater than that item.
</p>
<p>To maintain these properties, inserting and deleting items from the tree must be
</p>
<p>done with some care. Inserting an item can cause splitting of a node. Deleting from
</p>
<p>a tree sometimes requires rebalancing of the tree. Looking up an item in a B-Tree
</p>
<p>is performed much the same way lookup is performed in a binary search tree. The
</p>
<p>node is examined to find the item. If it is not found, then the pointer is followed that
</p>
<p>lies between the items that are less than and greater than the item to be found. If this
</p>
<p>leads to a leaf node and the item is not found in the leaf node, the item is reported as
</p>
<p>not in the tree.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>272 11 B-Trees
</p>
<p>11.4 The Advantages of B-Trees
</p>
<p>A B-Tree may contain entire records instead of just key/value pairs as appear in
</p>
<p>Fig. 11.5 where the key/value pairs are the FeedID and record number of each record
</p>
<p>in the Feed table. For instance, the entire record for FeedID 10 might be stored
</p>
<p>directly in the B-Tree where (10,0) currently appears. In the examples in this text the
</p>
<p>B-Tree and the database table are stored separately. This has the advantage that more
</p>
<p>than one B-Tree index could be built over the Feed table. The B-Tree in Fig. 11.5 is
</p>
<p>built over the FeedID field. Some other unique field might be used to build another
</p>
<p>B-Tree over the table if desired. By storing the B-Tree and the table separately,
</p>
<p>multiple indices are possible.
</p>
<p>As mentioned earlier in the chapter, B-Trees provide O(logd n) lookup time where
</p>
<p>d is the degree of the B-Tree and n is the number of items in the tree. Hash tables
</p>
<p>provide faster lookup time than a B-Tree. So why not use a hash table instead?
</p>
<p>Unlike a hash table, a B-Tree provides ordered sequential access to the index.
</p>
<p>You can iterate over the items in a B-Tree much like binary trees provide iteration.
</p>
<p>Iteration over a B-Tree provides the items or keys in ascending (or descending) order.
</p>
<p>A hash table does not provide an ordering of its keys.
</p>
<p>B-Trees provide O(log n) insert, delete, and lookup time as well. While not as
</p>
<p>efficient as hash tables in this regard, B-Trees nodes are often quite large providing
</p>
<p>a very flat tree. In this case, the time for these three operations often comes close to
</p>
<p>that of a hash table.
</p>
<p>B-Trees are often constructed with literally millions of items. When a B-Tree
</p>
<p>reaches this size, holding all the nodes in memory at one time may consume a lot of
</p>
<p>RAM. This is a great advantage of B-Trees over hash tables. A B-Tree may be stored
</p>
<p>in a file itself. Since files are randomly accessible on a disk, a B-Tree&rsquo;s node may be
</p>
<p>thought of as a record in a file. Consider the B-Tree in Fig. 11.5. The nodes 1, 2, and 3
</p>
<p>could be thought of as three records within a file. The record number are the pointer
</p>
<p>values, so to search the B-Tree it is only necessary to start with the root node in
</p>
<p>memory. Then, to search when a pointer is followed during search, the record corre-
</p>
<p>sponding to the new node is read into memory during the search. A search can proceed
</p>
<p>in this way, reading one record at a time from disk. Typically a pool of records would
</p>
<p>be held in memory for a B-Tree and records would be replaced in memory using some
</p>
<p>sort of node replacement scheme. In this way a fixed amount of RAM can be allocated
</p>
<p>to hold a B-Tree that would typically be much smaller than the total size of the tree.
</p>
<p>In addition, since a B-Tree can be stored in a file, it is not necessary to reconstruct
</p>
<p>the B-Tree each time it is needed. The code in Sect. 11.2.7 stores the B-Trees in two
</p>
<p>files named Feed.idx and FeedAttribType.idx and reads the index from the file the
</p>
<p>next time the program is run.
</p>
<p>Deleting a record from a table with a million records or more in it could be an
</p>
<p>expensive operation if the table has to be completely rewritten. If sequential access
</p>
<p>to the underlying table is handled through the B-Tree or if the entire file is stored in
</p>
<p>the nodes of the B-Tree, deletion of a row or record in the table gets much simpler.
</p>
<p>For instance, in Fig. 11.6 the feed with FeedID of 10 remains in the Feed.tbl file, but
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.4 The Advantages of B-Trees 273
</p>
<p>Fig. 11.6 A Sample B-Tree with Key 10 Deleted
</p>
<p>has been deleted from the B-Tree. If sequential access is always handled through the
</p>
<p>B-Tree, it would appear that the feed with FeedID 10 has been deleted from the table.
</p>
<p>Deleting an item from the table in this way is a O(log n) operation while deleting
</p>
<p>by rewriting the entire file would take O(n) time. When n is millions of records, the
</p>
<p>difference between O(log n) and O(n) is significant.
</p>
<p>The same goes for inserting a new row or record within the Feed table. Adding
</p>
<p>one new record to the end of a file can be done quickly, without rewriting the entire
</p>
<p>file. When a B-Tree is used the newly inserted item automatically maintains its sorted
</p>
<p>position within the file.
</p>
<p>To summarize, B-Trees have several characteristics that make them attractive to
</p>
<p>use in relational databases and for providing access to large quantities or ordered
</p>
<p>data. These properties include:
</p>
<p>&bull; Ordered sequential access over the key value on O(n) time.
</p>
<p>&bull; O(log n) insert time, while maintaining the ordering of the items.
</p>
<p>&bull; O(log n) delete time of items within the B-Tree.
</p>
<p>&bull; If sequential access is handled through the B-Tree then O(log n) delete time is
</p>
<p>provided for the underlying table as well.
</p>
<p>&bull; B-Trees can be stored in a file and B-Tree nodes can be read on an as needed basis
</p>
<p>allowing B-Trees to be larger than available memory.
</p>
<p>&bull; A B-Tree index stored in a file does not have to be rebuilt each time it is needed
</p>
<p>in a program.
</p>
<p>It is this final point that make B-Trees and their derivatives so valuable to relational
</p>
<p>database implementations. Relational databases need B-Trees and their derivative
</p>
<p>implementations to efficiently process join operations while also providing many of
</p>
<p>the advantages listed above.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>274 11 B-Trees
</p>
<p>11.5 B-Tree Implementation
</p>
<p>Looking up a value in a B-Tree is relatively simple and is left as an exercise for the
</p>
<p>reader. Inserting and deleting values are where all the action is. Alan Tharp [7] pro-
</p>
<p>vides a great discussion of both inserting and deleting values in a B-Tree. In this text
</p>
<p>we provide new examples and suggest both iterative and recursive implementations
</p>
<p>of both operations.
</p>
<p>11.6 B-Tree Insert
</p>
<p>Inserting an item in a B-Tree involves finding the leaf node which should contain the
</p>
<p>item. It may also involve splitting if no room is left in the leaf node. When a leaf node
</p>
<p>reaches its capacity, which is two times its degree and a new item is being inserted, the
</p>
<p>2*degree+1 items are sorted and the median value (i.e. the middle value) is promoted
</p>
<p>up the tree to the parent node. In this way, splitting may cascade up the tree.
</p>
<p>To see the splitting process in action, consider building the tree given in Fig. 11.5
</p>
<p>with the keys given in this order [10, 8, 22, 14, 12, 18, 2, 50, 15]. The first item to be
</p>
<p>inserted is the 10. When this occurs, the B-Tree is empty, consisting of one empty
</p>
<p>node. The (10,4) item is added into that node as shown in Fig. 11.7.
</p>
<p>The items with keys 8, 14, and 22 are inserted in a similar fashion as shown in
</p>
<p>Fig. 11.8. The node is now full. The next item to be inserted will cause a split.
</p>
<p>The next item inserted is a 12 causing the node to split into two nodes. The left
</p>
<p>subtree node is the original node. The right subtree contains the new node. The middle
</p>
<p>value, 12 in this case, is promoted up to the parent. In this case, there is no parent
</p>
<p>since we split the root node. In this special case a new root node is created to hold
</p>
<p>the promoted value. After taking these steps, the tree appears as shown in Fig. 11.9.
</p>
<p>The three values 18, 2, and 50 are inserted resulting in the tree as shown in
</p>
<p>Fig. 11.10.
</p>
<p>When 15 is inserted B-Tree node number 2 is going to split and promote the
</p>
<p>middle value, 18 in this case, up to the parent. This time there is room in the parent
</p>
<p>so the new item is added resulting in the tree shown in Fig. 11.11.
</p>
<p>Fig. 11.7 Inserting 10 into an empty B-Tree
</p>
<p>Fig. 11.8 After Inserting 8, 14, and 22
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.6 B-Tree Insert 275
</p>
<p>Fig. 11.9 After Splitting as a Result of Inserting 12
</p>
<p>Fig. 11.10 After Inserting 18, 2, and 50
</p>
<p>Fig. 11.11 Inserting 15 into the B-Tree Causes Splitting
</p>
<p>Inserting an item causes one of two possible outcomes. Either the leaf node has
</p>
<p>room in it to add the new item or the leaf node splits resulting in a middle value and
</p>
<p>a new node being promoted to the parent. This suggests a recursive implementation
</p>
<p>is appropriate for inserting a new item. The recursive algorithm is given an item to
</p>
<p>insert and returns two values, the promoted key and the new right node if there is
</p>
<p>one and proceeds as follows.
</p>
<p>1. If this is a leaf node and there is room for it, make room and store the item in the
</p>
<p>node.
</p>
<p>2. Otherwise. if this is a leaf node, make a new node. Sort the new item and old
</p>
<p>items. Choose the middle item to promote to the parent. Take the items after the
</p>
<p>middle and put them into the new node. Return a tuple of the middle item and
</p>
<p>new right node.
</p>
<p>3. If this is a non-leaf node, call insert recursively on the appropriate subtree. Consult
</p>
<p>the return value of the recursive call to see if there is a newly promoted key and
</p>
<p>right subtree. If so, take the appropriate action to store the new item and subtree
</p>
<p>pointer in the node. If there is no room to store the promoted value, split again as
</p>
<p>described in step 2.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>276 11 B-Trees
</p>
<p>Step 3 above automatically handles any cascading splits that must occur. After
</p>
<p>the recursive call the algorithm looks for any promoted value and handles it by either
</p>
<p>adding it into the node or by splitting again. An iterative version of insert would
</p>
<p>proceed in a similar manner as the recursive version except that the path to the newly
</p>
<p>inserted item would have to be maintained on a stack. Then, after inserting or splitting
</p>
<p>the leaf node, the stack of nodes on the path to the leaf would be popped one at a
</p>
<p>time, handling any promoted values, until the stack was emptied.
</p>
<p>When writing insert as a recursive function it makes sense to implement it as a
</p>
<p>method of a B-Tree node class. Then the insert method on a B-Tree class can call
</p>
<p>the recursive insert on the B-Tree node class. In this way, if the root node is split,
</p>
<p>the B-Tree insert method can deal with this by creating a new root node from the
</p>
<p>promoted value and the left and right subtrees. Recall that the old root is the new left
</p>
<p>subtree in the newly created node.
</p>
<p>11.7 B-Tree Delete
</p>
<p>Deleting from a B-Tree can be written recursively or iteratively like the insert algo-
</p>
<p>rithm. When an item is deleted from a B-Tree there may be rebalancing required.
</p>
<p>Recall that every node, except the root node, of a B-Tree must contain at least degree
</p>
<p>items. There are just a few rules that can be followed to delete items from the tree
</p>
<p>while maintaining the balance requirements.
</p>
<p>1. If the node containing the item is a leaf node and the node has more than degree
</p>
<p>items in it then the item may simply be deleted.
</p>
<p>2. If the node containing the item is a leaf node and has degree or fewer items in it
</p>
<p>before deleting the value, then rebalancing is required.
</p>
<p>3. If the node is a non-leaf node then the least value of the right subtree can replace
</p>
<p>the item in the node.
</p>
<p>Rebalancing can be accomplished in one of two ways.
</p>
<p>1. If a sibling of the unbalanced node contains more than degree items, then some
</p>
<p>of those items can be rotated into the current node.
</p>
<p>2. If no rotation from a sibling is possible, then a sibling and the unbalanced node,
</p>
<p>along with the item that separates them in the parent, can be coalesced into one
</p>
<p>node. This reduces by one the number of items in the parent which in turn may
</p>
<p>cause cascading rotations or coalescing to occur.
</p>
<p>Another example will help to illustrate the delete and rebalancing algorithm.
</p>
<p>Consider deleting the item containing 14 from the B-Tree in Fig. 11.11. This causes
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.7 B-Tree Delete 277
</p>
<p>Fig. 11.12 After Deleting the Item Containing 14
</p>
<p>Fig. 11.13 After Deleting the Item Containing 50
</p>
<p>Fig. 11.14 After Deleting the Item Containing 8
</p>
<p>the node containing 14 to become unbalanced. Rebalancing is accomplished by
</p>
<p>borrowing items from its left sibling. This is depicted in Fig. 11.12.
</p>
<p>In Fig. 11.12 notice that the 10 rotates to the parent and the item containing 12
</p>
<p>rotates into node 2 of the tree. This is necessary to maintain the ordering within
</p>
<p>the nodes. The rotation travels through the parent to redistribute the items between
</p>
<p>the two nodes. Next, consider deleting the item containing 50. In this case there
</p>
<p>is no sibling on the right and the sibling on the left doesn&rsquo;t have enough items to
</p>
<p>redistribute them. So, nodes 2 and 4 are coalesced into one node along with the item
</p>
<p>containing 18 from the root node, producing the B-Tree shown in Fig. 11.13.
</p>
<p>Next, 8 is deleted from the B-Tree. This causes a left rotation with the right sibling
</p>
<p>resulting in the B-Tree depicted in Fig. 11.14.
</p>
<p>Continuing the example assume that the item containing a key of 12 is deleted
</p>
<p>from the tree. The item is in a non-leaf node so in this case the least value from the
</p>
<p>right subtree replaces the item containing 12. This must be followed up with deleting
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>278 11 B-Trees
</p>
<p>Fig. 11.15 After Deleting the Item Containing 12
</p>
<p>Fig. 11.16 After Deleting the Item Containing 18
</p>
<p>that value, the item containing 15 in this case, from the right subtree. The result is
</p>
<p>depicted in Fig. 11.15.
</p>
<p>Deleting 18 next causes the two sibling nodes to coalesce along with the separating
</p>
<p>item in the parent (the root in this case). The result is an empty root node as shown
</p>
<p>in Fig. 11.16. In this case, the delete method in the B-Tree class must recognize this
</p>
<p>situation and update the root node pointer to point to the correct node. B-Tree node
</p>
<p>3 is no longer the root node of the B-Tree. Deleting any more of the nodes simply
</p>
<p>reduces the number of items in the root node.
</p>
<p>Again, the delete method on B-Tree nodes may be implemented recursively. The
</p>
<p>B-Tree node delete method is given the item to delete and does not need to return
</p>
<p>anything. The recursive algorithm proceeds as follows.
</p>
<p>1. If the item to delete is in the current node then we do one of two things depending
</p>
<p>on whether it is a leaf node or not.
</p>
<p>a. If the node is a leaf node, the item is deleted from the node without regard to
</p>
<p>rebalancing.
</p>
<p>b. If the node is a non-leaf node, then the smallest valued item from the right
</p>
<p>subtree replaces the item and the smallest valued item is deleted from the right
</p>
<p>subtree.
</p>
<p>2. If the item is not in the current node then delete is called recursively on the correct
</p>
<p>subtree.
</p>
<p>3. After delete returns, rebalancing of the child on the path to the deleted item may
</p>
<p>be needed. If the child node is out of balance first try rotating a value from a left
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>11.7 B-Tree Delete 279
</p>
<p>or right sibling. If that can&rsquo;t be done, then coalesce the child node with a left or
</p>
<p>right sibling.
</p>
<p>If the algorithm is implemented iteratively instead of recursively a stack is needed
</p>
<p>to keep track of the path from the root node to the node containing the item to delete.
</p>
<p>After deleting the item the stack is emptied and as each node is popped from the
</p>
<p>stack rebalancing of the child node on the path may be required as described in the
</p>
<p>steps above.
</p>
<p>11.8 Chapter Summary
</p>
<p>B-Trees are very important data structures, especially for relational databases. In
</p>
<p>order for join operations to be implemented efficiently, indices are needed over at
</p>
<p>least some tables in a relational database. B-Trees are also important because they
</p>
<p>can be stored in record format on disk meaning that the entire index does not need
</p>
<p>to be present in RAM at any one time. This means that B-Trees can be created even
</p>
<p>for tables that consist of millions of records.
</p>
<p>B-Trees have many important properties including O(log n) lookup, insert, and
</p>
<p>delete time. B-Trees always remain balanced, regardless of the order of insertions
</p>
<p>and deletions. B-Trees can also provide sequential access of records within a table
</p>
<p>in a sorted order, either ascending or descending.
</p>
<p>Due to the balance requirement in B-Trees splitting of nodes may be required
</p>
<p>during item insertion. Rebalancing of nodes may be required during item deletion.
</p>
<p>Rebalancing takes the form of rotation of items or coalescing of nodes. Rotation to
</p>
<p>redistribute items is the preferred method of rebalancing.
</p>
<p>Both the insert and delete operations may be implemented either recursively or
</p>
<p>iteratively. In either case the splitting or rebalancing may result in cascading splitting
</p>
<p>or rebalancing as the effects ripple up through the tree on the path taken to insert
</p>
<p>or delete the item. If implemented iteratively, both the insert and delete algorithms
</p>
<p>require a stack to record the path from the root node to the inserted or deleted item so
</p>
<p>that this ripple affect can be handled. In the recursive case no stack is required since the
</p>
<p>run-time stack remembers the path from the root node to the inserted or deleted item.
</p>
<p>There are derivative implementations of B-Trees that have been created. B+-Trees
</p>
<p>and B#-Trees are two other variations that are not covered in this text. Alan Tharp
</p>
<p>[7], among others, covers both these derivative implementations.
</p>
<p>11.9 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>280 11 B-Trees
</p>
<p>1. How does the use of an index improve the efficiency of the sample join operation
</p>
<p>presented in Sect. 11.2.7?
</p>
<p>2. What advantages does a B-Tree have over a hash table implementation of an
</p>
<p>index?
</p>
<p>3. What advantages does a hash table have over a B-Tree implementation of an
</p>
<p>index?
</p>
<p>4. How can a B-Tree index be created over a table with millions of records and still
</p>
<p>be usable? What challenges could this pose and how does a B-Tree provide a
</p>
<p>means to deal with those challenges?
</p>
<p>5. Starting with Fig. 11.13 insert an item with key 13 and draw a picture of the
</p>
<p>resulting B-Tree.
</p>
<p>6. Starting with Fig. 11.10 delete the item containing 12 and draw a picture of the
</p>
<p>resulting B-Tree.
</p>
<p>7. When does a node get coalesced? What does that mean? Provide a short example
</p>
<p>different from any example in the text.
</p>
<p>8. When does a rotation correct imbalance in a node? Provide a short example
</p>
<p>different from any example in the text.
</p>
<p>9. Insert the values 1 through 10 into an empty B-Tree of degree 4 to demonstrate
</p>
<p>your understanding of the insert algorithm. Draw pictures, but you can combine
</p>
<p>pictures that don&rsquo;t require splitting. At each split be sure to draw a completely
</p>
<p>new picture.
</p>
<p>10. Delete the values 7, 8 and 9 from the tree you constructed in the previous review
</p>
<p>question showing the rebalanced tree after each deletion.
</p>
<p>11.10 Programming Problems
</p>
<p>1. Write a B-Tree class and a B-Tree node class. Implement the insert and delete
</p>
<p>algorithms described in this chapter. Implement a lookup method as well. Use
</p>
<p>this implementation to efficiently run the join operation presented in Sect. 11.2.7.
</p>
<p>Compare the time this algorithm takes to run to the time the non-indexed join,
</p>
<p>from Sect. 11.2.5, takes to run. Write the two methods recursively.
</p>
<p>2. Write the B-Tree class with iterative, non-recursive, implementations of insert
</p>
<p>and delete. In this case the insert and delete methods of the B-Tree class don&rsquo;t
</p>
<p>necessarily have to call insert and delete on B-Tree nodes.
</p>
<p>3. Since the example tables in this chapter are rather small, after completing exer-
</p>
<p>cise 1 or 2, run the query code again using a dictionary for the index. Compare
</p>
<p>the amount of time taken to implement the query in this way with the B-tree
</p>
<p>implementation. Comment on the experiment results.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12Heuristic Search
</p>
<p>This text has focused on the interaction of algorithms with data structures. Many of
</p>
<p>the algorithms presented in this text deal with search and how to organize data so
</p>
<p>searching can be done efficiently. Many problems involve searching for an answer
</p>
<p>among many possible solutions, not all of which are correct. Sometimes, there are
</p>
<p>so many possibilities, no algorithm can be written that will efficiently find a correct
</p>
<p>solution amongst all the possible solutions. In these cases, we may be able to use a
</p>
<p>rule of thumb, most often called a heuristic in computer science, to eliminate some of
</p>
<p>these possibilities from our search space. If the heuristic does not eliminate possible
</p>
<p>solutions, it may at least help us order the possible solutions so we look at better
</p>
<p>possible solutions first, whatever better might mean.
</p>
<p>In Chap. 7 depth first search of a graph was presented. Sometimes search spaces for
</p>
<p>graphs or other problems grow to such an enormous size, it is impossible to blindly
</p>
<p>search for a goal node. This is where a heuristic can come in handy. This chapter
</p>
<p>uses searching a maze, which is really just a type of graph, as an example to illustrate
</p>
<p>several search algorithms that are related to depth first or breadth first search. Several
</p>
<p>applications of these search algorithms are also presented or discussed.
</p>
<p>Heuristic search is often covered in texts on Artificial Intelligence [3]. As problems
</p>
<p>in AI are better understood, algorithms arise that become more commonplace over
</p>
<p>time. The heuristic algorithms presented in this chapter are covered in more detail
</p>
<p>in an AI text, but as data sizes grow, heuristic search will become more and more
</p>
<p>necessary in all sorts of applications. AI techniques may be useful in many search
</p>
<p>problems and so are covered in this chapter to provide an introduction to search
</p>
<p>algorithms designed to deal with large or infinite search spaces.
</p>
<p>12.1 Chapter Goals
</p>
<p>By the end of this chapter you will have been presented with examples of depth first
</p>
<p>and breadth first search. Hill climbing, best first search, and the A* (pronounced A
</p>
<p>star) algorithm will also be presented. In addition, heuristics will be applied to the
</p>
<p>search in two person game playing as well.
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_12
</p>
<p>281
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
</div>
<div class="page"><p/>
<p>282 12 Heuristic Search
</p>
<p>While heuristic search is not the solution to every problem, as data sizes grow, the
</p>
<p>use of heuristics will become more important. This chapter provides the necessary
</p>
<p>information to choose between at least some of these techniques to improve perfor-
</p>
<p>mance and solve some interesting large problems that would otherwise be unsolvable
</p>
<p>in a reasonable amount of time.
</p>
<p>12.2 Depth First Search
</p>
<p>We first encountered depth first search in Chap. 6 where we discuss search spaces and
</p>
<p>using depth first search to find a solution to some sudoku puzzles. Then, in Chap. 7
</p>
<p>the depth first search algorithm was generalized a bit to handle search spaces that
</p>
<p>include cycles. To prevent getting stuck in a cycle, a visited set was used to avoid
</p>
<p>looking at vertices that had already been considered. A slightly modified version of
</p>
<p>the depth first search for graphs is presented in Sect. 12.2.1. In this version the path
</p>
<p>from the start to the goal is returned if the goal is found. Otherwise, the empty list is
</p>
<p>returned to indicate the goal was not found.
</p>
<p>12.2.1 Iterative Depth First Search of a Graph
</p>
<p>1 def graphDFS(G, start, goal):
</p>
<p>2   # G = (V,E) is the graph with vertices, V, and edges, E.
</p>
<p>3   V,E = G
</p>
<p>4   stack = Stack()
</p>
<p>5   visited = Set()
</p>
<p>6   stack.push([start]) # The stack is a stack of paths
</p>
<p>7
</p>
<p>8   while not stack.isEmpty():
</p>
<p>9     # A path is popped from the stack.
</p>
<p>10     path = stack.pop()
</p>
<p>11     current = path[0] # the last vertex in the path.
</p>
<p>12     if not current in visited:
</p>
<p>13       # The current vertex is added to the visited set.
</p>
<p>14       visited.add(current)
</p>
<p>15
</p>
<p>16       # If the current vertex is the goal vertex, then we discontinue the
</p>
<p>17       # search reporting that we found the goal.
</p>
<p>18       if current == goal:
</p>
<p>19         return path # return path to goal
</p>
<p>20
</p>
<p>21       # Otherwise, for every adjacent vertex, v, to the current vertex
</p>
<p>22       # in the graph, v is pushed on the stack of paths yet to search
</p>
<p>23       # unless v is already in the path in which case the edge
</p>
<p>24       # leading to v is ignored.
</p>
<p>25       for v in adjacent(current,E):
</p>
<p>26         if not v in path:
</p>
<p>27           stack.push([v]+path)
</p>
<p>28
</p>
<p>29   # If we get this far, then we did not find the goal.
</p>
<p>30   return [] # return an empty path
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_6">http://dx.doi.org/10.1007/978-3-319-13072-9_6</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
</div>
<div class="page"><p/>
<p>12.2 Depth First Search 283
</p>
<p>The algorithm in Sect. 12.2.1 consists of a while loop that finds a path from a start
</p>
<p>node to a goal node. When there is a choice of direction on this path, all choices
</p>
<p>are pushed onto the stack. By pushing all choices, if a path leads to a dead end, the
</p>
<p>algorithm just doesn&rsquo;t push anything new onto the stack. The next time through the
</p>
<p>loop, the next path is popped from the stack, resulting in the algorithm backtracking
</p>
<p>to a point where it last made a decision on the direction it was going.
</p>
<p>12.2.2 Maze Representation
</p>
<p>How should the maze be represented? Data representation is such an important part
</p>
<p>of any algorithm. The maze consists of rows and columns. We can think of each
</p>
<p>location in the maze as a tuple of (row, column). These tuples can be added to a
</p>
<p>hash set for lookup in O(1) time. By using a hash set we can determine the adjacent
</p>
<p>(row,column) locations in O(1) time as well for any location within the maze. When
</p>
<p>a maze is read from a file, the (row, column) pairs can be added to a hash set. The
</p>
<p>adjacent function then must be given a location and the maze hash set to determine
</p>
<p>the adjacent locations.
</p>
<p>12.2.3 DFS Example
</p>
<p>Consider searching the maze in Fig. 12.1. Let&rsquo;s assume that our depth first search
</p>
<p>algorithm prefers to go up if possible when searching a maze. If it can&rsquo;t go up, then
</p>
<p>it prefers to go down. Next preference is given to going left in the maze, followed
</p>
<p>lastly by going right. Assume we start at the top of the maze and want to exit at the
</p>
<p>bottom. Note that going on the diagonal is not considered in the examples presented
</p>
<p>in this chapter since otherwise moves where two corners in the maze meet would be
</p>
<p>Fig. 12.1 Depth First Search of a Maze
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>284 12 Heuristic Search
</p>
<p>possible. Diagonal moves would have the affect of moving through what looks like
</p>
<p>walls in the maze in some circumstances.
</p>
<p>According to our direction preference, the algorithm proceeds by making steps 1
</p>
<p>and 2 in red. Then it proceeds to travel to the left into region A. When it gets to 10 in
</p>
<p>region A, there are no possible moves adjacent to step 10 that have not already been
</p>
<p>visited. The code in lines 23&ndash;25 cannot find anything to push onto the stack.
</p>
<p>However, when step 2 was originally considered, all the other choices were pushed
</p>
<p>onto the stack including the red three that appears to the right of step 2. When nothing
</p>
<p>is pushed onto the stack while looking at step 10 in region A, the next top value on
</p>
<p>the stack is the red step 3. The unvisited nodes adjacent to the red step 3 are then
</p>
<p>pushed onto the stack. The last location pushed is the red step 4, which leads to the
</p>
<p>red step 5 being pushed and considered next. Then the depth first search proceeds to
</p>
<p>the left again, examining all the locations in region B.
</p>
<p>When region B is exhausted, backtracking occurs again, resulting in taking the red
</p>
<p>step 6. This leads to the search entering region D next, exhausting the possibilities on
</p>
<p>this path and backtracking occurring to take the search to step 12 in red. Likewise,
</p>
<p>regions E, F, and G are explored. When the search gets to red step 21 the depth first
</p>
<p>search prefers to go up and proceeds to the top of the maze and enters region H.
</p>
<p>We can tell by looking at the maze that entering region H will lead nowhere. But
</p>
<p>depth first search does not know or care about this. It just blindly considers the next
</p>
<p>possible path to the goal until that path leads to the goal or we have exhausted all
</p>
<p>possible next steps and backtrack. Backtracking out of region H leads to step 34 in
</p>
<p>red. When we reach step 44 the algorithm prefers to go down first and proceeds on a
</p>
<p>wild goose chase leading from region I to region J where it runs out of possible next
</p>
<p>steps and backtracks to the red step 44. Finally, that path leads to the goal.
</p>
<p>There are some things to notice about this search. First, as mentioned before, it
</p>
<p>was a blind search that uses backtracking to eventually find the goal. In this example
</p>
<p>the depth first search examined every location in the maze, but that is not always the
</p>
<p>case. Depth first search did find a solution, but it wasn&rsquo;t the optimal solution. If the
</p>
<p>depth first search were programmed to go right first it would have found a solution
</p>
<p>much faster and found the optimal solution for this maze. Unfortunately of course,
</p>
<p>that won&rsquo;t work for all mazes.
</p>
<p>While the maze search space is finite, what if the maze was infinite in size and
</p>
<p>we went to the left while we should have started going right? The algorithm would
</p>
<p>blindly proceed going left forever, never finding a solution. The drawbacks of depth
</p>
<p>first search are as follows.
</p>
<p>&bull; Depth first search cannot handle infinite search spaces unless it gets lucky and
</p>
<p>proceeds down a path that leads to the goal.
</p>
<p>&bull; It does not necessarily find an optimal solution.
</p>
<p>&bull; Unless we are lucky, the search order in a finite space may lead to exhaustively
</p>
<p>trying every possible path.
</p>
<p>We may be able to do better using either breadth first search or a heuristic search.
</p>
<p>Read on to see how these algorithms work.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.3 Breadth First Search 285
</p>
<p>12.3 Breadth First Search
</p>
<p>Breadth First Search was first mentioned in Chap. 7. The code for breadth first search
</p>
<p>differs in a small way from depth first search. Instead of a stack, a queue is used to
</p>
<p>store the alternative choices. The change to the code is small, but the impact on the
</p>
<p>performance of the algorithm is quite big.
</p>
<p>Depth first search goes down one path until the path leads to the goal or no
</p>
<p>more steps can be taken. When a path is exhausted and does not end at the goal,
</p>
<p>backtracking occurs. In contrast, breadth first search explores all paths from the
</p>
<p>starting location at the same time. This is because each alternative is enqueued onto
</p>
<p>the queue and then each alternative is dequeued too. This has an effect on how the
</p>
<p>search proceeds.
</p>
<p>12.3.1 BFS Example
</p>
<p>Breadth first search takes a step on each path each time through the while loop in
</p>
<p>Sect. 12.2.1. So, after step 2 in Fig. 12.1 the two step 3&rsquo;s occur next. Then the three
</p>
<p>step 4&rsquo;s occur. The three step 5&rsquo;s are next. The five step 6&rsquo;s are all done on the next
</p>
<p>five iterations of the while loop.
</p>
<p>You can see that the number of alternatives is growing in this maze. There were
</p>
<p>2 step 2&rsquo;s on up to five step 6&rsquo;s. The number of choices at each step is called the
</p>
<p>branching factor of a problem. A branching factor of one would mean that there is
</p>
<p>no choice from one step to the next. A branching factor of two means the problem
</p>
<p>doubles in size at each step.
</p>
<p>Since breadth first search takes a step in each direction at each step, a branching
</p>
<p>factor of two would be bad. A branching factor of two means the size of the search
</p>
<p>space grows exponentially (assuming no repeated states). Breadth first search is not
</p>
<p>a good search in this case unless the goal node is very near the start node.
</p>
<p>The breadth first search shown in Fig. 12.2 covers nearly as much of the maze as
</p>
<p>the blind depth first search did. Only a few locations are left unvisited. The breadth
</p>
<p>first search found the optimal solution to this maze. In fact, breadth first search will
</p>
<p>always find the optimal solution if it is given enough time.
</p>
<p>Breadth first search also deals well with infinite search spaces. Because breadth
</p>
<p>first search branches out from the source exploring all possible paths simultaneously,
</p>
<p>it will never get stuck going down some infinite path forever. It may help to visualize
</p>
<p>pouring water into the maze. The water will fill the maze from the source and find
</p>
<p>the shortest way to the goal.
</p>
<p>The advantages and disadvantages of breadth first search are as follows.
</p>
<p>&bull; Breadth first search can deal with infinite search spaces.
</p>
<p>&bull; Breadth first search will always find the optimal goal.
</p>
<p>&bull; It may not perform well at all when the problem has too high a branching factor.
</p>
<p>In fact, it may take millions of years or more to use breadth first search on some
</p>
<p>problems.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_7">http://dx.doi.org/10.1007/978-3-319-13072-9_7</a></div>
</div>
<div class="page"><p/>
<p>286 12 Heuristic Search
</p>
<p>Fig. 12.2 Breadth First Search of a Maze
</p>
<p>While it would be nice to be able to find optimal solutions to problems, breadth
</p>
<p>first search is not really all that practical to use. Most interesting problems have high
</p>
<p>enough branching factors that breadth first search is impractical.
</p>
<p>12.4 Hill Climbing
</p>
<p>Depth first search was impractical because it blindly searched for a solution. If the
</p>
<p>search is truly blind then sometimes we&rsquo;ll get lucky and find a solution quickly while
</p>
<p>other times we might not find a solution at all depending on the size of the search
</p>
<p>space, especially when there are infinite branches.
</p>
<p>If we had some more information about where the goal is, then we might be able
</p>
<p>to improve the depth first search algorithm. Think of trying to summit a mountain.
</p>
<p>We can see the peak of the mountain so we know the general direction we want to
</p>
<p>take to get there. We want to climb the hill. That&rsquo;s where the name of this algorithm
</p>
<p>comes from.
</p>
<p>Anyone who has climbed mountains knows that sometimes what appears to be a
</p>
<p>route up the mountain leads to a dead end. Sometimes what appears to be a route to
</p>
<p>the top only leads to a smaller peak close by. These false peaks are called localized
</p>
<p>maxima and hill climbing can suffer from finding a localized maximum and thinking
</p>
<p>that it is the overall goal that was sought.
</p>
<p>12.4.1 Hill Climbing Example
</p>
<p>Figure 12.3 features the same maze with hill climbing applied to the search. To climb
</p>
<p>the hill we apply a heuristic to help. In searching a maze, if we know the exit point of
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4 Hill Climbing 287
</p>
<p>Fig. 12.3 Hill Climbing Search of a Maze
</p>
<p>the maze we can employ the Manhattan distance as a heuristic to guide us towards
</p>
<p>the goal. We don&rsquo;t know the length of the path that will lead to the solution since we
</p>
<p>don&rsquo;t know all the details of the maze, but we can estimate the distance from where
</p>
<p>we are to the goal if we know the location of the goal and our current location.
</p>
<p>The Manhattan distance is a measure of the number of rows and columns that
</p>
<p>separate any two locations on a maze or map. In Fig. 12.3 the Manhattan distance
</p>
<p>from the start to the goal is 36. We have to go down one row, then right 20 columns,
</p>
<p>and down 15 rows. This distance is called the Manhattan distance because it would
</p>
<p>be like walking between buildings in Manhattan or city blocks in any city.
</p>
<p>The Manhattan distance would be either exact or an under-estimate of the total
</p>
<p>distance to the goal. In Fig. 12.3 it is an exact estimate, but in general a direct route
</p>
<p>to the goal may not be possible in which case the Manhattan distance would be an
</p>
<p>under-estimate. This is important because over-estimating the distance will mean
</p>
<p>that hill climbing will end up working like depth first search again. The heuristic
</p>
<p>would not affect the performance of the algorithm. For instance, if we took the easy
</p>
<p>approach and said that our distance was always 100 from the goal, hill climbing
</p>
<p>would not really occur.
</p>
<p>The example in Fig. 12.3 shows that the algorithm chooses to go down first if
</p>
<p>possible. Then it goes right. The goal location is known and the minimum Manhattan
</p>
<p>distance orders the choices to be explored. Going left or up is not an option unless
</p>
<p>nothing else is available. So the algorithm proceeds down and to the right until it
</p>
<p>reaches step 25 where it has no choice on this path but to go up.
</p>
<p>Hill climbing performs like depth first search in that it won&rsquo;t give up on a path
</p>
<p>until it reaches a dead end. While hill climbing does not find the optimal solution in
</p>
<p>Fig. 12.3, it does find a solution and examines far fewer locations in this case than
</p>
<p>breadth first or depth first search. The advantages and disadvantages of hill climbing
</p>
<p>are as follows.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>288 12 Heuristic Search
</p>
<p>&bull; The location of the goal must be known prior to starting the search.
</p>
<p>&bull; You must have a heuristic that can be applied that will either under-estimate or
</p>
<p>provide an exact length of the path to the goal. The better the heuristic, the better
</p>
<p>the hill climbing search algorithm.
</p>
<p>&bull; Hill climbing can perform well even in large search spaces.
</p>
<p>&bull; Hill climbing can handle infinite search branches if the heuristic can avoid them.
</p>
<p>&bull; Hill climbing may suffer from local maxima or peaks.
</p>
<p>&bull; Hill climbing may not find an optimal solution like breadth first search.
</p>
<p>To implement hill climbing the alternative choices at each step are sorted according
</p>
<p>to the heuristic before they are placed on the stack. Otherwise, the code is exactly
</p>
<p>the same as that of depth first search.
</p>
<p>12.4.2 Closed Knight&rsquo;s Tour
</p>
<p>Hill climbing can be used in solving the closed Knight&rsquo;s Tour problem. Solving this
</p>
<p>problem involves moving a knight from the game of chess around a chess board (or
</p>
<p>any size board). The knight must be moved two squares followed by one square in
</p>
<p>the perpendicular direction, forming an L on the chessboard. The closed knight tour
</p>
<p>problem is to find a path that visits every location on the board through a sequence
</p>
<p>of legal knight moves that starts and ends in the same location with no square being
</p>
<p>visited twice except the starting and ending location.
</p>
<p>Since we want to find a path through the board, the solution can be represented
</p>
<p>as a path from start to finish. Each node in the path is a move on the board. A move
</p>
<p>is valid if it is on the board and is not already in the path. In this way, the board itself
</p>
<p>never has to be explicitly built.
</p>
<p>Generating possible moves for a knight could be rather complex if you try to
</p>
<p>write code to deal with the edges of the board. In general, when adjacent nodes have
</p>
<p>to be generated and special cases occur on boundaries, it is far easier to generate a
</p>
<p>set of possibly invalid moves along with the valid moves. In the case of moving a
</p>
<p>knight around, there are eight possible moves in the general case. After generating
</p>
<p>all possible moves, the invalid moves are obvious and can be filtered out. Using this
</p>
<p>technique, boundary conditions are handled in a uniform manner once instead of
</p>
<p>with each separate possible move. The code is much cleaner and the logic is much
</p>
<p>easier to understand.
</p>
<p>Figure 12.4 provides a solution to the closed knight&rsquo;s tour problem for a 12&times; 12
</p>
<p>board. The tour starts in the lower left corner where two edges were not drawn so
</p>
<p>you can see where the tour began and ended while it was being computed. The tour
</p>
<p>took a few minutes to find using a heuristic to sort the choices of next location.
</p>
<p>A least constrained heuristic was applied to sort the new choices before adding them
</p>
<p>to the stack. The least constrained next choice was the choice that would have the
</p>
<p>most choices next. Sorting the next moves in this fashion avoids looking at paths
</p>
<p>that lead to dead ends by generally staying closer to the edges of the board where
</p>
<p>the next move has the most choices. In other words, it avoids moving to the middle
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.4 Hill Climbing 289
</p>
<p>Fig. 12.4 A Closed 12&times; 12 Knight&rsquo;s Tour
</p>
<p>and getting stuck in the middle of the board. This heuristic is not perfect and some
</p>
<p>backtracking is still required to find the solution. Nevertheless, without this heuristic
</p>
<p>there would be no hope in solving the problem in a reasonable amount of time for a
</p>
<p>12&times; 12 board. In fact, the 8&times; 8 solution can&rsquo;t be found in a reasonable amount of
</p>
<p>time with simple depth first search, unless you get lucky and search in the correct
</p>
<p>direction at each step. With the heuristic and hill climbing applied, the 8&times; 8 solution
</p>
<p>can be found in just a few seconds.
</p>
<p>12.4.3 The N-Queens Problem
</p>
<p>To solve the N-Queens problem, N queens must be placed on an N&times;N chess board
</p>
<p>so that no two queens are in the same column, row, or diagonal. Solving this using
</p>
<p>depth first search would not work. The search space is too large and you would
</p>
<p>simply have to get very lucky to find a solution using brute force.
</p>
<p>The N-Queens problem does have the unique feature that when a queen is placed
</p>
<p>on the board, all other locations in the row, column, or the diagonals it was placed in
</p>
<p>are no longer possible candidates for future moves. Removing these possible moves
</p>
<p>from the list of available locations is called forward checking. This forward checking
</p>
<p>decreases the size of the search space at each step.
</p>
<p>The choice of the next row to place a queen is another unique feature of the
</p>
<p>N-Queens problem. The solution won&rsquo;t be easier to find if a random row is picked or
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>290 12 Heuristic Search
</p>
<p>if we simply pick the next row in the sequence of rows. So the search for the solution
</p>
<p>is only what column to place the next queen in.
</p>
<p>To aide in forward checking, the board can be represented as a tuple: (queen
</p>
<p>locations, available locations). The first item in the tuple is the list of placed queens.
</p>
<p>The second item of the tuple is the list of available locations on the board. The
</p>
<p>forward checking can pick one of the available locations for the next row. At this
</p>
<p>point all locations in the second part of the tuple that conflict with the choice of
</p>
<p>the next queen placement can be eliminated. Thus forward checking removes all the
</p>
<p>possible locations that are no longer viable given a choice of placement for a queen.
</p>
<p>The hill climbing part of solving the N-Queens problem comes into play when
</p>
<p>the choice of which column to place a queen is made. The column chosen is the one
</p>
<p>that least constrains future choices. Like the Knight&rsquo;s Tour, the N-Queens problem
</p>
<p>benefits when the next choice made leaves the maximum number of choices later.
</p>
<p>Using this heuristic, forward checking, and the simple selection of the next row in
</p>
<p>which to place a queen, it is possible to solve the 25-Queens problem in a reasonable
</p>
<p>amount of time. One solution is shown in Fig. 12.5.
</p>
<p>To review, implementing hill climbing requires the alternative choices at each step
</p>
<p>be sorted according to the heuristic before they are placed on the stack. Otherwise, the
</p>
<p>code is exactly the same as that of depth first search. In some cases, like the Knight&rsquo;s
</p>
<p>Tour and the N-Queens problem, any solution is an optimal solution. But, as noted
</p>
<p>above when searching a maze, hill climbing does not necessarily find an optimal solu-
</p>
<p>tion. Wouldn&rsquo;t it be nice if we could combine breadth first search and hill climbing.
</p>
<p>Fig. 12.5 A 25-Queens Solution
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.5 Best First Search 291
</p>
<p>12.5 Best First Search
</p>
<p>So, breadth first search can find an optimal solution and deal with infinite search
</p>
<p>spaces, but it is not very efficient and can only be used in some smaller problems.
</p>
<p>Hill climbing is more efficient, but may not find an optimal solution. Combining the
</p>
<p>two we get best first search. In best first search we order the entire queue according to
</p>
<p>the distance of each current node to the goal using the same heuristic as hill climbing.
</p>
<p>12.5.1 Best First Example
</p>
<p>Consider the example in Fig. 12.6. Step 3 moves closer by moving down one row to
</p>
<p>step 4. Now, to the right of step 3 is an equally good move (actually better knowing
</p>
<p>the optimal solution), but the next step is better at step 5 than to the right of 3 because
</p>
<p>it is closer to the eventual goal. So best first proceeds down and to the right like hill
</p>
<p>climbing until it gets to step 26 in red. At this step it is forced to move up and away
</p>
<p>from the goal. In this case red step 28 looks just as good as blue step 24 along the
</p>
<p>bottom. The Manhattan distance of both is 14. When we reach red step 29 then blue
</p>
<p>step 22 in the middle of the maze looks just as good. The effect of heading away
</p>
<p>from the goal is to start search all paths simultaneously. That&rsquo;s how best first works.
</p>
<p>It explores one path while it is moving towards the goal and multiple paths when
</p>
<p>moving away from the goal.
</p>
<p>The code for best first search is a lot like breadth first except that a priority queue is
</p>
<p>used to sort the possible next steps on the queue according to their estimated distance
</p>
<p>from the goal. Best first has the advantage of considering multiple paths, like breadth
</p>
<p>first search, when heading away from the goal while performing like hill climbing
</p>
<p>when heading toward the goal.
</p>
<p>Fig. 12.6 Best First Search of a Maze
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>292 12 Heuristic Search
</p>
<p>In the example shown here we did not do better than hill climbing. Of course,
</p>
<p>that is only this example. In general hill climbing may do worse than best first. It
</p>
<p>all depends on the order that locations are searched in the search space. However,
</p>
<p>neither hill climbing or best first found the optimal solution like breadth first search.
</p>
<p>They both got stuck heading into the long path in the middle of the maze.
</p>
<p>12.6 A* Search
</p>
<p>Wouldn&rsquo;t it be nice to be able to give up on some paths if they seem too long? That&rsquo;s
</p>
<p>the idea behind the A* algorithm. In this search, the next choices are sorted by their
</p>
<p>estimate of the distance to the goal (the Manhattan distance in our maze examples)
</p>
<p>and the distance of the path so far. The effect of this is that paths are abandoned (for
</p>
<p>a while anyway) if they appear to be taking too long to reach the goal.
</p>
<p>12.6.1 A* Example
</p>
<p>In Fig. 12.7 the same path is first attempted by going down and to the right until step
</p>
<p>25 at the bottom of the maze is reached. Then that path is abandoned because the
</p>
<p>length of the path plus the Manhattan distance at step 4 in red is better than taking
</p>
<p>another step (step 26) at the bottom of the maze. Again the search goes down and to
</p>
<p>the right eventually filling the same region H from Fig. 12.1. At this point the search
</p>
<p>continues across the top to step 19 where it again goes down to step 33 at which
</p>
<p>point step 20 in red looks better than taking step 34 to the left. The search gives up
</p>
<p>on the blue path at step 33 and then proceeds to the goal from red step 20.
</p>
<p>Fig. 12.7 A-Star Search of a Maze
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.6 A* Search 293
</p>
<p>The A* algorithm finds an optimal solution in this example because it gives up
</p>
<p>on two paths that are getting too long according to the heuristic plus total cost so far.
</p>
<p>Of course the optimality of the solution depends on the heuristic and the total cost.
</p>
<p>For instance, the heuristic should be good enough to return 0 as the cost of getting
</p>
<p>from the goal to the goal. The heuristic cannot over-estimate the cost of getting to
</p>
<p>the goal from the current node.
</p>
<p>The A* algorithm was used to solve a problem in the Infinite Mario AI competition.
</p>
<p>In this competition programmers from around the world were given the task of writing
</p>
<p>code that would guide Mario through a programmable version of the Nintendo game
</p>
<p>Mario Brothers. The idea was that machine learning techniques would be employed
</p>
<p>to teach Mario to make good decisions while navigating the game&rsquo;s world. Instead
</p>
<p>of using machine learning, Robin Baumgarten solved the problem of getting Mario
</p>
<p>through the game by implementing the A* algorithm. In Robin&rsquo;s solution Mario
</p>
<p>makes choices based on the path length so far plus a heuristically computed cost
</p>
<p>to get to the goal. The A* implementation solved the problem and was a hit on the
</p>
<p>internet. You can read more about Robin&rsquo;s solution and how he developed it at http://
</p>
<p>aigamedev.com/open/interviews/mario-ai/.
</p>
<p>12.7 Minimax Revisited
</p>
<p>In Chap. 4 tictactoe was presented as a demonstration of two dimensional arrays.
</p>
<p>The outline of the minimax algorithm was presented. The minimax algorithm is
</p>
<p>used by computer games to provide a computer opponent. Minimax only applies
</p>
<p>in two person games of what is called perfect information. These are games where
</p>
<p>everyone can see everything. Poker is not a game of perfect information. Tic tac toe
</p>
<p>is a game of perfect information.
</p>
<p>The game of tic tac toe is small enough that adults can generally look far enough
</p>
<p>ahead so they never lose, unless they make a careless mistake. Children on the other
</p>
<p>hand sometimes can&rsquo;t get enough! If you don&rsquo;t have children or younger brothers and
</p>
<p>sisters, someday you will understand. Tic tac toe is also small enough to be solvable
</p>
<p>by a computer. The minimax algorithm can play the game to its conclusion to insure
</p>
<p>that it never loses, just like an adult.
</p>
<p>The game of connect four is a bit different. In this game, black and red checkers
</p>
<p>are dropped down slots in a vertically positioned board. The board is seven checkers
</p>
<p>wide by six checkers tall. Checkers always drop as far down as possible so there
</p>
<p>are at most seven choices at each turn in the game. The goal is to get four of your
</p>
<p>checkers in a row, a column, or on a diagonal. In Fig. 12.8 the computer has won
</p>
<p>with the four black checkers on the diagonal.
</p>
<p>Playing connect four is not as easy as playing tic tac toe. With a branching factor
</p>
<p>of approximately seven at each turn, the number of possible boards quickly grows
</p>
<p>past what can be considered exhaustively in a reasonable amount of time. In these
</p>
<p>situations a heuristic must be added to the minimax algorithm to cut off the search.
</p>
<p>The algorithm is not repeated here. See Sect. 4.9 for a complete description of the
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://aigamedev.com/open/interviews/mario-ai/">http://aigamedev.com/open/interviews/mario-ai/</a></div>
<div class="annotation"><a href="http://aigamedev.com/open/interviews/mario-ai/">http://aigamedev.com/open/interviews/mario-ai/</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_4">http://dx.doi.org/10.1007/978-3-319-13072-9_4</a></div>
</div>
<div class="page"><p/>
<p>294 12 Heuristic Search
</p>
<p>Fig. 12.8 The Connect Four Game
</p>
<p>algorithm. The base cases for minimax are then modified as follows to incorporate
</p>
<p>the search cutoff heuristic.
</p>
<p>1. The current board is a win for the computer. In that case minimax returns a 1 for
</p>
<p>a computer win.
</p>
<p>2. The current board is a win for the human. In that case minimax returns a &minus;1 for
</p>
<p>a human win.
</p>
<p>3. The current board is full. In that case, since neither human or computer won,
</p>
<p>minimax returns a 0.
</p>
<p>4. The maximum depth has been reached. Evaluate the board with no more search
</p>
<p>and report a number between &minus;1.0 and 1.0. A negative value indicates the human
</p>
<p>is more likely to win given this board. A positive value indicates the computer is
</p>
<p>more likely to win.
</p>
<p>To implement this last base case for the algorithm, a new depth parameter is passed
</p>
<p>to the minimax algorithm and possibly some other parameters as well. Early in a
</p>
<p>game the maximum depth may not be very deep. However, later in a game, when
</p>
<p>less choices are available, the maximum depth may be deeper. Increasing the depth
</p>
<p>of search is the best way to improve the computer&rsquo;s ability to win at games like this.
</p>
<p>A good heuristic can also help in earlier stages of the game when deeper search is
</p>
<p>not possible. Coming up with a good heuristic is a challenge. The trick is to keep
</p>
<p>it relatively simple to compute while encouraging moves in some fashion on the
</p>
<p>board.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>12.7 Minimax Revisited 295
</p>
<p>We have developed a connect four implementation based on these ideas that
</p>
<p>runs on standard hardware without any special multiprocessing. Our version beats
</p>
<p>all commercially available apps and applications presently available when playing
</p>
<p>against them. Your challenge, should you care to take it on, is to build a better one.
</p>
<p>A front-end for this game is available in Sect. 20.6 or on the text&rsquo;s website so you
</p>
<p>can build your own connect four game.
</p>
<p>12.8 Chapter Summary
</p>
<p>This chapter covered heuristics and how they play a part in problems when the
</p>
<p>search space grows too large for an exhaustive search. Many problems that would
</p>
<p>otherwise be unsolvable are solvable when heuristics are applied. However, the nature
</p>
<p>of a heuristic is that sometimes they work well and other times they may not. If a
</p>
<p>heuristic worked every time, it would be called a technique and not a heuristic.
</p>
<p>We must think carefully about whether heuristic search is really required or not
</p>
<p>when solving problems. Choosing the right problem representation, data structure,
</p>
<p>or algorithm is much more important than a brute force approach and applying a
</p>
<p>heuristic. It may be that a problem that seems too big to solve can be reduced to
</p>
<p>something that can be solved by the right algorithm. When there is no such reduction
</p>
<p>possible, heuristic search may be the answer.
</p>
<p>The search algorithms hill climbing, best first, and A* are best remembered by
</p>
<p>comparing their algorithms to depth first search and breadth first search. Hill climbing
</p>
<p>is like depth first search except that a heuristic is applied to order the newly added
</p>
<p>nodes to the stack. Best first is like breadth first search except that all the nodes on the
</p>
<p>queue are ordered according to the heuristic. It is often implemented with a priority
</p>
<p>queue. The A* algorithm is like best first except that the queue is ordered by the sum
</p>
<p>of the heuristically estimated distance to the goal plus the distance travelled so far.
</p>
<p>The minimax algorithm too uses a heuristic when the search space is too large. An
</p>
<p>effective game engine will always search as deep as possible, but when the search
</p>
<p>must be cut off, a good heuristic will help in estimating the worth of a move in the
</p>
<p>game.
</p>
<p>12.9 Review Questions
</p>
<p>Answer these short answer, multiple choice, and true/false questions to test your
</p>
<p>mastery of the chapter.
</p>
<p>1. Which is faster, depth first search or breadth first search?
</p>
<p>2. Which search, depth first or breadth first, may not complete in some situations?
</p>
<p>When could that happen?
</p>
<p>3. When hill climbing, what could prevent the algorithm from finding a goal node?
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>296 12 Heuristic Search
</p>
<p>4. Will the best first search algorithm find an optimal solution? Why or why not?
</p>
<p>5. Will the A* algorithm find an optimal solution? Why or why not?
</p>
<p>6. When would hill climbing be better to use than the A* algorithm?
</p>
<p>7. What is forward checking and how does that help solve a problem?
</p>
<p>8. Describe what happens in the depth first search algorithm when backtracking
</p>
<p>occurs. Be specific about how the algorithm behaves at the point when back-
</p>
<p>tracking occurs in Sect. 12.2.1.
</p>
<p>9. Name a game that cannot use the minimax algorithm other than poker.
</p>
<p>10. What is the best way to insure that minimax behaves as desired: a really good
</p>
<p>heuristic or deeper search?
</p>
<p>12.10 Programming Problems
</p>
<p>1. Write a program that uses the five search algorithms in this chapter to search a
</p>
<p>maze as shown in the examples. Construct sample mazes by writing a text file
</p>
<p>where each space represents an open location in the maze and each non-space
</p>
<p>character represents a wall in the maze. Start the maze with the number of rows
</p>
<p>and columns of the maze on the first two lines of the file. Assume that you search
</p>
<p>the maze from top to bottom to find a way through it. There should be only one
</p>
<p>entry and one exit from your maze. Compare and contrast the different algorithms
</p>
<p>and their performance on your sample mazes. Be sure to download the maze
</p>
<p>searching front-end from the text&rsquo;s website so you can visualize your results. The
</p>
<p>architecture for communication between the front-end and your back-end code
</p>
<p>is provided in the front-end program file.
</p>
<p>2. Write a program to solve the Knight&rsquo;s Tour problem. Be sure to use a heuristic in
</p>
<p>your search to narrow the search space. Make sure you can solve the tour quickly
</p>
<p>for an 8&times; 8 board. Draw your solution using turtle graphics.
</p>
<p>3. Write a program to solve the N-Queens problem. Use forward checking and a
</p>
<p>heuristic to solve the N-Queens problem for an 8&times; 8 board. For an extra challenge
</p>
<p>try to solve it for a 25&times; 25 board. The program will likely need to run for a while (a
</p>
<p>half hour?) to solve this one. Be sure to use the N-Queens front-end code provided
</p>
<p>on the text&rsquo;s website to visualize your result. The back-end code you write should
</p>
<p>follow the architecture presented at the top of the front-end program file.
</p>
<p>4. Write the connect four program to challenge another student&rsquo;s connect four. You
</p>
<p>both must write programs that have a pass button. A flip of a coin can determine
</p>
<p>who goes first. The one who goes first should begin by pressing their pass button.
</p>
<p>Then you and the other student can flip back and forth while your computer pro-
</p>
<p>grams compete. To keep things moving, your game must make a move within 30 s
</p>
<p>or it forfeits. You can use the front-end code presented in Sect. 20.6 as your front-
</p>
<p>end. You must write the back-end code. Follow the architecture to communicate
</p>
<p>with the front-end code presented at the top of the front-end program file.
</p>
<p>5. For an extra challenge, write the connect four program and beat the program
</p>
<p>provided by the authors on text website. To run the author&rsquo;s code you must have
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://dx.doi.org/10.1007/978-3-319-13072-9_20">http://dx.doi.org/10.1007/978-3-319-13072-9_20</a></div>
</div>
<div class="page"><p/>
<p>12.10 Programming Problems 297
</p>
<p>Python version 3 and Common Lisp installed. Both the front-end code and the
</p>
<p>author&rsquo;s back-end code must be in the same directory or folder to run the author&rsquo;s
</p>
<p>version of the program. You can get the author&rsquo;s front-end and back-end code
</p>
<p>from the text&rsquo;s website.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>13Appendix A: Integer Operators
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing help(int) in the Python shell. In this documentation the variables x, y, and z
</p>
<p>refer to integers. The official Python 3 documentation is at http://docs.python.org/3/.
</p>
<p>Operator Returns Comments
</p>
<p>x+y int Returns the sum of x and y
</p>
<p>x&minus;y int Returns the difference of x and y
</p>
<p>x*y int Returns the product of x and y
</p>
<p>x/y float Returns the quotient of x divided by y
</p>
<p>x//y int Returns the integer quotient of x divided by y
</p>
<p>x%y int Returns x modulo y. This is the remainder of dividing
</p>
<p>x by y
</p>
<p>&minus;x int Returns the negation of x
</p>
<p>x&amp;y int Returns the bit-wise and of x and y
</p>
<p>x|y int Returns the bit-wise or of x and y
</p>
<p>xy int Returns the bit-wise exclusive or of x and y
</p>
<p>x&lt;&lt;y int Returns a bit-wise shift left of x by y bits. Shifting left
by 1 bit multiplies x by 2
</p>
<p>x&gt;&gt;y int Returns a bit-wise right shift of x by y bits
</p>
<p>Ëœx int Returns an integer where each bit in the x has been
inverted. x + x = &minus;1 for all x
</p>
<p>abs(x) int Returns the absolute value of x
</p>
<p>divmod(x, y) (q,r) Returns the quotient q and the remainder r as a tuple
</p>
<p>float(x) float Returns the float representation of x
</p>
<p>hex(x) str Returns a hexadecimal representation of x as a string
</p>
<p>int(x) int Returns x
</p>
<p>oct(x) str Return an octal representation of x as a string
</p>
<p>pow(x, y[, z]) int Returns x to the y power modulo z. If z is not
</p>
<p>specified then it returns x to the y power
</p>
<p>repr(x) str Returns a string representation of x
</p>
<p>str(x) str Returns a string representation of x
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_13
</p>
<p>299
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>14Appendix B: Float Operators
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing help(float) in the Python shell. In this documentation at least one of the vari-
</p>
<p>ables x and y refer to floats. The official Python 3 documentation is at http://docs.
</p>
<p>python.org/3/.
</p>
<p>Operator Returns Comments
</p>
<p>x+y float Returns the sum of x and y
</p>
<p>x&minus;y float Returns the difference of x and y
</p>
<p>x*y float Returns the product of x and y
</p>
<p>x/y float Returns the quotient of x divided by y
</p>
<p>x//y float Returns the quotient of integer division of x divided
</p>
<p>by y. However, the result is still a float
</p>
<p>x%y float Returns x modulo y. This is the remainder of dividing
</p>
<p>x by y
</p>
<p>abs(x) int Returns the absolute value of x
</p>
<p>divmod(x, y) (q,r) Returns the quotient q and the remainder r as a tuple.
</p>
<p>Both q and r are floats, but integer division is
</p>
<p>performed. The value r is the whole and fractional
</p>
<p>part of any remainder. The value q is a whole number
</p>
<p>float(x) float Returns the float representation of x
</p>
<p>int(x) int Returns the floor of x as an integer
</p>
<p>pow(x, y) float Returns x to the y power
</p>
<p>repr(x) str Returns a string representation of x
</p>
<p>str(x) str Returns a string representation of x
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_14
</p>
<p>301
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>15Appendix C: String Operators andMethods
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing help(str) in the Python shell. In the documentation found here the variables s
</p>
<p>and t are references to strings. The official Python 3 documentation is at http://docs.
</p>
<p>python.org/3/.
</p>
<p>Method Returns Comments
</p>
<p>s+t str Return a new string which is the concatenation of s and t
</p>
<p>s in t bool Returns True if s is a substring of t and False otherwise
</p>
<p>s==t bool Returns True if s and t refer to strings with the same sequence of
</p>
<p>characters
</p>
<p>s&gt;=t bool Returns True if s is lexicographically greater than or equal to t
</p>
<p>s&lt;=t bool Returns True if s is lexicographically less than or equal to t
</p>
<p>s&gt;t bool Returns True if s is lexicographically greater than t
</p>
<p>s&lt;t bool Returns True if s is lexicographically less than t
</p>
<p>s!=t bool Returns True if s is lexicographically not equal to t
</p>
<p>s[i] str Returns the character at index i in the string. If i is negative then it
</p>
<p>returns the character at index len(s)&minus;i
</p>
<p>s[[i]:[j]] str Returns the slice of characters starting at index i and extending to index
</p>
<p>j&minus;1 in the string. If i is omitted then the slice begins at index 0. If j is
</p>
<p>omitted then the slice extends to the end of the list. If i is negative then it
</p>
<p>returns the slice starting at index len(s)+ i (and likewise for the slice
</p>
<p>ending at j)
</p>
<p>s &lowast; i str Returns a new string with s repeated i times
</p>
<p>i &lowast; s str Returns a new string with s repeated i times
</p>
<p>chr(i) str Return the ASCII character equivalent of the integer i
</p>
<p>float(s) float Returns the float contained in the string s
</p>
<p>int(s) int Returns the integer contained in the string s
</p>
<p>len(s) int Returns the number of characters in s
</p>
<p>ord(s) int Returns the ASCII decimal equivalent of the single character string s
</p>
<p>repr(s) Returns a string representation of s. This adds an extra pair of quotes to s
</p>
<p>str(s) str Returns a string representation of s. In this case you get just the string s
</p>
<p>s.capitalize() str Returns a copy of the string s with the first character upper case
</p>
<p>(continued)
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_15
</p>
<p>303
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>304 15 Appendix C: String Operators and Methods
</p>
<p>(continued)
</p>
<p>Method Returns Comments
</p>
<p>s.center(width[, fillchar]) str Returns s centered in a string of length width.
</p>
<p>Padding is done using the specified fill character
</p>
<p>(default is a space)
</p>
<p>s.count(sub[, start[, end]]) int Returns the number of non-overlapping
</p>
<p>occurrences of substring sub in string s[start:end].
</p>
<p>Optional arguments start and end are interpreted
</p>
<p>as in slice notation
</p>
<p>s.encode([encoding[, errors]]) bytes Encodes s using the codec registered for
</p>
<p>encoding. Encoding defaults to the default
</p>
<p>encoding. Errors may be given to set a different
</p>
<p>error handling scheme. Default is &lsquo;strict&rsquo; meaning
</p>
<p>that encoding errors raise a UnicodeEncodeError.
</p>
<p>Other possible values are &lsquo;ignore&rsquo;, &lsquo;replace&rsquo; and
</p>
<p>&lsquo;xmlcharrefreplace&rsquo; as well as any other name
</p>
<p>registered with codecs.register_error that can
</p>
<p>handle UnicodeEncodeErrors
</p>
<p>s.endswith(suffix[, start[, end]]) bool Returns True if s ends with the specified suffix,
</p>
<p>False otherwise. With optional start, test s
</p>
<p>beginning at that position. With optional end, stop
</p>
<p>comparing s at that position. Suffix can also be a
</p>
<p>tuple of strings to try
</p>
<p>s.expandtabs([tabsize]) str Returns a copy of s where all tab characters are
</p>
<p>expanded using spaces. If tabsize is not given, a
</p>
<p>tab size of 8 characters is assumed
</p>
<p>s.find(sub[, start[, end]]) int Returns the lowest index in s where substring sub
</p>
<p>is found, such that sub is contained within
</p>
<p>s[start:end]. Optional arguments start and end are
</p>
<p>interpreted as in slice notation
</p>
<p>Return &minus;1 on failure
</p>
<p>s.format(*args, **kwargs) str
</p>
<p>s.index(sub[, start[, end]]) int Like s.find() but raise ValueError when the
</p>
<p>substring is not found
</p>
<p>s.isalnum() bool Returns True if all characters in s are
</p>
<p>alphanumeric and there is at least one character in
</p>
<p>s, False otherwise
</p>
<p>s.isalpha() bool Returns True if all characters in s are alphabetic
</p>
<p>and there is at least one character in s, False
</p>
<p>otherwise
</p>
<p>s.isdecimal() bool Returns True if there are only decimal characters
</p>
<p>in s, False otherwise
</p>
<p>s.isdigit() bool Returns True if all characters in s are digits and
</p>
<p>there is at least one character in s, False otherwise
</p>
<p>s.isidentifier() bool Returns True if s is a valid identifier according to
</p>
<p>the language definition
</p>
<p>s.islower() bool Returns True if all cased characters in s are
</p>
<p>lowercase and there is at least one cased character
</p>
<p>in s, False otherwise
</p>
<p>(continued)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>15 Appendix C: String Operators and Methods 305
</p>
<p>(continued)
</p>
<p>Method Returns Comments
</p>
<p>s.isnumeric() bool Returns True if there are only numeric characters in s,
</p>
<p>False otherwise
</p>
<p>s.isprintable() bool Returns True if all characters in s are considered
</p>
<p>printable in repr() or s is empty, False otherwise
</p>
<p>s.isspace() bool Returns True if all characters in s are whitespace and
</p>
<p>there is at least one character in s, False otherwise
</p>
<p>s.istitle() bool Returns True if s is a titlecased string and there is at
</p>
<p>least one character in s, i.e. upper- and titlecase
</p>
<p>characters may only follow uncased characters and
</p>
<p>lowercase characters only cased ones. Return False
</p>
<p>otherwise
</p>
<p>s.isupper() bool Returns True if all cased characters in s are uppercase
</p>
<p>and there is at least one cased character in s, False
</p>
<p>otherwise
</p>
<p>s.join(sequence) str Returns a string which is the concatenation of the
</p>
<p>strings in the sequence. The separator between
</p>
<p>elements is s
</p>
<p>s.ljust(width[, fillchar]) str Returns s left-justified in a Unicode string of length
</p>
<p>width. Padding is done using the specified fill
</p>
<p>character (default is a space)
</p>
<p>s.lower() str Returns a copy of the string s converted to lowercase
</p>
<p>s.lstrip([chars]) str Returns a copy of the string s with leading whitespace
</p>
<p>removed. If chars is given and not None, remove
</p>
<p>characters in chars instead
</p>
<p>s.partition(sep) (h,sep,t) Searches for the separator sep in s, and returns the part
</p>
<p>before it, the separator itself, and the part after it. If the
</p>
<p>separator is not found, returns s and two empty strings
</p>
<p>s.replace (old, new[, count]) str Returns a copy of s with all occurrences of substring
</p>
<p>old replaced by new. If the optional argument count is
</p>
<p>given, only the first count occurrences are replaced
</p>
<p>s.rfind(sub[, start[, end]]) int Returns the highest index in s where substring sub is
</p>
<p>found, such that sub is contained within s[start:end].
</p>
<p>Optional arguments start and end are interpreted as in
</p>
<p>slice notation
</p>
<p>Returns &minus;1 on failure
</p>
<p>s.rindex(sub[, start[, end]]) int Like s.rfind() but raise ValueError when the substring
</p>
<p>is not found
</p>
<p>s.rjust(width[, fillchar]) str Returns s right-justified in a string of length width.
</p>
<p>Padding is done using the specified fill character
</p>
<p>(default is a space)
</p>
<p>s.rpartition(sep) (t,sep,h) Searches for the separator sep in s, starting at the end
</p>
<p>of s, and returns the part before it, the separator itself,
</p>
<p>and the part after it. If the separator is not found,
</p>
<p>returns two empty strings and s
</p>
<p>(continued)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>306 15 Appendix C: String Operators and Methods
</p>
<p>(continued)
</p>
<p>Method Returns Comments
</p>
<p>s.rsplit([sep[, maxsplit]]) string list Returns a list of the words in s, using sep as the
</p>
<p>delimiter string, starting at the end of the string and
</p>
<p>working to the front. If maxsplit is given, at most
</p>
<p>maxsplit splits are done. If sep is not specified, any
</p>
<p>whitespace string is a separator
</p>
<p>s.rstrip([chars]) str Returns a copy of the string s with trailing
</p>
<p>whitespace removed. If chars is given and not
</p>
<p>None, removes characters in chars instead
</p>
<p>s.split([sep[, maxsplit]]) string list Returns a list of the words in s, using sep as the
</p>
<p>delimiter string. If maxsplit is given, at most
</p>
<p>maxsplit splits are done. If sep is not specified or is
</p>
<p>None, any whitespace string is a separator and
</p>
<p>empty strings are removed from the result
</p>
<p>s.splitlines([keepends]) string list Returns a list of the lines in s, breaking at line
</p>
<p>boundaries. Line breaks are not included in the
</p>
<p>resulting list unless keepends is given and true
</p>
<p>s.startswith(prefix[, start[, end]]) bool Returns True if s starts with the specified prefix,
</p>
<p>False otherwise. With optional start, test s
</p>
<p>beginning at that position. With optional end, stop
</p>
<p>comparing s at that position. prefix can also be a
</p>
<p>tuple of strings to try
</p>
<p>s.strip([chars]) str Returns a copy of the string s with leading and
</p>
<p>trailing whitespace removed. If chars is given and
</p>
<p>not None, removes characters in chars instead
</p>
<p>s.swapcase() str Returns a copy of s with uppercase characters
</p>
<p>converted to lowercase and vice versa
</p>
<p>s.title() str Returns a titlecased version of s, i.e. words start
</p>
<p>with title case characters, all remaining cased
</p>
<p>characters have lower case
</p>
<p>s.translate(table) str Returns a copy of the string s, where all characters
</p>
<p>have been mapped through the given translation
</p>
<p>table, which must be a mapping of Unicode
</p>
<p>ordinals to Unicode ordinals, strings, or None.
</p>
<p>Unmapped characters are left untouched.
</p>
<p>Characters mapped to None are deleted
</p>
<p>s.upper() str Returns a copy of s converted to uppercase
</p>
<p>s.zfill(width) str Pad a numeric string s with zeros on the left, to fill
</p>
<p>a field of the specified width. The string s is never
</p>
<p>truncated
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>16Appendix D: List Operators andMethods
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing help(list) in the Python shell. In the documentation found here the vari-
</p>
<p>ables x and y are references to lists. The official Python 3 documentation is at
</p>
<p>http://docs.python.org/3/.
</p>
<p>Method Returns Comments
</p>
<p>list() list Returns a new empty list. You can also use [ ] to initialize a new
</p>
<p>empty list
</p>
<p>list(sequence) list Returns new list initialized from sequence&rsquo;s items
</p>
<p>[ item [,item]+ ] list Writing a number of comma-separated items in square brackets
</p>
<p>constructs a new list of those items
</p>
<p>x+y list Returns a new list containing the concatenation of the items in x
</p>
<p>and y
</p>
<p>e in x bool Returns True if the item e is in x and False otherwise
</p>
<p>del x[i] Deletes the item at index i in x. This is not an expression and
</p>
<p>does not return a value
</p>
<p>x==y bool Returns True if x and y contain the same number of items and
</p>
<p>each of those corresponding items are pairwise equal
</p>
<p>x&gt;=y bool Returns True if x is greater than or equal to y according to a
</p>
<p>lexicographical ordering of the elements in x and y. If x and y
</p>
<p>have different lengths their items are == up to the shortest
</p>
<p>length, then this returns True if x is longer than y
</p>
<p>x&lt;=y bool Returns True if x is lexicographically before y or equal to y and
</p>
<p>False otherwise
</p>
<p>x&gt;y bool Returns True if x is lexicographically after y and False otherwise
</p>
<p>x&lt;y bool Returns True if x is lexicographically before y and False
</p>
<p>otherwise
</p>
<p>x!=y bool Returns True if x and y are of different length or if some item of
</p>
<p>x is not == to some item of y. Otherwise it returns False
</p>
<p>x[i] item Returns the item at index i of x
</p>
<p>(continued)
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_16
</p>
<p>307
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>308 16 Appendix D: List Operators and Methods
</p>
<p>(continued)
</p>
<p>Method Returns Comments
</p>
<p>x[[i]:[j]] list Returns the slice of items starting at index i and extending to
</p>
<p>index j&minus;1 in the string. If i is omitted then the slice begins at
</p>
<p>index 0. If j is omitted then the slice extends to the end of the list.
</p>
<p>If i is negative then it returns the slice starting at index len(x)+i
</p>
<p>(and likewise for the slice ending at j)
</p>
<p>x[i]=e Assigns the position at index i the value of e in x. The list x must
</p>
<p>already have an item at index i before this assignment occurs. In
</p>
<p>other words, assigning an item to a list in this way will not
</p>
<p>extend the length of the list to accommodate it
</p>
<p>x+=y This mutates the list x to append the items in y
</p>
<p>x*=i This mutates the list x to be i copies of the original x
</p>
<p>iter(x) iterator Returns an iterator over x
</p>
<p>len(x) int Returns the number of items in x
</p>
<p>x*i list Returns a new list with the items of x repeated i times
</p>
<p>i*x list Returns a new list with the items of x repeated i times
</p>
<p>repr(x) str Returns a string representation of x
</p>
<p>x.append(e) None This mutates the value of x to add e as its last element. The
</p>
<p>function returns None, but the return value is irrelevant since it
</p>
<p>mutates x
</p>
<p>x.count(e) int Returns the number of occurrences of e in x by using == equality
</p>
<p>x.extend(iter) None Mutates x by appending elements from the iterable, iter
</p>
<p>x.index(e,[i,[j]]) int Returns the first index of an element that == e between the the
</p>
<p>start index, i, and the stop index, j&minus;1. It raises ValueError if the
</p>
<p>value is not present in the specified sequence. If j is omitted then
</p>
<p>it searches to the end of the list. If i is omitted then it searches
</p>
<p>from the beginning of the list
</p>
<p>x.insert(i, e) None Insert e before index i in x, mutating x
</p>
<p>x.pop([index]) item Remove and return the item at index. If index is omitted then the
</p>
<p>item at len(x)&minus;1 is removed. The pop method returns the item
</p>
<p>and mutates x. It raises IndexError if list is empty or index is out
</p>
<p>of range
</p>
<p>x.remove(e) None remove first occurrence of e in x, mutating x. It raises ValueError
</p>
<p>if the value is not present
</p>
<p>x.reverse() None Reverses all the items in x, mutating x
</p>
<p>x.sort() None Sorts all the items of x according to their natural ordering as
</p>
<p>determined by the item&rsquo;s __cmp__ method, mutating x. Two
</p>
<p>keyword parameters are possible: key and reverse. If
</p>
<p>reverse=True is specified, then the result of sorting will have the
</p>
<p>list in reverse of the natural ordering. If key=f is specified then f
</p>
<p>must be a function that takes an item of x and returns the value
</p>
<p>of that item that should be used as the key when sorting
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>17Appendix E: Dictionary Operators andMethods
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing help(dict) in the Python shell. In the documentation found here the variable
</p>
<p>D is a reference to a dictionary. A few methods were omitted here for brevity. The
</p>
<p>official Python 3 documentation is at http://docs.python.org/3/.
</p>
<p>Method Returns Comments
</p>
<p>dict() dict new empty dictionary
</p>
<p>dict(mapping) dict new dictionary initialized from a mapping object&rsquo;s (key, value) pairs
</p>
<p>dict(seq) dict new dictionary initialized as if via:
</p>
<p>D = {}
</p>
<p>for k, v in seq:
</p>
<p>D[k] = v
</p>
<p>dict(**kwargs) dict new dictionary initialized with the name=value pairs
</p>
<p>in the keyword arg list. For example: dict(one=1, two=2)
</p>
<p>k in D bool True if D has key k, else False
</p>
<p>del D[k] Deletes key k from dictionary D
</p>
<p>D1==D2 bool Returns True if dictionaries D1 and D2 have same keys mapped to
</p>
<p>same values
</p>
<p>D[k] value Returns value k maps to in D. If k is not mapped, it
</p>
<p>type raises a KeyError exception
</p>
<p>iter(D) iterator Returns an iterator over D
</p>
<p>len(D) int Returns the number of keys in D
</p>
<p>D1!=D2 bool Returns True if D1 and D2 have any different keys or keys map to
</p>
<p>different values
</p>
<p>repr(D) str Returns a string representation of D
</p>
<p>D[k]=e Stores the key, value pair k,e in D
</p>
<p>D.clear() None Remove all items from D
</p>
<p>D.copy() dict a shallow copy of D
</p>
<p>D.get(k[,e]) value D[k] if k in D, else e. e defaults to None
</p>
<p>type
</p>
<p>D.items() items a set-like object providing a view on D&rsquo;s items
</p>
<p>(continued)
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_17
</p>
<p>309
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>310 17 Appendix E: Dictionary Operators and Methods
</p>
<p>(continued)
</p>
<p>Method Returns Comments
</p>
<p>D.keys() keys a set-like object providing a view on D&rsquo;s keys
</p>
<p>D.pop(k[,e]) v remove specified key and return the corresponding value. If
</p>
<p>key is not found, e is returned if given, otherwise KeyError is
</p>
<p>raised
</p>
<p>D.popitem() (k, v) remove and return some (key, value) pair as a 2-tuple; but
</p>
<p>raise KeyError if D is empty
</p>
<p>D.setdefault(k[,e]) D.get(k,e) Returns D.get(k,e) and also sets d[k]=e if k not in D
</p>
<p>D.update(E, **F) None Update D from dict/iterable E and F
</p>
<p>If E has a .keys() method, does: for k in E: D[k] = E[k]
</p>
<p>If E lacks .keys() method, does: for (k, v) in E: D[k] = v
</p>
<p>In either case, this is followed by: for k in F: D[k] = F[k]
</p>
<p>D.values() values an object providing a view on D&rsquo;s values
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18Appendix F:Turtle Methods
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing
</p>
<p>from turt le import &lowast;
</p>
<p>help (Turtle )
</p>
<p>in the Python shell. In the documentation found here the variable turtle is a reference
</p>
<p>to a Turtle object. This is a subset of that documentation. The official Python 3
</p>
<p>documentation is at http://docs.python.org/3/.
</p>
<p>Method Description
</p>
<p>turtle.back(distance)
</p>
<p>Aliases: backward bk
</p>
<p>Argument:
</p>
<p>distance &ndash; a number
</p>
<p>Move the turtle backward by distance, opposite to the direction the
</p>
<p>turtle is headed. Do not change the turtle&rsquo;s heading.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(0.00, 0.00)
</p>
<p>&gt;&gt;&gt; turtle.backward(30)
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(&minus;30.00, 0.00)
</p>
<p>turtle.begin_fill()
</p>
<p>Called just before drawing a shape to be filled.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.color("black","red")
</p>
<p>&gt;&gt;&gt; turtle.begin_fill()
</p>
<p>&gt;&gt;&gt; turtle.circle(60)
</p>
<p>&gt;&gt;&gt;turtle.end_fill()
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_18
</p>
<p>311
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>312 18 Appendix F:Turtle Methods
</p>
<p>Method Description
</p>
<p>turtle.begin_poly()
</p>
<p>Start recording the vertices of a polygon. Current turtle position
</p>
<p>is first point of polygon.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.begin_poly()
</p>
<p>turtle.circle(radius, extent=None, steps=None)
</p>
<p>Arguments:
</p>
<p>radius &ndash; a number
</p>
<p>extent (optional) &ndash; a number
</p>
<p>steps (optional) &ndash; an integer
</p>
<p>Draw a circle with given radius. The center is radius units left
</p>
<p>of the turtle; extent - an angle - determines which part of the
</p>
<p>circle is drawn. If extent is not given, draw the entire circle.
</p>
<p>If extent is not a full circle, one endpoint of the arc is the
</p>
<p>current pen position. Draw the arc in counterclockwise direction
</p>
<p>if radius is positive, otherwise in clockwise direction. Finally
</p>
<p>the direction of the turtle is changed by the amount of extent.
</p>
<p>As the circle is approximated by an inscribed regular polygon,
</p>
<p>steps determines the number of steps to use. If not given,
</p>
<p>it will be calculated automatically. Maybe used to draw regular
</p>
<p>polygons.
</p>
<p>call: circle(radius) # full circle
</p>
<p>&ndash;or: circle(radius, extent) # arc
</p>
<p>&ndash;or: circle(radius, extent, steps)
</p>
<p>&ndash;or: circle(radius, steps=6) # 6-sided polygon
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.circle(50)
</p>
<p>&gt;&gt;&gt; turtle.circle(120, 180) # semicircle
</p>
<p>turtle.clear()
</p>
<p>Delete the turtle&rsquo;s drawings from the screen. Do not move turtle.
</p>
<p>State and position of the turtle as well as drawings of other
</p>
<p>turtles are not affected.
</p>
<p>Examples (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.clear()
</p>
<p>turtle.color(*args)
</p>
<p>Arguments:
</p>
<p>Several input formats are allowed.
</p>
<p>They use 0, 1, 2, or 3 arguments as follows:
</p>
<p>color()
</p>
<p>Return the current pencolor and the current fillcolor
</p>
<p>as a pair of color specification strings as are returned
</p>
<p>by pencolor and fillcolor.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Appendix F:Turtle Methods 313
</p>
<p>Method Description
</p>
<p>color(colorstring), color((r,g,b)), color(r,g,b)
</p>
<p>inputs as in pencolor, set both, fillcolor and pencolor,
</p>
<p>to the given value.
</p>
<p>color(colorstring1, colorstring2),
</p>
<p>color((r1,g1,b1), (r2,g2,b2))
</p>
<p>equivalent to pencolor(colorstring1) and fillcolor(colorstring2)
</p>
<p>and analogously, if the other input format is used.
</p>
<p>If turtleshape is a polygon, outline and interior of that polygon
</p>
<p>is drawn with the newly set colors.
</p>
<p>For mor info see: pencolor, fillcolor
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.color(&rsquo;red&rsquo;, &rsquo;green&rsquo;)
</p>
<p>&gt;&gt;&gt; turtle.color()
</p>
<p>(&rsquo;red&rsquo;, &rsquo;green&rsquo;)
</p>
<p>&gt;&gt;&gt; colormode(255)
</p>
<p>&gt;&gt;&gt; color((40, 80, 120), (160, 200, 240))
</p>
<p>&gt;&gt;&gt; color()
</p>
<p>(&rsquo;#285078&rsquo;, &rsquo;#a0c8f0&rsquo;)
</p>
<p>turtle.degrees()
</p>
<p>Set the angle measurement units to degrees.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>1.5707963267948966
</p>
<p>&gt;&gt;&gt; turtle.degrees()
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>90.0
</p>
<p>turtle.dot(size=None, *color)
</p>
<p>Optional arguments:
</p>
<p>size &ndash; an integer +&gt;+= 1 (if given)
</p>
<p>color &ndash; a colorstring or a numeric color tuple
</p>
<p>Draw a circular dot with diameter size, using color.
</p>
<p>If size is not given, the maximum of pensize+4 and 2*pensize is used.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.dot()
</p>
<p>&gt;&gt;&gt; turtle.fd(50); turtle.dot(20, "blue"); turtle.fd(50)
</p>
<p>turtle.end_fill()
</p>
<p>Fill the shape drawn after the call begin_fill().
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.color("black","red")
</p>
<p>&gt;&gt;&gt; turtle.begin_fill()
</p>
<p>&gt;&gt;&gt; turtle.circle(60)
</p>
<p>&gt;&gt;&gt; turtle.end_fill()
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>314 18 Appendix F:Turtle Methods
</p>
<p>Method Description
</p>
<p>turtle.end_poly()
</p>
<p>Stop recording the vertices of a polygon. Current turtle position is
</p>
<p>last point of polygon. This will be connected with the first point.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.end_poly()
</p>
<p>turtle.filling()
</p>
<p>Return fillstate (True if filling, False else).
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.begin_fill()
</p>
<p>&gt;&gt;&gt; if turtle.filling():
</p>
<p>turtle.pensize(5)
</p>
<p>else:
</p>
<p>turtle.pensize(3)
</p>
<p>turtle.fillcolor(*args)
</p>
<p>Return or set the fillcolor.
</p>
<p>Arguments:
</p>
<p>Four input formats are allowed:
</p>
<p>- fillcolor()
</p>
<p>Return the current fillcolor as color specification string,
</p>
<p>possibly in hex-number format (see example).
</p>
<p>May be used as input to another color/pencolor/fillcolor call.
</p>
<p>- fillcolor(colorstring)
</p>
<p>s is a Tk color specification string, such as "red" or "yellow"
</p>
<p>- fillcolor((r, g, b))
</p>
<p>*a tuple* of r, g, and b, which represent, an RGB color,
</p>
<p>and each of r, g, and b are in the range 0..colormode,
</p>
<p>where colormode is either 1.0 or 255
</p>
<p>- fillcolor(r, g, b)
</p>
<p>r, g, and b represent an RGB color, and each of r, g, and b
</p>
<p>are in the range 0..colormode
</p>
<p>If turtleshape is a polygon, the interior of that polygon is drawn
</p>
<p>with the newly set fillcolor.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.fillcolor(&rsquo;violet&rsquo;)
</p>
<p>&gt;&gt;&gt; col = turtle.pencolor()
</p>
<p>&gt;&gt;&gt; turtle.fillcolor(col)
</p>
<p>&gt;&gt;&gt; turtle.fillcolor(0, .5, 0)
</p>
<p>turtle.forward(distance)
</p>
<p>Aliases: fd
</p>
<p>Argument:
</p>
<p>distance &ndash; a number (integer or float)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Appendix F:Turtle Methods 315
</p>
<p>Method Description
</p>
<p>Move the turtle forward by the specified distance, in the direction
</p>
<p>the turtle is headed.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(0.00, 0.00)
</p>
<p>&gt;&gt;&gt; turtle.forward(25)
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(25.00,0.00)
</p>
<p>&gt;&gt;&gt; turtle.forward(&minus;75)
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(&minus;50.00,0.00)
</p>
<p>turtle.get_poly()
</p>
<p>Return the lastly recorded polygon.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; p = turtle.get_poly()
</p>
<p>&gt;&gt;&gt; turtle.register_shape("myFavouriteShape", p)
</p>
<p>turtle.get_shapepoly()
</p>
<p>Return the current shape polygon as tuple of coordinate pairs.
</p>
<p>Examples (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.shape("square")
</p>
<p>&gt;&gt;&gt; turtle.shapetransform(4, &minus;1, 0, 2)
</p>
<p>&gt;&gt;&gt; turtle.get_shapepoly()
</p>
<p>((50, &minus;20), (30, 20), (&minus;50, 20), (&minus;30, &minus;20))
</p>
<p>turtle.getscreen()
</p>
<p>Return the TurtleScreen object, the turtle is drawing on.
</p>
<p>So TurtleScreen-methods can be called for that object.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; ts = turtle.getscreen()
</p>
<p>&gt;&gt;&gt; ts
</p>
<p>&lt;turtle.TurtleScreen object at 0x0106B770&gt;
</p>
<p>&gt;&gt;&gt; ts.bgcolor(&ldquo;pink&rdquo;)
</p>
<p>turtle.goto(x, y=None)
</p>
<p>Aliases: setpos setposition
</p>
<p>Arguments:
</p>
<p>x &ndash; a number or a pair/vector of numbers
</p>
<p>y &ndash; a number None
</p>
<p>call: goto(x, y) # two coordinates
</p>
<p>&ndash;or: goto((x, y)) # a pair (tuple) of coordinates
</p>
<p>&ndash;or: goto(vec) # e.g. as returned by pos()
</p>
<p>Move turtle to an absolute position. If the pen is down,
</p>
<p>a line will be drawn. The turtle&rsquo;s orientation does not change.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>316 18 Appendix F:Turtle Methods
</p>
<p>Method Description
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; tp = turtle.pos()
</p>
<p>&gt;&gt;&gt; tp
</p>
<p>(0.00, 0.00)
</p>
<p>&gt;&gt;&gt; turtle.setpos(60,30)
</p>
<p>&gt;&gt;&gt; turtle.pos()
</p>
<p>(60.00,30.00)
</p>
<p>&gt;&gt;&gt; turtle.setpos((20,80))
</p>
<p>&gt;&gt;&gt; turtle.pos()
</p>
<p>(20.00,80.00)
</p>
<p>&gt;&gt;&gt; turtle.setpos(tp)
</p>
<p>&gt;&gt;&gt; turtle.pos()
</p>
<p>(0.00,0.00)
</p>
<p>turtle.heading()
</p>
<p>Return the turtle&rsquo;s current heading.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.left(67)
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>67.0
</p>
<p>turtle.hideturtle()
</p>
<p>Makes the turtle invisible.
</p>
<p>Aliases: ht
</p>
<p>It&rsquo;s a good idea to do this while you&rsquo;re in the
</p>
<p>middle of a complicated drawing, because hiding
</p>
<p>the turtle speeds up the drawing observably.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.hideturtle()
</p>
<p>turtle.isdown()
</p>
<p>Return True if pen is down, False if it&rsquo;s up.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.penup()
</p>
<p>&gt;&gt;&gt; turtle.isdown()
</p>
<p>False
</p>
<p>&gt;&gt;&gt; turtle.pendown()
</p>
<p>&gt;&gt;&gt; turtle.isdown()
</p>
<p>True
</p>
<p>turtle.isvisible()
</p>
<p>Return True if the Turtle is shown, False if it&rsquo;s hidden.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.hideturtle()
</p>
<p>&gt;&gt;&gt; print(turtle.isvisible())
</p>
<p>False
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Appendix F:Turtle Methods 317
</p>
<p>Method Description
</p>
<p>turtle.left(angle)
</p>
<p>Aliases: lt
</p>
<p>Argument:
</p>
<p>angle &ndash; a number (integer or float)
</p>
<p>Turn turtle left by angle units. (Units are by default degrees,
</p>
<p>but can be set via the degrees() and radians() functions.)
</p>
<p>Angle orientation depends on mode. (See this.)
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>22.0
</p>
<p>&gt;&gt;&gt; turtle.left(45)
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>67.0
</p>
<p>turtle.onclick(fun, btn=1, add=None)
</p>
<p>Bind fun to mouse-click event on this turtle on canvas.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with two arguments, to which will be assigned
</p>
<p>the coordinates of the clicked point on the canvas.
</p>
<p>num &ndash; number of the mouse-button defaults to 1 (left mouse button).
</p>
<p>add &ndash; True or False. If True, new binding will be added, otherwise
</p>
<p>it will replace a former binding.
</p>
<p>Example for the anonymous turtle, i. e. the procedural way:
</p>
<p>&gt;&gt;&gt; def turn(x, y):
</p>
<p>turtle.left(360)
</p>
<p>&gt;&gt;&gt; onclick(turn) # Now clicking into the turtle will turn it.
</p>
<p>&gt;&gt;&gt; onclick(None) # event-binding will be removed
</p>
<p>turtle.ondrag(fun, btn=1, add=None)
</p>
<p>Bind fun to mouse-move event on this turtle on canvas.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with two arguments, to which will be assigned
</p>
<p>the coordinates of the clicked point on the canvas.
</p>
<p>num &ndash; number of the mouse-button defaults to 1 (left mouse button).
</p>
<p>Every sequence of mouse-move-events on a turtle is preceded by a
</p>
<p>mouse-click event on that turtle.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.ondrag(turtle.goto)
</p>
<p>### Subsequently clicking and dragging a Turtle will
</p>
<p>### move it across the screen thereby producing handdrawings
</p>
<p>### (if pen is down).
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>318 18 Appendix F:Turtle Methods
</p>
<p>Method Description
</p>
<p>turtle.onrelease(fun, btn=1, add=None)
</p>
<p>Bind fun to mouse-button-release event on this turtle on canvas.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with two arguments, to which will be assigned
</p>
<p>the coordinates of the clicked point on the canvas.
</p>
<p>num &ndash; number of the mouse-button defaults to 1 (left mouse button).
</p>
<p>turtle.pencolor(*args)
</p>
<p>Return or set the pencolor.
</p>
<p>Arguments:
</p>
<p>Four input formats are allowed:
</p>
<p>- pencolor()
</p>
<p>Return the current pencolor as color specification string,
</p>
<p>possibly in hex-number format (see example).
</p>
<p>May be used as input to another color/pencolor/fillcolor call.
</p>
<p>- pencolor(colorstring)
</p>
<p>s is a Tk color specification string, such as "red" or "yellow"
</p>
<p>- pencolor((r, g, b))
</p>
<p>*a tuple* of r, g, and b, which represent, an RGB color,
</p>
<p>and each of r, g, and b are in the range 0..colormode,
</p>
<p>where colormode is either 1.0 or 255
</p>
<p>- pencolor(r, g, b)
</p>
<p>r, g, and b represent an RGB color, and each of r, g, and b
</p>
<p>are in the range 0..colormode
</p>
<p>If turtleshape is a polygon, the outline of that polygon is drawn
</p>
<p>with the newly set pencolor.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.pencolor(&rsquo;brown&rsquo;)
</p>
<p>&gt;&gt;&gt; tup = (0.2, 0.8, 0.55)
</p>
<p>&gt;&gt;&gt; turtle.pencolor(tup)
</p>
<p>&gt;&gt;&gt; turtle.pencolor()
</p>
<p>&rsquo;#33cc8c&rsquo;
</p>
<p>turtle.pendown()
</p>
<p>Pull the pen down &ndash; drawing when moving.
</p>
<p>Aliases: pd down
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.pendown()
</p>
<p>turtle.pensize(width=None)
</p>
<p>Set or return the line thickness.
</p>
<p>Aliases: width
</p>
<p>Argument:
</p>
<p>width &ndash; positive number
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Appendix F:Turtle Methods 319
</p>
<p>Method Description
</p>
<p>Set the line thickness to width or return it. If resizemode is set
</p>
<p>to "auto" and turtleshape is a polygon, that polygon is drawn with
</p>
<p>the same line thickness. If no argument is given, current pensize
</p>
<p>is returned.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.pensize()
</p>
<p>1
</p>
<p>turtle.pensize(10) # from here on lines of width 10 are drawn
</p>
<p>turtle.penup()
</p>
<p>Pull the pen up &ndash; no drawing when moving.
</p>
<p>Aliases: pu up
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.penup()
</p>
<p>turtle.radians()
</p>
<p>Set the angle measurement units to radians.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>90
</p>
<p>&gt;&gt;&gt; turtle.radians()
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>1.5707963267948966
</p>
<p>turtle.reset()
</p>
<p>Delete the turtle&rsquo;s drawings from the screen, re-center the turtle
</p>
<p>and set variables to the default values.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(0.00,&minus;22.00)
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>100.0
</p>
<p>&gt;&gt;&gt; turtle.reset()
</p>
<p>&gt;&gt;&gt; turtle.position()
</p>
<p>(0.00,0.00)
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>0.0
</p>
<p>turtle.setheading(to_angle)
</p>
<p>Set the orientation of the turtle to to_angle.
</p>
<p>Aliases: seth
</p>
<p>Argument:
</p>
<p>to_angle &ndash; a number (integer or float)
</p>
<p>Set the orientation of the turtle to to_angle.
</p>
<p>Here are some common directions in degrees:
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>320 18 Appendix F:Turtle Methods
</p>
<p>Method Description
</p>
<p>standard - mode: logo-mode:
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</p>
<p>0 - east 0 - north
</p>
<p>90 - north 90 - east
</p>
<p>180 - west 180 - south
</p>
<p>270 - south 270 - west
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.setheading(90)
</p>
<p>&gt;&gt;&gt; turtle.heading()
</p>
<p>90
</p>
<p>turtle.shape(name=None)
</p>
<p>Set turtle shape to shape with given name / return current shapename.
</p>
<p>Optional argument:
</p>
<p>name &ndash; a string, which is a valid shapename
</p>
<p>Set turtle shape to shape with given name or, if name is not given,
</p>
<p>return name of current shape.
</p>
<p>Shape with name must exist in the TurtleScreen&rsquo;s shape dictionary.
</p>
<p>Initially there are the following polygon shapes:
</p>
<p>&rsquo;arrow&rsquo;, &rsquo;turtle&rsquo;, &rsquo;circle&rsquo;, &rsquo;square&rsquo;, &rsquo;triangle&rsquo;, &rsquo;classic&rsquo;.
</p>
<p>To learn about how to deal with shapes see Screen-method register_shape.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.shape()
</p>
<p>&rsquo;arrow&rsquo;
</p>
<p>&gt;&gt;&gt; turtle.shape("turtle")
</p>
<p>&gt;&gt;&gt; turtle.shape()
</p>
<p>&rsquo;turtle&rsquo;
</p>
<p>turtle.showturtle()
</p>
<p>Makes the turtle visible.
</p>
<p>Aliases: st
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.hideturtle()
</p>
<p>&gt;&gt;&gt; turtle.showturtle()
</p>
<p>turtle.speed(speed=None)
</p>
<p>Return or set the turtle&rsquo;s speed.
</p>
<p>Optional argument:
</p>
<p>speed &ndash; an integer in the range 0..10 or a speedstring (see below)
</p>
<p>Set the turtle&rsquo;s speed to an integer value in the range 0 .. 10.
</p>
<p>If no argument is given: return current speed.
</p>
<p>If input is a number greater than 10 or smaller than 0.5,
</p>
<p>speed is set to 0.
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>18 Appendix F:Turtle Methods 321
</p>
<p>Method Description
</p>
<p>turtle.undo()
</p>
<p>Undo (repeatedly) the last turtle action.
</p>
<p>Number of available undo actions is determined by the size of
</p>
<p>the undobuffer.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; for i in range(4):
</p>
<p>turtle.fd(50); turtle.lt(80)
</p>
<p>&gt;&gt;&gt; for i in range(8):
</p>
<p>turtle.undo()
</p>
<p>turtle.write(arg, move=False, align=&rsquo;left&rsquo;, font=(&rsquo;Arial&rsquo;, 8, &rsquo;normal&rsquo;))
</p>
<p>Write text at the current turtle position.
</p>
<p>Arguments:
</p>
<p>arg &ndash; info, which is to be written to the TurtleScreen
</p>
<p>move (optional) &ndash; True/False
</p>
<p>align (optional) &ndash; one of the strings "left","center"or right"
</p>
<p>font (optional) &ndash; a triple (fontname, fontsize, fonttype)
</p>
<p>Write text - the string representation of arg - at the current
</p>
<p>turtle position according to align ("left","center"or right")
</p>
<p>and with the given font.
</p>
<p>If move is True, the pen is moved to the bottom-right corner
</p>
<p>of the text. By default, move is False.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.write(&rsquo;Home = &rsquo;, True, align="center")
</p>
<p>&gt;&gt;&gt; turtle.write((0,0), True)
</p>
<p>turtle.xcor()
</p>
<p>Return the turtle&rsquo;s x coordinate.
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; reset()
</p>
<p>&gt;&gt;&gt; turtle.left(60)
</p>
<p>&gt;&gt;&gt; turtle.forward(100)
</p>
<p>&gt;&gt;&gt; print(turtle.xcor())
</p>
<p>50.0
</p>
<p>turtle.ycor()
</p>
<p>Return the turtle&rsquo;s y coordinate
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; reset()
</p>
<p>&gt;&gt;&gt; turtle.left(60)
</p>
<p>&gt;&gt;&gt; turtle.forward(100)
</p>
<p>&gt;&gt;&gt; print(turtle.ycor())
</p>
<p>86.6025403784
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>19Appendix G:TurtleScreen Methods
</p>
<p>This documentation was generated from the Python documentation available by
</p>
<p>typing
</p>
<p>from turt le import &lowast;
</p>
<p>help (TurtleScreen)
</p>
<p>in the Python shell. In the documentation found here the variable turtle is a reference
</p>
<p>to a Turtle object and screen is a reference to the TurtleScreen object. This is a subset
</p>
<p>of that documentation. The official Python 3 documentation is at http://docs.python.
</p>
<p>org/3/.
</p>
<p>Method Description
</p>
<p>screen.addshape(name)
</p>
<p>Same thing as screen.register_shape(name)
</p>
<p>screen.bgcolor(*args)
</p>
<p>Set or return backgroundcolor of the TurtleScreen.
</p>
<p>Arguments (if given): a color string or three numbers
</p>
<p>in the range 0..colormode or a 3-tuple of such numbers.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.bgcolor("orange")
</p>
<p>&gt;&gt;&gt; screen.bgcolor()
</p>
<p>&rsquo;orange&rsquo;
</p>
<p>&gt;&gt;&gt; screen.bgcolor(0.5,0,0.5)
</p>
<p>&gt;&gt;&gt; screen.bgcolor()
</p>
<p>&rsquo;#800080&rsquo;
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_19
</p>
<p>323
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
<div class="annotation"><a href="http://docs.python.org/3/">http://docs.python.org/3/</a></div>
</div>
<div class="page"><p/>
<p>324 19 Appendix G:TurtleScreen Methods
</p>
<p>Method Description
</p>
<p>screen.bgpic(picname=None)
</p>
<p>Set background image or return name of current backgroundimage.
</p>
<p>Optional argument:
</p>
<p>picname &ndash; a string, name of a gif-file or "nopic".
</p>
<p>If picname is a filename, set the corresponing image as background.
</p>
<p>If picname is "nopic", delete backgroundimage, if present.
</p>
<p>If picname is None, return the filename of the current backgroundimage.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.bgpic()
</p>
<p>&rsquo;nopic&rsquo;
</p>
<p>&gt;&gt;&gt; screen.bgpic("landscape.gif")
</p>
<p>&gt;&gt;&gt; screen.bgpic()
</p>
<p>&rsquo;landscape.gif&rsquo;
</p>
<p>screen.clear()
</p>
<p>Delete all drawings and all turtles from the TurtleScreen.
</p>
<p>Reset empty TurtleScreen to its initial state: white background,
</p>
<p>no backgroundimage, no eventbindings and tracing on.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>screen.clear()
</p>
<p>Note: this method is not available as function.
</p>
<p>screen.colormode(cmode=None)
</p>
<p>Return the colormode or set it to 1.0 or 255.
</p>
<p>Optional argument:
</p>
<p>cmode &ndash; one of the values 1.0 or 255
</p>
<p>r, g, b values of colortriples have to be in range 0..cmode.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.colormode()
</p>
<p>1.0
</p>
<p>&gt;&gt;&gt; screen.colormode(255)
</p>
<p>&gt;&gt;&gt; turtle.pencolor(240,160,80)
</p>
<p>screen.delay(delay=None)
</p>
<p>Return or set the drawing delay in milliseconds.
</p>
<p>Optional argument:
</p>
<p>delay &ndash; positive integer
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.delay(15)
</p>
<p>&gt;&gt;&gt; screen.delay()
</p>
<p>15
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>19 Appendix G:TurtleScreen Methods 325
</p>
<p>Method Description
</p>
<p>screen.getcanvas()
</p>
<p>Return the Canvas of this TurtleScreen.
</p>
<p>Example (for a Screen instance named screen):
</p>
<p>&gt;&gt;&gt; cv = screen.getcanvas()
</p>
<p>&gt;&gt;&gt; cv
</p>
<p>&lt;turtle.ScrolledCanvas instance at 0x010742D8&gt;
</p>
<p>screen.getshapes()
</p>
<p>Return a list of names of all currently available turtle shapes.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.getshapes()
</p>
<p>[&rsquo;arrow&rsquo;, &rsquo;blank&rsquo;, &rsquo;circle&rsquo;, ... , &rsquo;turtle&rsquo;]
</p>
<p>screen.listen(xdummy=None, ydummy=None)
</p>
<p>Set focus on TurtleScreen (in order to collect key-events)
</p>
<p>Dummy arguments are provided in order
</p>
<p>to be able to pass listen to the onclick method.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.listen()
</p>
<p>screen.mode(mode=None)
</p>
<p>Set turtle-mode (&rsquo;standard&rsquo;, &rsquo;logo&rsquo; or &rsquo;world&rsquo;) and perform reset.
</p>
<p>Optional argument:
</p>
<p>mode &ndash; on of the strings &rsquo;standard&rsquo;, &rsquo;logo&rsquo; or &rsquo;world&rsquo;
</p>
<p>Mode &rsquo;standard&rsquo; is compatible with turtle.py.
</p>
<p>Mode &rsquo;logo&rsquo; is compatible with most Logo-Turtle-Graphics.
</p>
<p>Mode &rsquo;world&rsquo; uses userdefined &rsquo;worldcoordinates&rsquo;. *Attention*: in
</p>
<p>this mode angles appear distorted if x/y unit-ratio doesn&rsquo;t equal 1.
</p>
<p>If mode is not given, return the current mode.
</p>
<p>Mode Initial turtle heading positive angles
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>&rsquo;standard&rsquo; to the right (east) counterclockwise
</p>
<p>&rsquo;logo&rsquo; upward (north) clockwise
</p>
<p>Examples:
</p>
<p>&gt;&gt;&gt; mode(&rsquo;logo&rsquo;) # resets turtle heading to north
</p>
<p>&gt;&gt;&gt; mode()
</p>
<p>&rsquo;logo&rsquo;
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>326 19 Appendix G:TurtleScreen Methods
</p>
<p>Method Description
</p>
<p>screen.onclick(fun, btn=1, add=None)
</p>
<p>Bind fun to mouse-click event on canvas.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with two arguments, the coordinates of the
</p>
<p>clicked point on the canvas.
</p>
<p>num &ndash; the number of the mouse-button, defaults to 1
</p>
<p>Example (for a TurtleScreen instance named screen
</p>
<p>and a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; screen.onclick(turtle.goto)
</p>
<p>### Subsequently clicking into the TurtleScreen will
</p>
<p>### make the turtle move to the clicked point.
</p>
<p>&gt;&gt;&gt; screen.onclick(None)
</p>
<p>### event-binding will be removed
</p>
<p>screen.onkey(fun, key)
</p>
<p>Bind fun to key-release event of key.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with no arguments
</p>
<p>key &ndash; a string: key (e.g. "a") or key-symbol (e.g. "space")
</p>
<p>In order to be able to register key-events, TurtleScreen
</p>
<p>Must have focus. (See method listen.)
</p>
<p>Example (for a TurtleScreen instance named screen
</p>
<p>and a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; def f():
</p>
<p>turtle.fd(50)
</p>
<p>turtle.lt(60)
</p>
<p>&gt;&gt;&gt; screen.onkey(f, "Up")
</p>
<p>&gt;&gt;&gt; screen.listen()
</p>
<p>### Subsequently the turtle can be moved by
</p>
<p>### repeatedly pressing the up-arrow key,
</p>
<p>### consequently drawing a hexagon
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>19 Appendix G:TurtleScreen Methods 327
</p>
<p>Method Description
</p>
<p>screen.onkeypress(fun, key=None)
</p>
<p>Bind fun to key-press event of key if key is given,
</p>
<p>or to any key-press-event if no key is given.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with no arguments
</p>
<p>key &ndash; a string: key (e.g. "a") or key-symbol (e.g. "space")
</p>
<p>In order to be able to register key-events, TurtleScreen
</p>
<p>must have focus. (See method listen.)
</p>
<p>Example (for a TurtleScreen instance named screen
</p>
<p>and a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; def f():
</p>
<p>turtle.fd(50)
</p>
<p>&gt;&gt;&gt; screen.onkey(f, "Up")
</p>
<p>&gt;&gt;&gt; screen.listen()
</p>
<p>### Subsequently the turtle can be moved by
</p>
<p>### repeatedly pressing the up-arrow key,
</p>
<p>### or by keeping pressed the up-arrow key.
</p>
<p>### consequently drawing a hexagon.
</p>
<p>screen.ontimer(fun, t=0)
</p>
<p>Install a timer, which calls fun after t milliseconds.
</p>
<p>Arguments:
</p>
<p>fun &ndash; a function with no arguments.
</p>
<p>t &ndash; a number &gt;= 0
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; running = True
</p>
<p>&gt;&gt;&gt; def f():
</p>
<p>if running:
</p>
<p>turtle.fd(50)
</p>
<p>turtle.lt(60)
</p>
<p>screen.ontimer(f, 250)
</p>
<p>&gt;&gt;&gt; f() ### makes the turtle marching around
</p>
<p>&gt;&gt;&gt; running = False
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>328 19 Appendix G:TurtleScreen Methods
</p>
<p>Method Description
</p>
<p>screen.register_shape(name, shape=None)
</p>
<p>Adds a turtle shape to TurtleScreen&rsquo;s shapelist.
</p>
<p>Arguments:
</p>
<p>(1) name is the name of a gif-file and shape is None.
</p>
<p>Installs the corresponding image shape.
</p>
<p>!! Image-shapes DO NOT rotate when turning the turtle,
</p>
<p>!! so they do not display the heading of the turtle!
</p>
<p>(2) name is an arbitrary string and shape is a tuple
</p>
<p>of pairs of coordinates. Installs the corresponding
</p>
<p>polygon shape
</p>
<p>(3) name is an arbitrary string and shape is a
</p>
<p>(compound) Shape object. Installs the corresponding
</p>
<p>compound shape.
</p>
<p>To use a shape, you have to issue the command shape(shapename).
</p>
<p>call: register_shape("turtle.gif")
</p>
<p>&ndash;or: register_shape("tri", ((0,0), (10,10), (-10,10)))
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.register_shape("triangle", ((5,-3),(0,5),(-5,-3)))
</p>
<p>screen.reset()
</p>
<p>Reset all Turtles on the Screen to their initial state.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.reset()
</p>
<p>screen.screensize(canvwidth=None, canvheight=None, bg=None)
</p>
<p>Resize the canvas the turtles are drawing on.
</p>
<p>Optional arguments:
</p>
<p>canvwidth &ndash; positive integer, new width of canvas in pixels
</p>
<p>canvheight &ndash; positive integer, new height of canvas in pixels
</p>
<p>bg &ndash; colorstring or color-tupel, new backgroundcolor
</p>
<p>If no arguments are given, return current (canvaswidth, canvasheight)
</p>
<p>Do not alter the drawing window. To observe hidden parts of
</p>
<p>the canvas use the scrollbars. (Can make visible those parts
</p>
<p>of a drawing, which were outside the canvas before!)
</p>
<p>Example (for a Turtle instance named turtle):
</p>
<p>&gt;&gt;&gt; turtle.screensize(2000,1500)
</p>
<p>### e. g. to search for an erroneously escaped turtle ;-)
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>19 Appendix G:TurtleScreen Methods 329
</p>
<p>Method Description
</p>
<p>screen.setworldcoordinates(llx, lly, urx, ury)
</p>
<p>Set up a user defined coordinate-system.
</p>
<p>Arguments:
</p>
<p>llx &ndash; a number, x-coordinate of lower left corner of canvas
</p>
<p>lly &ndash; a number, y-coordinate of lower left corner of canvas
</p>
<p>urx &ndash; a number, x-coordinate of upper right corner of canvas
</p>
<p>ury &ndash; a number, y-coordinate of upper right corner of canvas
</p>
<p>Set up user coodinat-system and switch to mode &rsquo;world&rsquo; if necessary.
</p>
<p>This performs a screen.reset. If mode &rsquo;world&rsquo; is already active,
</p>
<p>All drawings are redrawn according to the new coordinates.
</p>
<p>But ATTENTION: in user-defined coordinatesystems angles may appear
</p>
<p>distorted. (see Screen.mode())
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.setworldcoordinates(-10,-0.5,50,1.5)
</p>
<p>&gt;&gt;&gt; for _ in range(36):
</p>
<p>turtle.left(10)
</p>
<p>turtle.forward(0.5)
</p>
<p>screen.title(titlestr)
</p>
<p>Set the title of the Turtle Graphics screen. The title appears in the title bar
</p>
<p>of the window.
</p>
<p>screen.tracer(n=None, delay=None)
</p>
<p>Turns turtle animation on/off and set delay for update drawings.
</p>
<p>Optional arguments:
</p>
<p>n &ndash; nonnegative integer
</p>
<p>delay &ndash; nonnegative integer
</p>
<p>If n is given, only each n-th regular screen update is really performed.
</p>
<p>(Can be used to accelerate the drawing of complex graphics.)
</p>
<p>Second arguments sets delay value (see RawTurtle.delay())
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.tracer(8, 25)
</p>
<p>&gt;&gt;&gt; dist = 2
</p>
<p>&gt;&gt;&gt; for i in range(200):
</p>
<p>turtle.fd(dist)
</p>
<p>turtle.rt(90)
</p>
<p>dist += 2
</p>
<p>screen.turtles()
</p>
<p>Return the list of turtles on the screen.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.turtles()
</p>
<p>[&lt;turtle.Turtle object at 0x00E11FB0&gt;]
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>330 19 Appendix G:TurtleScreen Methods
</p>
<p>Method Description
</p>
<p>screen.update()
</p>
<p>Perform a TurtleScreen update.
</p>
<p>screen.window_height()
</p>
<p>Return the height of the turtle window.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.window_height()
</p>
<p>480
</p>
<p>screen.window_width()
</p>
<p>Return the width of the turtle window.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.window_width()
</p>
<p>640
</p>
<p>screen.mainloop()
</p>
<p>Starts event loop - calling Tkinter&rsquo;s mainloop function.
</p>
<p>Must be last statement in a turtle graphics program.
</p>
<p>Must NOT be used if a script is run from within IDLE in -n mode
</p>
<p>(No subprocess) - for interactive use of turtle graphics.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.mainloop()
</p>
<p>screen.numinput(title, prompt, default=None, minval=None, maxval=None)
</p>
<p>Pop up a dialog window for input of a number.
</p>
<p>Arguments: title is the title of the dialog window,
</p>
<p>prompt is a text mostly describing what numerical information to input.
</p>
<p>default: default value
</p>
<p>minval: minimum value for imput
</p>
<p>maxval: maximum value for input
</p>
<p>The number input must be in the range minval .. maxval if these are
</p>
<p>given. If not, a hint is issued and the dialog remains open for
</p>
<p>correction. Return the number input.
</p>
<p>If the dialog is canceled, return None.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.numinput("Poker", "Your stakes:", 1000, minval=10, maxval=10000)
</p>
<p>screen.textinput(title, prompt)
</p>
<p>Pop up a dialog window for input of a string.
</p>
<p>Arguments: title is the title of the dialog window,
</p>
<p>prompt is a text mostly describing what information to input.
</p>
<p>Return the string input
</p>
<p>If the dialog is canceled, return None.
</p>
<p>Example (for a TurtleScreen instance named screen):
</p>
<p>&gt;&gt;&gt; screen.textinput("NIM", "Name of first player:")
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20Appendix H: Complete Programs
</p>
<p>20.1 The Draw Program
</p>
<p>This is the sample drawing application from the first chapter. It illustrates the use of
</p>
<p>the tkinter library including many widgets and mouse handling. This program can
</p>
<p>be downloaded from the text&rsquo;s website.
</p>
<p>1 # T h e i m p o r t s i n c l u d e t u r t l e g r a p h i c s and t k i n t e r m o d u l e s .
</p>
<p>2 # T h e c o l o r c h o o s e r and f i l e d i a l o g m o d u l e s l e t t h e u s e r
</p>
<p>3 # p i c k a c o l o r and a f i l e n a m e .
</p>
<p>4 import t u r t l e
</p>
<p>5 import t k i n t e r
</p>
<p>6 import t k i n t e r . c o l o r c h o o s e r
</p>
<p>7 import t k i n t e r . f i l e d i a l o g
</p>
<p>8 import xml . dom . minidom
</p>
<p>9
</p>
<p>10 # T h e f o l l o w i n g c l a s s e s d e f i n e t h e d i f f e r e n t commands t h a t
</p>
<p>11 # a r e s u p p o r t e d by t h e d r a w i n g a p p l i c a t i o n .
</p>
<p>12 c l a s s GoToCommand :
</p>
<p>13 def _ _ i n i t _ _ ( s e l f , x , y , width = 1 , c o l o r = " b l a c k " ) :
</p>
<p>14 s e l f . x = x
</p>
<p>15 s e l f . y = y
</p>
<p>16 s e l f . width = width
</p>
<p>17 s e l f . c o l o r = c o l o r
</p>
<p>18
</p>
<p>19 # T h e draw method f o r e a c h command d r a w s t h e command
</p>
<p>20 # u s i n g t h e g i v e n t u r t l e
</p>
<p>21 def draw ( s e l f , t u r t l e ) :
</p>
<p>22 t u r t l e . width ( s e l f . width )
</p>
<p>23 t u r t l e . p e n c o l o r ( s e l f . c o l o r )
</p>
<p>24 t u r t l e . goto ( s e l f . x , s e l f . y )
</p>
<p>25
</p>
<p>26 # T h e _ _ s t r _ _ method i s a s p e c i a l method t h a t i s c a l l e d
</p>
<p>27 # when a command i s c o n v e r t e d t o a s t r i n g . T h e s t r i n g
</p>
<p>28 # v e r s i o n o f t h e command i s how i t a p p e a r s i n t h e g r a p h i c s
</p>
<p>29 # f i l e f o r m a t .
</p>
<p>30 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>31 r e t u r n &rsquo;&lt;Command x =" &rsquo; + s t r ( s e l f . x ) + &rsquo; " y =" &rsquo; + s t r ( s e l f . y ) + \
</p>
<p>32 &rsquo; " width =" &rsquo; + s t r ( s e l f . width ) \
</p>
<p>33 + &rsquo; " c o l o r =" &rsquo; + s e l f . c o l o r + &rsquo; " &gt;GoTo &lt;/Command&gt; &rsquo;
</p>
<p>34
</p>
<p>35 c l a s s CircleCommand :
</p>
<p>36 def _ _ i n i t _ _ ( s e l f , r a d i u s , width = 1 , c o l o r = " b l a c k " ) :
</p>
<p>37 s e l f . r a d i u s = r a d i u s
</p>
<p>38 s e l f . width = width
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9_20
</p>
<p>331
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>332 20 Appendix H: Complete Programs
</p>
<p>39 s e l f . c o l o r = c o l o r
</p>
<p>40
</p>
<p>41 def draw ( s e l f , t u r t l e ) :
</p>
<p>42 t u r t l e . width ( s e l f . width )
</p>
<p>43 t u r t l e . p e n c o l o r ( s e l f . c o l o r )
</p>
<p>44 t u r t l e . c i r c l e ( s e l f . r a d i u s )
</p>
<p>45
</p>
<p>46 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>47 r e t u r n &rsquo;&lt;Command r a d i u s =" &rsquo; + s t r ( s e l f . r a d i u s ) + &rsquo; " width =" &rsquo; + \
</p>
<p>48 s t r ( s e l f . width ) + &rsquo; " c o l o r =" &rsquo; + s e l f . c o l o r + &rsquo; " &gt; C i r c l e &lt;/Command&gt; &rsquo;
</p>
<p>49
</p>
<p>50 c l a s s BeginFi l lCommand :
</p>
<p>51 def _ _ i n i t _ _ ( s e l f , c o l o r ) :
</p>
<p>52 s e l f . c o l o r = c o l o r
</p>
<p>53
</p>
<p>54 def draw ( s e l f , t u r t l e ) :
</p>
<p>55 t u r t l e . f i l l c o l o r ( s e l f . c o l o r )
</p>
<p>56 t u r t l e . b e g i n _ f i l l ( )
</p>
<p>57
</p>
<p>58 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>59 r e t u r n &rsquo;&lt;Command c o l o r =" &rsquo; + s e l f . c o l o r + &rsquo; " &gt; B e g i n F i l l &lt;/Command&gt; &rsquo;
</p>
<p>60
</p>
<p>61 c l a s s EndFillCommand :
</p>
<p>62 def _ _ i n i t _ _ ( s e l f ) :
</p>
<p>63 pass
</p>
<p>64
</p>
<p>65 def draw ( s e l f , t u r t l e ) :
</p>
<p>66 t u r t l e . e n d _ f i l l ( )
</p>
<p>67
</p>
<p>68 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>69 r e t u r n " &lt;Command&gt; E n d F i l l &lt;/Command&gt; "
</p>
<p>70
</p>
<p>71 c l a s s PenUpCommand :
</p>
<p>72 def _ _ i n i t _ _ ( s e l f ) :
</p>
<p>73 pass
</p>
<p>74
</p>
<p>75 def draw ( s e l f , t u r t l e ) :
</p>
<p>76 t u r t l e . penup ( )
</p>
<p>77
</p>
<p>78 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>79 r e t u r n " &lt;Command&gt;PenUp &lt;/Command&gt; "
</p>
<p>80
</p>
<p>81 c l a s s PenDownCommand :
</p>
<p>82 def _ _ i n i t _ _ ( s e l f ) :
</p>
<p>83 pass
</p>
<p>84
</p>
<p>85 def draw ( s e l f , t u r t l e ) :
</p>
<p>86 t u r t l e . pendown ( )
</p>
<p>87
</p>
<p>88 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>89 r e t u r n " &lt;Command&gt;PenDown&lt;/Command&gt; "
</p>
<p>90
</p>
<p>91 # T h i s i s t h e P y L i s t c o n t a i n e r o b j e c t . I t i s meant t o h o l d a
</p>
<p>92 c l a s s P y L i s t :
</p>
<p>93 def _ _ i n i t _ _ ( s e l f ) :
</p>
<p>94 s e l f . g c L i s t = [ ]
</p>
<p>95
</p>
<p>96 # T h e append method i s u s e d t o add commands t o t h e s e q u e n c e .
</p>
<p>97 def append ( s e l f , i tem ) :
</p>
<p>98 s e l f . g c L i s t = s e l f . g c L i s t + [ i tem ]
</p>
<p>99
</p>
<p>100 # T h i s method i s u s e d by t h e undo f u n c t i o n . I t s l i c e s t h e s e q u e n c e
</p>
<p>101 # t o remove t h e l a s t i t e m
</p>
<p>102 def removeLast ( s e l f ) :
</p>
<p>103 s e l f . g c L i s t = s e l f . g c L i s t [ : &minus;1 ]
</p>
<p>104
</p>
<p>105 # T h i s s p e c i a l method i s c a l l e d when i t e r a t i n g o v e r t h e s e q u e n c e .
</p>
<p>106 # Each t i m e y i e l d i s c a l l e d a n o t h e r e l e m e n t o f t h e s e q u e n c e i s r e t u r n e d
</p>
<p>107 # t o t h e i t e r a t o r ( i . e . t h e f o r l o o p t h a t c a l l e d t h i s . )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.1 The Draw Program 333
</p>
<p>108 def _ _ i t e r _ _ ( s e l f ) :
</p>
<p>109 f o r c i n s e l f . g c L i s t :
</p>
<p>110 y i e l d c
</p>
<p>111
</p>
<p>112 # T h i s i s c a l l e d when t h e l e n f u n c t i o n i s c a l l e d on t h e s e q u e n c e .
</p>
<p>113 def _ _ l e n _ _ ( s e l f ) :
</p>
<p>114 r e t u r n l e n ( s e l f . g c L i s t )
</p>
<p>115
</p>
<p>116 # T h i s c l a s s d e f i n e s t h e d r a w i n g a p p l i c a t i o n . T h e f o l l o w i n g l i n e s a y s t h a t
</p>
<p>117 # t h e D r a w i n g A p p l i c a t i o n c l a s s i n h e r i t s f r o m t h e Frame c l a s s . T h i s means
</p>
<p>118 # t h a t a D r a w i n g A p p l i c a t i o n i s l i k e a Frame o b j e c t e x c e p t f o r t h e c o d e
</p>
<p>119 # w r i t t e n h e r e w h i c h r e d e f i n e s / e x t e n d s t h e b e h a v i o r o f a Frame .
</p>
<p>120 c l a s s D r a w i n g A p p l i c a t i o n ( t k i n t e r . Frame ) :
</p>
<p>121 def _ _ i n i t _ _ ( s e l f , master=None ) :
</p>
<p>122 super ( ) . _ _ i n i t _ _ ( master )
</p>
<p>123 s e l f . pack ( )
</p>
<p>124 s e l f . buildWindow ( )
</p>
<p>125 s e l f . graphicsCommands = P y L i s t ( )
</p>
<p>126
</p>
<p>127 # T h i s method i s c a l l e d t o c r e a t e a l l t h e w i d g e t s , p l a c e them i n t h e GUI ,
</p>
<p>128 # and d e f i n e t h e e v e n t h a n d l e r s f o r t h e a p p l i c a t i o n .
</p>
<p>129 def buildWindow ( s e l f ) :
</p>
<p>130
</p>
<p>131 # T h e m a s t e r i s t h e r o o t window . T h e t i t l e i s s e t a s b e l o w .
</p>
<p>132 s e l f . master . t i t l e ( " Draw " )
</p>
<p>133
</p>
<p>134 # H e r e i s how t o c r e a t e a menu b a r . T h e t e a r o f f =0 means t h a t menus
</p>
<p>135 # can &rsquo; t be s e p a r a t e d f r o m t h e window w h i c h i s a f e a t u r e o f t k i n t e r .
</p>
<p>136 bar = t k i n t e r . Menu ( s e l f . master )
</p>
<p>137 f i l e M e n u = t k i n t e r . Menu ( bar , t e a r o f f =0)
</p>
<p>138
</p>
<p>139 # T h i s c o d e i s c a l l e d by t h e " New " menu i t e m b e l o w when i t i s s e l e c t e d .
</p>
<p>140 # T h e same a p p l i e s f o r l o a d F i l e , a d d T o F i l e , and s a v e F i l e b e l o w . T h e
</p>
<p>141 # " E x i t " menu i t e m b e l o w c a l l s q u i t on t h e " m a s t e r " o r r o o t window .
</p>
<p>142 def newWindow ( ) :
</p>
<p>143 # T h i s s e t s up t h e t u r t l e t o be r e a d y f o r a new p i c t u r e t o be
</p>
<p>144 # drawn . I t a l s o s e t s t h e s e q u e n c e b a c k t o empty . I t i s n e c e s s a r y
</p>
<p>145 # f o r t h e graphicsCommands s e q u e n c e t o be i n t h e o b j e c t ( i . e .
</p>
<p>146 # s e l f . graphicsCommands ) b e c a u s e o t h e r w i s e t h e s t a t e m e n t :
</p>
<p>147 # graphicsCommands = P y L i s t ( )
</p>
<p>148 # would make t h i s v a r i a b l e a l o c a l v a r i a b l e i n t h e newWindow
</p>
<p>149 # method . I f i t w e r e l o c a l , i t would n o t be s e t anymore o n c e t h e
</p>
<p>150 # newWindow method r e t u r n e d .
</p>
<p>151 t h e T u r t l e . c l e a r ( )
</p>
<p>152 t h e T u r t l e . penup ( )
</p>
<p>153 t h e T u r t l e . goto ( 0 , 0 )
</p>
<p>154 t h e T u r t l e . pendown ( )
</p>
<p>155 s c r e e n . update ( )
</p>
<p>156 s c r e e n . l i s t e n ( )
</p>
<p>157 s e l f . graphicsCommands = P y L i s t ( )
</p>
<p>158
</p>
<p>159 f i l e M e n u . add_command ( l a b e l = " New " ,command=newWindow )
</p>
<p>160
</p>
<p>161 # T h e p a r s e f u n c t i o n adds t h e c o n t e n t s o f an XML f i l e t o t h e s e q u e n c e .
</p>
<p>162 def p a r s e ( f i l e n a m e ) :
</p>
<p>163 xmldoc = xml . dom . minidom . p a r s e ( f i l e n a m e )
</p>
<p>164
</p>
<p>165 graphicsCommandsElement = xmldoc . getElementsByTagName ( " GraphicsCommands " ) [ 0 ]
</p>
<p>166
</p>
<p>167 graphicsCommands = graphicsCommandsElement . getElementsByTagName ( " Command " )
</p>
<p>168
</p>
<p>169 f o r commandElement i n graphicsCommands :
</p>
<p>170 p r i n t ( type ( commandElement ) )
</p>
<p>171 command = commandElement . f i r s t C h i l d . d a t a . s t r i p ( )
</p>
<p>172 a t t r = commandElement . a t t r i b u t e s
</p>
<p>173 i f command == " GoTo " :
</p>
<p>174 x = f l o a t ( a t t r [ " x " ] . v a l u e )
</p>
<p>175 y = f l o a t ( a t t r [ " y " ] . v a l u e )
</p>
<p>176 width = f l o a t ( a t t r [ " width " ] . v a l u e )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>334 20 Appendix H: Complete Programs
</p>
<p>177 c o l o r = a t t r [ " c o l o r " ] . v a l u e . s t r i p ( )
</p>
<p>178 cmd = GoToCommand ( x , y , width , c o l o r )
</p>
<p>179
</p>
<p>180 e l i f command == " C i r c l e " :
</p>
<p>181 r a d i u s = f l o a t ( a t t r [ " r a d i u s " ] . v a l u e )
</p>
<p>182 width = f l o a t ( a t t r [ " width " ] . v a l u e )
</p>
<p>183 c o l o r = a t t r [ " c o l o r " ] . v a l u e . s t r i p ( )
</p>
<p>184 cmd = CircleCommand ( r a d i u s , width , c o l o r )
</p>
<p>185
</p>
<p>186 e l i f command == " B e g i n F i l l " :
</p>
<p>187 c o l o r = a t t r [ " c o l o r " ] . v a l u e . s t r i p ( )
</p>
<p>188 cmd = BeginFi l lCommand ( c o l o r )
</p>
<p>189
</p>
<p>190 e l i f command == " E n d F i l l " :
</p>
<p>191 cmd = EndFillCommand ( )
</p>
<p>192
</p>
<p>193 e l i f command == " PenUp " :
</p>
<p>194 cmd = PenUpCommand ( )
</p>
<p>195
</p>
<p>196 e l i f command == " PenDown " :
</p>
<p>197 cmd = PenDownCommand ( )
</p>
<p>198 e l s e :
</p>
<p>199 r a i s e R u n t i m e E r r o r ( " Unknown Command : " + command )
</p>
<p>200
</p>
<p>201 s e l f . graphicsCommands . append ( cmd )
</p>
<p>202
</p>
<p>203 def l o a d F i l e ( ) :
</p>
<p>204
</p>
<p>205 f i l e n a m e = t k i n t e r . f i l e d i a l o g . a s k o p e n f i l e n a m e ( t i t l e = " S e l e c t a G r a p h i c s F i l e " )
</p>
<p>206
</p>
<p>207 newWindow ( )
</p>
<p>208
</p>
<p>209 # T h i s r e&minus; i n i t i a l i z e s t h e s e q u e n c e f o r t h e new p i c t u r e .
</p>
<p>210 s e l f . graphicsCommands = P y L i s t ( )
</p>
<p>211
</p>
<p>212 # c a l l i n g p a r s e w i l l r e a d t h e g r a p h i c s commands f r o m t h e f i l e .
</p>
<p>213 p a r s e ( f i l e n a m e )
</p>
<p>214
</p>
<p>215 f o r cmd i n s e l f . graphicsCommands :
</p>
<p>216 cmd . draw ( t h e T u r t l e )
</p>
<p>217
</p>
<p>218 # T h i s l i n e i s n e c e s s a r y t o u p d a t e t h e window a f t e r t h e p i c t u r e i s drawn .
</p>
<p>219 s c r e e n . update ( )
</p>
<p>220
</p>
<p>221
</p>
<p>222 f i l e M e n u . add_command ( l a b e l = " Load . . . " ,command= l o a d F i l e )
</p>
<p>223
</p>
<p>224 def a d dT o F i l e ( ) :
</p>
<p>225 f i l e n a m e = t k i n t e r . f i l e d i a l o g . a s k o p e n f i l e n a m e ( t i t l e = " S e l e c t a G r a p h i c s F i l e " )
</p>
<p>226
</p>
<p>227 t h e T u r t l e . penup ( )
</p>
<p>228 t h e T u r t l e . goto ( 0 , 0 )
</p>
<p>229 t h e T u r t l e . pendown ( )
</p>
<p>230 t h e T u r t l e . p e n c o l o r ( " #000000 " )
</p>
<p>231 t h e T u r t l e . f i l l c o l o r ( " #000000 " )
</p>
<p>232 cmd = PenUpCommand ( )
</p>
<p>233 s e l f . graphicsCommands . append ( cmd )
</p>
<p>234 cmd = GoToCommand ( 0 , 0 , 1 , " #000000 " )
</p>
<p>235 s e l f . graphicsCommands . append ( cmd )
</p>
<p>236 cmd = PenDownCommand ( )
</p>
<p>237 s e l f . graphicsCommands . append ( cmd )
</p>
<p>238 s c r e e n . update ( )
</p>
<p>239 p a r s e ( f i l e n a m e )
</p>
<p>240
</p>
<p>241 f o r cmd i n s e l f . graphicsCommands :
</p>
<p>242 cmd . draw ( t h e T u r t l e )
</p>
<p>243
</p>
<p>244
</p>
<p>245
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.1 The Draw Program 335
</p>
<p>246 s c r e e n . update ( )
</p>
<p>247
</p>
<p>248 f i l e M e n u . add_command ( l a b e l = " Load I n t o . . . " ,command= a d dT o F i l e )
</p>
<p>249
</p>
<p>250 # T h e w r i t e f u n c t i o n w r i t e s an XML f i l e t o t h e g i v e n f i l e n a m e
</p>
<p>251 def w r i t e ( f i l e n a m e ) :
</p>
<p>252 f i l e = open ( f i l e n a m e , "w" )
</p>
<p>253 f i l e . w r i t e ( &rsquo; &lt;? xml v e r s i o n = " 1 .0 " encoding =" UTF&minus;8" s t a n d a l o n e =" no " ? &gt;\ n &rsquo; )
</p>
<p>254 f i l e . w r i t e ( &rsquo;&lt;GraphicsCommands &gt;\ n &rsquo; )
</p>
<p>255 f o r cmd i n s e l f . graphicsCommands :
</p>
<p>256 f i l e . w r i t e ( &rsquo; &rsquo;+ s t r ( cmd)+ " \ n " )
</p>
<p>257
</p>
<p>258 f i l e . w r i t e ( &rsquo; &lt;/ GraphicsCommands &gt;\ n &rsquo; )
</p>
<p>259
</p>
<p>260 f i l e . c l o s e ( )
</p>
<p>261
</p>
<p>262 def s a v e F i l e ( ) :
</p>
<p>263 f i l e n a m e = t k i n t e r . f i l e d i a l o g . a s k s a v e a s f i l e n a m e ( t i t l e = " Save P i c t u r e As . . . " )
</p>
<p>264 w r i t e ( f i l e n a m e )
</p>
<p>265
</p>
<p>266 f i l e M e n u . add_command ( l a b e l = " Save As . . . " ,command= s a v e F i l e )
</p>
<p>267
</p>
<p>268
</p>
<p>269 f i l e M e n u . add_command ( l a b e l = " E x i t " ,command= s e l f . master . q u i t )
</p>
<p>270
</p>
<p>271 bar . add_cascade ( l a b e l = " F i l e " ,menu= f i l e M e n u )
</p>
<p>272
</p>
<p>273 # T h i s t e l l s t h e r o o t window t o d i s p l a y t h e n e w l y c r e a t e d menu b a r .
</p>
<p>274 s e l f . master . c o n f i g ( menu= bar )
</p>
<p>275
</p>
<p>276 # H e r e s e v e r a l w i d g e t s a r e c r e a t e d . T h e c a n v a s i s t h e d r a w i n g a r e a on
</p>
<p>277 # t h e l e f t s i d e o f t h e window .
</p>
<p>278 c a n v a s = t k i n t e r . Canvas ( s e l f , width =600 , h e i g h t =600)
</p>
<p>279 c a n v a s . pack ( s i d e = t k i n t e r . LEFT )
</p>
<p>280
</p>
<p>281 # By c r e a t i n g a R a wT u r t l e , we can have t h e t u r t l e draw on t h i s c a n v a s .
</p>
<p>282 # O t h e r w i s e , a R a w T u r t l e and a T u r t l e a r e e x a c t l y t h e same .
</p>
<p>283 t h e T u r t l e = t u r t l e . R a wT u r t l e ( c a n v a s )
</p>
<p>284
</p>
<p>285 # T h i s makes t h e s h a p e o f t h e t u r t l e a c i r c l e .
</p>
<p>286 t h e T u r t l e . shape ( " c i r c l e " )
</p>
<p>287 s c r e e n = t h e T u r t l e . g e t s c r e e n ( )
</p>
<p>288
</p>
<p>289 # T h i s c a u s e s t h e a p p l i c a t i o n t o n o t u p d a t e t h e s c r e e n u n l e s s
</p>
<p>290 # s c r e e n . u p d a t e ( ) i s c a l l e d . T h i s i s n e c e s s a r y f o r t h e o n d r a g e v e n t
</p>
<p>291 # h a n d l e r b e l o w . W i t h o u t i t , t h e program bombs a f t e r d r a g g i n g t h e
</p>
<p>292 # t u r t l e a r o u n d f o r a w h i l e .
</p>
<p>293 s c r e e n . t r a c e r ( 0 )
</p>
<p>294
</p>
<p>295 # T h i s i s t h e a r e a on t h e r i g h t s i d e o f t h e window where a l l t h e
</p>
<p>296 # b u t t o n s , l a b e l s , and e n t r y b o x e s a r e l o c a t e d . T h e pad c r e a t e s some empty
</p>
<p>297 # s p a c e a r o u n d t h e s i d e . T h e s i d e p u t s t h e s i d e B a r on t h e r i g h t s i d e o f t h e
</p>
<p>298 # t h i s f r a m e . T h e f i l l t e l l s i t t o f i l l i n a l l s p a c e a v a i l a b l e on t h e r i g h t
</p>
<p>299 # s i d e .
</p>
<p>300 s i d e B a r = t k i n t e r . Frame ( s e l f , padx = 5 ,pady =5)
</p>
<p>301 s i d e B a r . pack ( s i d e = t k i n t e r . RIGHT , f i l l = t k i n t e r . BOTH )
</p>
<p>302
</p>
<p>303 # T h i s i s a l a b e l w i d g e t . P a c k i n g i t p u t s i t a t t h e t o p o f t h e s i d e b a r .
</p>
<p>304 p o i n t L a b e l = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " Width " )
</p>
<p>305 p o i n t L a b e l . pack ( )
</p>
<p>306
</p>
<p>307 # T h i s e n t r y w i d g e t a l l o w s t h e u s e r t o p i c k a w i d t h f o r t h e i r l i n e s .
</p>
<p>308 # W i t h t h e w i d t h S i z e v a r i a b l e b e l o w you can w r i t e w i d t h S i z e . g e t ( ) t o g e t
</p>
<p>309 # t h e c o n t e n t s o f t h e e n t r y w i d g e t and w i d t h S i z e . s e t ( v a l ) t o s e t t h e v a l u e
</p>
<p>310 # o f t h e e n t r y w i d g e t t o v a l . I n i t i a l l y t h e w i d t h S i z e i s s e t t o 1 . s t r ( 1 ) i s
</p>
<p>311 # n e e d e d b e c a u s e t h e e n t r y w i d g e t must be g i v e n a s t r i n g .
</p>
<p>312 w i d t h S i z e = t k i n t e r . S t r i n g V a r ( )
</p>
<p>313 w i d t h E n t r y = t k i n t e r . E n t r y ( s i d e B a r , t e x t v a r i a b l e = w i d t h S i z e )
</p>
<p>314 w i d t h E n t r y . pack ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>336 20 Appendix H: Complete Programs
</p>
<p>315 w i d t h S i z e . s e t ( s t r ( 1 ) )
</p>
<p>316
</p>
<p>317 r a d i u s L a b e l = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " R a d i u s " )
</p>
<p>318 r a d i u s L a b e l . pack ( )
</p>
<p>319 r a d i u s S i z e = t k i n t e r . S t r i n g V a r ( )
</p>
<p>320 r a d i u s E n t r y = t k i n t e r . E n t r y ( s i d e B a r , t e x t v a r i a b l e = r a d i u s S i z e )
</p>
<p>321 r a d i u s S i z e . s e t ( s t r ( 1 0 ) )
</p>
<p>322 r a d i u s E n t r y . pack ( )
</p>
<p>323
</p>
<p>324 # A b u t t o n w i d g e t c a l l s an e v e n t h a n d l e r when i t i s p r e s s e d . T h e c i r c l e H a n d l e r
</p>
<p>325 # f u n c t i o n b e l o w i s t h e e v e n t h a n d l e r when t h e Draw C i r c l e b u t t o n i s p r e s s e d .
</p>
<p>326 def c i r c l e H a n d l e r ( ) :
</p>
<p>327 # When d r a w i n g , a command i s c r e a t e d and t h e n t h e command i s drawn by c a l l i n g
</p>
<p>328 # t h e draw method . A d d i n g t h e command t o t h e graphicsCommands s e q u e n c e means t h e
</p>
<p>329 # a p p l i c a t i o n w i l l remember t h e p i c t u r e .
</p>
<p>330 cmd = CircleCommand ( f l o a t ( r a d i u s S i z e . get ( ) ) , f l o a t ( w i d t h S i z e . get ( ) ) , penColor . get ( ) )
</p>
<p>331 cmd . draw ( t h e T u r t l e )
</p>
<p>332 s e l f . graphicsCommands . append ( cmd )
</p>
<p>333
</p>
<p>334 # T h e s e two l i n e s a r e n e e d e d t o u p d a t e t h e s c r e e n and t o p u t t h e f o c u s b a c k
</p>
<p>335 # i n t h e d r a w i n g c a n v a s . T h i s i s n e c e s s a r y b e c a u s e when p r e s s i n g " u " t o undo ,
</p>
<p>336 # t h e s c r e e n must have f o c u s t o r e c e i v e t h e k e y p r e s s .
</p>
<p>337 s c r e e n . update ( )
</p>
<p>338 s c r e e n . l i s t e n ( )
</p>
<p>339
</p>
<p>340 # T h i s c r e a t e s t h e b u t t o n w i d g e t i n t h e s i d e B a r . T h e f i l l = t k i n t e r . BOTH c a u s e s t h e b u t t o n
</p>
<p>341 # t o expand t o f i l l t h e e n t i r e w i d t h o f t h e s i d e B a r .
</p>
<p>342 c i r c l e B u t t o n = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " Draw C i r c l e " , command= c i r c l e H a n d l e r )
</p>
<p>343 c i r c l e B u t t o n . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>344
</p>
<p>345 # T h e c o l o r mode 255 b e l o w a l l o w s c o l o r s t o be s p e c i f i e d i n RGB f o r m ( i . e . Red /
</p>
<p>346 # G r e e n / B l u e ) . T h e mode a l l o w s t h e Red v a l u e t o be s e t by a two d i g i t h e x a d e c i m a l
</p>
<p>347 # number r a n g i n g f r o m 00&minus;F F . T h e same a p p l i e s f o r B l u e and G r e e n v a l u e s . T h e
</p>
<p>348 # c o l o r c h o o s e r s b e l o w r e t u r n a s t r i n g r e p r e s e n t i n g t h e s e l e c t e d c o l o r and a s l i c e
</p>
<p>349 # i s t a k e n t o e x t r a c t t h e # RRGGBB h e x a d e c i m a l s t r i n g t h a t t h e c o l o r c h o o s e r s r e t u r n .
</p>
<p>350 s c r e e n . colormode ( 2 5 5 )
</p>
<p>351 penLabel = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " Pen C o l o r " )
</p>
<p>352 penLabel . pack ( )
</p>
<p>353 penColor = t k i n t e r . S t r i n g V a r ( )
</p>
<p>354 p e n E n t r y = t k i n t e r . E n t r y ( s i d e B a r , t e x t v a r i a b l e = penColor )
</p>
<p>355 p e n E n t r y . pack ( )
</p>
<p>356 # T h i s i s t h e c o l o r b l a c k .
</p>
<p>357 penColor . s e t ( " #000000 " )
</p>
<p>358
</p>
<p>359 def g e t P e n C o l o r ( ) :
</p>
<p>360 c o l o r = t k i n t e r . c o l o r c h o o s e r . a s k c o l o r ( )
</p>
<p>361 i f c o l o r ! = None :
</p>
<p>362 penColor . s e t ( s t r ( c o l o r ) [ &minus;9 : &minus;2 ] )
</p>
<p>363
</p>
<p>364 p e n C o l o r B u t t o n = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " P i c k Pen C o l o r " , command= g e t P e n C o l o r )
</p>
<p>365 p e n C o l o r B u t t o n . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>366
</p>
<p>367 f i l l L a b e l = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " F i l l C o l o r " )
</p>
<p>368 f i l l L a b e l . pack ( )
</p>
<p>369 f i l l C o l o r = t k i n t e r . S t r i n g V a r ( )
</p>
<p>370 f i l l E n t r y = t k i n t e r . E n t r y ( s i d e B a r , t e x t v a r i a b l e = f i l l C o l o r )
</p>
<p>371 f i l l E n t r y . pack ( )
</p>
<p>372 f i l l C o l o r . s e t ( " #000000 " )
</p>
<p>373
</p>
<p>374 def g e t F i l l C o l o r ( ) :
</p>
<p>375 c o l o r = t k i n t e r . c o l o r c h o o s e r . a s k c o l o r ( )
</p>
<p>376 i f c o l o r ! = None :
</p>
<p>377 f i l l C o l o r . s e t ( s t r ( c o l o r ) [ &minus;9 : &minus;2 ] )
</p>
<p>378
</p>
<p>379 f i l l C o l o r B u t t o n = \
</p>
<p>380 t k i n t e r . B u t t o n ( s i d e B a r , t e x t = " P i c k F i l l C o l o r " , command= g e t F i l l C o l o r )
</p>
<p>381 f i l l C o l o r B u t t o n . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>382
</p>
<p>383
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.1 The Draw Program 337
</p>
<p>384 def b e g i n F i l l H a n d l e r ( ) :
</p>
<p>385 cmd = BeginFi l lCommand ( f i l l C o l o r . get ( ) )
</p>
<p>386 cmd . draw ( t h e T u r t l e )
</p>
<p>387 s e l f . graphicsCommands . append ( cmd )
</p>
<p>388
</p>
<p>389 b e g i n F i l l B u t t o n = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " Begin F i l l " , command= b e g i n F i l l H a n d l e r )
</p>
<p>390 b e g i n F i l l B u t t o n . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>391
</p>
<p>392 def e n d F i l l H a n d l e r ( ) :
</p>
<p>393 cmd = EndFillCommand ( )
</p>
<p>394 cmd . draw ( t h e T u r t l e )
</p>
<p>395 s e l f . graphicsCommands . append ( cmd )
</p>
<p>396
</p>
<p>397 e n d F i l l B u t t o n = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " End F i l l " , command= e n d F i l l H a n d l e r )
</p>
<p>398 e n d F i l l B u t t o n . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>399
</p>
<p>400 penLabel = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " Pen I s Down " )
</p>
<p>401 penLabel . pack ( )
</p>
<p>402
</p>
<p>403 def penUpHandler ( ) :
</p>
<p>404 cmd = PenUpCommand ( )
</p>
<p>405 cmd . draw ( t h e T u r t l e )
</p>
<p>406 penLabel . c o n f i g u r e ( t e x t = " Pen I s Up " )
</p>
<p>407 s e l f . graphicsCommands . append ( cmd )
</p>
<p>408
</p>
<p>409 penUpButton = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " Pen Up " , command=penUpHandler )
</p>
<p>410 penUpButton . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>411
</p>
<p>412 def penDownHandler ( ) :
</p>
<p>413 cmd = PenDownCommand ( )
</p>
<p>414 cmd . draw ( t h e T u r t l e )
</p>
<p>415 penLabel . c o n f i g u r e ( t e x t = " Pen I s Down " )
</p>
<p>416 s e l f . graphicsCommands . append ( cmd )
</p>
<p>417
</p>
<p>418 penDownButton = t k i n t e r . Bu t t on ( s i d e B a r , t e x t = " Pen Down " , command=penDownHandler )
</p>
<p>419 penDownButton . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>420
</p>
<p>421 # H e r e i s a n o t h e r e v e n t h a n d l e r . T h i s one h a n d l e s mouse c l i c k s on t h e s c r e e n .
</p>
<p>422 def c l i c k H a n d l e r ( x , y ) :
</p>
<p>423 # When a mouse c l i c k o c c u r s , g e t t h e w i d t h S i z e e n t r y v a l u e and s e t t h e w i d t h o f t h e
</p>
<p>424 # pen t o t h e w i d t h S i z e v a l u e . T h e f l o a t ( w i d t h S i z e . g e t ( ) ) i s n e e d e d b e c a u s e
</p>
<p>425 # t h e w i d t h i s a f l o a t , b u t t h e e n t r y w i d g e t s t o r e s i t a s a s t r i n g .
</p>
<p>426 cmd = GoToCommand ( x , y , f l o a t ( w i d t h S i z e . get ( ) ) , penColor . get ( ) )
</p>
<p>427 cmd . draw ( t h e T u r t l e )
</p>
<p>428 s e l f . graphicsCommands . append ( cmd )
</p>
<p>429 s c r e e n . update ( )
</p>
<p>430 s c r e e n . l i s t e n ( )
</p>
<p>431
</p>
<p>432 # H e r e i s how we t i e t h e c l i c k H a n d l e r t o mouse c l i c k s .
</p>
<p>433 s c r e e n . o n c l i c k ( c l i c k H a n d l e r )
</p>
<p>434
</p>
<p>435 def d r a g H a n d l e r ( x , y ) :
</p>
<p>436 cmd = GoToCommand ( x , y , f l o a t ( w i d t h S i z e . get ( ) ) , penColor . get ( ) )
</p>
<p>437 cmd . draw ( t h e T u r t l e )
</p>
<p>438 s e l f . graphicsCommands . append ( cmd )
</p>
<p>439 s c r e e n . update ( )
</p>
<p>440 s c r e e n . l i s t e n ( )
</p>
<p>441
</p>
<p>442 t h e T u r t l e . ondrag ( d r a g H a n d l e r )
</p>
<p>443
</p>
<p>444 # t h e u n d o H a n d l e r u n d o e s t h e l a s t command by r e m o v i n g i t f r o m t h e
</p>
<p>445 # s e q u e n c e and t h e n r e d r a w i n g t h e e n t i r e p i c t u r e .
</p>
<p>446 def undoHandler ( ) :
</p>
<p>447 i f l e n ( s e l f . graphicsCommands ) &gt; 0 :
</p>
<p>448 s e l f . graphicsCommands . removeLast ( )
</p>
<p>449 t h e T u r t l e . c l e a r ( )
</p>
<p>450 t h e T u r t l e . penup ( )
</p>
<p>451 t h e T u r t l e . goto ( 0 , 0 )
</p>
<p>452 t h e T u r t l e . pendown ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>338 20 Appendix H: Complete Programs
</p>
<p>453 f o r cmd i n s e l f . graphicsCommands :
</p>
<p>454 cmd . draw ( t h e T u r t l e )
</p>
<p>455 s c r e e n . update ( )
</p>
<p>456 s c r e e n . l i s t e n ( )
</p>
<p>457
</p>
<p>458 s c r e e n . o n k e y p r e s s ( undoHandler , " u " )
</p>
<p>459 s c r e e n . l i s t e n ( )
</p>
<p>460
</p>
<p>461 # T h e main f u n c t i o n i n o u r GUI program i s v e r y s i m p l e . I t c r e a t e s t h e
</p>
<p>462 # r o o t window . Then i t c r e a t e s t h e D r a w i n g A p p l i c a t i o n f r a m e w h i c h c r e a t e s
</p>
<p>463 # a l l t h e w i d g e t s and h a s t h e l o g i c f o r t h e e v e n t h a n d l e r s . C a l l i n g m a i n l o o p
</p>
<p>464 # on t h e f r a m e s makes i t s t a r t l i s t e n i n g f o r e v e n t s . T h e m a i n l o o p f u n c t i o n w i l l
</p>
<p>465 # r e t u r n when t h e a p p l i c a t i o n i s e x i t e d .
</p>
<p>466 def main ( ) :
</p>
<p>467 r o o t = t k i n t e r . Tk ( )
</p>
<p>468 drawingApp = D r a w i n g A p p l i c a t i o n ( r o o t )
</p>
<p>469
</p>
<p>470 drawingApp . mainloop ( )
</p>
<p>471 p r i n t ( " Program E x e c u t i o n Completed . " )
</p>
<p>472
</p>
<p>473 i f __name__ == " __main__ " :
</p>
<p>474 main ( )
</p>
<p>20.2 The Scope Program
</p>
<p>This is the sample program from the first chapter that illustrates the use of scope
</p>
<p>within a program. This program can be downloaded from the text&rsquo;s website.
</p>
<p>1 import math
</p>
<p>2
</p>
<p>3
</p>
<p>4 P I = math . p i
</p>
<p>5
</p>
<p>6 def a r e a ( r a d i u s ) :
</p>
<p>7 g l o b a l z
</p>
<p>8 z = 6
</p>
<p>9 t h e A r e a = P I &lowast; r a d i u s &lowast;&lowast; 2
</p>
<p>10
</p>
<p>11 r e t u r n t h e A r e a
</p>
<p>12
</p>
<p>13
</p>
<p>14 def main ( ) :
</p>
<p>15 g l o b a l z
</p>
<p>16
</p>
<p>17 h i s t o r y O f P r o m p t s = [ ]
</p>
<p>18 h i s t o r y O f O u t p u t = [ ]
</p>
<p>19
</p>
<p>20 def g e t I n p u t ( prompt ) :
</p>
<p>21 x = input ( prompt )
</p>
<p>22 h i s t o r y O f P r o m p t s . append ( prompt )
</p>
<p>23
</p>
<p>24 r e t u r n x
</p>
<p>25
</p>
<p>26 def showOutput ( v a l ) :
</p>
<p>27 h i s t o r y O f O u t p u t . append ( v a l )
</p>
<p>28 p r i n t ( v a l )
</p>
<p>29
</p>
<p>30 r S t r i n g = g e t I n p u t ( " P l e a s e e n t e r the r a d i u s o f a c i r c l e : " )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.2 The Scope Program 339
</p>
<p>31
</p>
<p>32 r = f l o a t ( r S t r i n g )
</p>
<p>33
</p>
<p>34 v a l = a r e a ( r )
</p>
<p>35 p r i n t ( z )
</p>
<p>36 showOutput ( " The a r e a o f the c i r c l e i s " + s t r ( v a l ) )
</p>
<p>37
</p>
<p>38 i f __name__ == " __main__ " :
</p>
<p>39 main ( )
</p>
<p>20.3 The Sort Animation
</p>
<p>1 import t k i n t e r
</p>
<p>2 import t u r t l e
</p>
<p>3 import random
</p>
<p>4 import t ime
</p>
<p>5 import math
</p>
<p>6
</p>
<p>7 c l a s s P o i n t ( t u r t l e . R a wT u r t l e ) :
</p>
<p>8 def _ _ i n i t _ _ ( s e l f , canvas , x , y ) :
</p>
<p>9 super ( ) . _ _ i n i t _ _ ( c a n v a s )
</p>
<p>10 c a n v a s . r e g i s t e r _ s h a p e ( " dot " , ( ( 3 ,0 ) , ( 2 ,2 ) , ( 0 ,3 ) , ( &minus; 2 ,2 ) , ( &minus; 3 ,0 ) , ( &minus; 2 , &minus; 2 ) , ( 0 , &minus; 3 ) , ( 2 , &minus; 2 ) ) )
</p>
<p>11 s e l f . shape ( " dot " )
</p>
<p>12 s e l f . speed ( 0 )
</p>
<p>13 s e l f . penup ( )
</p>
<p>14 s e l f . goto ( x , y )
</p>
<p>15
</p>
<p>16 def _ _ s t r _ _ ( s e l f ) :
</p>
<p>17 r e t u r n " ( " + s t r ( s e l f . x c o r ( ) ) + " , " + s t r ( s e l f . y c o r ( ) ) + " ) "
</p>
<p>18
</p>
<p>19 def _ _ l t _ _ ( s e l f , o t h e r ) :
</p>
<p>20 r e t u r n s e l f . y c o r ( ) &lt; o t h e r . y c o r ( )
</p>
<p>21
</p>
<p>22 # T h i s c l a s s d e f i n e s t h e a n i m a t i o n a p p l i c a t i o n . T h e f o l l o w i n g l i n e s a y s t h a t
</p>
<p>23 # t h e S o r t A n i m a t i o n c l a s s i n h e r i t s f r o m t h e Frame c l a s s .
</p>
<p>24 c l a s s S o r t A n i m a t i o n ( t k i n t e r . Frame ) :
</p>
<p>25 def _ _ i n i t _ _ ( s e l f , master =None ) :
</p>
<p>26 super ( ) . _ _ i n i t _ _ ( master )
</p>
<p>27 s e l f . pack ( )
</p>
<p>28 s e l f . buildWindow ( )
</p>
<p>29 s e l f . paused = F a l s e
</p>
<p>30 s e l f . s t o p = F a l s e
</p>
<p>31 s e l f . r u n n i n g = F a l s e
</p>
<p>32
</p>
<p>33
</p>
<p>34 def buildWindow ( s e l f ) :
</p>
<p>35
</p>
<p>36 def p a r t i t i o n ( seq , s t a r t , s t o p ) :
</p>
<p>37 p i v o t I n d e x = s t a r t
</p>
<p>38 p i v o t = seq [ p i v o t I n d e x ]
</p>
<p>39
</p>
<p>40 t h e T u r t l e . c o l o r ( " red " )
</p>
<p>41 t h e T u r t l e . penup ( )
</p>
<p>42 t h e T u r t l e . goto ( s t a r t , p i v o t . y c o r ( ) )
</p>
<p>43 t h e T u r t l e . pendown ( )
</p>
<p>44 t h e T u r t l e . goto ( stop , p i v o t . y c o r ( ) )
</p>
<p>45 s c r e e n . update ( )
</p>
<p>46
</p>
<p>47 # Why t w i c e ? B e c a u s e o n c e d o e s n &rsquo; t seem t o d i s p l a y
</p>
<p>48 # t h e l i n e t h e f i r s t t i m e t h r o u g h f o r some r e a s o n
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>340 20 Appendix H: Complete Programs
</p>
<p>49 t h e T u r t l e . c o l o r ( " red " )
</p>
<p>50 t h e T u r t l e . penup ( )
</p>
<p>51 t h e T u r t l e . goto ( s t a r t , p i v o t . y c o r ( ) )
</p>
<p>52 t h e T u r t l e . pendown ( )
</p>
<p>53 t h e T u r t l e . goto ( stop , p i v o t . y c o r ( ) )
</p>
<p>54 s c r e e n . update ( )
</p>
<p>55
</p>
<p>56 i = s t a r t +1
</p>
<p>57 j = stop&minus;1
</p>
<p>58
</p>
<p>59 while i &lt;= j :
</p>
<p>60 while i &lt;= j and not p i v o t &lt; seq [ i ] :
</p>
<p>61 i +=1
</p>
<p>62 while i &lt;= j and p i v o t &lt; seq [ j ] :
</p>
<p>63 j &minus;=1
</p>
<p>64
</p>
<p>65 i f i &lt; j :
</p>
<p>66 tmp = seq [ i ]
</p>
<p>67 seq [ i ] = seq [ j ]
</p>
<p>68 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>69 seq [ j ] = tmp
</p>
<p>70 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>71 s c r e e n . update ( )
</p>
<p>72 i +=1
</p>
<p>73 j &minus;=1
</p>
<p>74
</p>
<p>75 seq [ p i v o t I n d e x ] = seq [ j ]
</p>
<p>76 seq [ p i v o t I n d e x ] . goto ( p i v o t I n d e x , seq [ p i v o t I n d e x ] . y c o r ( ) )
</p>
<p>77 seq [ j ] = p i v o t
</p>
<p>78 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>79 seq [ j ] . c o l o r ( " green " )
</p>
<p>80 s c r e e n . update ( )
</p>
<p>81
</p>
<p>82 t h e T u r t l e . c o l o r ( " w h i t e " )
</p>
<p>83 t h e T u r t l e . penup ( )
</p>
<p>84 t h e T u r t l e . goto ( 0 , p i v o t . y c o r ( ) )
</p>
<p>85 t h e T u r t l e . pendown ( )
</p>
<p>86 t h e T u r t l e . goto ( l e n ( seq ) , p i v o t . y c o r ( ) )
</p>
<p>87 s c r e e n . update ( )
</p>
<p>88
</p>
<p>89 r e t u r n j
</p>
<p>90
</p>
<p>91
</p>
<p>92 def q u i c k s o r t R e c u r s i v e l y ( seq , s t a r t , s t o p ) :
</p>
<p>93 i f s t a r t &gt;= s t o p :
</p>
<p>94 r e t u r n
</p>
<p>95
</p>
<p>96 i f s t o p p i n g ( ) :
</p>
<p>97 r e t u r n
</p>
<p>98
</p>
<p>99 p i v o t I n d e x = p a r t i t i o n ( seq , s t a r t , s t o p )
</p>
<p>100
</p>
<p>101 i f s t o p p i n g ( ) :
</p>
<p>102 r e t u r n
</p>
<p>103
</p>
<p>104 q u i c k s o r t R e c u r s i v e l y ( seq , s t a r t , p i v o t I n d e x )
</p>
<p>105
</p>
<p>106 i f s t o p p i n g ( ) :
</p>
<p>107 r e t u r n
</p>
<p>108
</p>
<p>109 q u i c k s o r t R e c u r s i v e l y ( seq , p i v o t I n d e x + 1 , s t o p )
</p>
<p>110
</p>
<p>111 def q u i c k s o r t ( seq ) :
</p>
<p>112 q u i c k s o r t R e c u r s i v e l y ( seq , 0 , l e n ( seq ) )
</p>
<p>113
</p>
<p>114 def merge ( seq , s t a r t , mid , s t o p ) :
</p>
<p>115 l e n g t h = s t o p &minus; s t a r t
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.3 The Sort Animation 341
</p>
<p>116 l o g = math . l o g ( l e n g t h , 2 )
</p>
<p>117
</p>
<p>118 t h e T u r t l e . c o l o r ( " b l u e " )
</p>
<p>119 t h e T u r t l e . penup ( )
</p>
<p>120 t h e T u r t l e . goto ( s t a r t ,&minus;3&lowast; l o g )
</p>
<p>121 t h e T u r t l e . pendown ( )
</p>
<p>122 t h e T u r t l e . f o r w a r d ( l e n g t h )
</p>
<p>123 s c r e e n . update ( )
</p>
<p>124
</p>
<p>125 l s t = [ ]
</p>
<p>126 i = s t a r t
</p>
<p>127 j = mid
</p>
<p>128
</p>
<p>129 # Merge t h e two l i s t s w h i l e e a c h h a s more e l e m e n t s
</p>
<p>130 while i &lt; mid and j &lt; s t o p :
</p>
<p>131 i f seq [ i ] &lt; seq [ j ] :
</p>
<p>132 l s t . append ( seq [ i ] )
</p>
<p>133 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>134 i +=1
</p>
<p>135 e l s e :
</p>
<p>136 l s t . append ( seq [ j ] )
</p>
<p>137 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>138 j +=1
</p>
<p>139 # s c r e e n . u p d a t e ( )
</p>
<p>140
</p>
<p>141 # Copy i n t h e r e s t o f t h e s t a r t t o mid s e q u e n c e
</p>
<p>142 while i &lt; mid :
</p>
<p>143 l s t . append ( seq [ i ] )
</p>
<p>144 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>145 i +=1
</p>
<p>146 # s c r e e n . u p d a t e ( )
</p>
<p>147
</p>
<p>148 # Copy i n t h e r e s t o f t h e mid t o s t o p s e q u e n c e
</p>
<p>149 while j &lt; mid :
</p>
<p>150 l s t . append ( seq [ j ] )
</p>
<p>151 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>152 j +=1
</p>
<p>153 # s c r e e n . u p d a t e ( )
</p>
<p>154
</p>
<p>155 # Copy t h e e l e m e n t s b a c k t o t h e o r i g i n a l s e q u e n c e
</p>
<p>156 f o r i i n range ( l e n ( l s t ) ) :
</p>
<p>157 seq [ s t a r t + i ] = l s t [ i ]
</p>
<p>158 l s t [ i ] . goto ( s t a r t + i , l s t [ i ] . y c o r ( ) )
</p>
<p>159 l s t [ i ] . c o l o r ( " green " )
</p>
<p>160 s c r e e n . update ( )
</p>
<p>161
</p>
<p>162 def m e r g e S o r t R e c u r s i v e l y ( seq , s t a r t , s t o p ) :
</p>
<p>163 # We must u s e &gt;= h e r e o n l y when t h e s e q u e n c e we a r e s o r t i n g
</p>
<p>164 # i s empty . O t h e r w i s e s t a r t == s t o p &minus;1 i n t h e b a s e c a s e .
</p>
<p>165 i f s t a r t &gt;= stop &minus;1:
</p>
<p>166 r e t u r n
</p>
<p>167
</p>
<p>168 mid = ( s t a r t + s t o p ) / / 2
</p>
<p>169
</p>
<p>170 i f s t o p p i n g ( ) :
</p>
<p>171 r e t u r n
</p>
<p>172
</p>
<p>173 l e n g t h = stop&minus;s t a r t
</p>
<p>174 l o g = math . l o g ( l e n g t h , 2 )
</p>
<p>175
</p>
<p>176 t h e T u r t l e . c o l o r ( " red " )
</p>
<p>177 t h e T u r t l e . penup ( )
</p>
<p>178 t h e T u r t l e . goto ( s t a r t ,&minus;3&lowast; l o g )
</p>
<p>179 t h e T u r t l e . pendown ( )
</p>
<p>180 t h e T u r t l e . f o r w a r d ( l e n g t h )
</p>
<p>181 s c r e e n . update ( )
</p>
<p>182
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>342 20 Appendix H: Complete Programs
</p>
<p>183 # Why t w i c e ? B e c a u s e o n c e d o e s n &rsquo; t seem t o d i s p l a y
</p>
<p>184 # t h e l i n e t h e f i r s t t i m e t h r o u g h f o r some r e a s o n
</p>
<p>185 t h e T u r t l e . c o l o r ( " red " )
</p>
<p>186 t h e T u r t l e . penup ( )
</p>
<p>187 t h e T u r t l e . goto ( s t a r t ,&minus;3&lowast; l o g )
</p>
<p>188 t h e T u r t l e . pendown ( )
</p>
<p>189 t h e T u r t l e . f o r w a r d ( l e n g t h )
</p>
<p>190 s c r e e n . update ( )
</p>
<p>191
</p>
<p>192 m e r g e S o r t R e c u r s i v e l y ( seq , s t a r t , mid )
</p>
<p>193
</p>
<p>194 i f s t o p p i n g ( ) :
</p>
<p>195 r e t u r n
</p>
<p>196
</p>
<p>197 m e r g e S o r t R e c u r s i v e l y ( seq , mid , s t o p )
</p>
<p>198
</p>
<p>199 i f s t o p p i n g ( ) :
</p>
<p>200 r e t u r n
</p>
<p>201
</p>
<p>202 t h e T u r t l e . c o l o r ( " b l u e " )
</p>
<p>203 t h e T u r t l e . penup ( )
</p>
<p>204 t h e T u r t l e . goto ( s t a r t ,&minus;3&lowast; l o g )
</p>
<p>205 t h e T u r t l e . pendown ( )
</p>
<p>206 t h e T u r t l e . f o r w a r d ( l e n g t h )
</p>
<p>207 s c r e e n . update ( )
</p>
<p>208
</p>
<p>209 merge ( seq , s t a r t , mid , s t o p )
</p>
<p>210
</p>
<p>211 s c r e e n . update ( )
</p>
<p>212 t h e T u r t l e . c o l o r ( " w h i t e " )
</p>
<p>213 t h e T u r t l e . goto ( s t a r t &minus;1,&minus;3&lowast; l o g )
</p>
<p>214 t h e T u r t l e . pendown ( )
</p>
<p>215 t h e T u r t l e . f o r w a r d ( l e n g t h +2)
</p>
<p>216 s c r e e n . update ( )
</p>
<p>217
</p>
<p>218 def mergeSort ( seq ) :
</p>
<p>219 m e r g e S o r t R e c u r s i v e l y ( seq , 0 , l e n ( seq ) )
</p>
<p>220
</p>
<p>221 def s e l e c t ( seq , s t a r t ) :
</p>
<p>222 minIndex = s t a r t
</p>
<p>223 seq [ minIndex ] . c o l o r ( " green " )
</p>
<p>224
</p>
<p>225 f o r i i n range ( s t a r t , l e n ( seq ) ) :
</p>
<p>226 i f seq [ minIndex ] &gt; seq [ i ] :
</p>
<p>227 seq [ minIndex ] . c o l o r ( " b l a c k " )
</p>
<p>228 minIndex = i
</p>
<p>229 seq [ minIndex ] . c o l o r ( " green " )
</p>
<p>230
</p>
<p>231 r e t u r n minIndex
</p>
<p>232
</p>
<p>233 def s e l e c t i o n S o r t ( seq ) :
</p>
<p>234 f o r i i n range ( l e n ( seq ) ) :
</p>
<p>235 minIndex = s e l e c t ( seq , i )
</p>
<p>236 i f s t o p p i n g ( ) :
</p>
<p>237 r e t u r n
</p>
<p>238 tmp = seq [ i ]
</p>
<p>239 seq [ i ] = seq [ minIndex ]
</p>
<p>240 seq [ minIndex ] = tmp
</p>
<p>241 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>242 seq [ minIndex ] . goto ( minIndex , seq [ minIndex ] . y c o r ( ) )
</p>
<p>243 seq [ i ] . c o l o r ( " green " )
</p>
<p>244
</p>
<p>245 def pause ( ) :
</p>
<p>246 while s e l f . paused :
</p>
<p>247 t ime . s l e e p ( 1 )
</p>
<p>248 s c r e e n . update ( )
</p>
<p>249 s c r e e n . l i s t e n ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.3 The Sort Animation 343
</p>
<p>250
</p>
<p>251 def s t o p p i n g ( ) :
</p>
<p>252 i f s e l f . paused :
</p>
<p>253 pause ( )
</p>
<p>254
</p>
<p>255 i f s e l f . s t o p :
</p>
<p>256 s e l f . pause = F a l s e
</p>
<p>257 s e l f . r u n n i n g = F a l s e
</p>
<p>258 s c r e e n . update ( )
</p>
<p>259 s c r e e n . l i s t e n ( )
</p>
<p>260 r e t u r n T r u e
</p>
<p>261
</p>
<p>262 r e t u r n F a l s e
</p>
<p>263
</p>
<p>264 s e l f . master . t i t l e ( " S o r t A n i m a t i o n s " )
</p>
<p>265
</p>
<p>266 bar = t k i n t e r . Menu ( s e l f . master )
</p>
<p>267 f i l e M e n u = t k i n t e r . Menu ( bar , t e a r o f f =0)
</p>
<p>268
</p>
<p>269 def c l e a r ( ) :
</p>
<p>270 s c r e e n . c l e a r ( )
</p>
<p>271 s c r e e n . update ( )
</p>
<p>272 s c r e e n . l i s t e n ( )
</p>
<p>273
</p>
<p>274 def newWindow ( ) :
</p>
<p>275 c l e a r ( )
</p>
<p>276 i f s e l f . r u n n i n g :
</p>
<p>277 s e l f . s t o p = T r u e
</p>
<p>278
</p>
<p>279 f i l e M e n u . add_command ( l a b e l = " C l e a r " ,command=newWindow )
</p>
<p>280 f i l e M e n u . add_command ( l a b e l = " E x i t " ,command= s e l f . master . q u i t )
</p>
<p>281 bar . add_cascade ( l a b e l = " F i l e " ,menu= f i l e M e n u )
</p>
<p>282 s e l f . master . c o n f i g ( menu= bar )
</p>
<p>283
</p>
<p>284 c a n v a s = t k i n t e r . Canvas ( s e l f , width =600 , h e i g h t =600)
</p>
<p>285 c a n v a s . pack ( s i d e = t k i n t e r . LEFT )
</p>
<p>286
</p>
<p>287 t h e T u r t l e = t u r t l e . R a wT u r t l e ( c a n v a s )
</p>
<p>288 t h e T u r t l e . ht ( )
</p>
<p>289 t h e T u r t l e . speed ( 0 )
</p>
<p>290 s c r e e n = t h e T u r t l e . g e t s c r e e n ( )
</p>
<p>291 s c r e e n . t r a c e r ( 0 )
</p>
<p>292
</p>
<p>293 s i d e B a r = t k i n t e r . Frame ( s e l f , padx = 5 ,pady =5)
</p>
<p>294 s i d e B a r . pack ( s i d e = t k i n t e r . RIGHT , f i l l = t k i n t e r . BOTH )
</p>
<p>295
</p>
<p>296 s p e e d L a b e l = t k i n t e r . L a b e l ( s i d e B a r , t e x t = " Animation Speed " )
</p>
<p>297 s p e e d L a b e l . pack ( )
</p>
<p>298 speed = t k i n t e r . S t r i n g V a r ( )
</p>
<p>299 s p e e d E n t r y = t k i n t e r . E n t r y ( s i d e B a r , t e x t v a r i a b l e =speed )
</p>
<p>300 s p e e d E n t r y . pack ( )
</p>
<p>301 speed . s e t ( " 10 " )
</p>
<p>302
</p>
<p>303 def s e l S o r t H a n d l e r ( ) :
</p>
<p>304 s e l f . r u n n i n g = T r u e
</p>
<p>305 c l e a r ( )
</p>
<p>306 s c r e e n . s e t w o r l d c o o r d i n a t e s ( 0 ,0 ,2 0 0 ,2 0 0 )
</p>
<p>307 s c r e e n . t r a c e r ( 0 )
</p>
<p>308 s e l f . master . t i t l e ( " S e l e c t i o n S o r t Animat ion " )
</p>
<p>309 seq = [ ]
</p>
<p>310 f o r i i n range ( 2 0 0 ) :
</p>
<p>311 i f s t o p p i n g ( ) :
</p>
<p>312 r e t u r n
</p>
<p>313
</p>
<p>314 p = P o i n t ( s c r e e n , i , i )
</p>
<p>315 p . c o l o r ( " green " )
</p>
<p>316 seq . append ( p )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>344 20 Appendix H: Complete Programs
</p>
<p>317
</p>
<p>318 s c r e e n . update ( )
</p>
<p>319 s c r e e n . t r a c e r ( 1 )
</p>
<p>320
</p>
<p>321 f o r i i n range ( 2 0 0 ) :
</p>
<p>322 i f s t o p p i n g ( ) :
</p>
<p>323 r e t u r n
</p>
<p>324
</p>
<p>325 j = random . r a n d i n t ( 0 ,1 9 9 )
</p>
<p>326
</p>
<p>327 p = seq [ i ]
</p>
<p>328 seq [ i ] = seq [ j ]
</p>
<p>329 seq [ j ] = p
</p>
<p>330 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>331 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>332 seq [ i ] . c o l o r ( " b l a c k " )
</p>
<p>333 seq [ j ] . c o l o r ( " b l a c k " )
</p>
<p>334
</p>
<p>335 s e l e c t i o n S o r t ( seq )
</p>
<p>336 s e l f . r u n n i n g = F a l s e
</p>
<p>337 s e l f . s t o p = F a l s e
</p>
<p>338
</p>
<p>339 button = t k i n t e r . Button ( s i d e B a r , t e x t = " S e l e c t i o n S o r t " , command= s e l S o r t H a n d l e r )
</p>
<p>340 button . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>341
</p>
<p>342 def m e r g e S o r t H a n d l e r ( ) :
</p>
<p>343 s e l f . r u n n i n g = T r u e
</p>
<p>344 c l e a r ( )
</p>
<p>345 s c r e e n . s e t w o r l d c o o r d i n a t e s ( 0 , &minus;2 5 ,2 0 0 ,2 0 0 )
</p>
<p>346 t h e T u r t l e . width ( 5 )
</p>
<p>347 s c r e e n . t r a c e r ( 0 )
</p>
<p>348 s e l f . master . t i t l e ( " Merge S o r t Animat ion " )
</p>
<p>349 seq = [ ]
</p>
<p>350 f o r i i n range ( 2 0 0 ) :
</p>
<p>351 i f s t o p p i n g ( ) :
</p>
<p>352 r e t u r n
</p>
<p>353
</p>
<p>354 p = P o i n t ( s c r e e n , i , i )
</p>
<p>355 p . c o l o r ( " green " )
</p>
<p>356 seq . append ( p )
</p>
<p>357
</p>
<p>358 s c r e e n . update ( )
</p>
<p>359 s c r e e n . t r a c e r ( 1 )
</p>
<p>360 f o r i i n range ( 2 0 0 ) :
</p>
<p>361 i f s t o p p i n g ( ) :
</p>
<p>362 r e t u r n
</p>
<p>363
</p>
<p>364 j = random . r a n d i n t ( 0 ,1 9 9 )
</p>
<p>365
</p>
<p>366 p = seq [ i ]
</p>
<p>367 seq [ i ] = seq [ j ]
</p>
<p>368 seq [ j ] = p
</p>
<p>369 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>370 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>371 seq [ i ] . c o l o r ( " b l a c k " )
</p>
<p>372 seq [ j ] . c o l o r ( " b l a c k " )
</p>
<p>373
</p>
<p>374 s c r e e n . t r a c e r ( 0 )
</p>
<p>375 mergeSort ( seq )
</p>
<p>376 s e l f . r u n n i n g = F a l s e
</p>
<p>377 s e l f . s t o p = F a l s e
</p>
<p>378
</p>
<p>379 button = t k i n t e r . Button ( s i d e B a r , t e x t = " Merge S o r t " , command= m e r g e S o r t H a n d l e r )
</p>
<p>380 button . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>381
</p>
<p>382 def q u i c k S o r t H a n d l e r ( ) :
</p>
<p>383 s e l f . r u n n i n g = T r u e
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.3 The Sort Animation 345
</p>
<p>384 c l e a r ( )
</p>
<p>385 s c r e e n . s e t w o r l d c o o r d i n a t e s ( 0 ,0 ,2 0 0 ,2 0 0 )
</p>
<p>386 t h e T u r t l e . width ( 5 )
</p>
<p>387 s c r e e n . t r a c e r ( 0 )
</p>
<p>388 s e l f . master . t i t l e ( " Q u i c k s o r t Animat ion " )
</p>
<p>389 seq = [ ]
</p>
<p>390 f o r i i n range ( 2 0 0 ) :
</p>
<p>391 i f s t o p p i n g ( ) :
</p>
<p>392 r e t u r n
</p>
<p>393
</p>
<p>394 p = P o i n t ( s c r e e n , i , i )
</p>
<p>395 p . c o l o r ( " green " )
</p>
<p>396 seq . append ( p )
</p>
<p>397
</p>
<p>398 s c r e e n . update ( )
</p>
<p>399 s c r e e n . t r a c e r ( 1 )
</p>
<p>400 f o r i i n range ( 2 0 0 ) :
</p>
<p>401 i f s t o p p i n g ( ) :
</p>
<p>402 r e t u r n
</p>
<p>403
</p>
<p>404 j = random . r a n d i n t ( 0 ,1 9 9 )
</p>
<p>405
</p>
<p>406 p = seq [ i ]
</p>
<p>407 seq [ i ] = seq [ j ]
</p>
<p>408 seq [ j ] = p
</p>
<p>409 seq [ i ] . goto ( i , seq [ i ] . y c o r ( ) )
</p>
<p>410 seq [ j ] . goto ( j , seq [ j ] . y c o r ( ) )
</p>
<p>411 seq [ i ] . c o l o r ( " b l a c k " )
</p>
<p>412 seq [ j ] . c o l o r ( " b l a c k " )
</p>
<p>413
</p>
<p>414 s c r e e n . t r a c e r ( 1 )
</p>
<p>415 q u i c k s o r t ( seq )
</p>
<p>416 s e l f . r u n n i n g = F a l s e
</p>
<p>417 s e l f . s t o p = F a l s e
</p>
<p>418
</p>
<p>419
</p>
<p>420 button = t k i n t e r . Button ( s i d e B a r , t e x t = " Q u i c k s o r t " , command= q u i c k S o r t H a n d l e r )
</p>
<p>421 button . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>422
</p>
<p>423 def p a u s e H a n d l e r ( ) :
</p>
<p>424 s e l f . paused = not s e l f . paused
</p>
<p>425
</p>
<p>426 button = t k i n t e r . Button ( s i d e B a r , t e x t = " Pause " , command= p a u s e H a n d l e r )
</p>
<p>427 button . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>428
</p>
<p>429 def s t o p H a n d l e r ( ) :
</p>
<p>430 i f not s e l f . paused and s e l f . r u n n i n g :
</p>
<p>431 s e l f . s t o p = T r u e
</p>
<p>432
</p>
<p>433 button = t k i n t e r . Button ( s i d e B a r , t e x t = " Stop " , command= s t o p H a n d l e r )
</p>
<p>434 button . pack ( f i l l = t k i n t e r . BOTH )
</p>
<p>435
</p>
<p>436 s c r e e n . l i s t e n ( )
</p>
<p>437
</p>
<p>438 # T h e main f u n c t i o n i n o u r GUI program i s v e r y s i m p l e . I t c r e a t e s t h e
</p>
<p>439 # r o o t window . Then i t c r e a t e s t h e S o r t A n i m a t i o n f r a m e w h i c h c r e a t e s
</p>
<p>440 # a l l t h e w i d g e t s and h a s t h e l o g i c f o r t h e e v e n t h a n d l e r s . C a l l i n g m a i n l o o p
</p>
<p>441 # on t h e f r a m e s makes i t s t a r t l i s t e n i n g f o r e v e n t s . T h e m a i n l o o p f u n c t i o n w i l l
</p>
<p>442 # r e t u r n when t h e a p p l i c a t i o n i s e x i t e d .
</p>
<p>443 def main ( ) :
</p>
<p>444 r o o t = t k i n t e r . Tk ( )
</p>
<p>445 anim = S o r t A n i m a t i o n ( r o o t )
</p>
<p>446
</p>
<p>447 anim . mainloop ( )
</p>
<p>448
</p>
<p>449 i f __name__ == " __main__ " :
</p>
<p>450 main ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>346 20 Appendix H: Complete Programs
</p>
<p>20.4 The PlotData Program
</p>
<p>This is the plot program that is used throughout the text to plot experimentally
</p>
<p>gathered data so it can be visualized. This program can be downloaded from the
</p>
<p>text&rsquo;s website.
</p>
<p>1 import t u r t l e
</p>
<p>2 import t k i n t e r
</p>
<p>3 import t k i n t e r . c o l o r c h o o s e r
</p>
<p>4 import t k i n t e r . f i l e d i a l o g
</p>
<p>5 import xml . dom . minidom
</p>
<p>6 import math
</p>
<p>7 import s y s
</p>
<p>8
</p>
<p>9 c l a s s P l o t A p p l i c a t i o n ( t k i n t e r . Frame ) :
</p>
<p>10 def _ _ i n i t _ _ ( s e l f , master =None , d a t a f i l e =None ) :
</p>
<p>11 super ( ) . _ _ i n i t _ _ ( master )
</p>
<p>12 s e l f . d a t a f i l e = d a t a f i l e
</p>
<p>13 s e l f . pack ( )
</p>
<p>14 s e l f . buildWindow ( )
</p>
<p>15
</p>
<p>16
</p>
<p>17 def buildWindow ( s e l f ) :
</p>
<p>18
</p>
<p>19 s e l f . master . t i t l e ( " P l o t " )
</p>
<p>20
</p>
<p>21 bar = t k i n t e r . Menu ( s e l f . master )
</p>
<p>22 f i l e M e n u = t k i n t e r . Menu ( bar , t e a r o f f =0)
</p>
<p>23
</p>
<p>24 def l o a d F i l e ( f i l e n a m e =None ) :
</p>
<p>25
</p>
<p>26 i f f i l e n a m e == None :
</p>
<p>27 f i l e n a m e = t k i n t e r . f i l e d i a l o g . a s k o p e n f i l e n a m e ( t i t l e = " S e l e c t a P l o t F i l e " )
</p>
<p>28
</p>
<p>29 t h e T u r t l e . c l e a r ( )
</p>
<p>30 t h e T u r t l e . penup ( )
</p>
<p>31 t h e T u r t l e . goto ( 0 , 0 )
</p>
<p>32 t h e T u r t l e . pendown ( )
</p>
<p>33 s c r e e n . update ( )
</p>
<p>34 t h e T u r t l e . c o l o r ( " b l a c k " )
</p>
<p>35
</p>
<p>36 xmldoc = xml . dom . minidom . p a r s e ( f i l e n a m e )
</p>
<p>37
</p>
<p>38 p l o t E l e m e n t = xmldoc . getElementsByTagName ( " P l o t " ) [ 0 ]
</p>
<p>39
</p>
<p>40 a t t r = p l o t E l e m e n t . a t t r i b u t e s
</p>
<p>41 s e l f . master . t i t l e ( a t t r [ " t i t l e " ] . v a l u e )
</p>
<p>42
</p>
<p>43 a x e s E l e m e n t = p l o t E l e m e n t . getElementsByTagName ( " Axes " ) [ 0 ]
</p>
<p>44
</p>
<p>45 x A x i s E l e m e n t = a x e s E l e m e n t . getElementsByTagName ( " X A x i s " ) [ 0 ]
</p>
<p>46 x A x i s L a b e l = x A x i s E l e m e n t . f i r s t C h i l d . d a t a . s t r i p ( )
</p>
<p>47
</p>
<p>48 y A x i s E l e m e n t = a x e s E l e m e n t . getElementsByTagName ( " Y A x i s " ) [ 0 ]
</p>
<p>49 y A x i s L a b e l = y A x i s E l e m e n t . f i r s t C h i l d . d a t a . s t r i p ( )
</p>
<p>50
</p>
<p>51 x A t t r = x A x i s E l e m e n t . a t t r i b u t e s
</p>
<p>52 y A t t r = y A x i s E l e m e n t . a t t r i b u t e s
</p>
<p>53
</p>
<p>54 minX = f l o a t ( x A t t r [ " min " ] . v a l u e )
</p>
<p>55 maxX = f l o a t ( x A t t r [ " max " ] . v a l u e )
</p>
<p>56 minY = f l o a t ( y A t t r [ " min " ] . v a l u e )
</p>
<p>57 maxY = f l o a t ( y A t t r [ " max " ] . v a l u e )
</p>
<p>58
</p>
<p>59 x S i z e = maxX &minus; minX
</p>
<p>60 y S i z e = maxY &minus; minY
</p>
<p>61 x C e n t e r = x S i z e / 2 .0 + minX
</p>
<p>62 y C e n t e r = y S i z e / 2 .0 + minY
</p>
<p>63
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.4 The PlotData Program 347
</p>
<p>64 x P l a c e s = max(4&minus;round ( math . l o g ( x S i z e , 1 0 ) ) , 0 )
</p>
<p>65 y P l a c e s = max(4&minus;round ( math . l o g ( y S i z e , 1 0 ) ) , 0 )
</p>
<p>66
</p>
<p>67 l a b e l Y V a l = maxY &minus; 0 .1 0 &lowast; y S i z e
</p>
<p>68
</p>
<p>69 s c r e e n . s e t w o r l d c o o r d i n a t e s ( minX&minus;0.20 &lowast; x S i z e , minY &minus; 0 .2 0 &lowast; y S i z e , \
</p>
<p>70 maxX + 0 .2 0 &lowast; x S i z e , maxY + 0 .2 0 &lowast; y S i z e )
</p>
<p>71
</p>
<p>72 t h e T u r t l e . ht ( )
</p>
<p>73
</p>
<p>74 t h e T u r t l e . penup ( )
</p>
<p>75 t h e T u r t l e . goto ( minX , minY )
</p>
<p>76 t h e T u r t l e . pendown ( )
</p>
<p>77 t h e T u r t l e . goto ( maxX , minY )
</p>
<p>78 t h e T u r t l e . penup ( )
</p>
<p>79 t h e T u r t l e . goto ( minX , minY )
</p>
<p>80 t h e T u r t l e . pendown ( )
</p>
<p>81 t h e T u r t l e . goto ( minX , maxY )
</p>
<p>82 t h e T u r t l e . penup ( )
</p>
<p>83
</p>
<p>84 t h e T u r t l e . goto ( xCenter , minY &minus; y S i z e &lowast; 0 .1 0 )
</p>
<p>85 t h e T u r t l e . w r i t e ( x A x i s L a b e l , a l i g n = " c e n t e r " , f o n t = ( " A r i a l " ,1 4 , " bold " ) )
</p>
<p>86
</p>
<p>87 t h e T u r t l e . goto ( minX , maxY + 0 .0 5 &lowast; y S i z e )
</p>
<p>88 t h e T u r t l e . w r i t e ( y A x i s L a b e l , a l i g n = " c e n t e r " , f o n t = ( " A r i a l " ,1 4 , " bold " ) )
</p>
<p>89
</p>
<p>90 f o r i i n range ( 0 , 1 0 1 , 1 0 ) :
</p>
<p>91 x = minX + x S i z e &lowast; i / 1 0 0 .0
</p>
<p>92 y = minY + y S i z e &lowast; i / 1 0 0 .0
</p>
<p>93
</p>
<p>94 t h e T u r t l e . penup ( )
</p>
<p>95 t h e T u r t l e . goto ( x , minY+ y S i z e &lowast; 0 .0 2 5 )
</p>
<p>96 t h e T u r t l e . pendown ( )
</p>
<p>97 t h e T u r t l e . goto ( x , minY&minus;y S i z e &lowast; 0 .0 2 5 )
</p>
<p>98 t h e T u r t l e . penup ( )
</p>
<p>99 t h e T u r t l e . goto ( x , minY&minus;y S i z e &lowast; 0 .0 5 )
</p>
<p>100
</p>
<p>101 t h e T u r t l e . w r i t e ( ( " %1. " + s t r ( x P l a c e s ) + " f " )%x , a l i g n = " c e n t e r " , f o n t = ( " A r i a l " ,1 2 , " normal " ) )
</p>
<p>102
</p>
<p>103 t h e T u r t l e . penup ( )
</p>
<p>104 t h e T u r t l e . goto ( minX+ x S i z e &lowast; 0 .0 2 5 , y )
</p>
<p>105 t h e T u r t l e . pendown ( )
</p>
<p>106 t h e T u r t l e . goto ( minX&minus;x S i z e &lowast; 0 .0 2 5 , y )
</p>
<p>107 t h e T u r t l e . goto ( minX&minus;x S i z e &lowast; 0 .0 0 1 , y )
</p>
<p>108 t h e T u r t l e . w r i t e ( ( " %1. " + s t r ( y P l a c e s ) + " f " )%y , a l i g n = " r i g h t " , f o n t = ( " A r i a l " ,1 2 , " normal " ) )
</p>
<p>109
</p>
<p>110
</p>
<p>111 sequences = p l o t E l e m e n t . getElementsByTagName ( " Sequence " )
</p>
<p>112
</p>
<p>113 f o r sequence i n sequences :
</p>
<p>114 a t t r = sequence . a t t r i b u t e s
</p>
<p>115
</p>
<p>116 l a b e l = a t t r [ " t i t l e " ] . v a l u e . s t r i p ( )
</p>
<p>117 c o l o r = a t t r [ " c o l o r " ] . v a l u e
</p>
<p>118 t h e T u r t l e . c o l o r ( c o l o r )
</p>
<p>119 t h e T u r t l e . penup ( )
</p>
<p>120 t h e T u r t l e . goto ( xCenter , l a b e l Y V a l )
</p>
<p>121 l a b e l Y V a l = l a b e l Y V a l &minus; 0 .1 0 &lowast; y S i z e
</p>
<p>122 t h e T u r t l e . w r i t e ( l a b e l , a l i g n = " c e n t e r " , f o n t = ( " A r i a l " ,1 4 , " bold " ) )
</p>
<p>123
</p>
<p>124 d a t a P o i n t s = sequence . getElementsByTagName ( " D a t a P o i n t " )
</p>
<p>125
</p>
<p>126 f i r s t = d a t a P o i n t s [ 0 ]
</p>
<p>127 a t t r = f i r s t . a t t r i b u t e s
</p>
<p>128 x = f l o a t ( a t t r [ " x " ] . v a l u e )
</p>
<p>129 y = f l o a t ( a t t r [ " y " ] . v a l u e )
</p>
<p>130 t h e T u r t l e . goto ( x , y )
</p>
<p>131 t h e T u r t l e . dot ( )
</p>
<p>132 t h e T u r t l e . pendown ( )
</p>
<p>133
</p>
<p>134
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>348 20 Appendix H: Complete Programs
</p>
<p>135 f o r d a t a P o i n t i n d a t a P o i n t s :
</p>
<p>136 a t t r = d a t a P o i n t . a t t r i b u t e s
</p>
<p>137 x = f l o a t ( a t t r [ " x " ] . v a l u e )
</p>
<p>138 y = f l o a t ( a t t r [ " y " ] . v a l u e )
</p>
<p>139 t h e T u r t l e . goto ( x , y )
</p>
<p>140 t h e T u r t l e . dot ( )
</p>
<p>141
</p>
<p>142 s c r e e n . update ( )
</p>
<p>143
</p>
<p>144
</p>
<p>145
</p>
<p>146 f i l e M e n u . add_command ( l a b e l = " Load P l o t Data . . . " ,command= l o a d F i l e )
</p>
<p>147
</p>
<p>148 f i l e M e n u . add_command ( l a b e l = " E x i t " ,command= s e l f . master . q u i t )
</p>
<p>149
</p>
<p>150 bar . add_cascade ( l a b e l = " F i l e " ,menu= f i l e M e n u )
</p>
<p>151
</p>
<p>152 s e l f . master . c o n f i g ( menu= bar )
</p>
<p>153
</p>
<p>154 c a n v a s = t k i n t e r . Canvas ( s e l f , width =1000 , h e i g h t =800)
</p>
<p>155 c a n v a s . pack ( s i d e = t k i n t e r . LEFT )
</p>
<p>156
</p>
<p>157 t h e T u r t l e = t u r t l e . R a wT u r t l e ( c a n v a s )
</p>
<p>158
</p>
<p>159 s c r e e n = t h e T u r t l e . g e t s c r e e n ( )
</p>
<p>160
</p>
<p>161 s c r e e n . t r a c e r ( 0 )
</p>
<p>162
</p>
<p>163 i f s e l f . d a t a f i l e ! = None :
</p>
<p>164 l o a d F i l e ( s e l f . d a t a f i l e . s t r i p ( ) )
</p>
<p>165
</p>
<p>166 def main ( ) :
</p>
<p>167 r o o t = t k i n t e r . Tk ( )
</p>
<p>168 d a t a f i l e = None
</p>
<p>169 i f l e n ( s y s . a r g v ) &gt; 1 :
</p>
<p>170 d a t a f i l e = s y s . a r g v [ 1 ]
</p>
<p>171 plotApp = P l o t A p p l i c a t i o n ( r o o t , d a t a f i l e )
</p>
<p>172
</p>
<p>173 plotApp . mainloop ( )
</p>
<p>174 p r i n t ( " Program E x e c u t i o n Completed . " )
</p>
<p>175
</p>
<p>176 i f __name__ == " __main__ " :
</p>
<p>177 main ( )
</p>
<p>20.5 The Tic Tac Toe Application
</p>
<p>This is the starter code for an exercise in constructing a tic tac toe game. This program
</p>
<p>can be downloaded from the text&rsquo;s website.
</p>
<p>1 from t u r t l e import &lowast;
</p>
<p>2 import t k i n t e r . messagebox
</p>
<p>3 import t k i n t e r
</p>
<p>4 import random
</p>
<p>5 import math
</p>
<p>6 import d a t e t i m e
</p>
<p>7 import t ime
</p>
<p>8 import s y s
</p>
<p>9
</p>
<p>10 s c r e e n M i n = 0
</p>
<p>11 screenMax = 300
</p>
<p>12 Human = &minus;1
</p>
<p>13 Computer = 1
</p>
<p>14
</p>
<p>15 c l a s s Board :
</p>
<p>16 # When a b o a r d i s c o n s t r u c t e d , you may want t o make a c o p y o f t h e b o a r d .
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.5 The Tic Tac Toe Application 349
</p>
<p>17 # T h i s can be a s h a l l o w c o p y o f t h e b o a r d b e c a u s e T u r t l e o b j e c t s a r e
</p>
<p>18 # I m m u t a b l e f r o m t h e p e r s p e c t i v e o f a b o a r d o b j e c t .
</p>
<p>19 def _ _ i n i t _ _ ( s e l f , board=None , s c r e e n =None ) :
</p>
<p>20 s e l f . s c r e e n = s c r e e n
</p>
<p>21 i f s c r e e n == None :
</p>
<p>22 i f board ! = None :
</p>
<p>23 s e l f . s c r e e n = board . s c r e e n
</p>
<p>24
</p>
<p>25 s e l f . i t e m s = [ ]
</p>
<p>26 f o r i i n range ( 3 ) :
</p>
<p>27 r o w l s t = [ ]
</p>
<p>28 f o r j i n range ( 3 ) :
</p>
<p>29 i f board==None :
</p>
<p>30 r o w l s t . append (Dummy ( ) )
</p>
<p>31 e l s e :
</p>
<p>32 r o w l s t . append ( board [ i ] [ j ] )
</p>
<p>33
</p>
<p>34 s e l f . i t e m s . append ( r o w l s t )
</p>
<p>35
</p>
<p>36 # A c c e s s o r method f o r t h e s c r e e n
</p>
<p>37 def g e t s c r e e n ( s e l f ) :
</p>
<p>38 r e t u r n s e l f . s c r e e n
</p>
<p>39
</p>
<p>40 # T h e g e t i t e m method i s u s e d t o i n d e x i n t o t h e b o a r d . I t s h o u l d
</p>
<p>41 # r e t u r n a row o f t h e b o a r d . T h a t row i t s e l f i s i n d e x a b l e ( i t i s j u s t
</p>
<p>42 # a l i s t ) s o a c c e s s i n g a row and column i n t h e b o a r d can be w r i t t e n
</p>
<p>43 # b o a r d [ row ] [ column ] b e c a u s e o f t h i s method .
</p>
<p>44 def _ _ g e t i t e m _ _ ( s e l f , i n d e x ) :
</p>
<p>45 r e t u r n s e l f . i t e m s [ i n d e x ]
</p>
<p>46
</p>
<p>47 # T h i s method s h o u l d r e t u r n t r u e i f t h e two b o a r d s , s e l f and o t h e r ,
</p>
<p>48 # r e p r e s e n t e x a c t l y t h e same s t a t e .
</p>
<p>49 # READER E X E R C I S E : YOU MUST COMPLETE T H I S FUNCTION
</p>
<p>50 def __eq__ ( s e l f , o t h e r ) :
</p>
<p>51 pass
</p>
<p>52
</p>
<p>53 # T h i s method w i l l m u t a t e t h i s b o a r d t o c o n t a i n a l l dummy
</p>
<p>54 # t u r t l e s . T h i s way t h e b o a r d can be r e s e t when a new game
</p>
<p>55 # i s s e l e c t e d . I t s h o u l d NOT be u s e d e x c e p t when s t a r t i n g
</p>
<p>56 # a new game .
</p>
<p>57 def r e s e t ( s e l f ) :
</p>
<p>58
</p>
<p>59 s e l f . s c r e e n . t r a c e r ( 1 )
</p>
<p>60 f o r i i n range ( 3 ) :
</p>
<p>61 f o r j i n range ( 3 ) :
</p>
<p>62 s e l f . i t e m s [ i ] [ j ] . goto (&minus;100 ,&minus;100)
</p>
<p>63 s e l f . i t e m s [ i ] [ j ] = Dummy ( )
</p>
<p>64
</p>
<p>65 s e l f . s c r e e n . t r a c e r ( 0 )
</p>
<p>66
</p>
<p>67 # T h i s method s h o u l d r e t u r n an i n t e g e r r e p r e s e n t i n g t h e
</p>
<p>68 # s t a t e o f t h e b o a r d . I f t h e c o m p u t e r h a s won , r e t u r n 1 .
</p>
<p>69 # I f t h e human h a s won , r e t u r n &minus;1. O t h e r w i s e , r e t u r n 0 .
</p>
<p>70 # READER E X E R C I S E : YOU MUST COMPLETE T H I S FUNCTION
</p>
<p>71 def e v a l ( s e l f ) :
</p>
<p>72 pass
</p>
<p>73
</p>
<p>74 # T h i s method s h o u l d r e t u r n T r u e i f t h e b o a r d
</p>
<p>75 # i s c o m p l e t e l y f i l l e d up ( no dummy t u r t l e s ) .
</p>
<p>76 # O t h e r w i s e , i t s h o u l d r e t u r n F a l s e .
</p>
<p>77 # READER E X E R C I S E : YOU MUST COMPLETE T H I S FUNCTION
</p>
<p>78 def f u l l ( s e l f ) :
</p>
<p>79 pass
</p>
<p>80
</p>
<p>81 # T h i s method s h o u l d draw t h e X &rsquo; s and O &rsquo; s
</p>
<p>82 # Of t h i s b o a r d on t h e s c r e e n .
</p>
<p>83 def drawXOs ( s e l f ) :
</p>
<p>84
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>350 20 Appendix H: Complete Programs
</p>
<p>85 f o r row i n range ( 3 ) :
</p>
<p>86 f o r c o l i n range ( 3 ) :
</p>
<p>87 i f s e l f [ row ] [ c o l ] . e v a l ( ) ! = 0 :
</p>
<p>88 s e l f [ row ] [ c o l ] . s t ( )
</p>
<p>89 s e l f [ row ] [ c o l ] . goto ( c o l &lowast;100+50 ,row&lowast;100+50)
</p>
<p>90
</p>
<p>91 s e l f . s c r e e n . update ( )
</p>
<p>92
</p>
<p>93 # T h i s c l a s s i s j u s t f o r p l a c e h o l d e r o b j e c t s when no move h a s been made
</p>
<p>94 # y e t a t a p o s i t i o n i n t h e b o a r d . H a v i n g e v a l ( ) r e t u r n 0 i s c o n v e n i e n t when no
</p>
<p>95 # move h a s been made .
</p>
<p>96 c l a s s Dummy :
</p>
<p>97 def _ _ i n i t _ _ ( s e l f ) :
</p>
<p>98 pass
</p>
<p>99
</p>
<p>100 def e v a l ( s e l f ) :
</p>
<p>101 r e t u r n 0
</p>
<p>102
</p>
<p>103 def goto ( s e l f , x , y ) :
</p>
<p>104 pass
</p>
<p>105
</p>
<p>106 # I n t h e X and O c l a s s e s b e l o w t h e c o n s t r u c t o r b e g i n s by i n i t i a l i z i n g t h e
</p>
<p>107 # R a w T u r t l e p a r t o f t h e o b j e c t w i t h t h e c a l l t o s u p e r ( ) . _ _ i n i t _ _ ( c a n v a s ) . T h e
</p>
<p>108 # s u p e r ( ) c a l l r e t u r n s t h e c l a s s o f t h e s u p e r c l a s s ( t h e c l a s s above t h e X o r O
</p>
<p>109 # i n t h e c l a s s h i e r a r c h y ) . I n t h i s c a s e , t h e s u p e r c l a s s i s R a w T u r t l e . Then ,
</p>
<p>110 # c a l l i n g _ _ i n i t _ _ on t h e s u p e r c l a s s i n i t i a l i z e s t h e p a r t o f t h e o b j e c t t h a t i s
</p>
<p>111 # a R a w T u r t l e . c l a s s X ( R a w T u r t l e ) :
</p>
<p>112 def _ _ i n i t _ _ ( s e l f , c a n v a s ) :
</p>
<p>113 super ( ) . _ _ i n i t _ _ ( c a n v a s )
</p>
<p>114 s e l f . ht ( )
</p>
<p>115 s e l f . g e t s c r e e n ( ) . r e g i s t e r _ s h a p e ( " X " ,( ( &minus;4 0 , &minus;3 6 ) ,( &minus;4 0 , &minus;4 4 ) ,( 0 , &minus;4 ) ,( 4 0 , &minus;4 4 ) ,( 4 0 , &minus;3 6 ) , \
</p>
<p>116 ( 4 ,0 ) , ( 4 0 ,3 6 ) , ( 4 0 ,4 4 ) , ( 0 ,4 ) , ( &minus; 4 0 ,4 4 ) , ( &minus; 4 0 ,3 6 ) , ( &minus; 4 ,0 ) , ( &minus; 4 0 , &minus; 3 6 ) ) )
</p>
<p>117 s e l f . shape ( " X " )
</p>
<p>118 s e l f . penup ( )
</p>
<p>119 s e l f . speed ( 5 )
</p>
<p>120 s e l f . goto (&minus;100 ,&minus;100)
</p>
<p>121
</p>
<p>122 def e v a l ( s e l f ) :
</p>
<p>123 r e t u r n Computer
</p>
<p>124
</p>
<p>125 c l a s s O ( R a wT u r t l e ) :
</p>
<p>126 def _ _ i n i t _ _ ( s e l f , c a n v a s ) :
</p>
<p>127 super ( ) . _ _ i n i t _ _ ( c a n v a s )
</p>
<p>128 s e l f . ht ( )
</p>
<p>129 s e l f . shape ( " c i r c l e " )
</p>
<p>130 s e l f . penup ( )
</p>
<p>131 s e l f . speed ( 5 )
</p>
<p>132 s e l f . goto (&minus;100 ,&minus;100)
</p>
<p>133
</p>
<p>134 def e v a l ( s e l f ) :
</p>
<p>135 r e t u r n Human
</p>
<p>136
</p>
<p>137 # T h e minimax f u n c t i o n i s g i v e n a p l a y e r ( 1 = Computer , &minus;1 = Human ) and a
</p>
<p>138 # b o a r d o b j e c t . When t h e p l a y e r = Computer , minimax r e t u r n s t h e maximum
</p>
<p>139 # v a l u e o f a l l p o s s i b l e moves t h a t t h e Computer c o u l d make . When t h e p l a y e r =
</p>
<p>140 # Human t h e n minimax r e t u r n s t h e minimum v a l u e o f a l l p o s s i b l e moves t h e Human
</p>
<p>141 # c o u l d make . Minimax w o r k s by a s s u m i n g t h a t a t e a c h move t h e Computer w i l l p i c k
</p>
<p>142 # i t s b e s t move and t h e Human w i l l p i c k i t s b e s t move . I t d o e s t h i s by making a
</p>
<p>143 # move f o r t h e p l a y e r whose t u r n i t i s , and t h e n r e c u r s i v e l y c a l l i n g minimax .
</p>
<p>144 # T h e b a s e c a s e r e s u l t s when , g i v e n t h e s t a t e o f t h e board , someone h a s won o r
</p>
<p>145 # t h e b o a r d i s f u l l .
</p>
<p>146 # READER E X E R C I S E : YOU MUST
</p>
<p>147 COMPLETE T H I S FUNCTION
</p>
<p>148 def minimax ( p l a y e r , board ) :
</p>
<p>149 pass
</p>
<p>150
</p>
<p>151
</p>
<p>152
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.5 The Tic Tac Toe Application 351
</p>
<p>153 c l a s s T i cT a cT o e ( t k i n t e r . Frame ) :
</p>
<p>154 def _ _ i n i t _ _ ( s e l f , master =None ) :
</p>
<p>155 super ( ) . _ _ i n i t _ _ ( master )
</p>
<p>156 s e l f . pack ( )
</p>
<p>157 s e l f . buildWindow ( )
</p>
<p>158 s e l f . paused = F a l s e
</p>
<p>159 s e l f . s t o p = F a l s e
</p>
<p>160 s e l f . r u n n i n g = F a l s e
</p>
<p>161 s e l f . t u r n = Human
</p>
<p>162 s e l f . l o c k e d = F a l s e
</p>
<p>163
</p>
<p>164 def buildWindow ( s e l f ) :
</p>
<p>165
</p>
<p>166 cv = S c r o l l e d C a n v a s ( s e l f ,6 0 0 ,6 0 0 ,6 0 0 ,6 0 0 )
</p>
<p>167 cv . pack ( s i d e = t k i n t e r . LEFT )
</p>
<p>168 t = R a wT u r t l e ( cv )
</p>
<p>169 s c r e e n = t . g e t s c r e e n ( )
</p>
<p>170 s c r e e n . t r a c e r ( 1 0 0 0 0 0 )
</p>
<p>171
</p>
<p>172 s c r e e n . s e t w o r l d c o o r d i n a t e s ( screenMin , screenMin , screenMax , screenMax )
</p>
<p>173 s c r e e n . b g c o l o r ( " w h i t e " )
</p>
<p>174 t . ht ( )
</p>
<p>175
</p>
<p>176 f rame = t k i n t e r . Frame ( s e l f )
</p>
<p>177 f rame . pack ( s i d e = t k i n t e r . RIGHT , f i l l = t k i n t e r . BOTH )
</p>
<p>178 board = Board ( None , s c r e e n )
</p>
<p>179
</p>
<p>180 def drawGrid ( ) :
</p>
<p>181 s c r e e n . c l e a r ( )
</p>
<p>182 s c r e e n . t r a c e r ( 1 0 0 0 0 0 0 )
</p>
<p>183 s c r e e n . s e t w o r l d c o o r d i n a t e s ( screenMin , screenMin , screenMax , screenMax )
</p>
<p>184 s c r e e n . b g c o l o r ( " w h i t e " )
</p>
<p>185 s c r e e n . t r a c e r ( 0 )
</p>
<p>186 t = R a wT u r t l e ( cv )
</p>
<p>187 t . ht ( )
</p>
<p>188 t . pu ( )
</p>
<p>189 t . width ( 1 0 )
</p>
<p>190 t . c o l o r ( " green " )
</p>
<p>191 f o r i i n range ( 2 ) :
</p>
<p>192 t . penup ( )
</p>
<p>193 t . goto ( i &lowast;1 0 0 + 1 0 0 ,1 0 )
</p>
<p>194 t . pendown ( )
</p>
<p>195 t . goto ( i &lowast;1 0 0 + 1 0 0 ,2 9 0 )
</p>
<p>196 t . penup ( )
</p>
<p>197 t . goto ( 1 0 , i &lowast;100+100)
</p>
<p>198 t . pendown ( )
</p>
<p>199 t . goto ( 2 9 0 , i &lowast;100+100)
</p>
<p>200
</p>
<p>201 s c r e e n . update ( )
</p>
<p>202
</p>
<p>203
</p>
<p>204 def newGame ( ) :
</p>
<p>205 # d r a w G r i d ( )
</p>
<p>206 s e l f . t u r n = Human
</p>
<p>207 board . r e s e t ( )
</p>
<p>208 s e l f . l o c k e d = F a l s e
</p>
<p>209 s c r e e n . update ( )
</p>
<p>210
</p>
<p>211
</p>
<p>212 def s t a r t H a n d l e r ( ) :
</p>
<p>213 newGame ( )
</p>
<p>214
</p>
<p>215 drawGrid ( )
</p>
<p>216
</p>
<p>217 s t a r t B u t t o n = t k i n t e r . Butto n ( frame , t e x t = " New Game " , command= s t a r t H a n d l e r )
</p>
<p>218 s t a r t B u t t o n . pack ( )
</p>
<p>219
</p>
<p>220
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>352 20 Appendix H: Complete Programs
</p>
<p>221 def q u i t H a n d l e r ( ) :
</p>
<p>222 s e l f . master . q u i t ( )
</p>
<p>223
</p>
<p>224 q u i t B u t t o n = t k i n t e r . Butto n ( frame , t e x t = " Q u i t " , command= q u i t H a n d l e r )
</p>
<p>225 q u i t B u t t o n . pack ( )
</p>
<p>226
</p>
<p>227 def computerTurn ( ) :
</p>
<p>228 # T h e l o c k e d v a r i a b l e p r e v e n t s a n o t h e r e v e n t f r o m b e i n g
</p>
<p>229 # p r o c e s s e d w h i l e t h e c o m p u t e r i s making up i t s mind .
</p>
<p>230 s e l f . l o c k e d = T r u e
</p>
<p>231
</p>
<p>232 # C a l l Minimax t o f i n d t h e b e s t move t o make .
</p>
<p>233 # READER E X E R C I S E : YOU MUST COMPLETE T H I S CODE
</p>
<p>234 # A f t e r w r i t i n g t h i s code , t h e maxMove t u p l e s h o u l d
</p>
<p>235 # c o n t a i n t h e b e s t move f o r t h e c o m p u t e r . F o r i n s t a n c e ,
</p>
<p>236 # i f t h e b e s t move i s i n t h e f i r s t row and t h i r d column
</p>
<p>237 # t h e n maxMove would be ( 0 , 2 ) .
</p>
<p>238
</p>
<p>239 row , c o l = maxMove
</p>
<p>240 board [ row ] [ c o l ] = X ( cv )
</p>
<p>241 s e l f . l o c k e d = F a l s e
</p>
<p>242
</p>
<p>243
</p>
<p>244 def m o u s e C l i c k ( x , y ) :
</p>
<p>245 i f not s e l f . l o c k e d :
</p>
<p>246 row = i n t ( y / / 1 0 0 )
</p>
<p>247 c o l = i n t ( x / / 1 0 0 )
</p>
<p>248
</p>
<p>249 board [ row ] [ c o l ] = O ( cv )
</p>
<p>250
</p>
<p>251 s e l f . t u r n = Computer
</p>
<p>252
</p>
<p>253 board . drawXOs ( )
</p>
<p>254
</p>
<p>255 i f not board . f u l l ( ) and not abs ( board . e v a l ( ) ) = = 1 :
</p>
<p>256 computerTurn ( )
</p>
<p>257
</p>
<p>258 s e l f . t u r n = Human
</p>
<p>259
</p>
<p>260 board . drawXOs ( )
</p>
<p>261 e l s e :
</p>
<p>262 s e l f . l o c k e d = T r u e
</p>
<p>263
</p>
<p>264 i f board . e v a l ( ) == 1 :
</p>
<p>265 t k i n t e r . messagebox . showwarning ( " Game Over " , " X wins ! ! ! " )
</p>
<p>266
</p>
<p>267 i f board . e v a l ( ) == &minus;1:
</p>
<p>268 t k i n t e r . messagebox . showwarning ( " Game Over " , "O wins . How d i d t h a t happen ? " )
</p>
<p>269
</p>
<p>270 i f board . f u l l ( ) :
</p>
<p>271 t k i n t e r . messagebox . showwarning ( " Game Over " , " I t was a t i e . " )
</p>
<p>272
</p>
<p>273 s c r e e n . o n c l i c k ( m o u s e C l i c k )
</p>
<p>274
</p>
<p>275 s c r e e n . l i s t e n ( )
</p>
<p>276
</p>
<p>277 def main ( ) :
</p>
<p>278 r o o t = t k i n t e r . Tk ( )
</p>
<p>279 r o o t . t i t l e ( " T i c Tac Toe " )
</p>
<p>280 a p p l i c a t i o n = T i cT a cT o e ( r o o t )
</p>
<p>281 a p p l i c a t i o n . mainloop ( )
</p>
<p>282
</p>
<p>283 i f __name__ == " __main__ " :
</p>
<p>284 main ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.6 The Connect Four Front-End 353
</p>
<p>20.6 The Connect Four Front-End
</p>
<p>This provides the GUI front-end to the connect four game presented in the last chapter
</p>
<p>of the text. This can serve as a front-end for a computer opponent back-end. This
</p>
<p>program can be downloaded from the text&rsquo;s website.
</p>
<p>1 import t u r t l e
</p>
<p>2 import s u b p r o c e s s
</p>
<p>3 import t k i n t e r
</p>
<p>4 import s y s
</p>
<p>5 import t ime
</p>
<p>6
</p>
<p>7 # T h e f o l l o w i n g program w i l l p l a y c o n n e c t f o u r . T h i s
</p>
<p>8 # program and a a n o t h e r program communicate t h r o u g h p i p e s ( b o t h i n p u t and o u t p u t )
</p>
<p>9 # a c c o r d i n g t o t h i s a r c h i t e c t u r e . When a command i s s e n t i t i s i n d i c a t e d
</p>
<p>10 # w i t h a r i g h t a r r o w i n d i c a t i n g s o m e t h i n g i s w r i t t e n t o t h e o t h e r program &rsquo; s
</p>
<p>11 # s t a n d a r d i n p u t . When t h e o t h e r program s e n d s s o m e t h i n g t o t h i s P y t h o n Program
</p>
<p>12 # i t i s i n d i c a t e d w i t h a l e f t a r r o w . T h a t means i t i s w r i t t e n t o t h e s t a n d a r d
</p>
<p>13 # o u t p u t o f t h e o t h e r program .
</p>
<p>14
</p>
<p>15 # P y t h o n O t h e r
</p>
<p>16 # 0 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&gt; # New Game i s i n i t i a t e d by t h e O t h e r Code
</p>
<p>17 # &lt;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus; 0 # O t h e r Code s a y s OK .
</p>
<p>18 # 2 M &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&gt; # Human Move f o l l o w e d by Move V a l u e M w h i c h i s 0&minus;6.
</p>
<p>19 # # Move V a l u e M w i l l be on s e p a r a t e l i n e .
</p>
<p>20 # &lt;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus; 0 # O t h e r Code s a y s OK .
</p>
<p>21 # 1 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&gt; # Computer Move i s i n d i c a t e d t o O t h e r Code
</p>
<p>22 # &lt;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus; 0 M # S t a t u s OK and Move V a l u e M w h i c h i s 0&minus;6.
</p>
<p>23 # 3 &minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&gt; # Game O v e r ?
</p>
<p>24 # &lt;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus;&minus; V a l # V a l i s 0= Not Over , 1= Computer Won , 2=Human Won , 3= T i e .
</p>
<p>25
</p>
<p>26 # T h i s a r c h i t e c t u r e must be a d h e r e d t o s t r i c t l y f o r t h i s program t o work . H e r e
</p>
<p>27 # i s s a m p l e L i s p c o d e t h a t w i l l h a n d l e t h i s i n t e r a c t i o n . However , t h e o t h e r
</p>
<p>28 # program may be w r i t t e n i n any programming l a n g u a g e , i n c l u d i n g P y t h o n .
</p>
<p>29
</p>
<p>30 # ( d e f u n p l a y ( )
</p>
<p>31 # ( l e t ( ( gameBoard ( make&minus;hash&minus;t a b l e : s i z e 1 0 ) )
</p>
<p>32 # ( memo ( make&minus;hash&minus;t a b l e : s i z e 27 : t e s t # &rsquo; e q u a l p ) )
</p>
<p>33 # ( l a s t M o v e n i l ) )
</p>
<p>34
</p>
<p>35 # ( do ( ) ( n i l n i l )
</p>
<p>36 # ; ( p r i n t B o a r d gameBoard )
</p>
<p>37 # ( l e t ( ( msgId ( r e a d ) ) )
</p>
<p>38 # ( cond ( ( e q u a l msgId 2 ) ; ; Human t u r n t o c a l l human t u r n f u n c t i o n
</p>
<p>39 # ( s e t f l a s t M o v e ( humanTurn gameBoard ) ) )
</p>
<p>40
</p>
<p>41 # ( ( e q u a l msgId 0 ) ; ; New Game message
</p>
<p>42 # ( p r o g n
</p>
<p>43 # ( s e t f gameBoard ( make&minus;hash&minus;t a b l e : s i z e 1 0 ) )
</p>
<p>44 # ( s e t f memo ( make&minus;hash&minus;t a b l e : s i z e 27 : t e s t # &rsquo; e q u a l p ) )
</p>
<p>45 # ( f o r m a t t " 0 ~ % " ) ) )
</p>
<p>46 # ; ; R e t u r n a 0 t o i n d i c a t e t h e c o m p u t e r i s r e a d y
</p>
<p>47
</p>
<p>48 # ( ( e q u a l msgId 1 ) ; ; Computer T u r n message
</p>
<p>49 # ( s e t f l a s t M o v e ( c o m p u t e rT u r n gameBoard ) ) )
</p>
<p>50
</p>
<p>51 # ( ( e q u a l msgId 3 ) ; ; G e t Game S t a t u s
</p>
<p>52
</p>
<p>53 # ( cond ( ( e q u a l ( e v a l B o a r d gameBoard l a s t M o v e ) 1 ) ( f o r m a t t " 1 ~ % " ) )
</p>
<p>54 # ; ; T h e Computer Won
</p>
<p>55
</p>
<p>56 # ( ( e q u a l ( e v a l B o a r d gameBoard l a s t M o v e ) &minus;1) ( f o r m a t t " 2 ~ % " ) )
</p>
<p>57 # ; ; T h e Human Won
</p>
<p>58
</p>
<p>59 # ( ( f u l l B o a r d gameBoard ) ( f o r m a t t " 3 ~ % " ) )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>354 20 Appendix H: Complete Programs
</p>
<p>60 # ; ; I t &rsquo; s a draw
</p>
<p>61
</p>
<p>62 # ( t ( f o r m a t t " 0 ~ % " ) ) ) )
</p>
<p>63 # ; ; T h e game i s n o t o v e r y e t .
</p>
<p>64
</p>
<p>65 # ( t ( f o r m a t t " &minus; 1 ~ % " ) ) ) ) ) ) )
</p>
<p>66
</p>
<p>67 Computer = 1 Human = &minus;1
</p>
<p>68
</p>
<p>69 c l a s s T i l e ( t u r t l e . R a wT u r t l e ) :
</p>
<p>70 def _ _ i n i t _ _ ( s e l f , canvas , row , c o l , app ) :
</p>
<p>71 super ( ) . _ _ i n i t _ _ ( c a n v a s )
</p>
<p>72 s e l f . v a l = 0
</p>
<p>73 s e l f . row = row
</p>
<p>74 s e l f . c o l = c o l
</p>
<p>75 s e l f . t t t A p p l i c a t i o n = app
</p>
<p>76 s e l f . penup ( )
</p>
<p>77 s e l f . ht ( )
</p>
<p>78 s e l f . goto ( c o l &lowast;100+50 ,row&lowast;100+50)
</p>
<p>79
</p>
<p>80 def s e t S h a p e ( s e l f , horc , s c r e e n ) :
</p>
<p>81 s e l f . v a l = horc
</p>
<p>82
</p>
<p>83 i f horc == Computer :
</p>
<p>84 s e l f . shape ( " b l a c k c h e c k e r . g i f " )
</p>
<p>85 e l s e :
</p>
<p>86 s e l f . shape ( " r e d c h e c k e r . g i f " )
</p>
<p>87
</p>
<p>88 s e l f . drop ( s c r e e n )
</p>
<p>89
</p>
<p>90 def getOwner ( s e l f ) :
</p>
<p>91 r e t u r n s e l f . v a l
</p>
<p>92
</p>
<p>93 def c l i c k e d ( s e l f ) :
</p>
<p>94 p r i n t ( s e l f . row , s e l f . c o l )
</p>
<p>95
</p>
<p>96 def drop ( s e l f , s c r e e n ) :
</p>
<p>97 s e l f . goto ( s e l f . c o l &lowast;1 0 0 + 5 0 ,0 )
</p>
<p>98 s c r e e n . t r a c e r ( 1 )
</p>
<p>99 s e l f . speed ( 5 )
</p>
<p>100 s e l f . s t ( )
</p>
<p>101 s e l f . goto ( s e l f . c o l &lowast;100+50 , s e l f . row&lowast;100+55)
</p>
<p>102 s e l f . goto ( s e l f . c o l &lowast;100+50 , s e l f . row&lowast;100+45)
</p>
<p>103 s e l f . goto ( s e l f . c o l &lowast;100+50 , s e l f . row&lowast;100+50)
</p>
<p>104 s c r e e n . t r a c e r ( 0 )
</p>
<p>105
</p>
<p>106 c l a s s C o n n e c t 4 A p p l i c a t i o n ( t k i n t e r . Frame ) :
</p>
<p>107 def _ _ i n i t _ _ ( s e l f , master =None ) :
</p>
<p>108 super ( ) . _ _ i n i t _ _ ( master )
</p>
<p>109 s e l f . pack ( )
</p>
<p>110 s e l f . buildWindow ( )
</p>
<p>111 s e l f . r u n n i n g = F a l s e
</p>
<p>112
</p>
<p>113 def buildWindow ( s e l f ) :
</p>
<p>114
</p>
<p>115 s e l f . master . t i t l e ( " Connect Four " )
</p>
<p>116
</p>
<p>117 bar = t k i n t e r . Menu ( s e l f . master )
</p>
<p>118 f i l e M e n u = t k i n t e r . Menu ( bar , t e a r o f f =0)
</p>
<p>119
</p>
<p>120 f i l e M e n u . add_command ( l a b e l = " E x i t " ,command= s e l f . master . q u i t )
</p>
<p>121
</p>
<p>122 bar . add_cascade ( l a b e l = " F i l e " ,menu= f i l e M e n u )
</p>
<p>123
</p>
<p>124 s e l f . master . c o n f i g ( menu= bar )
</p>
<p>125
</p>
<p>126
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.6 The Connect Four Front-End 355
</p>
<p>127 c a n v a s = t k i n t e r . Canvas ( s e l f , width =700 , h e i g h t =600)
</p>
<p>128 c a n v a s . pack ( s i d e = t k i n t e r . LEFT )
</p>
<p>129
</p>
<p>130 t h e T u r t l e = t u r t l e . R a wT u r t l e ( c a n v a s )
</p>
<p>131 t h e T u r t l e . ht ( )
</p>
<p>132 s c r e e n = t h e T u r t l e . g e t s c r e e n ( )
</p>
<p>133 s c r e e n . s e t w o r l d c o o r d i n a t e s ( 0 ,6 0 0 ,7 0 0 ,0 )
</p>
<p>134 s c r e e n . r e g i s t e r _ s h a p e ( " b l a c k c h e c k e r . g i f " )
</p>
<p>135 s c r e e n . r e g i s t e r _ s h a p e ( " r e d c h e c k e r . g i f " )
</p>
<p>136 s c r e e n . t r a c e r ( 0 )
</p>
<p>137 s c r e e n . b g c o l o r ( " y e l l o w " )
</p>
<p>138
</p>
<p>139 t h e T u r t l e . width ( 5 )
</p>
<p>140 f o r k i n range ( 6 ) :
</p>
<p>141 t h e T u r t l e . penup ( )
</p>
<p>142 t h e T u r t l e . goto ( k &lowast;1 0 0 + 1 0 0 ,0 )
</p>
<p>143 t h e T u r t l e . pendown ( )
</p>
<p>144 t h e T u r t l e . goto ( k &lowast;1 0 0 + 1 0 0 ,6 0 0 )
</p>
<p>145
</p>
<p>146 t h e T u r t l e . ht ( )
</p>
<p>147
</p>
<p>148 s c r e e n . update ( )
</p>
<p>149
</p>
<p>150 def c h e c k S t a t u s ( ) :
</p>
<p>151 t o O t h e r . w r i t e ( " 3 \ n " )
</p>
<p>152 t o O t h e r . f l u s h ( )
</p>
<p>153
</p>
<p>154 s t a t u s = i n t ( f romOther . r e a d l i n e ( ) . s t r i p ( ) )
</p>
<p>155
</p>
<p>156 i f s t a t u s == 1 :
</p>
<p>157 t k i n t e r . messagebox . showinfo ( " Game Over " , " I Won ! ! ! ! ! " )
</p>
<p>158 e l i f s t a t u s == 2 :
</p>
<p>159 t k i n t e r . messagebox . showinfo ( " Game Over " , " You Won ! ! ! ! ! " )
</p>
<p>160 e l i f s t a t u s == 3 :
</p>
<p>161 t k i n t e r . messagebox . showinfo ( " Game Over " , " I t &rsquo; s a t i e . " )
</p>
<p>162
</p>
<p>163 # p r i n t ( " S t a t u s i s " , s t a t u s )
</p>
<p>164 r e t u r n s t a t u s
</p>
<p>165
</p>
<p>166 def ComputerTurn ( ) :
</p>
<p>167 t o O t h e r . w r i t e ( " 1 \ n " )
</p>
<p>168 t o O t h e r . f l u s h ( )
</p>
<p>169 s t a t u s = i n t ( f romOther . r e a d l i n e ( ) . s t r i p ( ) )
</p>
<p>170 # p r i n t ( " Computer T u r n O t h e r S t a t u s = " , s t a t u s )
</p>
<p>171 i f s t a t u s == 0 :
</p>
<p>172 move = i n t ( f romOther . r e a d l i n e ( ) )
</p>
<p>173 # p r i n t ( " Move i s " , move )
</p>
<p>174 row = move / / 7
</p>
<p>175 c o l = move % 7
</p>
<p>176
</p>
<p>177 m a t r i x [ row ] [ c o l ] . s e t S h a p e ( Computer , s c r e e n )
</p>
<p>178 s c r e e n . update ( )
</p>
<p>179
</p>
<p>180 def HumanTurn ( x , y ) :
</p>
<p>181 i f s e l f . r u n n i n g :
</p>
<p>182 r e t u r n
</p>
<p>183
</p>
<p>184 # s t a t u s = c h e c k S t a t u s ( )
</p>
<p>185
</p>
<p>186 # i f s t a t u s ! = 0 :
</p>
<p>187 # r e t u r n
</p>
<p>188
</p>
<p>189 s e l f . r u n n i n g = T r u e
</p>
<p>190 c o l = i n t ( x ) / / 100
</p>
<p>191
</p>
<p>192 row = 5
</p>
<p>193 while row &gt;= 0 and m a t r i x [ row ] [ c o l ] . i s v i s i b l e ( ) :
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>356 20 Appendix H: Complete Programs
</p>
<p>194 row = row &minus; 1
</p>
<p>195
</p>
<p>196 i f row &lt; 0 :
</p>
<p>197 # Then we c l i c k e d i n a column t h a t was a l r e a d y f u l l .
</p>
<p>198 s e l f . r u n n i n g = T r u e
</p>
<p>199 r e t u r n
</p>
<p>200
</p>
<p>201 v a l = row &lowast; 7 + c o l
</p>
<p>202
</p>
<p>203 # Do t h e Human T u r n
</p>
<p>204 t o O t h e r . w r i t e ( " 2 \ n " )
</p>
<p>205 t o O t h e r . f l u s h ( )
</p>
<p>206 t o O t h e r . w r i t e ( s t r ( v a l ) + " \ n " )
</p>
<p>207 t o O t h e r . f l u s h ( )
</p>
<p>208
</p>
<p>209 s t a t u s = fromOther . r e a d l i n e ( ) . s t r i p ( )
</p>
<p>210 # p r i n t ( " S t a t u s i s " , s t a t u s )
</p>
<p>211
</p>
<p>212 m a t r i x [ row ] [ c o l ] . s e t S h a p e ( Human , s c r e e n )
</p>
<p>213 s c r e e n . update ( )
</p>
<p>214
</p>
<p>215 # C h e c k t h e s t a t u s o f t h e game
</p>
<p>216 s t a t u s = c h e c k S t a t u s ( )
</p>
<p>217
</p>
<p>218 i f s t a t u s == 0 :
</p>
<p>219 # Do a Computer T u r n
</p>
<p>220 ComputerTurn ( )
</p>
<p>221 c h e c k S t a t u s ( )
</p>
<p>222
</p>
<p>223 s e l f . r u n n i n g = F a l s e
</p>
<p>224
</p>
<p>225
</p>
<p>226 m a t r i x = [ ]
</p>
<p>227
</p>
<p>228 f o r i i n range ( 6 ) :
</p>
<p>229 row = [ ]
</p>
<p>230 f o r j i n range ( 7 ) :
</p>
<p>231 t = T i l e ( canvas , i , j , s e l f )
</p>
<p>232 row . append ( t )
</p>
<p>233 m a t r i x . append ( row )
</p>
<p>234
</p>
<p>235 s c r e e n . update ( )
</p>
<p>236 s c r e e n . o n c l i c k ( HumanTurn )
</p>
<p>237
</p>
<p>238 s i d e B a r = t k i n t e r . Frame ( s e l f , padx = 5 ,pady = 5 , r e l i e f = t k i n t e r . RAISED , b o r d e r w i d t h = " 5 pt " )
</p>
<p>239 s i d e B a r . pack ( s i d e = t k i n t e r . RIGHT , f i l l = t k i n t e r . BOTH )
</p>
<p>240
</p>
<p>241 def NewGame ( ) :
</p>
<p>242 t o O t h e r . w r i t e ( " 0 \ n " )
</p>
<p>243 t o O t h e r . f l u s h ( )
</p>
<p>244 s t a t u s = i n t ( f romOther . r e a d l i n e ( ) . s t r i p ( ) )
</p>
<p>245
</p>
<p>246 f o r row i n m a t r i x :
</p>
<p>247 f o r token i n row :
</p>
<p>248 token . ht ( )
</p>
<p>249
</p>
<p>250 s c r e e n . update ( )
</p>
<p>251
</p>
<p>252 kb = t k i n t e r . Button ( s i d e B a r , t e x t = " P a s s " ,command=ComputerTurn )
</p>
<p>253 kb . pack ( )
</p>
<p>254
</p>
<p>255 ng = t k i n t e r . Button ( s i d e B a r , t e x t = " New Game " ,command=NewGame )
</p>
<p>256 ng . pack ( )
</p>
<p>257
</p>
<p>258
</p>
<p>259 proc = s u b p r o c e s s . Popen ( [ " c l i s p " , " c4 . f a s " ] , s t d o u t = s u b p r o c e s s . P IPE , \
</p>
<p>260 s t d i n = s u b p r o c e s s . P IPE , u n i v e r s a l _ n e w l i n e s =T r u e )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>20.6 The Connect Four Front-End 357
</p>
<p>261 f romOther = proc . s t d o u t
</p>
<p>262 t o O t h e r = proc . s t d i n
</p>
<p>263
</p>
<p>264 # To w r i t e t o t h e o t h e r program you s h o u l d u s e commands l i k e t h i s
</p>
<p>265 # t o O t h e r . w r i t e ( v a l + " \ n " )
</p>
<p>266 # Don &rsquo; t f o r g e t t o f l u s h t h e b u f f e r
</p>
<p>267 # t o O t h e r . f l u s h ( )
</p>
<p>268
</p>
<p>269 # To r e a d f r o m t h e o t h e r program you w r i t e
</p>
<p>270 # l i n e = f r o m O t h e r . r e a d l i n e ( ) . s t r i p ( )
</p>
<p>271
</p>
<p>272
</p>
<p>273
</p>
<p>274 def main ( ) :
</p>
<p>275 r o o t = t k i n t e r . Tk ( )
</p>
<p>276 animApp = C o n n e c t 4 A p p l i c a t i o n ( r o o t )
</p>
<p>277
</p>
<p>278 animApp . mainloop ( )
</p>
<p>279 p r i n t ( " Program E x e c u t i o n Completed . " )
</p>
<p>280
</p>
<p>281 i f __name__ == " __main__ " :
</p>
<p>282 main ( )
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Bibliography
</p>
<p>1. Adelson-Veskii G, Landis EM (1962) An algorithm for the organization of information. Proc
</p>
<p>USSR Acad Sci 146:263&ndash;266
</p>
<p>2. Carlis J, Maguire J (2000) Mastering data modeling: a user-driven approach. Addison-Wesley
</p>
<p>http://www.amazon.com/Mastering-Data-Modeling-User-Driven-Approach/dp/020170045X/
</p>
<p>ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1404178333&amp;sr=1-1
</p>
<p>3. Coppin B (2004) Artificial intelligence illuminated. Jones and Bartlett, USA
</p>
<p>4. Dijkstra EW (1959) A note on two problems in connexion with graphs. Nume Math 1:269&ndash;271
</p>
<p>5. Kruskal JB (1956) On the shortest spanning tree of a graph and the traveling salesman problem.
</p>
<p>Proc Am Math Soc 7:48&ndash;50
</p>
<p>6. Lutz M (2013) Learning Python. O&rsquo;Reilly Media http://www.amazon.com/Learning-
</p>
<p>Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1
</p>
<p>&amp;keywords=learning+python+lutz
</p>
<p>7. Tharp A (1988) File Organization and Processing. Wiley, New York
</p>
<p>8. Wikipedia (2014) Bloom filter. Wikipedia.org http://en.wikipedia.org/wiki/Bloom_filter
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9
</p>
<p>359
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
<div class="annotation"><a href="http://www.amazon.com/Mastering-Data-Modeling-User-Driven-Approach/dp/020170045X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1404178333&amp;sr=1-1">http://www.amazon.com/Mastering-Data-Modeling-User-Driven-Approach/dp/020170045X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1404178333&amp;sr=1-1</a></div>
<div class="annotation"><a href="http://www.amazon.com/Mastering-Data-Modeling-User-Driven-Approach/dp/020170045X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1404178333&amp;sr=1-1">http://www.amazon.com/Mastering-Data-Modeling-User-Driven-Approach/dp/020170045X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1404178333&amp;sr=1-1</a></div>
<div class="annotation"><a href="http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz">http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz</a></div>
<div class="annotation"><a href="http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz">http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz</a></div>
<div class="annotation"><a href="http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz">http://www.amazon.com/Learning-Python-Edition-Mark-Lutz/dp/1449355730/ref=sr_1_1?ie=UTF8&amp;qid=1398871248&amp;sr=8-1&amp;keywords=learning+python+lutz</a></div>
<div class="annotation"><a href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a></div>
</div>
<div class="page"><p/>
<p>Index
</p>
<p>A
</p>
<p>Algorithm, 1, 54&ndash;56
</p>
<p>recursive, 67, 68, 76
</p>
<p>sorting, 54, 56, 82, 100&ndash;102
</p>
<p>Arithmetic
</p>
<p>modulo, 83, 206
</p>
<p>B
</p>
<p>Backtrack, 177, 179, 189, 192
</p>
<p>Binary, 138, 143, 145, 166, 167
</p>
<p>Bipartite, 204
</p>
<p>Bloom filter, 205, 206
</p>
<p>B-tree, 261
</p>
<p>C
</p>
<p>Canvas, 25&ndash;27, 115
</p>
<p>Class, 3, 5, 6
</p>
<p>Complexity, 41
</p>
<p>amortized, 58, 60, 62, 93
</p>
<p>Computational complexity, 41, 50, 53, 54
</p>
<p>Constructor, 6, 37, 93&ndash;95, 120
</p>
<p>D
</p>
<p>Database, 261, 263
</p>
<p>Dict
</p>
<p>operators and methods, 309
</p>
<p>Dictionary, 3, 4, 36, 38, 154&ndash;156, 159, 183,
</p>
<p>237
</p>
<p>operators and methods, 309
</p>
<p>key, 4, 11, 27, 36, 38
</p>
<p>E
</p>
<p>Error
</p>
<p>run-time, 2
</p>
<p>syntax, 2, 168
</p>
<p>Expression
</p>
<p>postfix, 166, 167, 169, 180
</p>
<p>F
</p>
<p>File, 3, 13&ndash;16
</p>
<p>Float, 3&ndash;6, 8, 50
</p>
<p>operators, 301
</p>
<p>Function, 2, 3, 10&ndash;13
</p>
<p>G
</p>
<p>Grammar, 33, 35, 168, 169
</p>
<p>tokens, 128, 129, 138, 168
</p>
<p>Graph, 3, 11, 14, 15, 17, 20, 185
</p>
<p>bipartite, 204
</p>
<p>cycle, 187&ndash;189, 191
</p>
<p>dijkstra&rsquo;s algorithm, 185, 186, 197, 198
</p>
<p>edge, 186, 187
</p>
<p>kruskal&rsquo;s algorithm, 185, 186, 190, 191
</p>
<p>path, 185
</p>
<p>vertex, 186&ndash;189
</p>
<p>weighted, 188, 190, 197, 199
</p>
<p>H
</p>
<p>Hash, 56, 139, 144, 145
</p>
<p>Hashtable
</p>
<p>map, 154&ndash;156, 159, 183, 237
</p>
<p>&copy; Springer International Publishing Switzerland 2015
</p>
<p>K.D. Lee and S. Hubbard, Data Structures and Algorithms with Python,
</p>
<p>Undergraduate Topics in Computer Science, DOI 10.1007/978-3-319-13072-9
</p>
<p>361
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>362 Index
</p>
<p>set, 146&ndash;149
</p>
<p>Heap, 42, 67, 72, 73, 80, 87, 215
</p>
<p>I
</p>
<p>Ide, 1, 2, 4
</p>
<p>Import, 2, 11
</p>
<p>Index, 48, 64, 86, 90
</p>
<p>Int, 8
</p>
<p>operators, 299
</p>
<p>Integer, 3, 8, 38, 43, 49
</p>
<p>Integrated development environment, 1, 2, 4
</p>
<p>Interpreter, 2, 67, 69, 72, 73
</p>
<p>Iterator, 97, 150, 176, 183, 240
</p>
<p>yield, 97, 150, 165, 176, 237, 239
</p>
<p>L
</p>
<p>Lexicographical, 100, 101, 131
</p>
<p>List
</p>
<p>append, 3, 5, 8, 11, 20, 37
</p>
<p>array, 59, 62, 206, 207
</p>
<p>length, 16, 17, 22, 37, 39, 83
</p>
<p>linked, 91, 117, 118, 120, 121
</p>
<p>operators and methods, 307
</p>
<p>M
</p>
<p>Map, 139
</p>
<p>hashmap, 154&ndash;156, 159, 183, 237
</p>
<p>Matrix, 113, 114, 135, 140, 151
</p>
<p>Memoization, 139, 156&ndash;159
</p>
<p>Method, 5, 6
</p>
<p>Minimax, 116
</p>
<p>Module
</p>
<p>import, 2, 11
</p>
<p>Modulo, 83, 206
</p>
<p>N
</p>
<p>Node, 32, 36, 117, 118, 120
</p>
<p>O
</p>
<p>Object, 3&ndash;5
</p>
<p>Operator, 8, 10, 38
</p>
<p>P
</p>
<p>Path, 177, 185, 187&ndash;189
</p>
<p>Postfix, 166, 167, 169, 180
</p>
<p>Prefix, 168
</p>
<p>Program
</p>
<p>scope, 67, 69, 71
</p>
<p>Q
</p>
<p>Queue, 91, 125, 131
</p>
<p>priority, 138, 199, 215, 235, 236
</p>
<p>Quicksort
</p>
<p>pivot, 109&ndash;111
</p>
<p>R
</p>
<p>Relational database, 261, 263, 264
</p>
<p>Run-time stack, 2, 42, 67, 68, 72, 73
</p>
<p>activation record, 73
</p>
<p>S
</p>
<p>Scope, 67, 69, 71
</p>
<p>Screen
</p>
<p>operators and methods, 323
</p>
<p>Search, 56, 64, 72, 82, 93, 98
</p>
<p>best first, 281, 291, 292, 295
</p>
<p>breadth first, 185, 190, 202, 281, 284
</p>
<p>depth first, 177&ndash;179
</p>
<p>heuristic, 117, 235, 281
</p>
<p>hill climbing, 281, 286&ndash;288
</p>
<p>linear, 98, 102, 120, 147, 148
</p>
<p>Sequence, 5, 13, 26, 35, 91
</p>
<p>Sequential, 96, 163, 261, 267, 271
</p>
<p>Set, 4, 38, 139, 143
</p>
<p>hashset, 146&ndash;149
</p>
<p>union, 143, 144, 183, 192
</p>
<p>Sort
</p>
<p>merge, 105&ndash;107
</p>
<p>radix, 131, 132
</p>
<p>Sorting algorithm
</p>
<p>heapsort, 215, 222, 225, 229, 232, 234
</p>
<p>merge sort, 105&ndash;108
</p>
<p>quicksort, 107, 109&ndash;111
</p>
<p>selection sort, 102&ndash;104, 135
</p>
<p>Stack, 2, 25, 42, 67, 68, 72
</p>
<p>push, 73
</p>
<p>String, 4, 5, 10, 34
</p>
<p>operators and methods, 303
</p>
<p>Syntax, 1, 2, 164&ndash;166
</p>
<p>T
</p>
<p>Tic tac toe, 113, 115, 117, 137, 140
</p>
<p>Tree, 163, 164
</p>
<p>AVL, 237, 239, 240
</p>
<p>balance, 237&ndash;239
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<div class="page"><p/>
<p>Index 363
</p>
<p>binary search, 170, 172&ndash;174, 176
</p>
<p>b-tree, 176, 179, 261, 269
</p>
<p>child, 164, 170, 215
</p>
<p>depth, 177&ndash;179
</p>
<p>leaf, 217, 229, 232, 249, 250
</p>
<p>parent, 167, 217
</p>
<p>root, 163, 165, 166, 170, 172
</p>
<p>rotation, 243&ndash;245
</p>
<p>spanning, 185, 191&ndash;193
</p>
<p>splay, 176, 179, 237, 250, 251
</p>
<p>Trie, 209
</p>
<p>Turtle, 3, 11, 14
</p>
<p>methods, 311
</p>
<p>Turtle screen
</p>
<p>operators and methods, 323
</p>
<p>Type, 2, 3, 5
</p>
<p>This copy belongs to 'acha04'</p>
<p/>
</div>
<ul>	<li>Preface</li>
	<li>For Teachers</li>
	<li>Credits</li>
	<li>Contents</li>
	<li>1 Python Programming 101</li>
<ul>	<li>1.1 Chapter Goals</li>
	<li>1.2 Creating Objects</li>
<ul>	<li>1.2.1 Literal Values</li>
	<li>1.2.2 Non-literal Object Creation</li>
</ul>
	<li>1.3 Calling Methods on Objects</li>
	<li>1.4 Implementing a Class</li>
<ul>	<li>1.4.1 Creating Objects and Calling Methods</li>
	<li>1.4.2 The Dog Class</li>
</ul>
	<li>1.5 Operator Overloading</li>
<ul>	<li>1.5.1 The Dog Class with Overloaded Addition</li>
</ul>
	<li>1.6 Importing Modules</li>
	<li>1.7 Indentation in Python Programs</li>
	<li>1.8 The Main Function</li>
<ul>	<li>1.8.1 Python Program Structure</li>
</ul>
	<li>1.9 Reading from a File</li>
<ul>	<li>1.9.1 A Text File with Single Line Records</li>
	<li>1.9.2 Reading and Processing Single Line Records</li>
	<li>1.9.3 Pattern for Reading Single Line Records from a File</li>
</ul>
	<li>1.10 Reading Multi-line Records from a File</li>
<ul>	<li>1.10.1 A Text File with Multiple Line Records</li>
	<li>1.10.2 Reading and Processing Multi-line Records</li>
	<li>1.10.3 Pattern for Reading Multi-line Records from a File</li>
</ul>
	<li>1.11 A Container Class</li>
	<li>1.12 Polymorphism</li>
<ul>	<li>1.12.1 Graphics Command Classes</li>
</ul>
	<li>1.13 The Accumulator Pattern</li>
<ul>	<li>1.13.1 List of Squares</li>
	<li>1.13.2 A Graphics Program</li>
</ul>
	<li>1.14 Implementing a GUI with Tkinter</li>
<ul>	<li>1.14.1 A GUI Drawing Application</li>
</ul>
	<li>1.15 XML Files</li>
<ul>	<li>1.15.1 The Truck XML File</li>
	<li>1.15.2 The GoToCommand with XML Creation Code</li>
	<li>1.15.3 Writing Graphics Commands to an XML File</li>
</ul>
	<li>1.16 Reading XML Files</li>
<ul>	<li>1.16.1 Using an XML Parser</li>
</ul>
	<li>1.17 Chapter Summary</li>
	<li>1.18 Review Questions</li>
	<li>1.19 Programming Problems</li>
</ul>
	<li>2 Computational Complexity</li>
<ul>	<li>2.1 Chapter Goals</li>
	<li>2.2 Computer Architecture</li>
<ul>	<li>2.2.1 Running a Program</li>
</ul>
	<li>2.3 Accessing Elements in a Python List</li>
<ul>	<li>2.3.1 List Access Timing</li>
	<li>2.3.2 A Plot XML Sample</li>
</ul>
	<li>2.4 Big-Oh Notation</li>
	<li>2.5 The PyList Append Operation</li>
<ul>	<li>2.5.1 Inefficient Append</li>
</ul>
	<li>2.6 A Proof by Induction</li>
	<li>2.7 Making the PyList Append Efficient</li>
<ul>	<li>2.7.1 Efficient Append</li>
</ul>
	<li>2.8 Commonly Occurring Computational Complexities</li>
	<li>2.9 More Asymptotic Notation</li>
<ul>	<li>2.9.1 Big-Oh Asymptotic Upper Bound</li>
	<li>2.9.2 Asymptotic Lower Bound</li>
	<li>2.9.3 Theta Asymptotic Tight Bound</li>
</ul>
	<li>2.10 Amortized Complexity</li>
<ul>	<li>2.10.1 A PyList Class</li>
	<li>2.10.2 Proof of Append Complexity</li>
</ul>
	<li>2.11 Chapter Summary</li>
	<li>2.12 Review Questions</li>
	<li>2.13 Programming Problems</li>
</ul>
	<li>3 Recursion</li>
<ul>	<li>3.1 Chapter Goals</li>
	<li>3.2 Scope</li>
<ul>	<li>3.2.1 Local Scope</li>
	<li>3.2.2 Enclosing Scope</li>
	<li>3.2.3 Global Scope</li>
	<li>3.2.4 Built-In Scope</li>
	<li>3.2.5 LEGB</li>
</ul>
	<li>3.3 The Run-Time Stack and the Heap</li>
	<li>3.4 Writing a Recursive Function</li>
<ul>	<li>3.4.1 Sum of Integers</li>
	<li>3.4.2 Recursive Sum of Integers</li>
	<li>3.4.3 No Else Needed</li>
</ul>
	<li>3.5 Tracing the Execution of a Recursive Function</li>
	<li>3.6 Recursion in Computer Graphics</li>
<ul>	<li>3.6.1 Recursive Spiral</li>
</ul>
	<li>3.7 Recursion on Lists and Strings</li>
<ul>	<li>3.7.1 List Recursion</li>
	<li>3.7.2 Reversing a List</li>
	<li>3.7.3 Reversing a String</li>
	<li>3.7.4 Another Version of Reverse</li>
</ul>
	<li>3.8 Using Type Reflection</li>
<ul>	<li>3.8.1 Reflection Reverse</li>
</ul>
	<li>3.9 Chapter Summary</li>
	<li>3.10 Review Questions</li>
	<li>3.11 Programming Problems</li>
</ul>
	<li>4 Sequences</li>
<ul>	<li>4.1 Chapter Goals</li>
	<li>4.2 Lists</li>
<ul>	<li>4.2.1 The PyList Datatype</li>
	<li>4.2.2 The PyList Constructor</li>
	<li>4.2.3 PyList Get and Set</li>
	<li>4.2.4 PyList Concatenate</li>
	<li>4.2.5 PyList Append</li>
	<li>4.2.6 PyList Insert</li>
	<li>4.2.7 PyList Delete</li>
	<li>4.2.8 PyList Equality Test</li>
	<li>4.2.9 PyList Iteration</li>
	<li>4.2.10 PyList Length</li>
	<li>4.2.11 PyList Membership</li>
	<li>4.2.12 PyList String Conversion</li>
	<li>4.2.13 PyList String Representation</li>
</ul>
	<li>4.3 Cloning Objects</li>
	<li>4.4 Item Ordering</li>
<ul>	<li>4.4.1 The Point Class</li>
	<li>4.4.2 Calling the Sort Method</li>
</ul>
	<li>4.5 Selection Sort</li>
<ul>	<li>4.5.1 Selection Sort's Select Function</li>
	<li>4.5.2 The Selection Sort Code</li>
</ul>
	<li>4.6 Merge Sort</li>
<ul>	<li>4.6.1 The Merge Sort Code</li>
</ul>
	<li>4.7 Quicksort</li>
<ul>	<li>4.7.1 The Quicksort Code</li>
</ul>
	<li>4.8 Two-Dimensional Sequences</li>
<ul>	<li>4.8.1 The Board Class</li>
	<li>4.8.2 The X, O, and Dummy Classes</li>
</ul>
	<li>4.9 The Minimax Algorithm</li>
	<li>4.10 Linked Lists</li>
<ul>	<li>4.10.1 The Node Class</li>
	<li>4.10.2 The LinkedList Constructor</li>
	<li>4.10.3 LinkedList Get and Set</li>
	<li>4.10.4 LinkedList Concatenate</li>
	<li>4.10.5 LinkedList Append</li>
	<li>4.10.6 LinkedList Insert</li>
	<li>4.10.7 Other Linked List Operations</li>
</ul>
	<li>4.11 Stacks and Queues</li>
<ul>	<li>4.11.1 The Stack Class Code</li>
	<li>4.11.2 Infix Expression Evaluation</li>
	<li>4.11.3 Radix Sort</li>
	<li>4.11.4 The CharAt Function</li>
</ul>
	<li>4.12 Chapter Summary</li>
	<li>4.13 Review Questions</li>
	<li>4.14 Programming Problems</li>
</ul>
	<li>5 Sets and Maps</li>
<ul>	<li>5.1 Chapter Goals</li>
	<li>5.2 Playing Sudoku</li>
	<li>5.3 Sets</li>
	<li>5.4 Hashing</li>
	<li>5.5 The HashSet Class</li>
<ul>	<li>5.5.1 The HashSet Constructor</li>
	<li>5.5.2 Storing an Item</li>
	<li>5.5.3 Collision Resolution</li>
	<li>5.5.4 HashSet Add Helper Function</li>
	<li>5.5.5 The Load Factor</li>
	<li>5.5.6 HashSet Add</li>
	<li>5.5.7 Deleting an Item</li>
	<li>5.5.8 HashSet Remove Helper Function</li>
	<li>5.5.9 HashSet Remove</li>
	<li>5.5.10 Finding an Item</li>
	<li>5.5.11 HashSet Membership</li>
	<li>5.5.12 Iterating Over a Set</li>
	<li>5.5.13 Other Set Operations</li>
	<li>5.5.14 HashSet Difference Update</li>
	<li>5.5.15 HashSet Difference</li>
</ul>
	<li>5.6 Solving Sudoku</li>
<ul>	<li>5.6.1 The Sudoku Reduce Function</li>
</ul>
	<li>5.7 Maps</li>
<ul>	<li>5.7.1 The HashMap Class</li>
	<li>5.7.2 HashSet Get Item</li>
	<li>5.7.3 The HashMap Class</li>
</ul>
	<li>5.8 Memoization</li>
<ul>	<li>5.8.1 A Memoized Fibonacci Function</li>
</ul>
	<li>5.9 Correlating Two Sources of Information</li>
	<li>5.10 Chapter Summary</li>
	<li>5.11 Review Questions</li>
	<li>5.12 Programming Problems</li>
</ul>
	<li>6 Trees</li>
<ul>	<li>6.1 Chapter Goals</li>
	<li>6.2 Abstract Syntax Trees and Expressions</li>
<ul>	<li>6.2.1 Constructing ASTs</li>
</ul>
	<li>6.3 Prefix and Postfix Expressions</li>
<ul>	<li>6.3.1 AST Tree Traversal</li>
</ul>
	<li>6.4 Parsing Prefix Expressions</li>
<ul>	<li>6.4.1 The Prefix Expression Grammar</li>
	<li>6.4.2 A Prefix Expression Parser</li>
	<li>6.4.3 The Postfix Expression Grammar</li>
</ul>
	<li>6.5 Binary Search Trees</li>
<ul>	<li>6.5.1 The BinarySearchTree Class</li>
</ul>
	<li>6.6 Search Spaces</li>
<ul>	<li>6.6.1 Depth-First Search Algorithm</li>
	<li>6.6.2 Sudoku Depth-First Search</li>
	<li>6.6.3 Calling Sudoku's Solve Function</li>
</ul>
	<li>6.7 Chapter Summary</li>
	<li>6.8 Review Questions</li>
	<li>6.9 Programming Problems</li>
</ul>
	<li>7 Graphs</li>
<ul>	<li>7.1 Chapter Goals</li>
	<li>7.2 Graph Notation</li>
	<li>7.3 Searching a Graph</li>
<ul>	<li>7.3.1 Iterative Depth First Search of a Graph</li>
</ul>
	<li>7.4 Kruskal's Algorithm</li>
<ul>	<li>7.4.1 Proof of Correctness</li>
	<li>7.4.2 Kruskal's Complexity Analysis</li>
	<li>7.4.3 The Partition Data Structure</li>
</ul>
	<li>7.5 Dijkstra's Algorithm</li>
<ul>	<li>7.5.1 Dijkstra's Complexity Analysis</li>
</ul>
	<li>7.6 Graph Representations</li>
<ul>	<li>7.6.1 A Graph XML File</li>
	<li>7.6.2 A Vertex Class</li>
	<li>7.6.3 An Edge Class</li>
</ul>
	<li>7.7 Chapter Summary</li>
	<li>7.8 Review Questions</li>
	<li>7.9 Programming Problems</li>
</ul>
	<li>8 Membership Structures</li>
<ul>	<li>8.1 Chapter Goals</li>
	<li>8.2 Bloom Filters</li>
<ul>	<li>8.2.1 The Hashing Functions</li>
	<li>8.2.2 The Bloom Filter Size</li>
	<li>8.2.3 Drawbacks of a Bloom Filter</li>
</ul>
	<li>8.3 The Trie Datatype</li>
<ul>	<li>8.3.1 The Trie Class</li>
	<li>8.3.2 Inserting into a Trie</li>
	<li>8.3.3 Membership in a Trie</li>
	<li>8.3.4 Comparing Tries and Bloom Filters</li>
</ul>
	<li>8.4 Chapter Summary</li>
	<li>8.5 Review Questions</li>
	<li>8.6 Programming Problems</li>
</ul>
	<li>9 Heaps</li>
<ul>	<li>9.1 Chapter Goals</li>
	<li>9.2 Key Ideas</li>
	<li>9.3 Building a Heap</li>
<ul>	<li>9.3.1 The buildFrom Method</li>
</ul>
	<li>9.4 The Heapsort Algorithm Version 1</li>
<ul>	<li>9.4.1 The addToHeap Method</li>
</ul>
	<li>9.5 Analysis of Version 1 Phase I</li>
	<li>9.6 Phase II</li>
<ul>	<li>9.6.1 The siftDownFromTo Method</li>
</ul>
	<li>9.7 Analysis of Phase II</li>
	<li>9.8 The Heapsort Algorithm Version 2</li>
	<li>9.9 Analysis of Heapsort Version 2</li>
	<li>9.10 Comparison to Other Sorting Algorithms</li>
	<li>9.11 Chapter Summary</li>
	<li>9.12 Review Questions</li>
	<li>9.13 Programming Problems</li>
</ul>
	<li>10 Balanced Binary Search Trees</li>
<ul>	<li>10.1 Chapter Goals</li>
	<li>10.2 Binary Search Trees</li>
<ul>	<li>10.2.1 Binary Search Tree Insert</li>
</ul>
	<li>10.3 AVL Trees</li>
<ul>	<li>10.3.1 Definitions</li>
	<li>10.3.2 Implementation Alternatives</li>
	<li>10.3.3 AVLNode with Stored Balance</li>
	<li>10.3.4 AVL Tree Iterative Insert</li>
	<li>10.3.5 Rotations</li>
	<li>10.3.6 AVL Tree Recursive Insert</li>
	<li>10.3.7 The Recursive Insert AVL Tree Class Declaration</li>
	<li>10.3.8 Maintaining Balance Versus Height</li>
	<li>10.3.9 AVLNode with Stored Height</li>
	<li>10.3.10 Deleting an Item from an AVL Tree</li>
</ul>
	<li>10.4 Splay Trees</li>
<ul>	<li>10.4.1 Splay Rotations</li>
</ul>
	<li>10.5 Iterative Splaying</li>
	<li>10.6 Recursive Splaying</li>
	<li>10.7 Performance Analysis</li>
	<li>10.8 Chapter Summary</li>
	<li>10.9 Review Questions</li>
	<li>10.10 Programming Problems</li>
</ul>
	<li>11 B-Trees</li>
<ul>	<li>11.1 Chapter Goals</li>
	<li>11.2 Relational Databases</li>
<ul>	<li>11.2.1 The Feed Table</li>
	<li>11.2.2 The FeedAttribType Table</li>
	<li>11.2.3 The FeedAttribute Table</li>
	<li>11.2.4 A Temporary Table</li>
	<li>11.2.5 Programming the Joining of Tables</li>
	<li>11.2.6 The readRecord Function</li>
	<li>11.2.7 Efficient Join</li>
</ul>
	<li>11.3 B-Tree Organization</li>
	<li>11.4 The Advantages of B-Trees</li>
	<li>11.5 B-Tree Implementation</li>
	<li>11.6 B-Tree Insert</li>
	<li>11.7 B-Tree Delete</li>
	<li>11.8 Chapter Summary</li>
	<li>11.9 Review Questions</li>
	<li>11.10 Programming Problems</li>
</ul>
	<li>12 Heuristic Search</li>
<ul>	<li>12.1 Chapter Goals</li>
	<li>12.2 Depth First Search</li>
<ul>	<li>12.2.1 Iterative Depth First Search of a Graph</li>
	<li>12.2.2 Maze Representation</li>
	<li>12.2.3 DFS Example</li>
</ul>
	<li>12.3 Breadth First Search</li>
<ul>	<li>12.3.1 BFS Example</li>
</ul>
	<li>12.4 Hill Climbing</li>
<ul>	<li>12.4.1 Hill Climbing Example</li>
	<li>12.4.2 Closed Knight's Tour</li>
	<li>12.4.3 The N-Queens Problem</li>
</ul>
	<li>12.5 Best First Search</li>
<ul>	<li>12.5.1 Best First Example</li>
</ul>
	<li>12.6 A* Search</li>
<ul>	<li>12.6.1 A* Example</li>
</ul>
	<li>12.7 Minimax Revisited</li>
	<li>12.8 Chapter Summary</li>
	<li>12.9 Review Questions</li>
	<li>12.10 Programming Problems</li>
</ul>
	<li>13 Appendix A: Integer Operators</li>
	<li>14 Appendix B: Float Operators</li>
	<li>15 Appendix C: String Operators and Methods</li>
	<li>16 Appendix D: List Operators and Methods</li>
	<li>17 Appendix E: Dictionary Operators and Methods</li>
	<li>18 Appendix F: Turtle Methods</li>
	<li>19 Appendix G: TurtleScreen Methods</li>
	<li>20 Appendix H: Complete Programs</li>
<ul>	<li>20.1 The Draw Program</li>
	<li>20.2 The Scope Program</li>
	<li>20.3 The Sort Animation</li>
	<li>20.4 The PlotData Program</li>
	<li>20.5 The Tic Tac Toe Application</li>
	<li>20.6 The Connect Four Front-End</li>
</ul>
	<li> Bibliography</li>
	<li> Index</li>
</ul>
</body></html>